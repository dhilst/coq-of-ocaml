<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>What is coq-of-ocaml · coq-of-ocaml</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="`coq-of-ocaml` is a compiler from the [OCaml](https://ocaml.org/) programming language to the [Coq](https://coq.inria.fr/) proof language. It aims generate *idiomatic* and *human readable* Coq code. Technically speaking, this is a [shallow embedding](https://cstheory.stackexchange.com/questions/1370/shallow-versus-deep-embeddings) of OCaml into Coq."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="What is coq-of-ocaml · coq-of-ocaml"/><meta property="og:type" content="website"/><meta property="og:url" content="https://foobar-land.github.io/coq-of-ocaml/"/><meta property="og:description" content="`coq-of-ocaml` is a compiler from the [OCaml](https://ocaml.org/) programming language to the [Coq](https://coq.inria.fr/) proof language. It aims generate *idiomatic* and *human readable* Coq code. Technically speaking, this is a [shallow embedding](https://cstheory.stackexchange.com/questions/1370/shallow-versus-deep-embeddings) of OCaml into Coq."/><meta property="og:image" content="https://foobar-land.github.io/coq-of-ocaml/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://foobar-land.github.io/coq-of-ocaml/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/coq-of-ocaml/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="/coq-of-ocaml/js/language-name.js"></script><script src="/coq-of-ocaml/js/scrollSpy.js"></script><link rel="stylesheet" href="/coq-of-ocaml/css/main.css"/><script src="/coq-of-ocaml/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/coq-of-ocaml/"><img class="logo" src="/coq-of-ocaml/img/favicon.ico" alt="coq-of-ocaml"/><h2 class="headerTitleWithLogo">coq-of-ocaml</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive siteNavItemActive"><a href="/coq-of-ocaml/docs/introduction" target="_self">Docs</a></li><li class="siteNavGroupActive"><a href="/coq-of-ocaml/docs/examples" target="_self">Examples</a></li><li class=""><a href="https://github.com/clarus/coq-of-ocaml" target="_blank">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Introduction</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introduction</h3><ul class=""><li class="navListItem navListItemActive"><a class="navItem" href="/coq-of-ocaml/docs/introduction">What is coq-of-ocaml</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/coq-of-ocaml/docs/install">Install</a></li><li class="navListItem"><a class="navItem" href="/coq-of-ocaml/docs/run">Run</a></li><li class="navListItem"><a class="navItem" href="/coq-of-ocaml/docs/cookbook">Cookbook</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Language</h3><ul class=""><li class="navListItem"><a class="navItem" href="/coq-of-ocaml/docs/ocaml-core">OCaml core</a></li><li class="navListItem"><a class="navItem" href="/coq-of-ocaml/docs/type-definitions">Type definitions</a></li><li class="navListItem"><a class="navItem" href="/coq-of-ocaml/docs/module-system">Module system</a></li><li class="navListItem"><a class="navItem" href="/coq-of-ocaml/docs/gadts">GADTs</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Options</h3><ul class=""><li class="navListItem"><a class="navItem" href="/coq-of-ocaml/docs/attributes">Attributes</a></li><li class="navListItem"><a class="navItem" href="/coq-of-ocaml/docs/configuration">Configuration</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">More</h3><ul class=""><li class="navListItem"><a class="navItem" href="/coq-of-ocaml/docs/faq">Faq</a></li><li class="navListItem"><a class="navItem" href="/coq-of-ocaml/docs/examples">Examples</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">What is coq-of-ocaml</h1></header><article><div><span><p><code>coq-of-ocaml</code> is a compiler from the <a href="https://ocaml.org/">OCaml</a> programming language to the <a href="https://coq.inria.fr/">Coq</a> proof language. It aims generate <em>idiomatic</em> and <em>human readable</em> Coq code. Technically speaking, this is a <a href="https://cstheory.stackexchange.com/questions/1370/shallow-versus-deep-embeddings">shallow embedding</a> of OCaml into Coq.</p>
<p>We can use <code>coq-of-ocaml</code> to:</p>
<ul>
<li>do formal proofs on OCaml programs;</li>
<li>port OCaml projects to Coq.</li>
</ul>
<p>Starting from the following OCaml program:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">type</span> <span class="hljs-symbol">'a</span> tree =
  | <span class="hljs-type">Leaf</span> <span class="hljs-keyword">of</span> <span class="hljs-symbol">'a</span>
  | <span class="hljs-type">Node</span> <span class="hljs-keyword">of</span> <span class="hljs-symbol">'a</span> tree * <span class="hljs-symbol">'a</span> tree

<span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> sum tree =
  <span class="hljs-keyword">match</span> tree <span class="hljs-keyword">with</span>
  | <span class="hljs-type">Leaf</span> n -&gt; n
  | <span class="hljs-type">Node</span> (tree1, tree2) -&gt; sum tree1 + sum tree2
</code></pre>
<p>we get the following Coq program:</p>
<pre><code class="hljs css language-coq"><span class="hljs-comment">(* Generated by coq-of-ocaml *)</span>
<span class="hljs-keyword">Inductive</span> tree (a : <span class="hljs-keyword">Set</span>) : <span class="hljs-keyword">Set</span> :=
| <span class="hljs-type">Leaf</span> : a -&gt; tree a
| <span class="hljs-type">Node</span> : tree a -&gt; tree a -&gt; tree a.

<span class="hljs-keyword">Arguments</span> Leaf {<span class="hljs-keyword">_</span>}.
<span class="hljs-keyword">Arguments</span> Node {<span class="hljs-keyword">_</span>}.

<span class="hljs-keyword">Fixpoint</span> <span class="hljs-built_in">sum</span> (tree : tree int) : int :=
  <span class="hljs-keyword">match</span> tree <span class="hljs-built_in">with</span>
  | <span class="hljs-type">Leaf</span> n =&gt; n
  | <span class="hljs-type">Node</span> tree1 tree2 =&gt; Z.add (<span class="hljs-built_in">sum</span> tree1) (<span class="hljs-built_in">sum</span> tree2)
  <span class="hljs-keyword">end</span>.
</code></pre>
<p>We map the algebraic datatype <code>tree</code> to an equivalent inductive type <code>tree</code> in Coq. With the <code>Arguments</code> command, we ask Coq to be able to infer the type parameter <code>a</code>, as it is done in OCaml. We translate the recursive function <code>sum</code> using the command <code>Fixpoint</code> in Coq. By default, we represent the <code>int</code> type of OCaml by <code>Z</code> in Coq, but this can be parametrized.</p>
<h2><a class="anchor" aria-hidden="true" id="concepts"></a><a href="#concepts" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Concepts</h2>
<p>We can import to Coq the OCaml programs which are either purely functional or whose side-effects are in a <a href="https://caml.inria.fr/pub/docs/manual-ocaml/bindingops.html">monad</a>. We translate the primitive side-effects (references, exceptions, ...) to axioms. We may not completely preserve the semantics of the source code. One should do manual reviews to assert that the generated Coq code is a reasonable formalization of the sources. We produce a dummy Coq term and an explicit message in case of error. In particular, we always generate something and no errors are fatal.</p>
<p>We compile OCaml projects by pluging into <a href="https://github.com/ocaml/merlin">Merlin</a>. This means that if you are using Merlin then you can run <code>coq-of-ocaml</code> with no additional configurations.</p>
<p>We do not do special treatments for the termination of fixpoints. We disable termination checks using the Coq's flag <a href="https://coq.inria.fr/refman/proof-engine/vernacular-commands.html#coq:flag.Guard-Checking">Guard Checking</a>. We erase the type parameters for the <a href="https://caml.inria.fr/pub/docs/manual-ocaml/manual033.html">GADTs</a>. This makes sure that the type definitions are accepted, but can make the pattern matchings incomplete. In this case we offer the possibility to introduce dynamic casts guided by annotations in the OCaml code. We did not find a way to nicely represent GADTs in Coq yet. We think that this is hard because the dependent pattern matching works well on type indicies which are values, but does not with types.</p>
<p>We support modules, module types, functors and first-class modules. We generate either Coq modules or polymorphic records depending on the case. We generate axioms for <code>.mli</code> files to help formalizations, but importing <code>.mli</code> files should not be necessary for a project to compile in Coq.</p>
<h2><a class="anchor" aria-hidden="true" id="status"></a><a href="#status" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Status</h2>
<p><code>coq-of-ocaml</code> is under active development at <a href="https://www.nomadic-labs.com/">Nomadic Labs</a> to get a <a href="https://gitlab.com/nomadic-labs/coq-tezos-of-ocaml">Coq formalization</a> of the crypto-currency <a href="https://tezos.com/">Tezos</a>. To contact us, you can open an <a href="https://github.com/clarus/coq-of-ocaml/issues">issue</a> on GitHub or send <a href="mailto:contact@nomadic-labs.com">an email</a> to Nomadic Labs.</p>
<h2><a class="anchor" aria-hidden="true" id="workflow"></a><a href="#workflow" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Workflow</h2>
<p><code>coq-of-ocaml</code> works by compiling the OCaml files one by one. Thanks to Merlin, we get access to the typing environment of each file. Thus names referencing external definitions are properly interpreted.</p>
<p>In a typical project, we may want to translate some of the <code>.ml</code> files and keep the rest as axioms (for the libraries or non-critical files). To generate the axioms, we can run <code>coq-of-ocaml</code> on the <code>.mli</code> files for the parts we want to abstract. When something is not properly handled, <code>coq-of-ocaml</code> generates an error message. These errors do not necessarily need to be fixed. However, they are good warnings to help having a more extensive and reliable Coq formalization.</p>
<p>Generally, the generated Coq code for a project does not compile as it is. This can be due to unsupported OCaml features, or various small errors such as name collisions. In this case, you can:</p>
<ul>
<li>modify the OCaml input code, so that it fits what <code>coq-of-ocaml</code> handles or avoids Coq errors (follow the error messages);</li>
<li>use the <a href="attributes">attributes</a> or <a href="configuration">configuration</a> mechanism to customize the translation of <code>coq-of-ocaml</code>;</li>
<li>fork <code>coq-of-ocaml</code> to modify the code translation;</li>
<li>post-process the output with a script;</li>
<li>post-process the output by hand.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="related"></a><a href="#related" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Related</h2>
<p>In the OCaml community:</p>
<ul>
<li><a href="https://github.com/mariojppereira/cameleer">Cameleer</a> (verify OCaml programs leveraging the <a href="http://why3.lri.fr/">Why3</a>'s infrastructure)</li>
<li><a href="http://chargueraud.org/softs/cfml/">CFML</a> (import OCaml to Coq using characteristic formulae)</li>
<li><a href="https://github.com/mrmr1993/coq-of-ocaml">coq-of-ocaml-mrmr1993</a> (fork of <code>coq-of-ocaml</code> including side-effects, focusing on the compilation of the OCaml's stdlib)</li>
</ul>
<p>In the JavaScript community:</p>
<ul>
<li><a href="https://github.com/clarus/coq-of-js">coq-of-js</a> (sister project; <em>currently on halt to support <code>coq-of-ocaml</code></em>)</li>
</ul>
<p>In the Haskell community:</p>
<ul>
<li><a href="https://github.com/antalsz/hs-to-coq">hs-to-coq</a> (import Haskell to Coq)</li>
<li><a href="https://github.com/gdijkstra/hs-to-gallina">hs-to-gallina</a> (2012, by Gabe Dijkstra, first known project to do a shallow embedding of a mainstream functional programming language to Coq)</li>
</ul>
<p>In the Go community;</p>
<ul>
<li><a href="https://github.com/tchajed/goose">goose</a> (import Go to Coq)</li>
</ul>
<p>In the Rust community:</p>
<ul>
<li><a href="https://github.com/Kha/electrolysis">electrolysis</a> (import Rust to Lean)</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="credits"></a><a href="#credits" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Credits</h2>
<p>The <code>coq-of-ocaml</code> project started as part of a PhD directed by <a href="http://yann.regis-gianas.org/">Yann Regis-Gianas</a> and <a href="http://pauillac.inria.fr/~herbelin/">Hugo Herbelin
</a> as the university of <a href="https://u-paris.fr/">Paris 7</a>. Originally, the goal was to formalize real OCaml programs in Coq to study side-effects inference and proof techniques on functional programs. The project is now financed by <a href="https://www.nomadic-labs.com/">Nomadic Labs</a>, with the aim to be able to reason about the implementation of the crypto-currency <a href="https://tezos.com/">Tezos</a>. See this <a href="http://coq-blog.clarus.me/beginning-of-verification-for-the-parsing-of-smart-contracts.html">blog post</a> to get an example about what we can prove.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-next button" href="/coq-of-ocaml/docs/install"><span>Install</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#concepts">Concepts</a></li><li><a href="#status">Status</a></li><li><a href="#workflow">Workflow</a></li><li><a href="#related">Related</a></li><li><a href="#credits">Credits</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/coq-of-ocaml/" class="nav-home"><img src="/coq-of-ocaml/img/favicon.ico" alt="coq-of-ocaml" width="66" height="58"/></a><div><h5>Docs</h5><a href="/coq-of-ocaml/docs/introduction.html">Introduction</a><a href="/coq-of-ocaml/docs/install.html">Getting Started</a><a href="/coq-of-ocaml/docs/ocaml-core.html">Concepts</a></div><div><h5>Community</h5><a href="https://github.com/clarus/coq-of-ocaml/issues" target="_blank">Issues</a><a href="https://www.nomadic-labs.com/" target="_blank">Nomadic Labs</a></div><div><h5>More</h5><a href="https://github.com/clarus/coq-of-ocaml" target="_blank">GitHub</a><a class="github-button" href="https://github.com/clarus/coq-of-ocaml" data-icon="octicon-star" data-count-href="/clarus/coq-of-ocaml/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright">Copyright © 2021 Guillaume Claret</section></footer></div></body></html>