<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>GADTs · coq-of-ocaml</title><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="generator" content="Docusaurus"/><meta name="description" content="We provide some support for the [OCaml&#x27;s GADTs](https://caml.inria.fr/pub/docs/manual-ocaml/manual033.html), which are an advanced form of algebraic data-types. As [Coq](https://coq.inria.fr/) does not have a direct equivalent for the GADTs, we introduce some axioms guided by the user annotations."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="GADTs · coq-of-ocaml"/><meta property="og:type" content="website"/><meta property="og:url" content="https://clarus.github.io/coq-of-ocaml/"/><meta property="og:description" content="We provide some support for the [OCaml&#x27;s GADTs](https://caml.inria.fr/pub/docs/manual-ocaml/manual033.html), which are an advanced form of algebraic data-types. As [Coq](https://coq.inria.fr/) does not have a direct equivalent for the GADTs, we introduce some axioms guided by the user annotations."/><meta property="og:image" content="https://clarus.github.io/coq-of-ocaml/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://clarus.github.io/coq-of-ocaml/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="/coq-of-ocaml/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="/coq-of-ocaml/js/language-name.js"></script><script src="/coq-of-ocaml/js/scrollSpy.js"></script><link rel="stylesheet" href="/coq-of-ocaml/css/main.css"/><script src="/coq-of-ocaml/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/coq-of-ocaml/"><img class="logo" src="/coq-of-ocaml/img/favicon.ico" alt="coq-of-ocaml"/><h2 class="headerTitleWithLogo">coq-of-ocaml</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/coq-of-ocaml/docs/introduction" target="_self">Docs</a></li><li class="siteNavGroupActive"><a href="/coq-of-ocaml/docs/examples" target="_self">Examples</a></li><li class=""><a href="https://github.com/clarus/coq-of-ocaml" target="_blank">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Language</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introduction</h3><ul class=""><li class="navListItem"><a class="navItem" href="/coq-of-ocaml/docs/introduction">What is coq-of-ocaml</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/coq-of-ocaml/docs/install">Install</a></li><li class="navListItem"><a class="navItem" href="/coq-of-ocaml/docs/run">Run</a></li><li class="navListItem"><a class="navItem" href="/coq-of-ocaml/docs/cookbook">Cookbook</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Language</h3><ul class=""><li class="navListItem"><a class="navItem" href="/coq-of-ocaml/docs/ocaml-core">OCaml core</a></li><li class="navListItem"><a class="navItem" href="/coq-of-ocaml/docs/type-definitions">Type definitions</a></li><li class="navListItem"><a class="navItem" href="/coq-of-ocaml/docs/module-system">Module system</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/coq-of-ocaml/docs/gadts">GADTs</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Options</h3><ul class=""><li class="navListItem"><a class="navItem" href="/coq-of-ocaml/docs/attributes">Attributes</a></li><li class="navListItem"><a class="navItem" href="/coq-of-ocaml/docs/configuration">Configuration</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">More</h3><ul class=""><li class="navListItem"><a class="navItem" href="/coq-of-ocaml/docs/faq">Faq</a></li><li class="navListItem"><a class="navItem" href="/coq-of-ocaml/docs/examples">Examples</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">GADTs</h1></header><article><div><span><p>We provide some support for the <a href="https://caml.inria.fr/pub/docs/manual-ocaml/manual033.html">OCaml's GADTs</a>, which are an advanced form of algebraic data-types. As <a href="https://coq.inria.fr/">Coq</a> does not have a direct equivalent for the GADTs, we introduce some axioms guided by the user annotations.</p>
<p>For example, the following annotated, but valid, OCaml code:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">type</span> <span class="hljs-symbol">'a</span> int_or_string =
  | <span class="hljs-type">Int</span> : <span class="hljs-built_in">int</span> int_or_string
  | <span class="hljs-type">String</span> : <span class="hljs-built_in">string</span> int_or_string

<span class="hljs-keyword">let</span> to_string (<span class="hljs-keyword">type</span> a) (kind : a int_or_string) (x : a) : <span class="hljs-built_in">string</span> =
  <span class="hljs-keyword">match</span>[@coq_match_gadt] kind, x <span class="hljs-keyword">with</span>
  | <span class="hljs-type">Int</span>, (x : <span class="hljs-built_in">int</span>) -&gt; string_of_int x
  | <span class="hljs-type">String</span>, (x : <span class="hljs-built_in">string</span>) -&gt; x
</code></pre>
<p>will generate the Coq code:</p>
<pre><code class="hljs css language-coq"><span class="hljs-keyword">Reserved</span> <span class="hljs-keyword">Notation</span> <span class="hljs-string">"'int_or_string"</span>.

<span class="hljs-keyword">Inductive</span> int_or_string_gadt : <span class="hljs-keyword">Set</span> :=
| <span class="hljs-type">Int</span> : int_or_string_gadt
| <span class="hljs-type">String</span> : int_or_string_gadt

<span class="hljs-keyword">where</span> <span class="hljs-string">"'int_or_string"</span> := (<span class="hljs-keyword">fun</span> (<span class="hljs-keyword">_</span> : <span class="hljs-keyword">Set</span>) =&gt; int_or_string_gadt).

<span class="hljs-keyword">Definition</span> int_or_string := 'int_or_string.

<span class="hljs-keyword">Definition</span> to_string {A : <span class="hljs-keyword">Set</span>} (kind : int_or_string A) (x : A) : string :=
  <span class="hljs-keyword">match</span> (kind, x) <span class="hljs-built_in">with</span>
  | <span class="hljs-type">(Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-built_in">as</span> x) =&gt;
    <span class="hljs-keyword">let</span> 'existT <span class="hljs-keyword">_</span> tt x := obj_magic_exists (<span class="hljs-keyword">fun</span> <span class="hljs-keyword">_</span> =&gt; Z) x <span class="hljs-built_in">in</span>
    obj_magic string (OCaml.Stdlib.string_of_int x)
  | <span class="hljs-type">(String</span>, <span class="hljs-keyword">_</span> <span class="hljs-built_in">as</span> x) =&gt;
    <span class="hljs-keyword">let</span> 'existT <span class="hljs-keyword">_</span> tt x := obj_magic_exists (<span class="hljs-keyword">fun</span> <span class="hljs-keyword">_</span> =&gt; string) x <span class="hljs-built_in">in</span>
    obj_magic string x
  <span class="hljs-keyword">end</span>.
</code></pre>
<p>which does type-check. We need to prove that the <code>obj_magic</code> axioms are correct if we then want to evaluate the <code>to_string</code> function in Coq.</p>
<h2><a class="anchor" aria-hidden="true" id="existential-types"></a><a href="#existential-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Existential types</h2>
<p>Algebraic data-types with existential types but constant type parameters are a special case of GADTs. We handle existential types automatically and without using axioms, as Coq supports existential types. For example, we translate:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">type</span> printable = <span class="hljs-type">Printable</span> : <span class="hljs-symbol">'a</span> * (<span class="hljs-symbol">'a</span> -&gt; <span class="hljs-built_in">string</span>) -&gt; printable

<span class="hljs-keyword">let</span> printable_to_string (x : printable) : <span class="hljs-built_in">string</span> =
  <span class="hljs-keyword">let</span> <span class="hljs-type">Printable</span> (<span class="hljs-keyword">value</span>, print) = x <span class="hljs-keyword">in</span>
  print <span class="hljs-keyword">value</span>
</code></pre>
<p>to:</p>
<pre><code class="hljs css language-coq"><span class="hljs-keyword">Inductive</span> printable : <span class="hljs-keyword">Set</span> :=
| <span class="hljs-type">Printable</span> : <span class="hljs-keyword">forall</span> {a : <span class="hljs-keyword">Set</span>}, a -&gt; (a -&gt; string) -&gt; printable.

<span class="hljs-keyword">Definition</span> printable_to_string (x : printable) : string :=
  <span class="hljs-keyword">let</span> 'Printable value print := x <span class="hljs-built_in">in</span>
  <span class="hljs-keyword">let</span> 'existT <span class="hljs-keyword">_</span> __Printable_'a [value, print] :=
    existT
      (<span class="hljs-keyword">fun</span> __Printable_'a : <span class="hljs-keyword">Set</span> =&gt;
        [__Printable_'a ** (__Printable_'a -&gt; string)]) <span class="hljs-keyword">_</span> [value, print] <span class="hljs-built_in">in</span>
  print value.
</code></pre>
<p>The <code>let 'existT</code> command names the existential type variables with the same name as in OCaml. Indeed, in OCaml, Merlin would show <code>$Printable_'a</code> for the type of <code>value</code>. This is not required to type-check this example, but it may be useful to:</p>
<ul>
<li>debug;</li>
<li>validate sub-expression with type annotations using <code>__Printable_'a</code>.</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="gadts"></a><a href="#gadts" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>GADTs</h2>
<p>We handle the general case of GADTs by erasing the type parameters. Indeed, we did not achieve to use the type parameters so we prefer to remove them to:</p>
<ul>
<li>prevent clutter;</li>
<li>avoid some &quot;strict positivity&quot; errors when defining inductive types annotated by themselves.</li>
</ul>
<p>Reusing the example of the introduction, we see that for:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">type</span> <span class="hljs-symbol">'a</span> int_or_string =
  | <span class="hljs-type">Int</span> : <span class="hljs-built_in">int</span> int_or_string
  | <span class="hljs-type">String</span> : <span class="hljs-built_in">string</span> int_or_string
</code></pre>
<p>we define a second type without type annotations <code>int_or_string_gadt</code>:</p>
<pre><code class="hljs css language-coq"><span class="hljs-keyword">Reserved</span> <span class="hljs-keyword">Notation</span> <span class="hljs-string">"'int_or_string"</span>.

<span class="hljs-keyword">Inductive</span> int_or_string_gadt : <span class="hljs-keyword">Set</span> :=
| <span class="hljs-type">Int</span> : int_or_string_gadt
| <span class="hljs-type">String</span> : int_or_string_gadt

<span class="hljs-keyword">where</span> <span class="hljs-string">"'int_or_string"</span> := (<span class="hljs-keyword">fun</span> (<span class="hljs-keyword">_</span> : <span class="hljs-keyword">Set</span>) =&gt; int_or_string_gadt).

<span class="hljs-keyword">Definition</span> int_or_string := 'int_or_string.
</code></pre>
<p>but keep the polymorphic <code>int_or_string</code> type to preserve type arity. We simply drop the type parameter.</p>
<blockquote>
<p>Dropping type parameters in Coq may incur some issues to infer implicit type variables. We recommend to add type annotations with the OCaml attribute <code>[@coq_implicits &quot;(A := _)&quot;]</code> when Coq does not achieve to infer type variables.</p>
</blockquote>
<p>To compile the pattern-matching in GADT mode we require an attribute <code>[@coq_match_gadt]</code> in OCaml:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> to_string (<span class="hljs-keyword">type</span> a) (kind : a int_or_string) (x : a) : <span class="hljs-built_in">string</span> =
  <span class="hljs-keyword">match</span>[@coq_match_gadt] kind, x <span class="hljs-keyword">with</span>
  | <span class="hljs-type">Int</span>, (x : <span class="hljs-built_in">int</span>) -&gt; string_of_int x
  | <span class="hljs-type">String</span>, (x : <span class="hljs-built_in">string</span>) -&gt; x
</code></pre>
<p>This also works with the <code>function</code> keyword. For <code>coq-of-ocaml</code> to generate valid code, we add the variable <code>x</code> in the match. Indeed, the type <code>a</code> of <code>x</code> is unified during the match, either to <code>int</code> or <code>string</code>. We also precise this type for each branch with an annotation <code>(x : int)</code> to disambiguate from <code>(x : a)</code>. In Coq, we introduce two unsafe casts <code>obj_magic</code> in each branch:</p>
<ul>
<li>one for the variables of the pattern; this cast may also introduce some existential variables;</li>
<li>one to unify the types of the results of the branches.</li>
</ul>
<pre><code class="hljs css language-coq"><span class="hljs-keyword">Definition</span> to_string {A : <span class="hljs-keyword">Set</span>} (kind : int_or_string A) (x : A) : string :=
  <span class="hljs-keyword">match</span> (kind, x) <span class="hljs-built_in">with</span>
  | <span class="hljs-type">(Int</span>, <span class="hljs-keyword">_</span> <span class="hljs-built_in">as</span> x) =&gt;
    <span class="hljs-keyword">let</span> 'existT <span class="hljs-keyword">_</span> tt x := obj_magic_exists (<span class="hljs-keyword">fun</span> <span class="hljs-keyword">_</span> =&gt; Z) x <span class="hljs-built_in">in</span>
    obj_magic string (OCaml.Stdlib.string_of_int x)
  | <span class="hljs-type">(String</span>, <span class="hljs-keyword">_</span> <span class="hljs-built_in">as</span> x) =&gt;
    <span class="hljs-keyword">let</span> 'existT <span class="hljs-keyword">_</span> tt x := obj_magic_exists (<span class="hljs-keyword">fun</span> <span class="hljs-keyword">_</span> =&gt; string) x <span class="hljs-built_in">in</span>
    obj_magic string x
  <span class="hljs-keyword">end</span>.
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="obj_magic"></a><a href="#obj_magic" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Obj_magic</h2>
<p>We define two axioms in Coq:</p>
<pre><code class="hljs css language-coq"><span class="hljs-keyword">Axiom</span> obj_magic : <span class="hljs-keyword">forall</span> {A : <span class="hljs-keyword">Set</span>} (B : <span class="hljs-keyword">Set</span>), A -&gt; B.

<span class="hljs-keyword">Axiom</span> obj_magic_exists : <span class="hljs-keyword">forall</span> {As Bs : <span class="hljs-keyword">Type</span>} (T : Bs -&gt; <span class="hljs-keyword">Type</span>),
  As -&gt; {vs : Bs &amp; T vs}.
</code></pre>
<p>These (unsafe) axioms correspond to arbitrary casts between two types, the second form also introducing some existential variables. To evaluate these axioms when doing proofs on the generated code, we can use:</p>
<pre><code class="hljs css language-coq"><span class="hljs-keyword">Axiom</span> obj_magic_eval : <span class="hljs-keyword">forall</span> {A : <span class="hljs-keyword">Set</span>} {x : A}, obj_magic A x = x.

<span class="hljs-keyword">Axiom</span> obj_magic_exists_eval
  : <span class="hljs-keyword">forall</span> {Es : <span class="hljs-keyword">Type</span>} {T : Es -&gt; <span class="hljs-keyword">Set</span>} {vs : Es} {x : T vs},
  obj_magic_exists T x = existT <span class="hljs-keyword">_</span> vs x.
</code></pre>
<p>Applying these evaluation axioms amounts to verifying that the type constraints from OCaml are indeed valid. We need to have the right invariants on our data-types to be able to evaluate these axioms. Indeed, since we remove type annotations from the GADTs, we could construct invalid GADT values in Coq. Values produced as output of imported OCaml functions (not parametrized by GADTs) should always be valid according to the type-checker of OCaml</p>
<p>Here is a proof example to show that our <code>to_string</code> function is the identity on the strings:</p>
<pre><code class="hljs css language-coq"><span class="hljs-keyword">Lemma</span> to_string_on_string_is_id (s : string)
  : to_string String s = s.
  <span class="hljs-built_in">unfold</span> to_string.
  <span class="hljs-built_in">rewrite</span> (obj_magic_exists_eval (T := <span class="hljs-keyword">fun</span> <span class="hljs-keyword">_</span> =&gt; <span class="hljs-keyword">_</span>) (vs := tt)).
  <span class="hljs-built_in">rewrite</span> obj_magic_eval.
  <span class="hljs-built_in">reflexivity</span>.
<span class="hljs-keyword">Qed</span>.
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="tagged-gadts"></a><a href="#tagged-gadts" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Tagged GADTs</h2>
<p>Sometimes erasing the type parameters is undesirable because it will drastically change the semantics of your OCaml programs, this can make some properties to be unprovable.
With this in mind we provide a tagging mechanism to achieve this through the flag <code>[@@coq_tag_gadt]</code></p>
<p>For example, we would translate</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">type</span> <span class="hljs-symbol">'a</span> term =
  | <span class="hljs-type">T_Int</span> : <span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> term
  | <span class="hljs-type">T_String</span> : <span class="hljs-built_in">string</span> -&gt; <span class="hljs-built_in">string</span> term
[@@coq_tag_gadt]
</code></pre>
<p>to:</p>
<pre><code class="hljs css language-coq"><span class="hljs-keyword">Inductive</span> term : vtag -&gt; <span class="hljs-keyword">Set</span> :=
| <span class="hljs-type">T_Int</span> : int -&gt; term int_tag
| <span class="hljs-type">T_String</span> : string -&gt; term string_tag
| <span class="hljs-type">T_Sum</span> : term int_tag -&gt; term int_tag -&gt; term int_tag.
</code></pre>
<p>This allows us to directly translate impossible branches over GADTs without the use of the axiom <code>unreachable_gadt_branch</code> as follows:</p>
<pre><code class="hljs css language-ocaml"><span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> get_int (e : <span class="hljs-built_in">int</span> term) : <span class="hljs-built_in">int</span> =
  <span class="hljs-keyword">match</span>[@coq_tagged_match][@coq_match_with_default] e <span class="hljs-keyword">with</span>
  | <span class="hljs-type">T_Int</span> n -&gt; n
  | _ -&gt; .
</code></pre>
<p>Please notice that we have to indicate that we are pattern matching against a tagged GADT with the flag <code>coq_tagged_match</code>.</p>
<pre><code class="hljs css language-coq"><span class="hljs-keyword">Fixpoint</span> get_int (e : term int_tag) : int :=
  <span class="hljs-keyword">match</span> e <span class="hljs-built_in">in</span> term t0 <span class="hljs-keyword">return</span> t0 = int_tag -&gt; int <span class="hljs-built_in">with</span>
  | <span class="hljs-type">T_Int</span> n =&gt; <span class="hljs-keyword">fun</span> eq0 =&gt; ltac:(<span class="hljs-built_in">subst</span>; <span class="hljs-built_in">exact</span> n)
  | <span class="hljs-type">_</span> =&gt; ltac:(<span class="hljs-built_in">discriminate</span>)
  <span class="hljs-keyword">end</span> eq_refl.
</code></pre>
<p>For more details on the mechanisms behind this translation please check <a href="https://pedroabreu0.github.io/blog/2020/08/05/OCaml-GADTs-In-Coq">this blog post</a></p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/coq-of-ocaml/docs/module-system"><span class="arrow-prev">← </span><span>Module system</span></a><a class="docs-next button" href="/coq-of-ocaml/docs/attributes"><span>Attributes</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#existential-types">Existential types</a></li><li><a href="#gadts">GADTs</a></li><li><a href="#obj_magic">Obj_magic</a></li><li><a href="#tagged-gadts">Tagged GADTs</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/coq-of-ocaml/" class="nav-home"><img src="/coq-of-ocaml/img/favicon.ico" alt="coq-of-ocaml" width="66" height="58"/></a><div><h5>Docs</h5><a href="/coq-of-ocaml/docs/introduction.html">Introduction</a><a href="/coq-of-ocaml/docs/install.html">Getting Started</a><a href="/coq-of-ocaml/docs/ocaml-core.html">Concepts</a></div><div><h5>Community</h5><a href="https://github.com/clarus/coq-of-ocaml/issues" target="_blank">Issues</a><a href="https://www.nomadic-labs.com/" target="_blank">Nomadic Labs</a></div><div><h5>More</h5><a href="https://github.com/clarus/coq-of-ocaml" target="_blank">GitHub</a><a class="github-button" href="https://github.com/clarus/coq-of-ocaml" data-icon="octicon-star" data-count-href="/clarus/coq-of-ocaml/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section><section class="copyright">Copyright © 2021 Guillaume Claret</section></footer></div></body></html>