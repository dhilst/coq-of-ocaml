<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>coq-of-ocaml ‚Äì Examples</title>
    <link rel="shortcut icon" href="../img/favicon.ico">
    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/custom.css" rel="stylesheet">
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container-fluid" style="overflow: hidden;">
      <div class="navbar navbar-default" role="navigation">
        <div class="container-fluid">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse-list" aria-expanded="false">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="../">
              <img alt="logo" height="24px" src="../img/favicon.ico" />
              coq-of-ocaml <span class="hidden-xs">- Examples</span></a>
          </div>

          <div class="collapse navbar-collapse" id="navbar-collapse-list">
            <ul class="nav navbar-nav">
              <li ><a href="../kernel/">Kernel of Coq</a></li>
              <li class="active"><a href="../tezos/">Protocol of Tezos</a></li>
              <li ><a href="../tezos-interface/">Interface of Tezos</a></li>
              <li><a href="https://foobar-land.github.io/coq-of-ocaml/">Home</a></li>
            </ul>
          </div>
        </div>
      </div>
      <div class="article">

<div class="row center-block not-full-width">
  <div class="col-md-12">
        <h2>
      Protocol of Tezos in&nbsp;Coq
      <small>
      <span class="label label-success">Does compile</span>
      </small>
    </h2>
    <p>These are the sources of the <a href="https://gitlab.com/tezos/tezos/tree/master/src/proto_alpha/lib_protocol">protocol</a> of <a href="https://tezos.com/">Tezos</a> imported to <a href="https://coq.inria.fr/">Coq</a> by the current development version of <a href="https://github.com/clarus/coq-of-ocaml">coq-of-ocaml</a>. Tezos is a crypto-currency with smart-contracts and an upgradable protocol. To see the valid generated Coq files, go on <a href="https://foobar-land.github.io/coq-of-ocaml/build-tezos/html/toc.html">coq-of-ocaml/build-tezos/html/toc.html</a>.</p>
    <blockquote class="blockquote"><p class="mb-0" style="font-size: 16px;">(2020-03-11) Compiling all the protocol! üéâüêì</p></blockquote>

    <p>We show the original&nbsp;<a href="https://ocaml.org/">OCaml</a> code on the left and the imported&nbsp;<a href="https://coq.inria.fr/">Coq</a> code on the right. The imported code does compile. Warnings reported on the&nbsp;OCaml side are due to either various incompleteness in our tool, or to side-effects in the source code. Go on the <a href="https://gitter.im/clarus/coq-of-ocaml">Gitter chat</a> for more information. Work currently made at <a href="https://www.nomadic-labs.com/">Nomadic Labs</a>.</p>
    <p>To install the latest development version of <a href="https://foobar-land.github.io/coq-of-ocaml/">coq-of-ocaml</a> with <a href="https://opam.ocaml.org/">opam</a>:</p>
    <pre><code>opam repo add coq-released https://coq.inria.fr/opam/released
opam pin add https://github.com/clarus/coq-of-ocaml.git#master</code></pre>
    <ul>
      <li>OCaml size: 36294 lines</li>
      <li>Coq size: 45535 lines (+25% compared to&nbsp;OCaml)</li>
      <li>Warnings from coq-of-ocaml: 711</li>
    </ul>
    
      <canvas id="chart" width="400" height="400"></canvas>
      <script>
        window.chart =       {
        compiling: [
          13,
          292,
          1784,
          1529,
          1147,
          1541,
          2680,
          3100,
          2962,
          5892,
          9302,
          9302,
          9302,
          9302,
          9302,
          9302,
          9302,
          9402,
          9402,
          8851,
          9183,
          9413,
          9364,
          9364,
          11380,
          11380,
          11380,
          11380,
          13051,
          25328,
          25322,
          27076,
          30388,
          30401,
          29240,
          29013,
          29013,
          29028,
          29028,
          29028,
          29028,
          29028,
          25014,
          25014,
          24981,
          26259,
          26259,
          28609,
          32833,
          39901,
          41570,
          41570,
          41570,
          41570,
          41570,
          41570,
          41570,
          45535,
        ],
        generated: [
          47563,
          41904,
          43481,
          43404,
          44618,
          45107,
          44768,
          45158,
          46874,
          46800,
          49535,
          49535,
          49535,
          49535,
          49535,
          49535,
          49535,
          49443,
          49443,
          48616,
          49194,
          52058,
          51829,
          51829,
          51401,
          51401,
          51401,
          51401,
          51943,
          52522,
          52514,
          52355,
          53072,
          53116,
          49938,
          49269,
          49269,
          49288,
          49288,
          49288,
          49288,
          49288,
          48552,
          48552,
          48348,
          46049,
          46049,
          45766,
          46649,
          46664,
          46742,
          46742,
          46742,
          46742,
          46742,
          46742,
          46742,
          45535,
        ],
        labels: [
          "01-14",
          "01-15",
          "01-16",
          "01-17",
          "01-18",
          "01-19",
          "01-20",
          "01-21",
          "01-22",
          "01-23",
          "01-24",
          "01-25",
          "01-26",
          "01-27",
          "01-28",
          "01-29",
          "01-30",
          "01-31",
          "02-01",
          "02-02",
          "02-03",
          "02-04",
          "02-05",
          "02-06",
          "02-07",
          "02-08",
          "02-09",
          "02-10",
          "02-11",
          "02-12",
          "02-13",
          "02-14",
          "02-15",
          "02-16",
          "02-17",
          "02-18",
          "02-19",
          "02-20",
          "02-21",
          "02-22",
          "02-23",
          "02-24",
          "02-25",
          "02-26",
          "02-27",
          "02-28",
          "02-29",
          "03-01",
          "03-02",
          "03-03",
          "03-04",
          "03-05",
          "03-06",
          "03-07",
          "03-08",
          "03-09",
          "03-10",
          "03-11",
        ]
      }
;
      </script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.3/Chart.bundle.min.js"></script>
      <script src="../js/display-chart.js"></script>
    
    
      <img
        alt="Minion mic drop"
        class="img-responsive img-rounded center-block"
        src="https://media.giphy.com/media/DfbpTbQ9TvSX6/source.gif"
        style="margin-top: 60px; margin-bottom: 60px;"
      />
    
  </div>
</div>

<hr />
<div class="row" style="margin: 20px;">
  <h3>List of files</h3>
  <p>We add the warnings from coq-of-ocaml as annotations. They are not necessarly related to compilation bugs of the generated Coq files. These warnings are either due to unsupported features in coq-of-ocaml or to side-effects in the source code.</p>
  
  
  
  <div class="col-md-4">
    <ul>
      
      <li>
        <a href="#alpha_context.ml">alpha_context.ml</a>&nbsp;<span class="label label-warning">2</span>
      </li>
      
      <li>
        <a href="#alpha_context.mli">alpha_context.mli</a>&nbsp;<span class="label label-warning">15</span>
      </li>
      
      <li>
        <a href="#alpha_services.ml">alpha_services.ml</a>&nbsp;<span class="label label-warning">6</span>
      </li>
      
      <li>
        <a href="#alpha_services.mli">alpha_services.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#amendment.ml">amendment.ml</a>&nbsp;<span class="label label-warning">11</span>
      </li>
      
      <li>
        <a href="#amendment.mli">amendment.mli</a>&nbsp;<span class="label label-warning">2</span>
      </li>
      
      <li>
        <a href="#apply.ml">apply.ml</a>&nbsp;<span class="label label-warning">51</span>
      </li>
      
      <li>
        <a href="#apply_results.ml">apply_results.ml</a>&nbsp;<span class="label label-warning">7</span>
      </li>
      
      <li>
        <a href="#apply_results.mli">apply_results.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#baking.ml">baking.ml</a>&nbsp;<span class="label label-warning">19</span>
      </li>
      
      <li>
        <a href="#baking.mli">baking.mli</a>&nbsp;<span class="label label-warning">6</span>
      </li>
      
      <li>
        <a href="#blinded_public_key_hash.ml">blinded_public_key_hash.ml</a>&nbsp;<span class="label label-warning">2</span>
      </li>
      
      <li>
        <a href="#blinded_public_key_hash.mli">blinded_public_key_hash.mli</a>&nbsp;<span class="label label-warning">1</span>
      </li>
      
      <li>
        <a href="#block_header_repr.ml">block_header_repr.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#block_header_repr.mli">block_header_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#bootstrap_storage.ml">bootstrap_storage.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#bootstrap_storage.mli">bootstrap_storage.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#commitment_repr.ml">commitment_repr.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#commitment_repr.mli">commitment_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#commitment_storage.ml">commitment_storage.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#commitment_storage.mli">commitment_storage.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#constants_repr.ml">constants_repr.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#constants_services.ml">constants_services.ml</a>&nbsp;<span class="label label-warning">1</span>
      </li>
      
      <li>
        <a href="#constants_services.mli">constants_services.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#constants_storage.ml">constants_storage.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#contract_hash.ml">contract_hash.ml</a>&nbsp;<span class="label label-warning">1</span>
      </li>
      
      <li>
        <a href="#contract_repr.ml">contract_repr.ml</a>&nbsp;<span class="label label-warning">14</span>
      </li>
      
      <li>
        <a href="#contract_repr.mli">contract_repr.mli</a>&nbsp;<span class="label label-warning">1</span>
      </li>
      
      <li>
        <a href="#contract_services.ml">contract_services.ml</a>&nbsp;<span class="label label-warning">15</span>
      </li>
      
      <li>
        <a href="#contract_services.mli">contract_services.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#contract_storage.ml">contract_storage.ml</a>&nbsp;<span class="label label-warning">16</span>
      </li>
      
      <li>
        <a href="#contract_storage.mli">contract_storage.mli</a>&nbsp;<span class="label label-warning">1</span>
      </li>
      
      <li>
        <a href="#cycle_repr.ml">cycle_repr.ml</a>&nbsp;<span class="label label-warning">4</span>
      </li>
      
      <li>
        <a href="#cycle_repr.mli">cycle_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#delegate_services.ml">delegate_services.ml</a>&nbsp;<span class="label label-warning">14</span>
      </li>
      
      <li>
        <a href="#delegate_services.mli">delegate_services.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#delegate_storage.ml">delegate_storage.ml</a>&nbsp;<span class="label label-warning">11</span>
      </li>
      
      <li>
        <a href="#delegate_storage.mli">delegate_storage.mli</a>&nbsp;<span class="label label-warning">1</span>
      </li>
      
      <li>
        <a href="#fees_storage.ml">fees_storage.ml</a>&nbsp;<span class="label label-warning">7</span>
      </li>
      
      <li>
        <a href="#fees_storage.mli">fees_storage.mli</a>&nbsp;<span class="label label-warning">3</span>
      </li>
      
      <li>
        <a href="#fitness_repr.ml">fitness_repr.ml</a>&nbsp;<span class="label label-warning">5</span>
      </li>
      
    </ul>
  </div>
  
  <div class="col-md-4">
    <ul>
      
      <li>
        <a href="#fitness_storage.ml">fitness_storage.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#gas_limit_repr.ml">gas_limit_repr.ml</a>&nbsp;<span class="label label-warning">5</span>
      </li>
      
      <li>
        <a href="#gas_limit_repr.mli">gas_limit_repr.mli</a>&nbsp;<span class="label label-warning">2</span>
      </li>
      
      <li>
        <a href="#helpers_services.ml">helpers_services.ml</a>&nbsp;<span class="label label-warning">18</span>
      </li>
      
      <li>
        <a href="#helpers_services.mli">helpers_services.mli</a>&nbsp;<span class="label label-warning">1</span>
      </li>
      
      <li>
        <a href="#init_storage.ml">init_storage.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#legacy_script_support_repr.ml">legacy_script_support_repr.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#legacy_script_support_repr.mli">legacy_script_support_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#level_repr.ml">level_repr.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#level_repr.mli">level_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#level_storage.ml">level_storage.ml</a>&nbsp;<span class="label label-warning">2</span>
      </li>
      
      <li>
        <a href="#level_storage.mli">level_storage.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#main.ml">main.ml</a>&nbsp;<span class="label label-warning">3</span>
      </li>
      
      <li>
        <a href="#main.mli">main.mli</a>&nbsp;<span class="label label-warning">2</span>
      </li>
      
      <li>
        <a href="#manager_repr.ml">manager_repr.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#manager_repr.mli">manager_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#michelson_v1_gas.ml">michelson_v1_gas.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#michelson_v1_gas.mli">michelson_v1_gas.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#michelson_v1_primitives.ml">michelson_v1_primitives.ml</a>&nbsp;<span class="label label-warning">7</span>
      </li>
      
      <li>
        <a href="#michelson_v1_primitives.mli">michelson_v1_primitives.mli</a>&nbsp;<span class="label label-warning">3</span>
      </li>
      
      <li>
        <a href="#misc.ml">misc.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#misc.mli">misc.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#nonce_hash.ml">nonce_hash.ml</a>&nbsp;<span class="label label-warning">1</span>
      </li>
      
      <li>
        <a href="#nonce_storage.ml">nonce_storage.ml</a>&nbsp;<span class="label label-warning">7</span>
      </li>
      
      <li>
        <a href="#nonce_storage.mli">nonce_storage.mli</a>&nbsp;<span class="label label-warning">1</span>
      </li>
      
      <li>
        <a href="#operation_repr.ml">operation_repr.ml</a>&nbsp;<span class="label label-warning">7</span>
      </li>
      
      <li>
        <a href="#operation_repr.mli">operation_repr.mli</a>&nbsp;<span class="label label-warning">2</span>
      </li>
      
      <li>
        <a href="#parameters_repr.ml">parameters_repr.ml</a>&nbsp;<span class="label label-warning">1</span>
      </li>
      
      <li>
        <a href="#parameters_repr.mli">parameters_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#period_repr.ml">period_repr.ml</a>&nbsp;<span class="label label-warning">4</span>
      </li>
      
      <li>
        <a href="#period_repr.mli">period_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#qty_repr.ml">qty_repr.ml</a>&nbsp;<span class="label label-warning">11</span>
      </li>
      
      <li>
        <a href="#raw_context.ml">raw_context.ml</a>&nbsp;<span class="label label-warning">42</span>
      </li>
      
      <li>
        <a href="#raw_context.mli">raw_context.mli</a>&nbsp;<span class="label label-warning">7</span>
      </li>
      
      <li>
        <a href="#raw_level_repr.ml">raw_level_repr.ml</a>&nbsp;<span class="label label-warning">5</span>
      </li>
      
      <li>
        <a href="#raw_level_repr.mli">raw_level_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#roll_repr.ml">roll_repr.ml</a>&nbsp;<span class="label label-warning">1</span>
      </li>
      
      <li>
        <a href="#roll_repr.mli">roll_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#roll_storage.ml">roll_storage.ml</a>&nbsp;<span class="label label-warning">7</span>
      </li>
      
      <li>
        <a href="#roll_storage.mli">roll_storage.mli</a>&nbsp;<span class="label label-warning">1</span>
      </li>
      
      <li>
        <a href="#script_expr_hash.ml">script_expr_hash.ml</a>&nbsp;<span class="label label-warning">1</span>
      </li>
      
    </ul>
  </div>
  
  <div class="col-md-4">
    <ul>
      
      <li>
        <a href="#script_int_repr.ml">script_int_repr.ml</a>&nbsp;<span class="label label-warning">4</span>
      </li>
      
      <li>
        <a href="#script_int_repr.mli">script_int_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#script_interpreter.ml">script_interpreter.ml</a>&nbsp;<span class="label label-warning">28</span>
      </li>
      
      <li>
        <a href="#script_interpreter.mli">script_interpreter.mli</a>&nbsp;<span class="label label-warning">7</span>
      </li>
      
      <li>
        <a href="#script_ir_annot.ml">script_ir_annot.ml</a>&nbsp;<span class="label label-warning">14</span>
      </li>
      
      <li>
        <a href="#script_ir_annot.mli">script_ir_annot.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#script_ir_translator.ml">script_ir_translator.ml</a>&nbsp;<span class="label label-warning">179</span>
      </li>
      
      <li>
        <a href="#script_ir_translator.mli">script_ir_translator.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#script_repr.ml">script_repr.ml</a>&nbsp;<span class="label label-warning">4</span>
      </li>
      
      <li>
        <a href="#script_repr.mli">script_repr.mli</a>&nbsp;<span class="label label-warning">1</span>
      </li>
      
      <li>
        <a href="#script_tc_errors.ml">script_tc_errors.ml</a>&nbsp;<span class="label label-warning">46</span>
      </li>
      
      <li>
        <a href="#script_tc_errors_registration.ml">script_tc_errors_registration.ml</a>&nbsp;<span class="label label-warning">1</span>
      </li>
      
      <li>
        <a href="#script_timestamp_repr.ml">script_timestamp_repr.ml</a>&nbsp;<span class="label label-warning">2</span>
      </li>
      
      <li>
        <a href="#script_timestamp_repr.mli">script_timestamp_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#script_typed_ir.ml">script_typed_ir.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#seed_repr.ml">seed_repr.ml</a>&nbsp;<span class="label label-warning">4</span>
      </li>
      
      <li>
        <a href="#seed_repr.mli">seed_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#seed_storage.ml">seed_storage.ml</a>&nbsp;<span class="label label-warning">4</span>
      </li>
      
      <li>
        <a href="#seed_storage.mli">seed_storage.mli</a>&nbsp;<span class="label label-warning">1</span>
      </li>
      
      <li>
        <a href="#services_registration.ml">services_registration.ml</a>&nbsp;<span class="label label-warning">1</span>
      </li>
      
      <li>
        <a href="#state_hash.ml">state_hash.ml</a>&nbsp;<span class="label label-warning">1</span>
      </li>
      
      <li>
        <a href="#storage.ml">storage.ml</a>&nbsp;<span class="label label-warning">8</span>
      </li>
      
      <li>
        <a href="#storage.mli">storage.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#storage_description.ml">storage_description.ml</a>&nbsp;<span class="label label-warning">8</span>
      </li>
      
      <li>
        <a href="#storage_description.mli">storage_description.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#storage_functors.ml">storage_functors.ml</a>&nbsp;<span class="label label-warning">22</span>
      </li>
      
      <li>
        <a href="#storage_functors.mli">storage_functors.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#storage_sigs.ml">storage_sigs.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#tez_repr.ml">tez_repr.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#tez_repr.mli">tez_repr.mli</a>&nbsp;<span class="label label-warning">5</span>
      </li>
      
      <li>
        <a href="#time_repr.ml">time_repr.ml</a>&nbsp;<span class="label label-warning">6</span>
      </li>
      
      <li>
        <a href="#time_repr.mli">time_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#vote_repr.ml">vote_repr.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#vote_repr.mli">vote_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#vote_storage.ml">vote_storage.ml</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#vote_storage.mli">vote_storage.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#voting_period_repr.ml">voting_period_repr.ml</a>&nbsp;<span class="label label-warning">1</span>
      </li>
      
      <li>
        <a href="#voting_period_repr.mli">voting_period_repr.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
      <li>
        <a href="#voting_services.ml">voting_services.ml</a>&nbsp;<span class="label label-warning">7</span>
      </li>
      
      <li>
        <a href="#voting_services.mli">voting_services.mli</a>&nbsp;<span class="label label-success">‚úì</span>
      </li>
      
    </ul>
  </div>
  
</div>


<hr />
<div class="row conversion-row" id="alpha_context.ml">
  <div style="margin: 20px;">
    <h3>Alpha_context</h3>
    <ul>
      <li>OCaml size: 279 lines</li>
      <li>Coq size: 457 lines (+63% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#alpha_context.ml"><code>alpha_context.ml</code></a>&nbsp;<span class="label label-warning">2 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = Raw_context.t

type context = t

module type BASIC_DATA = sig
  type t

  include Compare.S with type t := t

  val encoding : t Data_encoding.t

  val pp : Format.formatter -&gt; t -&gt; unit
end

module Tez = Tez_repr
module Period = Period_repr

module Timestamp = struct
  include Time_repr

  let current = Raw_context.current_timestamp
end

include Operation_repr

module Operation = struct
  <abbr class="mark-warning" title="We do not handle types with both a synonym and a type definition">type 'kind t = 'kind operation = {
    shell : Operation.shell_header;
    protocol_data : 'kind protocol_data;
  }</abbr>

  type packed = packed_operation

  let unsigned_encoding = unsigned_operation_encoding

  include Operation_repr
end

module Block_header = Block_header_repr

module Vote = struct
  include Vote_repr
  include Vote_storage
end

module Raw_level = Raw_level_repr
module Cycle = Cycle_repr
module Script_int = Script_int_repr

module Script_timestamp = struct
  include Script_timestamp_repr

  let now ctxt =
    let {Constants_repr.time_between_blocks; _} = Raw_context.constants ctxt in
    match time_between_blocks with
    | [] -&gt;
        failwith
          &quot;Internal error: 'time_between_block' constants is an empty list.&quot;
    | first_delay :: _ -&gt;
        let current_timestamp = Raw_context.predecessor_timestamp ctxt in
        Time.add current_timestamp (Period_repr.to_seconds first_delay)
        |&gt; Timestamp.to_seconds |&gt; of_int64
end

module Script = struct
  include Michelson_v1_primitives
  include Script_repr

  let force_decode_in_context ctxt lexpr =
    Lwt.return
      ( Script_repr.force_decode lexpr
      &gt;&gt;? fun (v, cost) -&gt;
      Raw_context.consume_gas ctxt cost &gt;|? fun ctxt -&gt; (v, ctxt) )

  let force_bytes_in_context ctxt lexpr =
    Lwt.return
      ( Script_repr.force_bytes lexpr
      &gt;&gt;? fun (b, cost) -&gt;
      Raw_context.consume_gas ctxt cost &gt;|? fun ctxt -&gt; (b, ctxt) )

  module Legacy_support = Legacy_script_support_repr
end

module Fees = Fees_storage

type public_key = Signature.Public_key.t

type public_key_hash = Signature.Public_key_hash.t

type signature = Signature.t

module Constants = struct
  include Constants_repr
  include Constants_storage
end

module Voting_period = Voting_period_repr

module Gas = struct
  include Gas_limit_repr

  <abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Gas_limit_too_high = Raw_context.Gas_limit_too_high</abbr>

  let check_limit = Raw_context.check_gas_limit

  let set_limit = Raw_context.set_gas_limit

  let set_unlimited = Raw_context.set_gas_unlimited

  let consume = Raw_context.consume_gas

  let check_enough = Raw_context.check_enough_gas

  let level = Raw_context.gas_level

  let consumed = Raw_context.gas_consumed

  let block_level = Raw_context.block_gas_level
end

module Level = struct
  include Level_repr
  include Level_storage
end

module Contract = struct
  include Contract_repr
  include Contract_storage

  let originate c contract ~balance ~script ~delegate =
    originate_raw c contract ~balance ~script ~delegate

  let init_origination_nonce = Raw_context.init_origination_nonce

  let unset_origination_nonce = Raw_context.unset_origination_nonce
end

module Big_map = struct
  type id = Z.t

  let fresh = Storage.Big_map.Next.incr

  let fresh_temporary = Raw_context.fresh_temporary_big_map

  let mem c m k = Storage.Big_map.Contents.mem (c, m) k

  let get_opt c m k = Storage.Big_map.Contents.get_option (c, m) k

  let rpc_arg = Storage.Big_map.rpc_arg

  let cleanup_temporary c =
    Raw_context.temporary_big_maps c Storage.Big_map.remove_rec c
    &gt;&gt;= fun c -&gt; Lwt.return (Raw_context.reset_temporary_big_map c)

  let exists c id =
    Lwt.return
      (Raw_context.consume_gas c (Gas_limit_repr.read_bytes_cost Z.zero))
    &gt;&gt;=? fun c -&gt;
    Storage.Big_map.Key_type.get_option c id
    &gt;&gt;=? fun kt -&gt;
    match kt with
    | None -&gt;
        return (c, None)
    | Some kt -&gt;
        Storage.Big_map.Value_type.get c id
        &gt;&gt;=? fun kv -&gt; return (c, Some (kt, kv))
end

module Delegate = Delegate_storage

module Roll = struct
  include Roll_repr
  include Roll_storage
end

module Nonce = Nonce_storage

module Seed = struct
  include Seed_repr
  include Seed_storage
end

module Fitness = struct
  include Fitness_repr
  include Fitness

  type fitness = t

  include Fitness_storage
end

module Bootstrap = Bootstrap_storage

module Commitment = struct
  include Commitment_repr
  include Commitment_storage
end

module Global = struct
  let get_block_priority = Storage.Block_priority.get

  let set_block_priority = Storage.Block_priority.set
end

let prepare_first_block = Init_storage.prepare_first_block

let prepare = Init_storage.prepare

let finalize ?commit_message:message c =
  let fitness = Fitness.from_int64 (Fitness.current c) in
  let context = Raw_context.recover c in
  {
    Updater.context;
    fitness;
    message;
    max_operations_ttl = 60;
    last_allowed_fork_level =
      Raw_level.to_int32 @@ Level.last_allowed_fork_level c;
  }

let activate = Raw_context.activate

let fork_test_chain = Raw_context.fork_test_chain

let record_endorsement = Raw_context.record_endorsement

let allowed_endorsements = Raw_context.allowed_endorsements

let init_endorsements = Raw_context.init_endorsements

let included_endorsements = Raw_context.included_endorsements

let reset_internal_nonce = Raw_context.reset_internal_nonce

let fresh_internal_nonce = Raw_context.fresh_internal_nonce

let record_internal_nonce = Raw_context.record_internal_nonce

let internal_nonce_already_recorded =
  Raw_context.internal_nonce_already_recorded

let add_deposit = Raw_context.add_deposit

let add_fees = Raw_context.add_fees

let add_rewards = Raw_context.add_rewards

let get_deposits = Raw_context.get_deposits

let get_fees = Raw_context.get_fees

let get_rewards = Raw_context.get_rewards

let description = Raw_context.description
</pre>
  </div>
  <div class="col-md-6">
    <a href="#alpha_context.ml"><code>Alpha_context.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Block_header_repr.
Require Tezos.Bootstrap_storage.
Require Tezos.Commitment_repr.
Require Tezos.Commitment_storage.
Require Tezos.Constants_repr.
Require Tezos.Constants_storage.
Require Tezos.Contract_repr.
Require Tezos.Contract_storage.
Require Tezos.Cycle_repr.
Require Tezos.Delegate_storage.
Require Tezos.Fees_storage.
Require Tezos.Fitness_repr.
Require Tezos.Fitness_storage.
Require Tezos.Gas_limit_repr.
Require Tezos.Init_storage.
Require Tezos.Legacy_script_support_repr.
Require Tezos.Level_repr.
Require Tezos.Level_storage.
Require Tezos.Michelson_v1_primitives.
Require Tezos.Nonce_storage.
Require Tezos.Operation_repr.
Require Tezos.Period_repr.
Require Tezos.Raw_context.
Require Tezos.Raw_level_repr.
Require Tezos.Roll_repr.
Require Tezos.Roll_storage.
Require Tezos.Script_int_repr.
Require Tezos.Script_repr.
Require Tezos.Script_timestamp_repr.
Require Tezos.Seed_repr.
Require Tezos.Seed_storage.
Require Tezos.Storage_mli. Module Storage := Storage_mli.
Require Tezos.Storage_description.
Require Tezos.Storage_sigs.
Require Tezos.Tez_repr.
Require Tezos.Time_repr.
Require Tezos.Vote_repr.
Require Tezos.Vote_storage.
Require Tezos.Voting_period_repr.

Definition t : Set := Raw_context.t.

Definition context : Set := t.

Module BASIC_DATA.
  Record signature {t : Set} : Set := {
    t := t;
    op_eq : t -&gt; t -&gt; bool;
    op_ltgt : t -&gt; t -&gt; bool;
    op_lt : t -&gt; t -&gt; bool;
    op_lteq : t -&gt; t -&gt; bool;
    op_gteq : t -&gt; t -&gt; bool;
    op_gt : t -&gt; t -&gt; bool;
    compare : t -&gt; t -&gt; int;
    equal : t -&gt; t -&gt; bool;
    max : t -&gt; t -&gt; t;
    min : t -&gt; t -&gt; t;
    encoding : Data_encoding.t t;
    pp : Format.formatter -&gt; t -&gt; unit;
  }.
End BASIC_DATA.

Module Tez := Tez_repr.

Module Period := Period_repr.

Module Timestamp.
  Include Time_repr.
  
  Definition current : Raw_context.context -&gt; Time.t :=
    Raw_context.current_timestamp.
End Timestamp.

Include Operation_repr.

Module Operation.
  Definition t : Set := operation.
  
  Definition packed : Set := packed_operation.
  
  Definition unsigned_encoding
    : Data_encoding.t (Operation.shell_header * packed_contents_list) :=
    unsigned_operation_encoding.
  
  Include Operation_repr.
End Operation.

Module Block_header := Block_header_repr.

Module Vote.
  Include Vote_repr.
  
  Include Vote_storage.
End Vote.

Module Raw_level := Raw_level_repr.

Module Cycle := Cycle_repr.

Module Script_int := Script_int_repr.

Module Script_timestamp.
  Include Script_timestamp_repr.
  
  Definition now (ctxt : Raw_context.context) : t :=
    let '{|
      Constants_repr.parametric.time_between_blocks := time_between_blocks
        |} := Raw_context.constants ctxt in
    match time_between_blocks with
    | [] =&gt;
      Pervasives.failwith
        &quot;Internal error: 'time_between_block' constants is an empty list.&quot;
    | cons first_delay _ =&gt;
      let current_timestamp := Raw_context.predecessor_timestamp ctxt in
      of_int64
        (Timestamp.to_seconds
          (Time.add current_timestamp (Period_repr.to_seconds first_delay)))
    end.
End Script_timestamp.

Module Script.
  Include Michelson_v1_primitives.
  
  Include Script_repr.
  
  Definition force_decode_in_context
    (ctxt : Raw_context.context) (lexpr : Script_repr.lazy_expr)
    : Lwt.t (Error_monad.tzresult (Script_repr.expr * Raw_context.context)) :=
    Lwt.__return
      (let? '(v, cost) := Script_repr.force_decode lexpr in
      Error_monad.op_gtpipequestion (Raw_context.consume_gas ctxt cost)
        (fun ctxt =&gt; (v, ctxt))).
  
  Definition force_bytes_in_context
    (ctxt : Raw_context.context) (lexpr : Script_repr.lazy_expr)
    : Lwt.t (Error_monad.tzresult (MBytes.t * Raw_context.context)) :=
    Lwt.__return
      (let? '(__b_value, cost) := Script_repr.force_bytes lexpr in
      Error_monad.op_gtpipequestion (Raw_context.consume_gas ctxt cost)
        (fun ctxt =&gt; (__b_value, ctxt))).
  
  Module Legacy_support := Legacy_script_support_repr.
End Script.

Module Fees := Fees_storage.

Definition public_key : Set := (|Signature.Public_key|).(S.SPublic_key.t).

Definition public_key_hash : Set :=
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.t).

Definition signature : Set := Signature.t.

Module Constants.
  Include Constants_repr.
  
  Include Constants_storage.
End Constants.

Module Voting_period := Voting_period_repr.

Module Gas.
  Include Gas_limit_repr.
  
  (* ‚ùå Structure item `typext` not handled. *)
  (* type_extension *)
  
  Definition check_limit : Raw_context.t -&gt; Z.t -&gt; Error_monad.tzresult unit :=
    Raw_context.check_gas_limit.
  
  Definition set_limit : Raw_context.t -&gt; Z.t -&gt; Raw_context.t :=
    Raw_context.set_gas_limit.
  
  Definition set_unlimited : Raw_context.t -&gt; Raw_context.t :=
    Raw_context.set_gas_unlimited.
  
  Definition consume
    : Raw_context.context -&gt; Gas_limit_repr.cost -&gt;
    Error_monad.tzresult Raw_context.context := Raw_context.consume_gas.
  
  Definition check_enough
    : Raw_context.context -&gt; Gas_limit_repr.cost -&gt; Error_monad.tzresult unit :=
    Raw_context.check_enough_gas.
  
  Definition level : Raw_context.t -&gt; Gas_limit_repr.t := Raw_context.gas_level.
  
  Definition consumed : Raw_context.t -&gt; Raw_context.t -&gt; Z.t :=
    Raw_context.gas_consumed.
  
  Definition block_level : Raw_context.t -&gt; Z.t := Raw_context.block_gas_level.
End Gas.

Module Level.
  Include Level_repr.
  
  Include Level_storage.
End Level.

Module Contract.
  Include Contract_repr.
  
  Include Contract_storage.
  
  Definition originate
    (c : Raw_context.t) (contract : Contract_repr.t) (balance : Tez_repr.t)
    (script : Script_repr.t * option big_map_diff)
    (delegate : option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
    : Lwt.t (Error_monad.tzresult Raw_context.t) :=
    originate_raw c None contract balance script delegate.
  
  Definition init_origination_nonce
    : Raw_context.t -&gt; (|Operation_hash|).(S.HASH.t) -&gt; Raw_context.t :=
    Raw_context.init_origination_nonce.
  
  Definition unset_origination_nonce : Raw_context.t -&gt; Raw_context.t :=
    Raw_context.unset_origination_nonce.
End Contract.

Module Big_map.
  Definition id : Set := Z.t.
  
  Definition fresh
    : Raw_context.t -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * Z.t)) :=
    Storage.Big_map.Next.incr.
  
  Definition fresh_temporary
    : Raw_context.context -&gt; Raw_context.context * Z.t :=
    Raw_context.fresh_temporary_big_map.
  
  Definition mem
    (c : Raw_context.t) (m : Z.t)
    (k :
      (|Storage.Big_map.Contents|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
    : Lwt.t (Error_monad.tzresult (Raw_context.t * bool)) :=
    (|Storage.Big_map.Contents|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.mem)
      (c, m) k.
  
  Definition get_opt
    (c : Raw_context.t) (m : Z.t)
    (k :
      (|Storage.Big_map.Contents|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
    : Lwt.t
      (Error_monad.tzresult
        (Raw_context.t *
          option
            (|Storage.Big_map.Contents|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value))) :=
    (|Storage.Big_map.Contents|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get_option)
      (c, m) k.
  
  Definition rpc_arg : RPC_arg.t Z.t := Storage.Big_map.rpc_arg.
  
  Definition cleanup_temporary (c : Raw_context.context)
    : Lwt.t Raw_context.context :=
    let= c := Raw_context.temporary_big_maps c Storage.Big_map.remove_rec c in
    Lwt.__return (Raw_context.reset_temporary_big_map c).
  
  Definition __exists
    (c : Raw_context.context)
    (id : (|Storage.Big_map.Key_type|).(Storage_sigs.Indexed_data_storage.key))
    : Lwt.t
      (Error_monad.tzresult
        (Raw_context.context *
          option
            ((|Storage.Big_map.Key_type|).(Storage_sigs.Indexed_data_storage.value)
              *
              (|Storage.Big_map.Value_type|).(Storage_sigs.Indexed_data_storage.value)))) :=
    let=? c :=
      Lwt.__return
        (Raw_context.consume_gas c (Gas_limit_repr.read_bytes_cost Z.zero)) in
    let=? kt :=
      (|Storage.Big_map.Key_type|).(Storage_sigs.Indexed_data_storage.get_option)
        c id in
    match kt with
    | None =&gt; Error_monad.__return (c, None)
    | Some kt =&gt;
      let=? kv :=
        (|Storage.Big_map.Value_type|).(Storage_sigs.Indexed_data_storage.get) c
          id in
      Error_monad.__return (c, (Some (kt, kv)))
    end.
End Big_map.

Module Delegate := Delegate_storage.

Module Roll.
  Include Roll_repr.
  
  Include Roll_storage.
End Roll.

Module Nonce := Nonce_storage.

Module Seed.
  Include Seed_repr.
  
  Include Seed_storage.
End Seed.

Module Fitness.
  Include Fitness_repr.
  
  Definition t := (|Fitness|).(S.T.t).
  
  Definition op_eq := (|Fitness|).(S.T.op_eq).
  
  Definition op_ltgt := (|Fitness|).(S.T.op_ltgt).
  
  Definition op_lt := (|Fitness|).(S.T.op_lt).
  
  Definition op_lteq := (|Fitness|).(S.T.op_lteq).
  
  Definition op_gteq := (|Fitness|).(S.T.op_gteq).
  
  Definition op_gt := (|Fitness|).(S.T.op_gt).
  
  Definition compare := (|Fitness|).(S.T.compare).
  
  Definition equal := (|Fitness|).(S.T.equal).
  
  Definition max := (|Fitness|).(S.T.max).
  
  Definition min := (|Fitness|).(S.T.min).
  
  Definition pp := (|Fitness|).(S.T.pp).
  
  Definition encoding := (|Fitness|).(S.T.encoding).
  
  Definition to_bytes := (|Fitness|).(S.T.to_bytes).
  
  Definition of_bytes := (|Fitness|).(S.T.of_bytes).
  
  Definition fitness : Set := t.
  
  Include Fitness_storage.
End Fitness.

Module Bootstrap := Bootstrap_storage.

Module Commitment.
  Include Commitment_repr.
  
  Include Commitment_storage.
End Commitment.

Module Global.
  Definition get_block_priority
    : Raw_context.t -&gt; Lwt.t (Error_monad.tzresult int) :=
    Storage.Block_priority.get.
  
  Definition set_block_priority
    : Raw_context.t -&gt; int -&gt; Lwt.t (Error_monad.tzresult Raw_context.t) :=
    Storage.Block_priority.set.
End Global.

Definition prepare_first_block
  : Context.t -&gt;
  (Raw_context.t -&gt; Script_repr.t -&gt;
  Lwt.t
    (Error_monad.tzresult
      ((Script_repr.t * option Contract_storage.big_map_diff) * Raw_context.t)))
  -&gt; int32 -&gt; Time.t -&gt; (|Fitness|).(S.T.t) -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t) := Init_storage.prepare_first_block.

Definition prepare
  : Context.t -&gt; Int32.t -&gt; Time.t -&gt; Time.t -&gt; (|Fitness|).(S.T.t) -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.context) := Init_storage.prepare.

Definition finalize (message : option string) (c : Raw_context.context)
  : Updater.validation_result :=
  let fitness := Fitness.from_int64 (Fitness.current c) in
  let context := Raw_context.recover c in
  {| Updater.validation_result.context := context;
    Updater.validation_result.fitness := fitness;
    Updater.validation_result.message := message;
    Updater.validation_result.max_operations_ttl := 60;
    Updater.validation_result.last_allowed_fork_level :=
      Raw_level.to_int32 (Level.last_allowed_fork_level c) |}.

Definition activate
  : Raw_context.context -&gt; (|Protocol_hash|).(S.HASH.t) -&gt; Lwt.t Raw_context.t :=
  Raw_context.activate.

Definition fork_test_chain
  : Raw_context.context -&gt; (|Protocol_hash|).(S.HASH.t) -&gt; Time.t -&gt;
  Lwt.t Raw_context.t := Raw_context.fork_test_chain.

Definition record_endorsement
  : Raw_context.context -&gt;
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt; Raw_context.context :=
  Raw_context.record_endorsement.

Definition allowed_endorsements
  : Raw_context.context -&gt;
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t)
    ((|Signature.Public_key|).(S.SPublic_key.t) * list int * bool) :=
  Raw_context.allowed_endorsements.

Definition init_endorsements
  : Raw_context.context -&gt;
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t)
    ((|Signature.Public_key|).(S.SPublic_key.t) * list int * bool) -&gt;
  Raw_context.context := Raw_context.init_endorsements.

Definition included_endorsements : Raw_context.context -&gt; int :=
  Raw_context.included_endorsements.

Definition reset_internal_nonce : Raw_context.context -&gt; Raw_context.context :=
  Raw_context.reset_internal_nonce.

Definition fresh_internal_nonce
  : Raw_context.context -&gt; Error_monad.tzresult (Raw_context.context * int) :=
  Raw_context.fresh_internal_nonce.

Definition record_internal_nonce
  : Raw_context.context -&gt; int -&gt; Raw_context.context :=
  Raw_context.record_internal_nonce.

Definition internal_nonce_already_recorded
  : Raw_context.context -&gt; int -&gt; bool :=
  Raw_context.internal_nonce_already_recorded.

Definition add_deposit
  : Raw_context.context -&gt;
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt; Tez_repr.t -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.context) := Raw_context.add_deposit.

Definition add_fees
  : Raw_context.context -&gt; Tez_repr.t -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.context) := Raw_context.add_fees.

Definition add_rewards
  : Raw_context.context -&gt; Tez_repr.t -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.context) := Raw_context.add_rewards.

Definition get_deposits
  : Raw_context.context -&gt;
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t)
    Tez_repr.t := Raw_context.get_deposits.

Definition get_fees : Raw_context.context -&gt; Tez_repr.t := Raw_context.get_fees.

Definition get_rewards : Raw_context.context -&gt; Tez_repr.t :=
  Raw_context.get_rewards.

Definition description : Storage_description.t Raw_context.context :=
  Raw_context.description.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="alpha_context.mli">
  <div style="margin: 20px;">
    <h3>Alpha_context_mli</h3>
    <ul>
      <li>OCaml size: 1393 lines</li>
      <li>Coq size: 2558 lines (+83% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#alpha_context.mli"><code>alpha_context.mli</code></a>&nbsp;<span class="label label-warning">15 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

module type BASIC_DATA = sig
  type t

  include Compare.S with type t := t

  val encoding : t Data_encoding.t

  val pp : Format.formatter -&gt; t -&gt; unit
end

type t

type context = t

type public_key = Signature.Public_key.t

type public_key_hash = Signature.Public_key_hash.t

type signature = Signature.t

module Tez : sig
  include BASIC_DATA with type t = Tez_repr.t

  type tez = t

  val zero : tez

  val one_mutez : tez

  val one_cent : tez

  val fifty_cents : tez

  val one : tez

  val ( -? ) : tez -&gt; tez -&gt; tez tzresult

  val ( +? ) : tez -&gt; tez -&gt; tez tzresult

  val ( *? ) : tez -&gt; int64 -&gt; tez tzresult

  val ( /? ) : tez -&gt; int64 -&gt; tez tzresult

  val of_string : string -&gt; tez option

  val to_string : tez -&gt; string

  val of_mutez : int64 -&gt; tez option

  val to_mutez : tez -&gt; int64
end

module Period : sig
  include BASIC_DATA

  type period = t

  val rpc_arg : period RPC_arg.arg

  val of_seconds : int64 -&gt; period tzresult

  val to_seconds : period -&gt; int64

  val mult : int32 -&gt; period -&gt; period tzresult

  val zero : period

  val one_second : period

  val one_minute : period

  val one_hour : period
end

module Timestamp : sig
  include BASIC_DATA with type t = Time.t

  type time = t

  val ( +? ) : time -&gt; Period.t -&gt; time tzresult

  val ( -? ) : time -&gt; time -&gt; Period.t tzresult

  val of_notation : string -&gt; time option

  val to_notation : time -&gt; string

  val of_seconds_string : string -&gt; time option

  val to_seconds_string : time -&gt; string

  val current : context -&gt; time
end

module Raw_level : sig
  include BASIC_DATA

  type raw_level = t

  val rpc_arg : raw_level RPC_arg.arg

  val diff : raw_level -&gt; raw_level -&gt; int32

  val root : raw_level

  val succ : raw_level -&gt; raw_level

  val pred : raw_level -&gt; raw_level option

  val to_int32 : raw_level -&gt; int32

  val of_int32 : int32 -&gt; raw_level tzresult
end

module Cycle : sig
  include BASIC_DATA

  type cycle = t

  val rpc_arg : cycle RPC_arg.arg

  val root : cycle

  val succ : cycle -&gt; cycle

  val pred : cycle -&gt; cycle option

  val add : cycle -&gt; int -&gt; cycle

  val sub : cycle -&gt; int -&gt; cycle option

  val to_int32 : cycle -&gt; int32

  module Map : S.MAP with type key = cycle
end

module Gas : sig
  type t = private Unaccounted | Limited of {remaining : Z.t}

  val encoding : t Data_encoding.encoding

  val pp : Format.formatter -&gt; t -&gt; unit

  type cost

  val cost_encoding : cost Data_encoding.encoding

  val pp_cost : Format.formatter -&gt; cost -&gt; unit

  <abbr class="mark-warning" title="Extensible types are not handled.">type error += Block_quota_exceeded</abbr> (* `Temporary *)

  <abbr class="mark-warning" title="Extensible types are not handled.">type error += Operation_quota_exceeded</abbr> (* `Temporary *)

  <abbr class="mark-warning" title="Extensible types are not handled.">type error += Gas_limit_too_high</abbr> (* `Permanent *)

  val free : cost

  val atomic_step_cost : int -&gt; cost

  val step_cost : int -&gt; cost

  val alloc_cost : int -&gt; cost

  val alloc_bytes_cost : int -&gt; cost

  val alloc_mbytes_cost : int -&gt; cost

  val alloc_bits_cost : int -&gt; cost

  val read_bytes_cost : Z.t -&gt; cost

  val write_bytes_cost : Z.t -&gt; cost

  val ( *@ ) : int -&gt; cost -&gt; cost

  val ( +@ ) : cost -&gt; cost -&gt; cost

  val check_limit : context -&gt; Z.t -&gt; unit tzresult

  val set_limit : context -&gt; Z.t -&gt; context

  val set_unlimited : context -&gt; context

  val consume : context -&gt; cost -&gt; context tzresult

  val check_enough : context -&gt; cost -&gt; unit tzresult

  val level : context -&gt; t

  val consumed : since:context -&gt; until:context -&gt; Z.t

  val block_level : context -&gt; Z.t
end

module Script_int = Script_int_repr

module Script_timestamp : sig
  open Script_int

  type t

  val compare : t -&gt; t -&gt; int

  val to_string : t -&gt; string

  val to_notation : t -&gt; string option

  val to_num_str : t -&gt; string

  val of_string : string -&gt; t option

  val diff : t -&gt; t -&gt; num

  val add_delta : t -&gt; num -&gt; t

  val sub_delta : t -&gt; num -&gt; t

  val now : context -&gt; t

  val to_zint : t -&gt; Z.t

  val of_zint : Z.t -&gt; t
end

module Script : sig
  <abbr class="mark-warning" title="We do not handle types with both a synonym and a type definition">type prim = Michelson_v1_primitives.prim =
    | K_parameter
    | K_storage
    | K_code
    | D_False
    | D_Elt
    | D_Left
    | D_None
    | D_Pair
    | D_Right
    | D_Some
    | D_True
    | D_Unit
    | I_PACK
    | I_UNPACK
    | I_BLAKE2B
    | I_SHA256
    | I_SHA512
    | I_ABS
    | I_ADD
    | I_AMOUNT
    | I_AND
    | I_BALANCE
    | I_CAR
    | I_CDR
    | I_CHAIN_ID
    | I_CHECK_SIGNATURE
    | I_COMPARE
    | I_CONCAT
    | I_CONS
    | I_CREATE_ACCOUNT
    | I_CREATE_CONTRACT
    | I_IMPLICIT_ACCOUNT
    | I_DIP
    | I_DROP
    | I_DUP
    | I_EDIV
    | I_EMPTY_BIG_MAP
    | I_EMPTY_MAP
    | I_EMPTY_SET
    | I_EQ
    | I_EXEC
    | I_APPLY
    | I_FAILWITH
    | I_GE
    | I_GET
    | I_GT
    | I_HASH_KEY
    | I_IF
    | I_IF_CONS
    | I_IF_LEFT
    | I_IF_NONE
    | I_INT
    | I_LAMBDA
    | I_LE
    | I_LEFT
    | I_LOOP
    | I_LSL
    | I_LSR
    | I_LT
    | I_MAP
    | I_MEM
    | I_MUL
    | I_NEG
    | I_NEQ
    | I_NIL
    | I_NONE
    | I_NOT
    | I_NOW
    | I_OR
    | I_PAIR
    | I_PUSH
    | I_RIGHT
    | I_SIZE
    | I_SOME
    | I_SOURCE
    | I_SENDER
    | I_SELF
    | I_SLICE
    | I_STEPS_TO_QUOTA
    | I_SUB
    | I_SWAP
    | I_TRANSFER_TOKENS
    | I_SET_DELEGATE
    | I_UNIT
    | I_UPDATE
    | I_XOR
    | I_ITER
    | I_LOOP_LEFT
    | I_ADDRESS
    | I_CONTRACT
    | I_ISNAT
    | I_CAST
    | I_RENAME
    | I_DIG
    | I_DUG
    | T_bool
    | T_contract
    | T_int
    | T_key
    | T_key_hash
    | T_lambda
    | T_list
    | T_map
    | T_big_map
    | T_nat
    | T_option
    | T_or
    | T_pair
    | T_set
    | T_signature
    | T_string
    | T_bytes
    | T_mutez
    | T_timestamp
    | T_unit
    | T_operation
    | T_address
    | T_chain_id</abbr>

  type location = Micheline.canonical_location

  type annot = Micheline.annot

  type expr = prim Micheline.canonical

  type lazy_expr = expr Data_encoding.lazy_t

  val lazy_expr : expr -&gt; lazy_expr

  type node = (location, prim) Micheline.node

  type t = {code : lazy_expr; storage : lazy_expr}

  val location_encoding : location Data_encoding.t

  val expr_encoding : expr Data_encoding.t

  val prim_encoding : prim Data_encoding.t

  val encoding : t Data_encoding.t

  val lazy_expr_encoding : lazy_expr Data_encoding.t

  val deserialized_cost : expr -&gt; Gas.cost

  val serialized_cost : MBytes.t -&gt; Gas.cost

  val traversal_cost : node -&gt; Gas.cost

  val node_cost : node -&gt; Gas.cost

  val int_node_cost : Z.t -&gt; Gas.cost

  val int_node_cost_of_numbits : int -&gt; Gas.cost

  val string_node_cost : string -&gt; Gas.cost

  val string_node_cost_of_length : int -&gt; Gas.cost

  val bytes_node_cost : MBytes.t -&gt; Gas.cost

  val bytes_node_cost_of_length : int -&gt; Gas.cost

  val prim_node_cost_nonrec : expr list -&gt; annot -&gt; Gas.cost

  val prim_node_cost_nonrec_of_length : int -&gt; annot -&gt; Gas.cost

  val seq_node_cost_nonrec : expr list -&gt; Gas.cost

  val seq_node_cost_nonrec_of_length : int -&gt; Gas.cost

  val minimal_deserialize_cost : lazy_expr -&gt; Gas.cost

  val force_decode_in_context :
    context -&gt; lazy_expr -&gt; (expr * context) tzresult Lwt.t

  val force_bytes_in_context :
    context -&gt; lazy_expr -&gt; (MBytes.t * context) tzresult Lwt.t

  val unit_parameter : lazy_expr

  module Legacy_support : sig
    val manager_script_code : lazy_expr

    val add_do :
      manager_pkh:Signature.Public_key_hash.t -&gt;
      script_code:lazy_expr -&gt;
      script_storage:lazy_expr -&gt;
      (lazy_expr * lazy_expr) tzresult Lwt.t

    val add_set_delegate :
      manager_pkh:Signature.Public_key_hash.t -&gt;
      script_code:lazy_expr -&gt;
      script_storage:lazy_expr -&gt;
      (lazy_expr * lazy_expr) tzresult Lwt.t

    val has_default_entrypoint : lazy_expr -&gt; bool

    val add_root_entrypoint : script_code:lazy_expr -&gt; lazy_expr tzresult Lwt.t
  end
end

module Constants : sig
  (** Fixed constants *)
  type fixed = {
    proof_of_work_nonce_size : int;
    nonce_length : int;
    max_revelations_per_block : int;
    max_operation_data_length : int;
    max_proposals_per_delegate : int;
  }

  val fixed_encoding : fixed Data_encoding.t

  val fixed : fixed

  val proof_of_work_nonce_size : int

  val nonce_length : int

  val max_revelations_per_block : int

  val max_operation_data_length : int

  val max_proposals_per_delegate : int

  (** Constants parameterized by context *)
  type parametric = {
    preserved_cycles : int;
    blocks_per_cycle : int32;
    blocks_per_commitment : int32;
    blocks_per_roll_snapshot : int32;
    blocks_per_voting_period : int32;
    time_between_blocks : Period.t list;
    endorsers_per_block : int;
    hard_gas_limit_per_operation : Z.t;
    hard_gas_limit_per_block : Z.t;
    proof_of_work_threshold : int64;
    tokens_per_roll : Tez.t;
    michelson_maximum_type_size : int;
    seed_nonce_revelation_tip : Tez.t;
    origination_size : int;
    block_security_deposit : Tez.t;
    endorsement_security_deposit : Tez.t;
    block_reward : Tez.t;
    endorsement_reward : Tez.t;
    cost_per_byte : Tez.t;
    hard_storage_limit_per_operation : Z.t;
    test_chain_duration : int64;
    quorum_min : int32;
    quorum_max : int32;
    min_proposal_quorum : int32;
    initial_endorsers : int;
    delay_per_missing_endorsement : Period.t;
  }

  val parametric_encoding : parametric Data_encoding.t

  val parametric : context -&gt; parametric

  val preserved_cycles : context -&gt; int

  val blocks_per_cycle : context -&gt; int32

  val blocks_per_commitment : context -&gt; int32

  val blocks_per_roll_snapshot : context -&gt; int32

  val blocks_per_voting_period : context -&gt; int32

  val time_between_blocks : context -&gt; Period.t list

  val endorsers_per_block : context -&gt; int

  val initial_endorsers : context -&gt; int

  val delay_per_missing_endorsement : context -&gt; Period.t

  val hard_gas_limit_per_operation : context -&gt; Z.t

  val hard_gas_limit_per_block : context -&gt; Z.t

  val cost_per_byte : context -&gt; Tez.t

  val hard_storage_limit_per_operation : context -&gt; Z.t

  val proof_of_work_threshold : context -&gt; int64

  val tokens_per_roll : context -&gt; Tez.t

  val michelson_maximum_type_size : context -&gt; int

  val block_reward : context -&gt; Tez.t

  val endorsement_reward : context -&gt; Tez.t

  val seed_nonce_revelation_tip : context -&gt; Tez.t

  val origination_size : context -&gt; int

  val block_security_deposit : context -&gt; Tez.t

  val endorsement_security_deposit : context -&gt; Tez.t

  val test_chain_duration : context -&gt; int64

  val quorum_min : context -&gt; int32

  val quorum_max : context -&gt; int32

  val min_proposal_quorum : context -&gt; int32

  (** All constants: fixed and parametric *)
  type t = {fixed : fixed; parametric : parametric}

  val encoding : t Data_encoding.t
end

module Voting_period : sig
  include BASIC_DATA

  type voting_period = t

  val rpc_arg : voting_period RPC_arg.arg

  val root : voting_period

  val succ : voting_period -&gt; voting_period

  type kind = Proposal | Testing_vote | Testing | Promotion_vote

  val kind_encoding : kind Data_encoding.encoding

  val to_int32 : voting_period -&gt; int32
end

module Level : sig
  type t = private {
    level : Raw_level.t;
    level_position : int32;
    cycle : Cycle.t;
    cycle_position : int32;
    voting_period : Voting_period.t;
    voting_period_position : int32;
    expected_commitment : bool;
  }

  include BASIC_DATA with type t := t

  val pp_full : Format.formatter -&gt; t -&gt; unit

  type level = t

  val root : context -&gt; level

  val succ : context -&gt; level -&gt; level

  val pred : context -&gt; level -&gt; level option

  val from_raw : context -&gt; ?offset:int32 -&gt; Raw_level.t -&gt; level

  val diff : level -&gt; level -&gt; int32

  val current : context -&gt; level

  val last_level_in_cycle : context -&gt; Cycle.t -&gt; level

  val levels_in_cycle : context -&gt; Cycle.t -&gt; level list

  val levels_in_current_cycle : context -&gt; ?offset:int32 -&gt; unit -&gt; level list

  val last_allowed_fork_level : context -&gt; Raw_level.t
end

module Fitness : sig
  include module type of Fitness

  type fitness = t

  val increase : ?gap:int -&gt; context -&gt; context

  val current : context -&gt; int64

  val to_int64 : fitness -&gt; int64 tzresult
end

module Nonce : sig
  type t = Nonce_storage.t

  type nonce = t

  val encoding : nonce Data_encoding.t

  type unrevealed = Storage.unrevealed_nonce

  val record_hash : context -&gt; unrevealed -&gt; context tzresult Lwt.t

  val reveal : context -&gt; Level.t -&gt; nonce -&gt; context tzresult Lwt.t

  type status = Storage.nonce_status

  val get : context -&gt; Level.t -&gt; status tzresult Lwt.t

  val of_bytes : MBytes.t -&gt; nonce tzresult

  val hash : nonce -&gt; Nonce_hash.t

  val check_hash : nonce -&gt; Nonce_hash.t -&gt; bool
end

module Seed : sig
  type seed

  <abbr class="mark-warning" title="Extensible types are not handled.">type error +=
    | Unknown of {oldest : Cycle.t; cycle : Cycle.t; latest : Cycle.t}</abbr>

  val for_cycle : context -&gt; Cycle.t -&gt; seed tzresult Lwt.t

  val cycle_end :
    context -&gt; Cycle.t -&gt; (context * Nonce.unrevealed list) tzresult Lwt.t

  val seed_encoding : seed Data_encoding.t
end

module Big_map : sig
  type id = Z.t

  val fresh : context -&gt; (context * id) tzresult Lwt.t

  val fresh_temporary : context -&gt; context * id

  val mem :
    context -&gt; id -&gt; Script_expr_hash.t -&gt; (context * bool) tzresult Lwt.t

  val get_opt :
    context -&gt;
    id -&gt;
    Script_expr_hash.t -&gt;
    (context * Script.expr option) tzresult Lwt.t

  val rpc_arg : id RPC_arg.t

  val cleanup_temporary : context -&gt; context Lwt.t

  val exists :
    context -&gt;
    id -&gt;
    (context * (Script.expr * Script.expr) option) tzresult Lwt.t
end

module Contract : sig
  include BASIC_DATA

  type contract = t

  val rpc_arg : contract RPC_arg.arg

  val to_b58check : contract -&gt; string

  val of_b58check : string -&gt; contract tzresult

  val implicit_contract : public_key_hash -&gt; contract

  val is_implicit : contract -&gt; public_key_hash option

  val exists : context -&gt; contract -&gt; bool tzresult Lwt.t

  val must_exist : context -&gt; contract -&gt; unit tzresult Lwt.t

  val allocated : context -&gt; contract -&gt; bool tzresult Lwt.t

  val must_be_allocated : context -&gt; contract -&gt; unit tzresult Lwt.t

  val list : context -&gt; contract list Lwt.t

  val get_manager_key : context -&gt; public_key_hash -&gt; public_key tzresult Lwt.t

  val is_manager_key_revealed :
    context -&gt; public_key_hash -&gt; bool tzresult Lwt.t

  val reveal_manager_key :
    context -&gt; public_key_hash -&gt; public_key -&gt; context tzresult Lwt.t

  val get_script_code :
    context -&gt; contract -&gt; (context * Script.lazy_expr option) tzresult Lwt.t

  val get_script :
    context -&gt; contract -&gt; (context * Script.t option) tzresult Lwt.t

  val get_storage :
    context -&gt; contract -&gt; (context * Script.expr option) tzresult Lwt.t

  val get_counter : context -&gt; public_key_hash -&gt; Z.t tzresult Lwt.t

  val get_balance : context -&gt; contract -&gt; Tez.t tzresult Lwt.t

  val init_origination_nonce : context -&gt; Operation_hash.t -&gt; context

  val unset_origination_nonce : context -&gt; context

  val fresh_contract_from_current_nonce :
    context -&gt; (context * t) tzresult Lwt.t

  val originated_from_current_nonce :
    since:context -&gt; until:context -&gt; contract list tzresult Lwt.t

  type big_map_diff_item =
    | Update of {
        big_map : Big_map.id;
        diff_key : Script.expr;
        diff_key_hash : Script_expr_hash.t;
        diff_value : Script.expr option;
      }
    | Clear of Big_map.id
    | Copy of Big_map.id * Big_map.id
    | Alloc of {
        big_map : Big_map.id;
        key_type : Script.expr;
        value_type : Script.expr;
      }

  type big_map_diff = big_map_diff_item list

  val big_map_diff_encoding : big_map_diff Data_encoding.t

  val originate :
    context -&gt;
    contract -&gt;
    balance:Tez.t -&gt;
    script:Script.t * big_map_diff option -&gt;
    delegate:public_key_hash option -&gt;
    context tzresult Lwt.t

  <abbr class="mark-warning" title="Extensible types are not handled.">type error += Balance_too_low of contract * Tez.t * Tez.t</abbr>

  val spend : context -&gt; contract -&gt; Tez.t -&gt; context tzresult Lwt.t

  val credit : context -&gt; contract -&gt; Tez.t -&gt; context tzresult Lwt.t

  val update_script_storage :
    context -&gt;
    contract -&gt;
    Script.expr -&gt;
    big_map_diff option -&gt;
    context tzresult Lwt.t

  val used_storage_space : context -&gt; t -&gt; Z.t tzresult Lwt.t

  val increment_counter : context -&gt; public_key_hash -&gt; context tzresult Lwt.t

  val check_counter_increment :
    context -&gt; public_key_hash -&gt; Z.t -&gt; unit tzresult Lwt.t

  (**/**)

  (* Only for testing *)
  type origination_nonce

  val initial_origination_nonce : Operation_hash.t -&gt; origination_nonce

  val originated_contract : origination_nonce -&gt; contract
end

module Delegate : sig
  type balance =
    | Contract of Contract.t
    | Rewards of Signature.Public_key_hash.t * Cycle.t
    | Fees of Signature.Public_key_hash.t * Cycle.t
    | Deposits of Signature.Public_key_hash.t * Cycle.t

  type balance_update = Debited of Tez.t | Credited of Tez.t

  type balance_updates = (balance * balance_update) list

  val balance_updates_encoding : balance_updates Data_encoding.t

  val cleanup_balance_updates : balance_updates -&gt; balance_updates

  val get : context -&gt; Contract.t -&gt; public_key_hash option tzresult Lwt.t

  val set :
    context -&gt; Contract.t -&gt; public_key_hash option -&gt; context tzresult Lwt.t

  val fold :
    context -&gt; init:'a -&gt; f:(public_key_hash -&gt; 'a -&gt; 'a Lwt.t) -&gt; 'a Lwt.t

  val list : context -&gt; public_key_hash list Lwt.t

  val freeze_deposit :
    context -&gt; public_key_hash -&gt; Tez.t -&gt; context tzresult Lwt.t

  val freeze_rewards :
    context -&gt; public_key_hash -&gt; Tez.t -&gt; context tzresult Lwt.t

  val freeze_fees :
    context -&gt; public_key_hash -&gt; Tez.t -&gt; context tzresult Lwt.t

  val cycle_end :
    context -&gt;
    Cycle.t -&gt;
    Nonce.unrevealed list -&gt;
    (context * balance_updates * Signature.Public_key_hash.t list) tzresult
    Lwt.t

  type frozen_balance = {deposit : Tez.t; fees : Tez.t; rewards : Tez.t}

  val punish :
    context -&gt;
    public_key_hash -&gt;
    Cycle.t -&gt;
    (context * frozen_balance) tzresult Lwt.t

  val full_balance : context -&gt; public_key_hash -&gt; Tez.t tzresult Lwt.t

  val has_frozen_balance :
    context -&gt; public_key_hash -&gt; Cycle.t -&gt; bool tzresult Lwt.t

  val frozen_balance : context -&gt; public_key_hash -&gt; Tez.t tzresult Lwt.t

  val frozen_balance_encoding : frozen_balance Data_encoding.t

  val frozen_balance_by_cycle_encoding :
    frozen_balance Cycle.Map.t Data_encoding.t

  val frozen_balance_by_cycle :
    context -&gt; Signature.Public_key_hash.t -&gt; frozen_balance Cycle.Map.t Lwt.t

  val staking_balance :
    context -&gt; Signature.Public_key_hash.t -&gt; Tez.t tzresult Lwt.t

  val delegated_contracts :
    context -&gt; Signature.Public_key_hash.t -&gt; Contract_repr.t list Lwt.t

  val delegated_balance :
    context -&gt; Signature.Public_key_hash.t -&gt; Tez.t tzresult Lwt.t

  val deactivated :
    context -&gt; Signature.Public_key_hash.t -&gt; bool tzresult Lwt.t

  val grace_period :
    context -&gt; Signature.Public_key_hash.t -&gt; Cycle.t tzresult Lwt.t
end

module Vote : sig
  type proposal = Protocol_hash.t

  val record_proposal :
    context -&gt; Protocol_hash.t -&gt; public_key_hash -&gt; context tzresult Lwt.t

  val get_proposals : context -&gt; int32 Protocol_hash.Map.t tzresult Lwt.t

  val clear_proposals : context -&gt; context Lwt.t

  val recorded_proposal_count_for_delegate :
    context -&gt; public_key_hash -&gt; int tzresult Lwt.t

  val listings_encoding :
    (Signature.Public_key_hash.t * int32) list Data_encoding.t

  val freeze_listings : context -&gt; context tzresult Lwt.t

  val clear_listings : context -&gt; context tzresult Lwt.t

  val listing_size : context -&gt; int32 tzresult Lwt.t

  val in_listings : context -&gt; public_key_hash -&gt; bool Lwt.t

  val get_listings : context -&gt; (public_key_hash * int32) list Lwt.t

  type ballot = Yay | Nay | Pass

  val ballot_encoding : ballot Data_encoding.t

  type ballots = {yay : int32; nay : int32; pass : int32}

  val ballots_encoding : ballots Data_encoding.t

  val has_recorded_ballot : context -&gt; public_key_hash -&gt; bool Lwt.t

  val record_ballot :
    context -&gt; public_key_hash -&gt; ballot -&gt; context tzresult Lwt.t

  val get_ballots : context -&gt; ballots tzresult Lwt.t

  val get_ballot_list :
    context -&gt; (Signature.Public_key_hash.t * ballot) list Lwt.t

  val clear_ballots : context -&gt; context Lwt.t

  val get_current_period_kind : context -&gt; Voting_period.kind tzresult Lwt.t

  val set_current_period_kind :
    context -&gt; Voting_period.kind -&gt; context tzresult Lwt.t

  val get_current_quorum : context -&gt; int32 tzresult Lwt.t

  val get_participation_ema : context -&gt; int32 tzresult Lwt.t

  val set_participation_ema : context -&gt; int32 -&gt; context tzresult Lwt.t

  val get_current_proposal : context -&gt; proposal tzresult Lwt.t

  val init_current_proposal : context -&gt; proposal -&gt; context tzresult Lwt.t

  val clear_current_proposal : context -&gt; context tzresult Lwt.t
end

module Block_header : sig
  <abbr class="mark-warning" title="We do not handle types with both a synonym and a type definition">type contents = Block_header_repr.contents = {
    priority : int;
    seed_nonce_hash : Nonce_hash.t option;
    proof_of_work_nonce : MBytes.t;
  }</abbr>

  <abbr class="mark-warning" title="We do not handle types with both a synonym and a type definition">type protocol_data = Block_header_repr.protocol_data = {
    contents : contents;
    signature : Signature.t;
  }</abbr>

  <abbr class="mark-warning" title="We do not handle types with both a synonym and a type definition">type block_header = Block_header_repr.block_header = {
    shell : Block_header.shell_header;
    protocol_data : protocol_data;
  }</abbr>

  type raw = Block_header.t

  type shell_header = Block_header.shell_header

  val raw : block_header -&gt; raw

  val hash : block_header -&gt; Block_hash.t

  val hash_raw : raw -&gt; Block_hash.t

  val encoding : block_header Data_encoding.encoding

  val raw_encoding : raw Data_encoding.t

  val contents_encoding : contents Data_encoding.t

  val unsigned_encoding : (shell_header * contents) Data_encoding.t

  val protocol_data_encoding : protocol_data Data_encoding.encoding

  val shell_header_encoding : shell_header Data_encoding.encoding

  (** The maximum size of block headers in bytes *)
  val max_header_length : int
end

module Kind : sig
  type seed_nonce_revelation = Seed_nonce_revelation_kind

  type double_endorsement_evidence = Double_endorsement_evidence_kind

  type double_baking_evidence = Double_baking_evidence_kind

  type activate_account = Activate_account_kind

  type endorsement = Endorsement_kind

  type proposals = Proposals_kind

  type ballot = Ballot_kind

  type reveal = Reveal_kind

  type transaction = Transaction_kind

  type origination = Origination_kind

  type delegation = Delegation_kind

  type 'a manager =
    | Reveal_manager_kind : reveal manager
    | Transaction_manager_kind : transaction manager
    | Origination_manager_kind : origination manager
    | Delegation_manager_kind : delegation manager
end

type _ contents_list =
  | Single : 'kind contents -&gt; 'kind contents_list
  | Cons :
      'kind Kind.manager contents * 'rest Kind.manager contents_list
      -&gt; ('kind * 'rest) Kind.manager contents_list

and 'kind protocol_data = {
  contents : 'kind contents_list;
  signature : Signature.t option;
}

and 'kind operation = {
  shell : Operation.shell_header;
  protocol_data : 'kind protocol_data;
}

and _ contents =
  | Endorsement : {level : Raw_level.t} -&gt; Kind.endorsement contents
  | Seed_nonce_revelation : {
      level : Raw_level.t;
      nonce : Nonce.t;
    }
      -&gt; Kind.seed_nonce_revelation contents
  | Double_endorsement_evidence : {
      op1 : Kind.endorsement operation;
      op2 : Kind.endorsement operation;
    }
      -&gt; Kind.double_endorsement_evidence contents
  | Double_baking_evidence : {
      bh1 : Block_header.block_header;
      bh2 : Block_header.block_header;
    }
      -&gt; Kind.double_baking_evidence contents
  | Activate_account : {
      id : Ed25519.Public_key_hash.t;
      activation_code : Blinded_public_key_hash.activation_code;
    }
      -&gt; Kind.activate_account contents
  | Proposals : {
      source : Signature.Public_key_hash.t;
      period : Voting_period.t;
      proposals : Protocol_hash.t list;
    }
      -&gt; Kind.proposals contents
  | Ballot : {
      source : Signature.Public_key_hash.t;
      period : Voting_period.t;
      proposal : Protocol_hash.t;
      ballot : Vote.ballot;
    }
      -&gt; Kind.ballot contents
  | Manager_operation : {
      source : Signature.Public_key_hash.t;
      fee : Tez.tez;
      counter : counter;
      operation : 'kind manager_operation;
      gas_limit : Z.t;
      storage_limit : Z.t;
    }
      -&gt; 'kind Kind.manager contents

and _ manager_operation =
  | Reveal : Signature.Public_key.t -&gt; Kind.reveal manager_operation
  | Transaction : {
      amount : Tez.tez;
      parameters : Script.lazy_expr;
      entrypoint : string;
      destination : Contract.contract;
    }
      -&gt; Kind.transaction manager_operation
  | Origination : {
      delegate : Signature.Public_key_hash.t option;
      script : Script.t;
      credit : Tez.tez;
      preorigination : Contract.t option;
    }
      -&gt; Kind.origination manager_operation
  | Delegation :
      Signature.Public_key_hash.t option
      -&gt; Kind.delegation manager_operation

and counter = Z.t

type 'kind internal_operation = {
  source : Contract.contract;
  operation : 'kind manager_operation;
  nonce : int;
}

type packed_manager_operation =
  | Manager : 'kind manager_operation -&gt; packed_manager_operation

type packed_contents = Contents : 'kind contents -&gt; packed_contents

type packed_contents_list =
  | Contents_list : 'kind contents_list -&gt; packed_contents_list

type packed_protocol_data =
  | Operation_data : 'kind protocol_data -&gt; packed_protocol_data

type packed_operation = {
  shell : Operation.shell_header;
  protocol_data : packed_protocol_data;
}

type packed_internal_operation =
  | Internal_operation : 'kind internal_operation -&gt; packed_internal_operation

val manager_kind : 'kind manager_operation -&gt; 'kind Kind.manager

module Fees : sig
  val origination_burn : context -&gt; (context * Tez.t) tzresult Lwt.t

  val record_paid_storage_space :
    context -&gt; Contract.t -&gt; (context * Z.t * Z.t * Tez.t) tzresult Lwt.t

  val start_counting_storage_fees : context -&gt; context

  val burn_storage_fees :
    context -&gt; storage_limit:Z.t -&gt; payer:Contract.t -&gt; context tzresult Lwt.t

  <abbr class="mark-warning" title="Extensible types are not handled.">type error += Cannot_pay_storage_fee</abbr> (* `Temporary *)

  <abbr class="mark-warning" title="Extensible types are not handled.">type error += Operation_quota_exceeded</abbr> (* `Temporary *)

  <abbr class="mark-warning" title="Extensible types are not handled.">type error += Storage_limit_too_high</abbr> (* `Permanent *)

  val check_storage_limit : context -&gt; storage_limit:Z.t -&gt; unit tzresult
end

module Operation : sig
  type nonrec 'kind contents = 'kind contents

  type nonrec packed_contents = packed_contents

  val contents_encoding : packed_contents Data_encoding.t

  type nonrec 'kind protocol_data = 'kind protocol_data

  type nonrec packed_protocol_data = packed_protocol_data

  val protocol_data_encoding : packed_protocol_data Data_encoding.t

  val unsigned_encoding :
    (Operation.shell_header * packed_contents_list) Data_encoding.t

  type raw = Operation.t

  val raw_encoding : raw Data_encoding.t

  val contents_list_encoding : packed_contents_list Data_encoding.t

  <abbr class="mark-warning" title="We do not handle types with both a synonym and a type definition">type 'kind t = 'kind operation = {
    shell : Operation.shell_header;
    protocol_data : 'kind protocol_data;
  }</abbr>

  type nonrec packed = packed_operation

  val encoding : packed Data_encoding.t

  val raw : _ operation -&gt; raw

  val hash : _ operation -&gt; Operation_hash.t

  val hash_raw : raw -&gt; Operation_hash.t

  val hash_packed : packed_operation -&gt; Operation_hash.t

  val acceptable_passes : packed_operation -&gt; int list

  <abbr class="mark-warning" title="Extensible types are not handled.">type error += Missing_signature</abbr> (* `Permanent *)

  <abbr class="mark-warning" title="Extensible types are not handled.">type error += Invalid_signature</abbr> (* `Permanent *)

  val check_signature :
    public_key -&gt; Chain_id.t -&gt; _ operation -&gt; unit tzresult Lwt.t

  val check_signature_sync :
    public_key -&gt; Chain_id.t -&gt; _ operation -&gt; unit tzresult

  val internal_operation_encoding : packed_internal_operation Data_encoding.t

  val pack : 'kind operation -&gt; packed_operation

  type ('a, 'b) eq = Eq : ('a, 'a) eq

  val equal : 'a operation -&gt; 'b operation -&gt; ('a, 'b) eq option

  module Encoding : sig
    type 'b case =
      | Case : {
          tag : int;
          name : string;
          encoding : 'a Data_encoding.t;
          select : packed_contents -&gt; 'b contents option;
          proj : 'b contents -&gt; 'a;
          inj : 'a -&gt; 'b contents;
        }
          -&gt; 'b case
    [@@coq_force_gadt]

    val endorsement_case : Kind.endorsement case

    val seed_nonce_revelation_case : Kind.seed_nonce_revelation case

    val double_endorsement_evidence_case :
      Kind.double_endorsement_evidence case

    val double_baking_evidence_case : Kind.double_baking_evidence case

    val activate_account_case : Kind.activate_account case

    val proposals_case : Kind.proposals case

    val ballot_case : Kind.ballot case

    val reveal_case : Kind.reveal Kind.manager case

    val transaction_case : Kind.transaction Kind.manager case

    val origination_case : Kind.origination Kind.manager case

    val delegation_case : Kind.delegation Kind.manager case

    module Manager_operations : sig
      type 'kind case =
        | MCase : {
            tag : int;
            name : string;
            encoding : 'a Data_encoding.t;
            select :
              packed_manager_operation -&gt; 'kind manager_operation option;
            proj : 'kind manager_operation -&gt; 'a;
            inj : 'a -&gt; 'kind manager_operation;
          }
            -&gt; 'kind case
      [@@coq_force_gadt]

      val reveal_case : Kind.reveal case

      val transaction_case : Kind.transaction case

      val origination_case : Kind.origination case

      val delegation_case : Kind.delegation case
    end
  end

  val of_list : packed_contents list -&gt; packed_contents_list

  val to_list : packed_contents_list -&gt; packed_contents list
end

module Roll : sig
  type t = private int32

  type roll = t

  val encoding : roll Data_encoding.t

  val snapshot_rolls : context -&gt; context tzresult Lwt.t

  val cycle_end : context -&gt; Cycle.t -&gt; context tzresult Lwt.t

  val baking_rights_owner :
    context -&gt; Level.t -&gt; priority:int -&gt; public_key tzresult Lwt.t

  val endorsement_rights_owner :
    context -&gt; Level.t -&gt; slot:int -&gt; public_key tzresult Lwt.t

  val delegate_pubkey : context -&gt; public_key_hash -&gt; public_key tzresult Lwt.t

  val get_rolls :
    context -&gt; Signature.Public_key_hash.t -&gt; roll list tzresult Lwt.t

  val get_change :
    context -&gt; Signature.Public_key_hash.t -&gt; Tez.t tzresult Lwt.t
end

module Commitment : sig
  type t = {
    blinded_public_key_hash : Blinded_public_key_hash.t;
    amount : Tez.tez;
  }

  val get_opt :
    context -&gt; Blinded_public_key_hash.t -&gt; Tez.t option tzresult Lwt.t

  val delete : context -&gt; Blinded_public_key_hash.t -&gt; context tzresult Lwt.t
end

module Bootstrap : sig
  val cycle_end : context -&gt; Cycle.t -&gt; context tzresult Lwt.t
end

module Global : sig
  val get_block_priority : context -&gt; int tzresult Lwt.t

  val set_block_priority : context -&gt; int -&gt; context tzresult Lwt.t
end

val prepare_first_block :
  Context.t -&gt;
  typecheck:(context -&gt;
            Script.t -&gt;
            ((Script.t * Contract.big_map_diff option) * context) tzresult
            Lwt.t) -&gt;
  level:Int32.t -&gt;
  timestamp:Time.t -&gt;
  fitness:Fitness.t -&gt;
  context tzresult Lwt.t

val prepare :
  Context.t -&gt;
  level:Int32.t -&gt;
  predecessor_timestamp:Time.t -&gt;
  timestamp:Time.t -&gt;
  fitness:Fitness.t -&gt;
  context tzresult Lwt.t

val finalize : ?commit_message:string -&gt; context -&gt; Updater.validation_result

val activate : context -&gt; Protocol_hash.t -&gt; context Lwt.t

val fork_test_chain : context -&gt; Protocol_hash.t -&gt; Time.t -&gt; context Lwt.t

val record_endorsement : context -&gt; Signature.Public_key_hash.t -&gt; context

val allowed_endorsements :
  context -&gt;
  (Signature.Public_key.t * int list * bool) Signature.Public_key_hash.Map.t

val init_endorsements :
  context -&gt;
  (Signature.Public_key.t * int list * bool) Signature.Public_key_hash.Map.t -&gt;
  context

val included_endorsements : context -&gt; int

val reset_internal_nonce : context -&gt; context

val fresh_internal_nonce : context -&gt; (context * int) tzresult

val record_internal_nonce : context -&gt; int -&gt; context

val internal_nonce_already_recorded : context -&gt; int -&gt; bool

val add_fees : context -&gt; Tez.t -&gt; context tzresult Lwt.t

val add_rewards : context -&gt; Tez.t -&gt; context tzresult Lwt.t

val add_deposit :
  context -&gt; Signature.Public_key_hash.t -&gt; Tez.t -&gt; context tzresult Lwt.t

val get_fees : context -&gt; Tez.t

val get_rewards : context -&gt; Tez.t

val get_deposits : context -&gt; Tez.t Signature.Public_key_hash.Map.t

val description : context Storage_description.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#alpha_context.mli"><code>Alpha_context_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Blinded_public_key_hash.
Require Tezos.Block_header_repr.
Require Tezos.Contract_repr.
Require Tezos.Michelson_v1_primitives.
Require Tezos.Nonce_hash.
Require Tezos.Nonce_storage.
Require Tezos.Script_expr_hash.
Require Tezos.Script_int_repr.
Require Tezos.Storage_mli. Module Storage := Storage_mli.
Require Tezos.Storage_description.
Require Tezos.Tez_repr.

Module BASIC_DATA.
  Record signature {t : Set} : Set := {
    t := t;
    op_eq : t -&gt; t -&gt; bool;
    op_ltgt : t -&gt; t -&gt; bool;
    op_lt : t -&gt; t -&gt; bool;
    op_lteq : t -&gt; t -&gt; bool;
    op_gteq : t -&gt; t -&gt; bool;
    op_gt : t -&gt; t -&gt; bool;
    compare : t -&gt; t -&gt; int;
    equal : t -&gt; t -&gt; bool;
    max : t -&gt; t -&gt; t;
    min : t -&gt; t -&gt; t;
    encoding : Data_encoding.t t;
    pp : Format.formatter -&gt; t -&gt; unit;
  }.
End BASIC_DATA.

Parameter t : Set.

Definition context : Set := t.

Definition public_key : Set := (|Signature.Public_key|).(S.SPublic_key.t).

Definition public_key_hash : Set :=
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.t).

Definition signature : Set := Signature.t.

Module Tez.
  Parameter Included_BASIC_DATA :
    {_ : unit &amp; BASIC_DATA.signature (t := Tez_repr.t)}.
  
  Definition t := (|Included_BASIC_DATA|).(BASIC_DATA.t).
  
  Definition op_eq : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_eq).
  
  Definition op_ltgt : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_ltgt).
  
  Definition op_lt : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lt).
  
  Definition op_lteq : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lteq).
  
  Definition op_gteq : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gteq).
  
  Definition op_gt : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gt).
  
  Definition compare : t -&gt; t -&gt; int :=
    (|Included_BASIC_DATA|).(BASIC_DATA.compare).
  
  Definition equal : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.equal).
  
  Definition max : t -&gt; t -&gt; t := (|Included_BASIC_DATA|).(BASIC_DATA.max).
  
  Definition min : t -&gt; t -&gt; t := (|Included_BASIC_DATA|).(BASIC_DATA.min).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_BASIC_DATA|).(BASIC_DATA.encoding).
  
  Definition pp : Format.formatter -&gt; t -&gt; unit :=
    (|Included_BASIC_DATA|).(BASIC_DATA.pp).
  
  Definition tez : Set := t.
  
  Parameter zero : tez.
  
  Parameter one_mutez : tez.
  
  Parameter one_cent : tez.
  
  Parameter fifty_cents : tez.
  
  Parameter one : tez.
  
  Parameter op_minusquestion : tez -&gt; tez -&gt; Error_monad.tzresult tez.
  
  Parameter op_plusquestion : tez -&gt; tez -&gt; Error_monad.tzresult tez.
  
  Parameter op_starquestion : tez -&gt; int64 -&gt; Error_monad.tzresult tez.
  
  Parameter op_divquestion : tez -&gt; int64 -&gt; Error_monad.tzresult tez.
  
  Parameter of_string : string -&gt; option tez.
  
  Parameter to_string : tez -&gt; string.
  
  Parameter of_mutez : int64 -&gt; option tez.
  
  Parameter to_mutez : tez -&gt; int64.
End Tez.

Module Period.
  Parameter Included_BASIC_DATA : {t : Set &amp; BASIC_DATA.signature (t := t)}.
  
  Definition t := (|Included_BASIC_DATA|).(BASIC_DATA.t).
  
  Definition op_eq : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_eq).
  
  Definition op_ltgt : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_ltgt).
  
  Definition op_lt : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lt).
  
  Definition op_lteq : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lteq).
  
  Definition op_gteq : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gteq).
  
  Definition op_gt : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gt).
  
  Definition compare : t -&gt; t -&gt; int :=
    (|Included_BASIC_DATA|).(BASIC_DATA.compare).
  
  Definition equal : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.equal).
  
  Definition max : t -&gt; t -&gt; t := (|Included_BASIC_DATA|).(BASIC_DATA.max).
  
  Definition min : t -&gt; t -&gt; t := (|Included_BASIC_DATA|).(BASIC_DATA.min).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_BASIC_DATA|).(BASIC_DATA.encoding).
  
  Definition pp : Format.formatter -&gt; t -&gt; unit :=
    (|Included_BASIC_DATA|).(BASIC_DATA.pp).
  
  Definition period : Set := t.
  
  Parameter rpc_arg : RPC_arg.arg period.
  
  Parameter of_seconds : int64 -&gt; Error_monad.tzresult period.
  
  Parameter to_seconds : period -&gt; int64.
  
  Parameter mult : int32 -&gt; period -&gt; Error_monad.tzresult period.
  
  Parameter zero : period.
  
  Parameter one_second : period.
  
  Parameter one_minute : period.
  
  Parameter one_hour : period.
End Period.

Module Timestamp.
  Parameter Included_BASIC_DATA :
    {_ : unit &amp; BASIC_DATA.signature (t := Time.t)}.
  
  Definition t := (|Included_BASIC_DATA|).(BASIC_DATA.t).
  
  Definition op_eq : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_eq).
  
  Definition op_ltgt : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_ltgt).
  
  Definition op_lt : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lt).
  
  Definition op_lteq : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lteq).
  
  Definition op_gteq : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gteq).
  
  Definition op_gt : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gt).
  
  Definition compare : t -&gt; t -&gt; int :=
    (|Included_BASIC_DATA|).(BASIC_DATA.compare).
  
  Definition equal : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.equal).
  
  Definition max : t -&gt; t -&gt; t := (|Included_BASIC_DATA|).(BASIC_DATA.max).
  
  Definition min : t -&gt; t -&gt; t := (|Included_BASIC_DATA|).(BASIC_DATA.min).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_BASIC_DATA|).(BASIC_DATA.encoding).
  
  Definition pp : Format.formatter -&gt; t -&gt; unit :=
    (|Included_BASIC_DATA|).(BASIC_DATA.pp).
  
  Definition time : Set := t.
  
  Parameter op_plusquestion : time -&gt; Period.t -&gt; Error_monad.tzresult time.
  
  Parameter op_minusquestion : time -&gt; time -&gt; Error_monad.tzresult Period.t.
  
  Parameter of_notation : string -&gt; option time.
  
  Parameter to_notation : time -&gt; string.
  
  Parameter of_seconds_string : string -&gt; option time.
  
  Parameter to_seconds_string : time -&gt; string.
  
  Parameter current : context -&gt; time.
End Timestamp.

Module Raw_level.
  Parameter Included_BASIC_DATA : {t : Set &amp; BASIC_DATA.signature (t := t)}.
  
  Definition t := (|Included_BASIC_DATA|).(BASIC_DATA.t).
  
  Definition op_eq : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_eq).
  
  Definition op_ltgt : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_ltgt).
  
  Definition op_lt : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lt).
  
  Definition op_lteq : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lteq).
  
  Definition op_gteq : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gteq).
  
  Definition op_gt : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gt).
  
  Definition compare : t -&gt; t -&gt; int :=
    (|Included_BASIC_DATA|).(BASIC_DATA.compare).
  
  Definition equal : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.equal).
  
  Definition max : t -&gt; t -&gt; t := (|Included_BASIC_DATA|).(BASIC_DATA.max).
  
  Definition min : t -&gt; t -&gt; t := (|Included_BASIC_DATA|).(BASIC_DATA.min).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_BASIC_DATA|).(BASIC_DATA.encoding).
  
  Definition pp : Format.formatter -&gt; t -&gt; unit :=
    (|Included_BASIC_DATA|).(BASIC_DATA.pp).
  
  Definition raw_level : Set := t.
  
  Parameter rpc_arg : RPC_arg.arg raw_level.
  
  Parameter diff : raw_level -&gt; raw_level -&gt; int32.
  
  Parameter root : raw_level.
  
  Parameter succ : raw_level -&gt; raw_level.
  
  Parameter pred : raw_level -&gt; option raw_level.
  
  Parameter to_int32 : raw_level -&gt; int32.
  
  Parameter of_int32 : int32 -&gt; Error_monad.tzresult raw_level.
End Raw_level.

Module Cycle.
  Parameter Included_BASIC_DATA : {t : Set &amp; BASIC_DATA.signature (t := t)}.
  
  Definition t := (|Included_BASIC_DATA|).(BASIC_DATA.t).
  
  Definition op_eq : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_eq).
  
  Definition op_ltgt : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_ltgt).
  
  Definition op_lt : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lt).
  
  Definition op_lteq : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lteq).
  
  Definition op_gteq : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gteq).
  
  Definition op_gt : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gt).
  
  Definition compare : t -&gt; t -&gt; int :=
    (|Included_BASIC_DATA|).(BASIC_DATA.compare).
  
  Definition equal : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.equal).
  
  Definition max : t -&gt; t -&gt; t := (|Included_BASIC_DATA|).(BASIC_DATA.max).
  
  Definition min : t -&gt; t -&gt; t := (|Included_BASIC_DATA|).(BASIC_DATA.min).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_BASIC_DATA|).(BASIC_DATA.encoding).
  
  Definition pp : Format.formatter -&gt; t -&gt; unit :=
    (|Included_BASIC_DATA|).(BASIC_DATA.pp).
  
  Definition cycle : Set := t.
  
  Parameter rpc_arg : RPC_arg.arg cycle.
  
  Parameter root : cycle.
  
  Parameter succ : cycle -&gt; cycle.
  
  Parameter pred : cycle -&gt; option cycle.
  
  Parameter add : cycle -&gt; int -&gt; cycle.
  
  Parameter sub : cycle -&gt; int -&gt; option cycle.
  
  Parameter to_int32 : cycle -&gt; int32.
  
  Parameter Map : {t : Set -&gt; Set &amp; S.MAP.signature (key := cycle) (t := t)}.
End Cycle.

Module Gas.
  Module ConstructorRecords_t.
    Module t.
      Module Limited.
        Record record {remaining : Set} : Set := Build {
          remaining : remaining }.
        Arguments record : clear implicits.
        Definition with_remaining {t_remaining} remaining
          (r : record t_remaining) :=
          Build t_remaining remaining.
      End Limited.
      Definition Limited_skeleton := Limited.record.
    End t.
  End ConstructorRecords_t.
  Import ConstructorRecords_t.
  
  Reserved Notation &quot;'t.Limited&quot;.
  
  Inductive t : Set :=
  | Unaccounted : t
  | Limited : 't.Limited -&gt; t
  
  where &quot;'t.Limited&quot; := (t.Limited_skeleton Z.t).
  
  Module t.
    Include ConstructorRecords_t.t.
    Definition Limited := 't.Limited.
  End t.
  
  Parameter encoding : Data_encoding.encoding t.
  
  Parameter pp : Format.formatter -&gt; t -&gt; unit.
  
  Parameter cost : Set.
  
  Parameter cost_encoding : Data_encoding.encoding cost.
  
  Parameter pp_cost : Format.formatter -&gt; cost -&gt; unit.
  
  (* extensible_type_definition `error` *)
  
  (* extensible_type_definition `error` *)
  
  (* extensible_type_definition `error` *)
  
  Parameter free : cost.
  
  Parameter atomic_step_cost : int -&gt; cost.
  
  Parameter step_cost : int -&gt; cost.
  
  Parameter alloc_cost : int -&gt; cost.
  
  Parameter alloc_bytes_cost : int -&gt; cost.
  
  Parameter alloc_mbytes_cost : int -&gt; cost.
  
  Parameter alloc_bits_cost : int -&gt; cost.
  
  Parameter read_bytes_cost : Z.t -&gt; cost.
  
  Parameter write_bytes_cost : Z.t -&gt; cost.
  
  Parameter op_starat : int -&gt; cost -&gt; cost.
  
  Parameter op_plusat : cost -&gt; cost -&gt; cost.
  
  Parameter check_limit : context -&gt; Z.t -&gt; Error_monad.tzresult unit.
  
  Parameter set_limit : context -&gt; Z.t -&gt; context.
  
  Parameter set_unlimited : context -&gt; context.
  
  Parameter consume : context -&gt; cost -&gt; Error_monad.tzresult context.
  
  Parameter check_enough : context -&gt; cost -&gt; Error_monad.tzresult unit.
  
  Parameter level : context -&gt; t.
  
  Parameter consumed : context -&gt; context -&gt; Z.t.
  
  Parameter block_level : context -&gt; Z.t.
End Gas.

Module Script_int := Script_int_repr.

Module Script_timestamp.
  Import Script_int.
  
  Parameter t : Set.
  
  Parameter compare : t -&gt; t -&gt; int.
  
  Parameter to_string : t -&gt; string.
  
  Parameter to_notation : t -&gt; option string.
  
  Parameter to_num_str : t -&gt; string.
  
  Parameter of_string : string -&gt; option t.
  
  Parameter diff : t -&gt; t -&gt; Script_int.num.
  
  Parameter add_delta : t -&gt; Script_int.num -&gt; t.
  
  Parameter sub_delta : t -&gt; Script_int.num -&gt; t.
  
  Parameter now : context -&gt; t.
  
  Parameter to_zint : t -&gt; Z.t.
  
  Parameter of_zint : Z.t -&gt; t.
End Script_timestamp.

Module Script.
  Definition prim : Set := Michelson_v1_primitives.prim.
  
  Definition location : Set := Micheline.canonical_location.
  
  Definition annot : Set := Micheline.annot.
  
  Definition expr : Set := Micheline.canonical prim.
  
  Definition lazy_expr : Set := Data_encoding.lazy_t expr.
  
  Parameter __lazy_expr_value : expr -&gt; lazy_expr.
  
  Definition node : Set := Micheline.node location prim.
  
  Module t.
    Record record : Set := Build {
      code : lazy_expr;
      storage : lazy_expr }.
    Definition with_code code (r : record) :=
      Build code r.(storage).
    Definition with_storage storage (r : record) :=
      Build r.(code) storage.
  End t.
  Definition t := t.record.
  
  Parameter location_encoding : Data_encoding.t location.
  
  Parameter expr_encoding : Data_encoding.t expr.
  
  Parameter prim_encoding : Data_encoding.t prim.
  
  Parameter encoding : Data_encoding.t t.
  
  Parameter lazy_expr_encoding : Data_encoding.t lazy_expr.
  
  Parameter deserialized_cost : expr -&gt; Gas.cost.
  
  Parameter serialized_cost : MBytes.t -&gt; Gas.cost.
  
  Parameter traversal_cost : node -&gt; Gas.cost.
  
  Parameter node_cost : node -&gt; Gas.cost.
  
  Parameter int_node_cost : Z.t -&gt; Gas.cost.
  
  Parameter int_node_cost_of_numbits : int -&gt; Gas.cost.
  
  Parameter string_node_cost : string -&gt; Gas.cost.
  
  Parameter string_node_cost_of_length : int -&gt; Gas.cost.
  
  Parameter bytes_node_cost : MBytes.t -&gt; Gas.cost.
  
  Parameter bytes_node_cost_of_length : int -&gt; Gas.cost.
  
  Parameter prim_node_cost_nonrec : list expr -&gt; annot -&gt; Gas.cost.
  
  Parameter prim_node_cost_nonrec_of_length : int -&gt; annot -&gt; Gas.cost.
  
  Parameter seq_node_cost_nonrec : list expr -&gt; Gas.cost.
  
  Parameter seq_node_cost_nonrec_of_length : int -&gt; Gas.cost.
  
  Parameter minimal_deserialize_cost : lazy_expr -&gt; Gas.cost.
  
  Parameter force_decode_in_context :
    context -&gt; lazy_expr -&gt; Lwt.t (Error_monad.tzresult (expr * context)).
  
  Parameter force_bytes_in_context :
    context -&gt; lazy_expr -&gt; Lwt.t (Error_monad.tzresult (MBytes.t * context)).
  
  Parameter unit_parameter : lazy_expr.
  
  Module Legacy_support.
    Parameter manager_script_code : lazy_expr.
    
    Parameter add_do :
      (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt; lazy_expr -&gt;
      lazy_expr -&gt; Lwt.t (Error_monad.tzresult (lazy_expr * lazy_expr)).
    
    Parameter add_set_delegate :
      (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt; lazy_expr -&gt;
      lazy_expr -&gt; Lwt.t (Error_monad.tzresult (lazy_expr * lazy_expr)).
    
    Parameter has_default_entrypoint : lazy_expr -&gt; bool.
    
    Parameter add_root_entrypoint :
      lazy_expr -&gt; Lwt.t (Error_monad.tzresult lazy_expr).
  End Legacy_support.
End Script.

Module Constants.
  Module fixed.
    Record record : Set := Build {
      proof_of_work_nonce_size : int;
      nonce_length : int;
      max_revelations_per_block : int;
      max_operation_data_length : int;
      max_proposals_per_delegate : int }.
    Definition with_proof_of_work_nonce_size proof_of_work_nonce_size
      (r : record) :=
      Build proof_of_work_nonce_size r.(nonce_length)
        r.(max_revelations_per_block) r.(max_operation_data_length)
        r.(max_proposals_per_delegate).
    Definition with_nonce_length nonce_length (r : record) :=
      Build r.(proof_of_work_nonce_size) nonce_length
        r.(max_revelations_per_block) r.(max_operation_data_length)
        r.(max_proposals_per_delegate).
    Definition with_max_revelations_per_block max_revelations_per_block
      (r : record) :=
      Build r.(proof_of_work_nonce_size) r.(nonce_length)
        max_revelations_per_block r.(max_operation_data_length)
        r.(max_proposals_per_delegate).
    Definition with_max_operation_data_length max_operation_data_length
      (r : record) :=
      Build r.(proof_of_work_nonce_size) r.(nonce_length)
        r.(max_revelations_per_block) max_operation_data_length
        r.(max_proposals_per_delegate).
    Definition with_max_proposals_per_delegate max_proposals_per_delegate
      (r : record) :=
      Build r.(proof_of_work_nonce_size) r.(nonce_length)
        r.(max_revelations_per_block) r.(max_operation_data_length)
        max_proposals_per_delegate.
  End fixed.
  Definition fixed := fixed.record.
  
  Parameter fixed_encoding : Data_encoding.t fixed.
  
  Parameter __fixed_value : fixed.
  
  Parameter proof_of_work_nonce_size : int.
  
  Parameter nonce_length : int.
  
  Parameter max_revelations_per_block : int.
  
  Parameter max_operation_data_length : int.
  
  Parameter max_proposals_per_delegate : int.
  
  Module parametric.
    Record record : Set := Build {
      preserved_cycles : int;
      blocks_per_cycle : int32;
      blocks_per_commitment : int32;
      blocks_per_roll_snapshot : int32;
      blocks_per_voting_period : int32;
      time_between_blocks : list Period.t;
      endorsers_per_block : int;
      hard_gas_limit_per_operation : Z.t;
      hard_gas_limit_per_block : Z.t;
      proof_of_work_threshold : int64;
      tokens_per_roll : Tez.t;
      michelson_maximum_type_size : int;
      seed_nonce_revelation_tip : Tez.t;
      origination_size : int;
      block_security_deposit : Tez.t;
      endorsement_security_deposit : Tez.t;
      block_reward : Tez.t;
      endorsement_reward : Tez.t;
      cost_per_byte : Tez.t;
      hard_storage_limit_per_operation : Z.t;
      test_chain_duration : int64;
      quorum_min : int32;
      quorum_max : int32;
      min_proposal_quorum : int32;
      initial_endorsers : int;
      delay_per_missing_endorsement : Period.t }.
    Definition with_preserved_cycles preserved_cycles (r : record) :=
      Build preserved_cycles r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_blocks_per_cycle blocks_per_cycle (r : record) :=
      Build r.(preserved_cycles) blocks_per_cycle r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_blocks_per_commitment blocks_per_commitment (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) blocks_per_commitment
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_blocks_per_roll_snapshot blocks_per_roll_snapshot
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        blocks_per_roll_snapshot r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_blocks_per_voting_period blocks_per_voting_period
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) blocks_per_voting_period
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_time_between_blocks time_between_blocks (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        time_between_blocks r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_endorsers_per_block endorsers_per_block (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) endorsers_per_block
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_hard_gas_limit_per_operation hard_gas_limit_per_operation
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        hard_gas_limit_per_operation r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_hard_gas_limit_per_block hard_gas_limit_per_block
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) hard_gas_limit_per_block
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_proof_of_work_threshold proof_of_work_threshold
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        proof_of_work_threshold r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_tokens_per_roll tokens_per_roll (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) tokens_per_roll
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_michelson_maximum_type_size michelson_maximum_type_size
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        michelson_maximum_type_size r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_seed_nonce_revelation_tip seed_nonce_revelation_tip
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) seed_nonce_revelation_tip
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_origination_size origination_size (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        origination_size r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_block_security_deposit block_security_deposit
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) block_security_deposit
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_endorsement_security_deposit endorsement_security_deposit
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        endorsement_security_deposit r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_block_reward block_reward (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) block_reward r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_endorsement_reward endorsement_reward (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) endorsement_reward
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_cost_per_byte cost_per_byte (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        cost_per_byte r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_hard_storage_limit_per_operation
      hard_storage_limit_per_operation (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) hard_storage_limit_per_operation
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_test_chain_duration test_chain_duration (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        test_chain_duration r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_quorum_min quorum_min (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) quorum_min r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_quorum_max quorum_max (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) quorum_max
        r.(min_proposal_quorum) r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_min_proposal_quorum min_proposal_quorum (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        min_proposal_quorum r.(initial_endorsers)
        r.(delay_per_missing_endorsement).
    Definition with_initial_endorsers initial_endorsers (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) initial_endorsers
        r.(delay_per_missing_endorsement).
    Definition with_delay_per_missing_endorsement delay_per_missing_endorsement
      (r : record) :=
      Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
        r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
        r.(time_between_blocks) r.(endorsers_per_block)
        r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
        r.(proof_of_work_threshold) r.(tokens_per_roll)
        r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
        r.(origination_size) r.(block_security_deposit)
        r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
        r.(cost_per_byte) r.(hard_storage_limit_per_operation)
        r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
        r.(min_proposal_quorum) r.(initial_endorsers)
        delay_per_missing_endorsement.
  End parametric.
  Definition parametric := parametric.record.
  
  Parameter parametric_encoding : Data_encoding.t parametric.
  
  Parameter __parametric_value : context -&gt; parametric.
  
  Parameter preserved_cycles : context -&gt; int.
  
  Parameter blocks_per_cycle : context -&gt; int32.
  
  Parameter blocks_per_commitment : context -&gt; int32.
  
  Parameter blocks_per_roll_snapshot : context -&gt; int32.
  
  Parameter blocks_per_voting_period : context -&gt; int32.
  
  Parameter time_between_blocks : context -&gt; list Period.t.
  
  Parameter endorsers_per_block : context -&gt; int.
  
  Parameter initial_endorsers : context -&gt; int.
  
  Parameter delay_per_missing_endorsement : context -&gt; Period.t.
  
  Parameter hard_gas_limit_per_operation : context -&gt; Z.t.
  
  Parameter hard_gas_limit_per_block : context -&gt; Z.t.
  
  Parameter cost_per_byte : context -&gt; Tez.t.
  
  Parameter hard_storage_limit_per_operation : context -&gt; Z.t.
  
  Parameter proof_of_work_threshold : context -&gt; int64.
  
  Parameter tokens_per_roll : context -&gt; Tez.t.
  
  Parameter michelson_maximum_type_size : context -&gt; int.
  
  Parameter block_reward : context -&gt; Tez.t.
  
  Parameter endorsement_reward : context -&gt; Tez.t.
  
  Parameter seed_nonce_revelation_tip : context -&gt; Tez.t.
  
  Parameter origination_size : context -&gt; int.
  
  Parameter block_security_deposit : context -&gt; Tez.t.
  
  Parameter endorsement_security_deposit : context -&gt; Tez.t.
  
  Parameter test_chain_duration : context -&gt; int64.
  
  Parameter quorum_min : context -&gt; int32.
  
  Parameter quorum_max : context -&gt; int32.
  
  Parameter min_proposal_quorum : context -&gt; int32.
  
  Module t.
    Record record : Set := Build {
      fixed : fixed;
      parametric : parametric }.
    Definition with_fixed fixed (r : record) :=
      Build fixed r.(parametric).
    Definition with_parametric parametric (r : record) :=
      Build r.(fixed) parametric.
  End t.
  Definition t := t.record.
  
  Parameter encoding : Data_encoding.t t.
End Constants.

Module Voting_period.
  Parameter Included_BASIC_DATA : {t : Set &amp; BASIC_DATA.signature (t := t)}.
  
  Definition t := (|Included_BASIC_DATA|).(BASIC_DATA.t).
  
  Definition op_eq : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_eq).
  
  Definition op_ltgt : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_ltgt).
  
  Definition op_lt : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lt).
  
  Definition op_lteq : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lteq).
  
  Definition op_gteq : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gteq).
  
  Definition op_gt : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gt).
  
  Definition compare : t -&gt; t -&gt; int :=
    (|Included_BASIC_DATA|).(BASIC_DATA.compare).
  
  Definition equal : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.equal).
  
  Definition max : t -&gt; t -&gt; t := (|Included_BASIC_DATA|).(BASIC_DATA.max).
  
  Definition min : t -&gt; t -&gt; t := (|Included_BASIC_DATA|).(BASIC_DATA.min).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_BASIC_DATA|).(BASIC_DATA.encoding).
  
  Definition pp : Format.formatter -&gt; t -&gt; unit :=
    (|Included_BASIC_DATA|).(BASIC_DATA.pp).
  
  Definition voting_period : Set := t.
  
  Parameter rpc_arg : RPC_arg.arg voting_period.
  
  Parameter root : voting_period.
  
  Parameter succ : voting_period -&gt; voting_period.
  
  Inductive kind : Set :=
  | Proposal : kind
  | Testing_vote : kind
  | Testing : kind
  | Promotion_vote : kind.
  
  Parameter kind_encoding : Data_encoding.encoding kind.
  
  Parameter to_int32 : voting_period -&gt; int32.
End Voting_period.

Module Level.
  Module t.
    Record record : Set := Build {
      level : Raw_level.t;
      level_position : int32;
      cycle : Cycle.t;
      cycle_position : int32;
      voting_period : Voting_period.t;
      voting_period_position : int32;
      expected_commitment : bool }.
    Definition with_level level (r : record) :=
      Build level r.(level_position) r.(cycle) r.(cycle_position)
        r.(voting_period) r.(voting_period_position) r.(expected_commitment).
    Definition with_level_position level_position (r : record) :=
      Build r.(level) level_position r.(cycle) r.(cycle_position)
        r.(voting_period) r.(voting_period_position) r.(expected_commitment).
    Definition with_cycle cycle (r : record) :=
      Build r.(level) r.(level_position) cycle r.(cycle_position)
        r.(voting_period) r.(voting_period_position) r.(expected_commitment).
    Definition with_cycle_position cycle_position (r : record) :=
      Build r.(level) r.(level_position) r.(cycle) cycle_position
        r.(voting_period) r.(voting_period_position) r.(expected_commitment).
    Definition with_voting_period voting_period (r : record) :=
      Build r.(level) r.(level_position) r.(cycle) r.(cycle_position)
        voting_period r.(voting_period_position) r.(expected_commitment).
    Definition with_voting_period_position voting_period_position
      (r : record) :=
      Build r.(level) r.(level_position) r.(cycle) r.(cycle_position)
        r.(voting_period) voting_period_position r.(expected_commitment).
    Definition with_expected_commitment expected_commitment (r : record) :=
      Build r.(level) r.(level_position) r.(cycle) r.(cycle_position)
        r.(voting_period) r.(voting_period_position) expected_commitment.
  End t.
  Definition t := t.record.
  
  Parameter Included_BASIC_DATA : {_ : unit &amp; BASIC_DATA.signature (t := t)}.
  
  Definition op_eq : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_eq).
  
  Definition op_ltgt : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_ltgt).
  
  Definition op_lt : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lt).
  
  Definition op_lteq : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lteq).
  
  Definition op_gteq : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gteq).
  
  Definition op_gt : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gt).
  
  Definition compare : t -&gt; t -&gt; int :=
    (|Included_BASIC_DATA|).(BASIC_DATA.compare).
  
  Definition equal : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.equal).
  
  Definition max : t -&gt; t -&gt; t := (|Included_BASIC_DATA|).(BASIC_DATA.max).
  
  Definition min : t -&gt; t -&gt; t := (|Included_BASIC_DATA|).(BASIC_DATA.min).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_BASIC_DATA|).(BASIC_DATA.encoding).
  
  Definition pp : Format.formatter -&gt; t -&gt; unit :=
    (|Included_BASIC_DATA|).(BASIC_DATA.pp).
  
  Parameter pp_full : Format.formatter -&gt; t -&gt; unit.
  
  Definition level : Set := t.
  
  Parameter root : context -&gt; level.
  
  Parameter succ : context -&gt; level -&gt; level.
  
  Parameter pred : context -&gt; level -&gt; option level.
  
  Parameter from_raw : context -&gt; option int32 -&gt; Raw_level.t -&gt; level.
  
  Parameter diff : level -&gt; level -&gt; int32.
  
  Parameter current : context -&gt; level.
  
  Parameter last_level_in_cycle : context -&gt; Cycle.t -&gt; level.
  
  Parameter levels_in_cycle : context -&gt; Cycle.t -&gt; list level.
  
  Parameter levels_in_current_cycle :
    context -&gt; option int32 -&gt; unit -&gt; list level.
  
  Parameter last_allowed_fork_level : context -&gt; Raw_level.t.
End Level.

Module Fitness.
  Parameter t : Set.
  
  Parameter op_eq : t -&gt; t -&gt; bool.
  
  Parameter op_ltgt : t -&gt; t -&gt; bool.
  
  Parameter op_lt : t -&gt; t -&gt; bool.
  
  Parameter op_lteq : t -&gt; t -&gt; bool.
  
  Parameter op_gteq : t -&gt; t -&gt; bool.
  
  Parameter op_gt : t -&gt; t -&gt; bool.
  
  Parameter compare : t -&gt; t -&gt; int.
  
  Parameter equal : t -&gt; t -&gt; bool.
  
  Parameter max : t -&gt; t -&gt; t.
  
  Parameter min : t -&gt; t -&gt; t.
  
  Parameter pp : Format.formatter -&gt; t -&gt; unit.
  
  Parameter encoding : Data_encoding.t t.
  
  Parameter to_bytes : t -&gt; MBytes.t.
  
  Parameter of_bytes : MBytes.t -&gt; option t.
  
  Definition fitness : Set := t.
  
  Parameter increase : option int -&gt; context -&gt; context.
  
  Parameter current : context -&gt; int64.
  
  Parameter to_int64 : fitness -&gt; Error_monad.tzresult int64.
End Fitness.

Module Nonce.
  Definition t : Set := Nonce_storage.t.
  
  Definition nonce : Set := t.
  
  Parameter encoding : Data_encoding.t nonce.
  
  Definition unrevealed : Set := Storage.unrevealed_nonce.
  
  Parameter record_hash :
    context -&gt; unrevealed -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter reveal :
    context -&gt; Level.t -&gt; nonce -&gt; Lwt.t (Error_monad.tzresult context).
  
  Definition status : Set := Storage.nonce_status.
  
  Parameter get : context -&gt; Level.t -&gt; Lwt.t (Error_monad.tzresult status).
  
  Parameter of_bytes : MBytes.t -&gt; Error_monad.tzresult nonce.
  
  Parameter __hash_value : nonce -&gt; Nonce_hash.t.
  
  Parameter check_hash : nonce -&gt; Nonce_hash.t -&gt; bool.
End Nonce.

Module Seed.
  Parameter seed : Set.
  
  (* extensible_type_definition `error` *)
  
  Parameter for_cycle : context -&gt; Cycle.t -&gt; Lwt.t (Error_monad.tzresult seed).
  
  Parameter cycle_end :
    context -&gt; Cycle.t -&gt;
    Lwt.t (Error_monad.tzresult (context * list Nonce.unrevealed)).
  
  Parameter seed_encoding : Data_encoding.t seed.
End Seed.

Module Big_map.
  Definition id : Set := Z.t.
  
  Parameter fresh : context -&gt; Lwt.t (Error_monad.tzresult (context * id)).
  
  Parameter fresh_temporary : context -&gt; context * id.
  
  Parameter mem :
    context -&gt; id -&gt; Script_expr_hash.t -&gt;
    Lwt.t (Error_monad.tzresult (context * bool)).
  
  Parameter get_opt :
    context -&gt; id -&gt; Script_expr_hash.t -&gt;
    Lwt.t (Error_monad.tzresult (context * option Script.expr)).
  
  Parameter rpc_arg : RPC_arg.t id.
  
  Parameter cleanup_temporary : context -&gt; Lwt.t context.
  
  Parameter __exists :
    context -&gt; id -&gt;
    Lwt.t (Error_monad.tzresult (context * option (Script.expr * Script.expr))).
End Big_map.

Module Contract.
  Parameter Included_BASIC_DATA : {t : Set &amp; BASIC_DATA.signature (t := t)}.
  
  Definition t := (|Included_BASIC_DATA|).(BASIC_DATA.t).
  
  Definition op_eq : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_eq).
  
  Definition op_ltgt : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_ltgt).
  
  Definition op_lt : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lt).
  
  Definition op_lteq : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_lteq).
  
  Definition op_gteq : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gteq).
  
  Definition op_gt : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.op_gt).
  
  Definition compare : t -&gt; t -&gt; int :=
    (|Included_BASIC_DATA|).(BASIC_DATA.compare).
  
  Definition equal : t -&gt; t -&gt; bool :=
    (|Included_BASIC_DATA|).(BASIC_DATA.equal).
  
  Definition max : t -&gt; t -&gt; t := (|Included_BASIC_DATA|).(BASIC_DATA.max).
  
  Definition min : t -&gt; t -&gt; t := (|Included_BASIC_DATA|).(BASIC_DATA.min).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_BASIC_DATA|).(BASIC_DATA.encoding).
  
  Definition pp : Format.formatter -&gt; t -&gt; unit :=
    (|Included_BASIC_DATA|).(BASIC_DATA.pp).
  
  Definition contract : Set := t.
  
  Parameter rpc_arg : RPC_arg.arg contract.
  
  Parameter to_b58check : contract -&gt; string.
  
  Parameter of_b58check : string -&gt; Error_monad.tzresult contract.
  
  Parameter implicit_contract : public_key_hash -&gt; contract.
  
  Parameter is_implicit : contract -&gt; option public_key_hash.
  
  Parameter __exists : context -&gt; contract -&gt; Lwt.t (Error_monad.tzresult bool).
  
  Parameter must_exist :
    context -&gt; contract -&gt; Lwt.t (Error_monad.tzresult unit).
  
  Parameter allocated :
    context -&gt; contract -&gt; Lwt.t (Error_monad.tzresult bool).
  
  Parameter must_be_allocated :
    context -&gt; contract -&gt; Lwt.t (Error_monad.tzresult unit).
  
  Parameter __list_value : context -&gt; Lwt.t (list contract).
  
  Parameter get_manager_key :
    context -&gt; public_key_hash -&gt; Lwt.t (Error_monad.tzresult public_key).
  
  Parameter is_manager_key_revealed :
    context -&gt; public_key_hash -&gt; Lwt.t (Error_monad.tzresult bool).
  
  Parameter reveal_manager_key :
    context -&gt; public_key_hash -&gt; public_key -&gt;
    Lwt.t (Error_monad.tzresult context).
  
  Parameter get_script_code :
    context -&gt; contract -&gt;
    Lwt.t (Error_monad.tzresult (context * option Script.lazy_expr)).
  
  Parameter get_script :
    context -&gt; contract -&gt;
    Lwt.t (Error_monad.tzresult (context * option Script.t)).
  
  Parameter get_storage :
    context -&gt; contract -&gt;
    Lwt.t (Error_monad.tzresult (context * option Script.expr)).
  
  Parameter get_counter :
    context -&gt; public_key_hash -&gt; Lwt.t (Error_monad.tzresult Z.t).
  
  Parameter get_balance :
    context -&gt; contract -&gt; Lwt.t (Error_monad.tzresult Tez.t).
  
  Parameter init_origination_nonce :
    context -&gt; (|Operation_hash|).(S.HASH.t) -&gt; context.
  
  Parameter unset_origination_nonce : context -&gt; context.
  
  Parameter fresh_contract_from_current_nonce :
    context -&gt; Lwt.t (Error_monad.tzresult (context * t)).
  
  Parameter originated_from_current_nonce :
    context -&gt; context -&gt; Lwt.t (Error_monad.tzresult (list contract)).
  
  Module ConstructorRecords_big_map_diff_item.
    Module big_map_diff_item.
      Module Update.
        Record record {big_map diff_key diff_key_hash diff_value : Set} : Set := Build {
          big_map : big_map;
          diff_key : diff_key;
          diff_key_hash : diff_key_hash;
          diff_value : diff_value }.
        Arguments record : clear implicits.
        Definition with_big_map
          {t_big_map t_diff_key t_diff_key_hash t_diff_value} big_map
          (r : record t_big_map t_diff_key t_diff_key_hash t_diff_value) :=
          Build t_big_map t_diff_key t_diff_key_hash t_diff_value big_map
            r.(diff_key) r.(diff_key_hash) r.(diff_value).
        Definition with_diff_key
          {t_big_map t_diff_key t_diff_key_hash t_diff_value} diff_key
          (r : record t_big_map t_diff_key t_diff_key_hash t_diff_value) :=
          Build t_big_map t_diff_key t_diff_key_hash t_diff_value r.(big_map)
            diff_key r.(diff_key_hash) r.(diff_value).
        Definition with_diff_key_hash
          {t_big_map t_diff_key t_diff_key_hash t_diff_value} diff_key_hash
          (r : record t_big_map t_diff_key t_diff_key_hash t_diff_value) :=
          Build t_big_map t_diff_key t_diff_key_hash t_diff_value r.(big_map)
            r.(diff_key) diff_key_hash r.(diff_value).
        Definition with_diff_value
          {t_big_map t_diff_key t_diff_key_hash t_diff_value} diff_value
          (r : record t_big_map t_diff_key t_diff_key_hash t_diff_value) :=
          Build t_big_map t_diff_key t_diff_key_hash t_diff_value r.(big_map)
            r.(diff_key) r.(diff_key_hash) diff_value.
      End Update.
      Definition Update_skeleton := Update.record.
      
      Module Alloc.
        Record record {big_map key_type value_type : Set} : Set := Build {
          big_map : big_map;
          key_type : key_type;
          value_type : value_type }.
        Arguments record : clear implicits.
        Definition with_big_map {t_big_map t_key_type t_value_type} big_map
          (r : record t_big_map t_key_type t_value_type) :=
          Build t_big_map t_key_type t_value_type big_map r.(key_type)
            r.(value_type).
        Definition with_key_type {t_big_map t_key_type t_value_type} key_type
          (r : record t_big_map t_key_type t_value_type) :=
          Build t_big_map t_key_type t_value_type r.(big_map) key_type
            r.(value_type).
        Definition with_value_type {t_big_map t_key_type t_value_type}
          value_type (r : record t_big_map t_key_type t_value_type) :=
          Build t_big_map t_key_type t_value_type r.(big_map) r.(key_type)
            value_type.
      End Alloc.
      Definition Alloc_skeleton := Alloc.record.
    End big_map_diff_item.
  End ConstructorRecords_big_map_diff_item.
  Import ConstructorRecords_big_map_diff_item.
  
  Reserved Notation &quot;'big_map_diff_item.Update&quot;.
  Reserved Notation &quot;'big_map_diff_item.Alloc&quot;.
  
  Inductive big_map_diff_item : Set :=
  | Update : 'big_map_diff_item.Update -&gt; big_map_diff_item
  | Clear : Big_map.id -&gt; big_map_diff_item
  | Copy : Big_map.id -&gt; Big_map.id -&gt; big_map_diff_item
  | Alloc : 'big_map_diff_item.Alloc -&gt; big_map_diff_item
  
  where &quot;'big_map_diff_item.Update&quot; :=
    (big_map_diff_item.Update_skeleton Big_map.id Script.expr Script_expr_hash.t
      (option Script.expr))
  and &quot;'big_map_diff_item.Alloc&quot; :=
    (big_map_diff_item.Alloc_skeleton Big_map.id Script.expr Script.expr).
  
  Module big_map_diff_item.
    Include ConstructorRecords_big_map_diff_item.big_map_diff_item.
    Definition Update := 'big_map_diff_item.Update.
    Definition Alloc := 'big_map_diff_item.Alloc.
  End big_map_diff_item.
  
  Definition big_map_diff : Set := list big_map_diff_item.
  
  Parameter big_map_diff_encoding : Data_encoding.t big_map_diff.
  
  Parameter originate :
    context -&gt; contract -&gt; Tez.t -&gt; Script.t * option big_map_diff -&gt;
    option public_key_hash -&gt; Lwt.t (Error_monad.tzresult context).
  
  (* extensible_type_definition `error` *)
  
  Parameter spend :
    context -&gt; contract -&gt; Tez.t -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter credit :
    context -&gt; contract -&gt; Tez.t -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter update_script_storage :
    context -&gt; contract -&gt; Script.expr -&gt; option big_map_diff -&gt;
    Lwt.t (Error_monad.tzresult context).
  
  Parameter used_storage_space :
    context -&gt; t -&gt; Lwt.t (Error_monad.tzresult Z.t).
  
  Parameter increment_counter :
    context -&gt; public_key_hash -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter check_counter_increment :
    context -&gt; public_key_hash -&gt; Z.t -&gt; Lwt.t (Error_monad.tzresult unit).
  
  Parameter origination_nonce : Set.
  
  Parameter initial_origination_nonce :
    (|Operation_hash|).(S.HASH.t) -&gt; origination_nonce.
  
  Parameter originated_contract : origination_nonce -&gt; contract.
End Contract.

Module Delegate.
  Inductive balance : Set :=
  | Contract : Contract.t -&gt; balance
  | Rewards :
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt; Cycle.t -&gt; balance
  | Fees :
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt; Cycle.t -&gt; balance
  | Deposits :
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt; Cycle.t -&gt; balance.
  
  Inductive balance_update : Set :=
  | Debited : Tez.t -&gt; balance_update
  | Credited : Tez.t -&gt; balance_update.
  
  Definition balance_updates : Set := list (balance * balance_update).
  
  Parameter balance_updates_encoding : Data_encoding.t balance_updates.
  
  Parameter cleanup_balance_updates : balance_updates -&gt; balance_updates.
  
  Parameter get :
    context -&gt; Contract.t -&gt;
    Lwt.t (Error_monad.tzresult (option public_key_hash)).
  
  Parameter set :
    context -&gt; Contract.t -&gt; option public_key_hash -&gt;
    Lwt.t (Error_monad.tzresult context).
  
  Parameter fold : forall {a : Set},
    context -&gt; a -&gt; (public_key_hash -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a.
  
  Parameter __list_value : context -&gt; Lwt.t (list public_key_hash).
  
  Parameter freeze_deposit :
    context -&gt; public_key_hash -&gt; Tez.t -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter freeze_rewards :
    context -&gt; public_key_hash -&gt; Tez.t -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter freeze_fees :
    context -&gt; public_key_hash -&gt; Tez.t -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter cycle_end :
    context -&gt; Cycle.t -&gt; list Nonce.unrevealed -&gt;
    Lwt.t
      (Error_monad.tzresult
        (context * balance_updates *
          list (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))).
  
  Module frozen_balance.
    Record record : Set := Build {
      deposit : Tez.t;
      fees : Tez.t;
      rewards : Tez.t }.
    Definition with_deposit deposit (r : record) :=
      Build deposit r.(fees) r.(rewards).
    Definition with_fees fees (r : record) :=
      Build r.(deposit) fees r.(rewards).
    Definition with_rewards rewards (r : record) :=
      Build r.(deposit) r.(fees) rewards.
  End frozen_balance.
  Definition frozen_balance := frozen_balance.record.
  
  Parameter punish :
    context -&gt; public_key_hash -&gt; Cycle.t -&gt;
    Lwt.t (Error_monad.tzresult (context * frozen_balance)).
  
  Parameter full_balance :
    context -&gt; public_key_hash -&gt; Lwt.t (Error_monad.tzresult Tez.t).
  
  Parameter has_frozen_balance :
    context -&gt; public_key_hash -&gt; Cycle.t -&gt; Lwt.t (Error_monad.tzresult bool).
  
  Parameter __frozen_balance_value :
    context -&gt; public_key_hash -&gt; Lwt.t (Error_monad.tzresult Tez.t).
  
  Parameter frozen_balance_encoding : Data_encoding.t frozen_balance.
  
  Parameter frozen_balance_by_cycle_encoding :
    Data_encoding.t ((|Cycle.Map|).(S.MAP.t) frozen_balance).
  
  Parameter frozen_balance_by_cycle :
    context -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
    Lwt.t ((|Cycle.Map|).(S.MAP.t) frozen_balance).
  
  Parameter staking_balance :
    context -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
    Lwt.t (Error_monad.tzresult Tez.t).
  
  Parameter delegated_contracts :
    context -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
    Lwt.t (list Contract_repr.t).
  
  Parameter delegated_balance :
    context -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
    Lwt.t (Error_monad.tzresult Tez.t).
  
  Parameter deactivated :
    context -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
    Lwt.t (Error_monad.tzresult bool).
  
  Parameter grace_period :
    context -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
    Lwt.t (Error_monad.tzresult Cycle.t).
End Delegate.

Module Vote.
  Definition proposal : Set := (|Protocol_hash|).(S.HASH.t).
  
  Parameter record_proposal :
    context -&gt; (|Protocol_hash|).(S.HASH.t) -&gt; public_key_hash -&gt;
    Lwt.t (Error_monad.tzresult context).
  
  Parameter get_proposals :
    context -&gt;
    Lwt.t
      (Error_monad.tzresult
        ((|Protocol_hash|).(S.HASH.Map).(S.INDEXES_Map.t) int32)).
  
  Parameter clear_proposals : context -&gt; Lwt.t context.
  
  Parameter recorded_proposal_count_for_delegate :
    context -&gt; public_key_hash -&gt; Lwt.t (Error_monad.tzresult int).
  
  Parameter listings_encoding :
    Data_encoding.t
      (list ((|Signature.Public_key_hash|).(S.SPublic_key_hash.t) * int32)).
  
  Parameter freeze_listings : context -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter clear_listings : context -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter listing_size : context -&gt; Lwt.t (Error_monad.tzresult int32).
  
  Parameter in_listings : context -&gt; public_key_hash -&gt; Lwt.t bool.
  
  Parameter get_listings : context -&gt; Lwt.t (list (public_key_hash * int32)).
  
  Inductive ballot : Set :=
  | Yay : ballot
  | Nay : ballot
  | Pass : ballot.
  
  Parameter ballot_encoding : Data_encoding.t ballot.
  
  Module ballots.
    Record record : Set := Build {
      yay : int32;
      nay : int32;
      pass : int32 }.
    Definition with_yay yay (r : record) :=
      Build yay r.(nay) r.(pass).
    Definition with_nay nay (r : record) :=
      Build r.(yay) nay r.(pass).
    Definition with_pass pass (r : record) :=
      Build r.(yay) r.(nay) pass.
  End ballots.
  Definition ballots := ballots.record.
  
  Parameter ballots_encoding : Data_encoding.t ballots.
  
  Parameter has_recorded_ballot : context -&gt; public_key_hash -&gt; Lwt.t bool.
  
  Parameter record_ballot :
    context -&gt; public_key_hash -&gt; ballot -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter get_ballots : context -&gt; Lwt.t (Error_monad.tzresult ballots).
  
  Parameter get_ballot_list :
    context -&gt;
    Lwt.t (list ((|Signature.Public_key_hash|).(S.SPublic_key_hash.t) * ballot)).
  
  Parameter clear_ballots : context -&gt; Lwt.t context.
  
  Parameter get_current_period_kind :
    context -&gt; Lwt.t (Error_monad.tzresult Voting_period.kind).
  
  Parameter set_current_period_kind :
    context -&gt; Voting_period.kind -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter get_current_quorum : context -&gt; Lwt.t (Error_monad.tzresult int32).
  
  Parameter get_participation_ema :
    context -&gt; Lwt.t (Error_monad.tzresult int32).
  
  Parameter set_participation_ema :
    context -&gt; int32 -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter get_current_proposal :
    context -&gt; Lwt.t (Error_monad.tzresult proposal).
  
  Parameter init_current_proposal :
    context -&gt; proposal -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter clear_current_proposal :
    context -&gt; Lwt.t (Error_monad.tzresult context).
End Vote.

Module Block_header.
  Definition contents : Set := Block_header_repr.contents.
  
  Definition protocol_data : Set := Block_header_repr.protocol_data.
  
  Definition block_header : Set := Block_header_repr.block_header.
  
  Definition raw : Set := Block_header.t.
  
  Definition shell_header : Set := Block_header.shell_header.
  
  Parameter __raw_value : block_header -&gt; raw.
  
  Parameter __hash_value : block_header -&gt; (|Block_hash|).(S.HASH.t).
  
  Parameter hash_raw : raw -&gt; (|Block_hash|).(S.HASH.t).
  
  Parameter encoding : Data_encoding.encoding block_header.
  
  Parameter raw_encoding : Data_encoding.t raw.
  
  Parameter contents_encoding : Data_encoding.t contents.
  
  Parameter unsigned_encoding : Data_encoding.t (shell_header * contents).
  
  Parameter protocol_data_encoding : Data_encoding.encoding protocol_data.
  
  Parameter shell_header_encoding : Data_encoding.encoding shell_header.
  
  Parameter max_header_length : int.
End Block_header.

Module Kind.
  Inductive seed_nonce_revelation : Set :=
  | Seed_nonce_revelation_kind : seed_nonce_revelation.
  
  Inductive double_endorsement_evidence : Set :=
  | Double_endorsement_evidence_kind : double_endorsement_evidence.
  
  Inductive double_baking_evidence : Set :=
  | Double_baking_evidence_kind : double_baking_evidence.
  
  Inductive activate_account : Set :=
  | Activate_account_kind : activate_account.
  
  Inductive endorsement : Set :=
  | Endorsement_kind : endorsement.
  
  Inductive proposals : Set :=
  | Proposals_kind : proposals.
  
  Inductive ballot : Set :=
  | Ballot_kind : ballot.
  
  Inductive reveal : Set :=
  | Reveal_kind : reveal.
  
  Inductive transaction : Set :=
  | Transaction_kind : transaction.
  
  Inductive origination : Set :=
  | Origination_kind : origination.
  
  Inductive delegation : Set :=
  | Delegation_kind : delegation.
  
  Inductive manager : Set :=
  | Reveal_manager_kind : manager
  | Transaction_manager_kind : manager
  | Origination_manager_kind : manager
  | Delegation_manager_kind : manager.
End Kind.

Module ConstructorRecords_contents_list_contents_manager_operation.
  Module contents.
    Module Endorsement.
      Record record {level : Set} : Set := Build {
        level : level }.
      Arguments record : clear implicits.
      Definition with_level {t_level} level (r : record t_level) :=
        Build t_level level.
    End Endorsement.
    Definition Endorsement_skeleton := Endorsement.record.
    
    Module Seed_nonce_revelation.
      Record record {level nonce : Set} : Set := Build {
        level : level;
        nonce : nonce }.
      Arguments record : clear implicits.
      Definition with_level {t_level t_nonce} level
        (r : record t_level t_nonce) :=
        Build t_level t_nonce level r.(nonce).
      Definition with_nonce {t_level t_nonce} nonce
        (r : record t_level t_nonce) :=
        Build t_level t_nonce r.(level) nonce.
    End Seed_nonce_revelation.
    Definition Seed_nonce_revelation_skeleton := Seed_nonce_revelation.record.
    
    Module Double_endorsement_evidence.
      Record record {op1 op2 : Set} : Set := Build {
        op1 : op1;
        op2 : op2 }.
      Arguments record : clear implicits.
      Definition with_op1 {t_op1 t_op2} op1 (r : record t_op1 t_op2) :=
        Build t_op1 t_op2 op1 r.(op2).
      Definition with_op2 {t_op1 t_op2} op2 (r : record t_op1 t_op2) :=
        Build t_op1 t_op2 r.(op1) op2.
    End Double_endorsement_evidence.
    Definition Double_endorsement_evidence_skeleton :=
      Double_endorsement_evidence.record.
    
    Module Double_baking_evidence.
      Record record {bh1 bh2 : Set} : Set := Build {
        bh1 : bh1;
        bh2 : bh2 }.
      Arguments record : clear implicits.
      Definition with_bh1 {t_bh1 t_bh2} bh1 (r : record t_bh1 t_bh2) :=
        Build t_bh1 t_bh2 bh1 r.(bh2).
      Definition with_bh2 {t_bh1 t_bh2} bh2 (r : record t_bh1 t_bh2) :=
        Build t_bh1 t_bh2 r.(bh1) bh2.
    End Double_baking_evidence.
    Definition Double_baking_evidence_skeleton := Double_baking_evidence.record.
    
    Module Activate_account.
      Record record {id activation_code : Set} : Set := Build {
        id : id;
        activation_code : activation_code }.
      Arguments record : clear implicits.
      Definition with_id {t_id t_activation_code} id
        (r : record t_id t_activation_code) :=
        Build t_id t_activation_code id r.(activation_code).
      Definition with_activation_code {t_id t_activation_code} activation_code
        (r : record t_id t_activation_code) :=
        Build t_id t_activation_code r.(id) activation_code.
    End Activate_account.
    Definition Activate_account_skeleton := Activate_account.record.
    
    Module Proposals.
      Record record {source period proposals : Set} : Set := Build {
        source : source;
        period : period;
        proposals : proposals }.
      Arguments record : clear implicits.
      Definition with_source {t_source t_period t_proposals} source
        (r : record t_source t_period t_proposals) :=
        Build t_source t_period t_proposals source r.(period) r.(proposals).
      Definition with_period {t_source t_period t_proposals} period
        (r : record t_source t_period t_proposals) :=
        Build t_source t_period t_proposals r.(source) period r.(proposals).
      Definition with_proposals {t_source t_period t_proposals} proposals
        (r : record t_source t_period t_proposals) :=
        Build t_source t_period t_proposals r.(source) r.(period) proposals.
    End Proposals.
    Definition Proposals_skeleton := Proposals.record.
    
    Module Ballot.
      Record record {source period proposal ballot : Set} : Set := Build {
        source : source;
        period : period;
        proposal : proposal;
        ballot : ballot }.
      Arguments record : clear implicits.
      Definition with_source {t_source t_period t_proposal t_ballot} source
        (r : record t_source t_period t_proposal t_ballot) :=
        Build t_source t_period t_proposal t_ballot source r.(period)
          r.(proposal) r.(ballot).
      Definition with_period {t_source t_period t_proposal t_ballot} period
        (r : record t_source t_period t_proposal t_ballot) :=
        Build t_source t_period t_proposal t_ballot r.(source) period
          r.(proposal) r.(ballot).
      Definition with_proposal {t_source t_period t_proposal t_ballot} proposal
        (r : record t_source t_period t_proposal t_ballot) :=
        Build t_source t_period t_proposal t_ballot r.(source) r.(period)
          proposal r.(ballot).
      Definition with_ballot {t_source t_period t_proposal t_ballot} ballot
        (r : record t_source t_period t_proposal t_ballot) :=
        Build t_source t_period t_proposal t_ballot r.(source) r.(period)
          r.(proposal) ballot.
    End Ballot.
    Definition Ballot_skeleton := Ballot.record.
    
    Module Manager_operation.
      Record record {source fee counter operation gas_limit storage_limit : Set} :
        Set := Build {
        source : source;
        fee : fee;
        counter : counter;
        operation : operation;
        gas_limit : gas_limit;
        storage_limit : storage_limit }.
      Arguments record : clear implicits.
      Definition with_source
        {t_source t_fee t_counter t_operation t_gas_limit t_storage_limit}
        source
        (r :
          record t_source t_fee t_counter t_operation t_gas_limit
            t_storage_limit) :=
        Build t_source t_fee t_counter t_operation t_gas_limit t_storage_limit
          source r.(fee) r.(counter) r.(operation) r.(gas_limit)
          r.(storage_limit).
      Definition with_fee
        {t_source t_fee t_counter t_operation t_gas_limit t_storage_limit} fee
        (r :
          record t_source t_fee t_counter t_operation t_gas_limit
            t_storage_limit) :=
        Build t_source t_fee t_counter t_operation t_gas_limit t_storage_limit
          r.(source) fee r.(counter) r.(operation) r.(gas_limit)
          r.(storage_limit).
      Definition with_counter
        {t_source t_fee t_counter t_operation t_gas_limit t_storage_limit}
        counter
        (r :
          record t_source t_fee t_counter t_operation t_gas_limit
            t_storage_limit) :=
        Build t_source t_fee t_counter t_operation t_gas_limit t_storage_limit
          r.(source) r.(fee) counter r.(operation) r.(gas_limit)
          r.(storage_limit).
      Definition with_operation
        {t_source t_fee t_counter t_operation t_gas_limit t_storage_limit}
        operation
        (r :
          record t_source t_fee t_counter t_operation t_gas_limit
            t_storage_limit) :=
        Build t_source t_fee t_counter t_operation t_gas_limit t_storage_limit
          r.(source) r.(fee) r.(counter) operation r.(gas_limit)
          r.(storage_limit).
      Definition with_gas_limit
        {t_source t_fee t_counter t_operation t_gas_limit t_storage_limit}
        gas_limit
        (r :
          record t_source t_fee t_counter t_operation t_gas_limit
            t_storage_limit) :=
        Build t_source t_fee t_counter t_operation t_gas_limit t_storage_limit
          r.(source) r.(fee) r.(counter) r.(operation) gas_limit
          r.(storage_limit).
      Definition with_storage_limit
        {t_source t_fee t_counter t_operation t_gas_limit t_storage_limit}
        storage_limit
        (r :
          record t_source t_fee t_counter t_operation t_gas_limit
            t_storage_limit) :=
        Build t_source t_fee t_counter t_operation t_gas_limit t_storage_limit
          r.(source) r.(fee) r.(counter) r.(operation) r.(gas_limit)
          storage_limit.
    End Manager_operation.
    Definition Manager_operation_skeleton := Manager_operation.record.
  End contents.
  Module manager_operation.
    Module Transaction.
      Record record {amount parameters entrypoint destination : Set} : Set := Build {
        amount : amount;
        parameters : parameters;
        entrypoint : entrypoint;
        destination : destination }.
      Arguments record : clear implicits.
      Definition with_amount {t_amount t_parameters t_entrypoint t_destination}
        amount (r : record t_amount t_parameters t_entrypoint t_destination) :=
        Build t_amount t_parameters t_entrypoint t_destination amount
          r.(parameters) r.(entrypoint) r.(destination).
      Definition with_parameters
        {t_amount t_parameters t_entrypoint t_destination} parameters
        (r : record t_amount t_parameters t_entrypoint t_destination) :=
        Build t_amount t_parameters t_entrypoint t_destination r.(amount)
          parameters r.(entrypoint) r.(destination).
      Definition with_entrypoint
        {t_amount t_parameters t_entrypoint t_destination} entrypoint
        (r : record t_amount t_parameters t_entrypoint t_destination) :=
        Build t_amount t_parameters t_entrypoint t_destination r.(amount)
          r.(parameters) entrypoint r.(destination).
      Definition with_destination
        {t_amount t_parameters t_entrypoint t_destination} destination
        (r : record t_amount t_parameters t_entrypoint t_destination) :=
        Build t_amount t_parameters t_entrypoint t_destination r.(amount)
          r.(parameters) r.(entrypoint) destination.
    End Transaction.
    Definition Transaction_skeleton := Transaction.record.
    
    Module Origination.
      Record record {delegate script credit preorigination : Set} : Set := Build {
        delegate : delegate;
        script : script;
        credit : credit;
        preorigination : preorigination }.
      Arguments record : clear implicits.
      Definition with_delegate {t_delegate t_script t_credit t_preorigination}
        delegate (r : record t_delegate t_script t_credit t_preorigination) :=
        Build t_delegate t_script t_credit t_preorigination delegate r.(script)
          r.(credit) r.(preorigination).
      Definition with_script {t_delegate t_script t_credit t_preorigination}
        script (r : record t_delegate t_script t_credit t_preorigination) :=
        Build t_delegate t_script t_credit t_preorigination r.(delegate) script
          r.(credit) r.(preorigination).
      Definition with_credit {t_delegate t_script t_credit t_preorigination}
        credit (r : record t_delegate t_script t_credit t_preorigination) :=
        Build t_delegate t_script t_credit t_preorigination r.(delegate)
          r.(script) credit r.(preorigination).
      Definition with_preorigination
        {t_delegate t_script t_credit t_preorigination} preorigination
        (r : record t_delegate t_script t_credit t_preorigination) :=
        Build t_delegate t_script t_credit t_preorigination r.(delegate)
          r.(script) r.(credit) preorigination.
    End Origination.
    Definition Origination_skeleton := Origination.record.
  End manager_operation.
End ConstructorRecords_contents_list_contents_manager_operation.
Import ConstructorRecords_contents_list_contents_manager_operation.

Module operation.
  Record record {shell protocol_data : Set} : Set := Build {
    shell : shell;
    protocol_data : protocol_data }.
  Arguments record : clear implicits.
  Definition with_shell {t_shell t_protocol_data} shell
    (r : record t_shell t_protocol_data) :=
    Build t_shell t_protocol_data shell r.(protocol_data).
  Definition with_protocol_data {t_shell t_protocol_data} protocol_data
    (r : record t_shell t_protocol_data) :=
    Build t_shell t_protocol_data r.(shell) protocol_data.
End operation.
Definition operation_skeleton := operation.record.

Module protocol_data.
  Record record {contents signature : Set} : Set := Build {
    contents : contents;
    signature : signature }.
  Arguments record : clear implicits.
  Definition with_contents {t_contents t_signature} contents
    (r : record t_contents t_signature) :=
    Build t_contents t_signature contents r.(signature).
  Definition with_signature {t_contents t_signature} signature
    (r : record t_contents t_signature) :=
    Build t_contents t_signature r.(contents) signature.
End protocol_data.
Definition protocol_data_skeleton := protocol_data.record.

Reserved Notation &quot;'contents.Endorsement&quot;.
Reserved Notation &quot;'contents.Seed_nonce_revelation&quot;.
Reserved Notation &quot;'contents.Double_endorsement_evidence&quot;.
Reserved Notation &quot;'contents.Double_baking_evidence&quot;.
Reserved Notation &quot;'contents.Activate_account&quot;.
Reserved Notation &quot;'contents.Proposals&quot;.
Reserved Notation &quot;'contents.Ballot&quot;.
Reserved Notation &quot;'contents.Manager_operation&quot;.
Reserved Notation &quot;'manager_operation.Transaction&quot;.
Reserved Notation &quot;'manager_operation.Origination&quot;.
Reserved Notation &quot;'protocol_data&quot;.
Reserved Notation &quot;'operation&quot;.
Reserved Notation &quot;'counter&quot;.

Inductive contents_list : Set :=
| Single : contents -&gt; contents_list
| Cons : contents -&gt; contents_list -&gt; contents_list

with contents : Set :=
| Endorsement : 'contents.Endorsement -&gt; contents
| Seed_nonce_revelation : 'contents.Seed_nonce_revelation -&gt; contents
| Double_endorsement_evidence :
  'contents.Double_endorsement_evidence -&gt; contents
| Double_baking_evidence : 'contents.Double_baking_evidence -&gt; contents
| Activate_account : 'contents.Activate_account -&gt; contents
| Proposals : 'contents.Proposals -&gt; contents
| Ballot : 'contents.Ballot -&gt; contents
| Manager_operation : 'contents.Manager_operation -&gt; contents

with manager_operation : Set :=
| Reveal : (|Signature.Public_key|).(S.SPublic_key.t) -&gt; manager_operation
| Transaction : 'manager_operation.Transaction -&gt; manager_operation
| Origination : 'manager_operation.Origination -&gt; manager_operation
| Delegation :
  option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  manager_operation

where &quot;'protocol_data&quot; :=
  (protocol_data_skeleton contents_list (option Signature.t))
and &quot;'operation&quot; := (operation_skeleton Operation.shell_header 'protocol_data)
and &quot;'counter&quot; := (Z.t)
and &quot;'contents.Endorsement&quot; := (contents.Endorsement_skeleton Raw_level.t)
and &quot;'contents.Seed_nonce_revelation&quot; :=
  (contents.Seed_nonce_revelation_skeleton Raw_level.t Nonce.t)
and &quot;'contents.Double_endorsement_evidence&quot; :=
  (contents.Double_endorsement_evidence_skeleton 'operation 'operation)
and &quot;'contents.Double_baking_evidence&quot; :=
  (contents.Double_baking_evidence_skeleton Block_header.block_header
    Block_header.block_header)
and &quot;'contents.Activate_account&quot; :=
  (contents.Activate_account_skeleton
    (|Ed25519|).(S.SIGNATURE.Public_key_hash).(S.SPublic_key_hash.t)
    Blinded_public_key_hash.activation_code)
and &quot;'contents.Proposals&quot; :=
  (contents.Proposals_skeleton
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) Voting_period.t
    (list (|Protocol_hash|).(S.HASH.t)))
and &quot;'contents.Ballot&quot; :=
  (contents.Ballot_skeleton (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)
    Voting_period.t (|Protocol_hash|).(S.HASH.t) Vote.ballot)
and &quot;'contents.Manager_operation&quot; :=
  (contents.Manager_operation_skeleton
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) Tez.tez 'counter
    manager_operation Z.t Z.t)
and &quot;'manager_operation.Transaction&quot; :=
  (manager_operation.Transaction_skeleton Tez.tez Script.lazy_expr string
    Contract.contract)
and &quot;'manager_operation.Origination&quot; :=
  (manager_operation.Origination_skeleton
    (option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) Script.t
    Tez.tez (option Contract.t)).

Module contents.
  Include ConstructorRecords_contents_list_contents_manager_operation.contents.
  Definition Endorsement := 'contents.Endorsement.
  Definition Seed_nonce_revelation := 'contents.Seed_nonce_revelation.
  Definition Double_endorsement_evidence :=
    'contents.Double_endorsement_evidence.
  Definition Double_baking_evidence := 'contents.Double_baking_evidence.
  Definition Activate_account := 'contents.Activate_account.
  Definition Proposals := 'contents.Proposals.
  Definition Ballot := 'contents.Ballot.
  Definition Manager_operation := 'contents.Manager_operation.
End contents.
Module manager_operation.
  Include ConstructorRecords_contents_list_contents_manager_operation.manager_operation.
  Definition Transaction := 'manager_operation.Transaction.
  Definition Origination := 'manager_operation.Origination.
End manager_operation.

Definition protocol_data := 'protocol_data.
Definition operation := 'operation.
Definition counter := 'counter.

Module internal_operation.
  Record record : Set := Build {
    source : Contract.contract;
    operation : manager_operation;
    nonce : int }.
  Definition with_source source (r : record) :=
    Build source r.(operation) r.(nonce).
  Definition with_operation operation (r : record) :=
    Build r.(source) operation r.(nonce).
  Definition with_nonce nonce (r : record) :=
    Build r.(source) r.(operation) nonce.
End internal_operation.
Definition internal_operation := internal_operation.record.

Inductive packed_manager_operation : Set :=
| Manager : manager_operation -&gt; packed_manager_operation.

Inductive packed_contents : Set :=
| Contents : contents -&gt; packed_contents.

Inductive packed_contents_list : Set :=
| Contents_list : contents_list -&gt; packed_contents_list.

Inductive packed_protocol_data : Set :=
| Operation_data : protocol_data -&gt; packed_protocol_data.

Module packed_operation.
  Record record : Set := Build {
    shell : Operation.shell_header;
    protocol_data : packed_protocol_data }.
  Definition with_shell shell (r : record) :=
    Build shell r.(protocol_data).
  Definition with_protocol_data protocol_data (r : record) :=
    Build r.(shell) protocol_data.
End packed_operation.
Definition packed_operation := packed_operation.record.

Inductive packed_internal_operation : Set :=
| Internal_operation : internal_operation -&gt; packed_internal_operation.

Parameter manager_kind : manager_operation -&gt; Kind.manager.

Module Fees.
  Parameter origination_burn :
    context -&gt; Lwt.t (Error_monad.tzresult (context * Tez.t)).
  
  Parameter record_paid_storage_space :
    context -&gt; Contract.t -&gt;
    Lwt.t (Error_monad.tzresult (context * Z.t * Z.t * Tez.t)).
  
  Parameter start_counting_storage_fees : context -&gt; context.
  
  Parameter burn_storage_fees :
    context -&gt; Z.t -&gt; Contract.t -&gt; Lwt.t (Error_monad.tzresult context).
  
  (* extensible_type_definition `error` *)
  
  (* extensible_type_definition `error` *)
  
  (* extensible_type_definition `error` *)
  
  Parameter check_storage_limit : context -&gt; Z.t -&gt; Error_monad.tzresult unit.
End Fees.

Module Operation.
  Definition contents : Set := contents.
  
  Definition packed_contents : Set := packed_contents.
  
  Parameter contents_encoding : Data_encoding.t packed_contents.
  
  Definition protocol_data : Set := protocol_data.
  
  Definition packed_protocol_data : Set := packed_protocol_data.
  
  Parameter protocol_data_encoding : Data_encoding.t packed_protocol_data.
  
  Parameter unsigned_encoding :
    Data_encoding.t (Operation.shell_header * packed_contents_list).
  
  Definition raw : Set := Operation.t.
  
  Parameter raw_encoding : Data_encoding.t raw.
  
  Parameter contents_list_encoding : Data_encoding.t packed_contents_list.
  
  Definition t : Set := operation.
  
  Definition packed : Set := packed_operation.
  
  Parameter encoding : Data_encoding.t packed.
  
  Parameter __raw_value : operation -&gt; raw.
  
  Parameter __hash_value : operation -&gt; (|Operation_hash|).(S.HASH.t).
  
  Parameter hash_raw : raw -&gt; (|Operation_hash|).(S.HASH.t).
  
  Parameter hash_packed : packed_operation -&gt; (|Operation_hash|).(S.HASH.t).
  
  Parameter acceptable_passes : packed_operation -&gt; list int.
  
  (* extensible_type_definition `error` *)
  
  (* extensible_type_definition `error` *)
  
  Parameter check_signature :
    public_key -&gt; (|Chain_id|).(S.HASH.t) -&gt; operation -&gt;
    Lwt.t (Error_monad.tzresult unit).
  
  Parameter check_signature_sync :
    public_key -&gt; (|Chain_id|).(S.HASH.t) -&gt; operation -&gt;
    Error_monad.tzresult unit.
  
  Parameter internal_operation_encoding :
    Data_encoding.t packed_internal_operation.
  
  Parameter __pack : operation -&gt; packed_operation.
  
  Inductive eq : Set :=
  | Eq : eq.
  
  Parameter equal : operation -&gt; operation -&gt; option eq.
  
  Module Encoding.
    Module ConstructorRecords_case.
      Module case.
        Module Case.
          Record record {tag name encoding select proj inj : Set} : Set := Build {
            tag : tag;
            name : name;
            encoding : encoding;
            select : select;
            proj : proj;
            inj : inj }.
          Arguments record : clear implicits.
          Definition with_tag {t_tag t_name t_encoding t_select t_proj t_inj}
            tag (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
            Build t_tag t_name t_encoding t_select t_proj t_inj tag r.(name)
              r.(encoding) r.(select) r.(proj) r.(inj).
          Definition with_name {t_tag t_name t_encoding t_select t_proj t_inj}
            name (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
            Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) name
              r.(encoding) r.(select) r.(proj) r.(inj).
          Definition with_encoding
            {t_tag t_name t_encoding t_select t_proj t_inj} encoding
            (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
            Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) r.(name)
              encoding r.(select) r.(proj) r.(inj).
          Definition with_select {t_tag t_name t_encoding t_select t_proj t_inj}
            select (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
            Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) r.(name)
              r.(encoding) select r.(proj) r.(inj).
          Definition with_proj {t_tag t_name t_encoding t_select t_proj t_inj}
            proj (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
            Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) r.(name)
              r.(encoding) r.(select) proj r.(inj).
          Definition with_inj {t_tag t_name t_encoding t_select t_proj t_inj}
            inj (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
            Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) r.(name)
              r.(encoding) r.(select) r.(proj) inj.
        End Case.
        Definition Case_skeleton := Case.record.
      End case.
    End ConstructorRecords_case.
    Import ConstructorRecords_case.
    
    Reserved Notation &quot;'case.Case&quot;.
    
    Inductive case : Set :=
    | Case : forall {a : Set}, 'case.Case a -&gt; case
    
    where &quot;'case.Case&quot; := (fun (t_a : Set) =&gt;
      case.Case_skeleton int string (Data_encoding.t t_a)
        (packed_contents -&gt; option contents) (contents -&gt; t_a) (t_a -&gt; contents)).
    
    Module case.
      Include ConstructorRecords_case.case.
      Definition Case := 'case.Case.
    End case.
    
    Parameter endorsement_case : case.
    
    Parameter seed_nonce_revelation_case : case.
    
    Parameter double_endorsement_evidence_case : case.
    
    Parameter double_baking_evidence_case : case.
    
    Parameter activate_account_case : case.
    
    Parameter proposals_case : case.
    
    Parameter ballot_case : case.
    
    Parameter reveal_case : case.
    
    Parameter transaction_case : case.
    
    Parameter origination_case : case.
    
    Parameter delegation_case : case.
    
    Module Manager_operations.
      Module ConstructorRecords_case.
        Module case.
          Module MCase.
            Record record {tag name encoding select proj inj : Set} : Set := Build {
              tag : tag;
              name : name;
              encoding : encoding;
              select : select;
              proj : proj;
              inj : inj }.
            Arguments record : clear implicits.
            Definition with_tag {t_tag t_name t_encoding t_select t_proj t_inj}
              tag (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
              Build t_tag t_name t_encoding t_select t_proj t_inj tag r.(name)
                r.(encoding) r.(select) r.(proj) r.(inj).
            Definition with_name {t_tag t_name t_encoding t_select t_proj t_inj}
              name (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
              Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) name
                r.(encoding) r.(select) r.(proj) r.(inj).
            Definition with_encoding
              {t_tag t_name t_encoding t_select t_proj t_inj} encoding
              (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
              Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag)
                r.(name) encoding r.(select) r.(proj) r.(inj).
            Definition with_select
              {t_tag t_name t_encoding t_select t_proj t_inj} select
              (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
              Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag)
                r.(name) r.(encoding) select r.(proj) r.(inj).
            Definition with_proj {t_tag t_name t_encoding t_select t_proj t_inj}
              proj (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
              Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag)
                r.(name) r.(encoding) r.(select) proj r.(inj).
            Definition with_inj {t_tag t_name t_encoding t_select t_proj t_inj}
              inj (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
              Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag)
                r.(name) r.(encoding) r.(select) r.(proj) inj.
          End MCase.
          Definition MCase_skeleton := MCase.record.
        End case.
      End ConstructorRecords_case.
      Import ConstructorRecords_case.
      
      Reserved Notation &quot;'case.MCase&quot;.
      
      Inductive case : Set :=
      | MCase : forall {a : Set}, 'case.MCase a -&gt; case
      
      where &quot;'case.MCase&quot; := (fun (t_a : Set) =&gt;
        case.MCase_skeleton int string (Data_encoding.t t_a)
          (packed_manager_operation -&gt; option manager_operation)
          (manager_operation -&gt; t_a) (t_a -&gt; manager_operation)).
      
      Module case.
        Include ConstructorRecords_case.case.
        Definition MCase := 'case.MCase.
      End case.
      
      Parameter reveal_case : case.
      
      Parameter transaction_case : case.
      
      Parameter origination_case : case.
      
      Parameter delegation_case : case.
    End Manager_operations.
  End Encoding.
  
  Parameter of_list : list packed_contents -&gt; packed_contents_list.
  
  Parameter to_list : packed_contents_list -&gt; list packed_contents.
End Operation.

Module Roll.
  Definition t : Set := int32.
  
  Definition roll : Set := t.
  
  Parameter encoding : Data_encoding.t roll.
  
  Parameter snapshot_rolls : context -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter cycle_end :
    context -&gt; Cycle.t -&gt; Lwt.t (Error_monad.tzresult context).
  
  Parameter baking_rights_owner :
    context -&gt; Level.t -&gt; int -&gt; Lwt.t (Error_monad.tzresult public_key).
  
  Parameter endorsement_rights_owner :
    context -&gt; Level.t -&gt; int -&gt; Lwt.t (Error_monad.tzresult public_key).
  
  Parameter delegate_pubkey :
    context -&gt; public_key_hash -&gt; Lwt.t (Error_monad.tzresult public_key).
  
  Parameter get_rolls :
    context -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
    Lwt.t (Error_monad.tzresult (list roll)).
  
  Parameter get_change :
    context -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
    Lwt.t (Error_monad.tzresult Tez.t).
End Roll.

Module Commitment.
  Module t.
    Record record : Set := Build {
      blinded_public_key_hash : Blinded_public_key_hash.t;
      amount : Tez.tez }.
    Definition with_blinded_public_key_hash blinded_public_key_hash
      (r : record) :=
      Build blinded_public_key_hash r.(amount).
    Definition with_amount amount (r : record) :=
      Build r.(blinded_public_key_hash) amount.
  End t.
  Definition t := t.record.
  
  Parameter get_opt :
    context -&gt; Blinded_public_key_hash.t -&gt;
    Lwt.t (Error_monad.tzresult (option Tez.t)).
  
  Parameter delete :
    context -&gt; Blinded_public_key_hash.t -&gt; Lwt.t (Error_monad.tzresult context).
End Commitment.

Module Bootstrap.
  Parameter cycle_end :
    context -&gt; Cycle.t -&gt; Lwt.t (Error_monad.tzresult context).
End Bootstrap.

Module Global.
  Parameter get_block_priority : context -&gt; Lwt.t (Error_monad.tzresult int).
  
  Parameter set_block_priority :
    context -&gt; int -&gt; Lwt.t (Error_monad.tzresult context).
End Global.

Parameter prepare_first_block :
  Context.t -&gt;
  (context -&gt; Script.t -&gt;
  Lwt.t
    (Error_monad.tzresult ((Script.t * option Contract.big_map_diff) * context)))
  -&gt; Int32.t -&gt; Time.t -&gt; Fitness.t -&gt; Lwt.t (Error_monad.tzresult context).

Parameter prepare :
  Context.t -&gt; Int32.t -&gt; Time.t -&gt; Time.t -&gt; Fitness.t -&gt;
  Lwt.t (Error_monad.tzresult context).

Parameter finalize : option string -&gt; context -&gt; Updater.validation_result.

Parameter activate : context -&gt; (|Protocol_hash|).(S.HASH.t) -&gt; Lwt.t context.

Parameter fork_test_chain :
  context -&gt; (|Protocol_hash|).(S.HASH.t) -&gt; Time.t -&gt; Lwt.t context.

Parameter record_endorsement :
  context -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt; context.

Parameter allowed_endorsements :
  context -&gt;
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t)
    ((|Signature.Public_key|).(S.SPublic_key.t) * list int * bool).

Parameter init_endorsements :
  context -&gt;
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t)
    ((|Signature.Public_key|).(S.SPublic_key.t) * list int * bool) -&gt; context.

Parameter included_endorsements : context -&gt; int.

Parameter reset_internal_nonce : context -&gt; context.

Parameter fresh_internal_nonce :
  context -&gt; Error_monad.tzresult (context * int).

Parameter record_internal_nonce : context -&gt; int -&gt; context.

Parameter internal_nonce_already_recorded : context -&gt; int -&gt; bool.

Parameter add_fees : context -&gt; Tez.t -&gt; Lwt.t (Error_monad.tzresult context).

Parameter add_rewards :
  context -&gt; Tez.t -&gt; Lwt.t (Error_monad.tzresult context).

Parameter add_deposit :
  context -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt; Tez.t -&gt;
  Lwt.t (Error_monad.tzresult context).

Parameter get_fees : context -&gt; Tez.t.

Parameter get_rewards : context -&gt; Tez.t.

Parameter get_deposits :
  context -&gt;
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t) Tez.t.

Parameter description : Storage_description.t context.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="alpha_services.ml">
  <div style="margin: 20px;">
    <h3>Alpha_services</h3>
    <ul>
      <li>OCaml size: 117 lines</li>
      <li>Coq size: 152 lines (+29% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#alpha_services.ml"><code>alpha_services.ml</code></a>&nbsp;<span class="label label-warning">6 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

let custom_root = RPC_path.open_root

module Seed = struct
  module S = struct
    open Data_encoding

    let seed =
      RPC_service.post_service
        ~description:&quot;Seed of the cycle to which the block belongs.&quot;
        ~query:RPC_query.empty
        ~input:empty
        ~output:Seed.seed_encoding
        RPC_path.(custom_root / &quot;context&quot; / &quot;seed&quot;)
  end

  <abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
    let open Services_registration in
    register0 S.seed (fun ctxt () () -&gt;
        let l = Level.current ctxt in
        Seed.for_cycle ctxt l.cycle)</abbr>

  let get ctxt block = RPC_context.make_call0 S.seed ctxt block () ()
end

module Nonce = struct
  type info = Revealed of Nonce.t | Missing of Nonce_hash.t | Forgotten

  let info_encoding =
    let open Data_encoding in
    union
      [ case
          (Tag 0)
          ~title:&quot;Revealed&quot;
          (obj1 (req &quot;nonce&quot; Nonce.encoding))
          (function Revealed nonce -&gt; Some nonce | _ -&gt; None)
          (fun nonce -&gt; Revealed nonce);
        case
          (Tag 1)
          ~title:&quot;Missing&quot;
          (obj1 (req &quot;hash&quot; Nonce_hash.encoding))
          (function Missing nonce -&gt; Some nonce | _ -&gt; None)
          (fun nonce -&gt; Missing nonce);
        case
          (Tag 2)
          ~title:&quot;Forgotten&quot;
          empty
          (function Forgotten -&gt; Some () | _ -&gt; None)
          (fun () -&gt; Forgotten) ]

  module S = struct
    let get =
      RPC_service.get_service
        ~description:&quot;Info about the nonce of a previous block.&quot;
        ~query:RPC_query.empty
        ~output:info_encoding
        RPC_path.(custom_root / &quot;context&quot; / &quot;nonces&quot; /: Raw_level.rpc_arg)
  end

  let register () =
    let open Services_registration in
    register1 S.get (fun ctxt raw_level () () -&gt;
        let level = Level.from_raw ctxt raw_level in
        Nonce.get ctxt level
        &gt;&gt;= function
        | Ok (Storage.Revealed nonce) -&gt;
            return (Revealed nonce)
        | Ok (Storage.Unrevealed {nonce_hash; _}) -&gt;
            return (Missing nonce_hash)
        | Error _ -&gt;
            return Forgotten)

  let get ctxt block level =
    RPC_context.make_call1 S.get ctxt block level () ()
end

module Contract = Contract_services
module Constants = Constants_services
module Delegate = Delegate_services
module Helpers = Helpers_services
module Forge = Helpers_services.Forge
module Parse = Helpers_services.Parse
module Voting = Voting_services

let register () =
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Contract.register ()</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Constants.register ()</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Delegate.register ()</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Helpers.register ()</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Nonce.register ()</abbr> ;
  Voting.register ()
</pre>
  </div>
  <div class="col-md-6">
    <a href="#alpha_services.ml"><code>Alpha_services.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Constants_services.
Require Tezos.Contract_services.
Require Tezos.Delegate_services.
Require Tezos.Helpers_services.
Require Tezos.Nonce_hash.
Require Tezos.Seed_repr.
Require Tezos.Services_registration.
Require Tezos.Storage_mli. Module Storage := Storage_mli.
Require Tezos.Voting_services.

Import Alpha_context.

Definition custom_root {A : Set} : RPC_path.context A := RPC_path.open_root.

Module Seed.
  Module S.
    Import Data_encoding.
    
    Definition __seed_value
      : RPC_service.service Updater.rpc_context Updater.rpc_context unit unit
        Alpha_context.Seed.seed :=
      RPC_service.post_service
        (Some &quot;Seed of the cycle to which the block belongs.&quot;) RPC_query.empty
        Data_encoding.empty Alpha_context.Seed.seed_encoding
        (RPC_path.op_div (RPC_path.op_div custom_root &quot;context&quot;) &quot;seed&quot;).
  End S.
  
  (* ‚ùå Top-level evaluations are ignored *)
  (* top_level_evaluation *)
  
  Definition get {A : Set} (ctxt : RPC_context.simple A) (block : A)
    : Lwt.t (Error_monad.shell_tzresult Alpha_context.Seed.seed) :=
    RPC_context.make_call0 S.__seed_value ctxt block tt tt.
End Seed.

Module Nonce.
  Inductive info : Set :=
  | Revealed : Alpha_context.Nonce.t -&gt; info
  | Missing : Nonce_hash.t -&gt; info
  | Forgotten : info.
  
  Definition info_encoding : Data_encoding.encoding info :=
    Data_encoding.union None
      [
        Data_encoding.__case_value &quot;Revealed&quot; None (Data_encoding.Tag 0)
          (Data_encoding.obj1
            (Data_encoding.req None None &quot;nonce&quot;
              Alpha_context.Nonce.encoding))
          (fun function_parameter =&gt;
            match function_parameter with
            | Revealed __nonce_value =&gt; Some __nonce_value
            | _ =&gt; None
            end) (fun __nonce_value =&gt; Revealed __nonce_value);
        Data_encoding.__case_value &quot;Missing&quot; None (Data_encoding.Tag 1)
          (Data_encoding.obj1
            (Data_encoding.req None None &quot;hash&quot; Nonce_hash.encoding))
          (fun function_parameter =&gt;
            match function_parameter with
            | Missing __nonce_value =&gt; Some __nonce_value
            | _ =&gt; None
            end) (fun __nonce_value =&gt; Missing __nonce_value);
        Data_encoding.__case_value &quot;Forgotten&quot; None (Data_encoding.Tag 2)
          Data_encoding.empty
          (fun function_parameter =&gt;
            match function_parameter with
            | Forgotten =&gt; Some tt
            | _ =&gt; None
            end)
          (fun function_parameter =&gt;
            let '_ := function_parameter in
            Forgotten)
      ].
  
  Module S.
    Definition get
      : RPC_service.service Updater.rpc_context
        (Updater.rpc_context * Alpha_context.Raw_level.raw_level) unit unit info :=
      RPC_service.get_service (Some &quot;Info about the nonce of a previous block.&quot;)
        RPC_query.empty info_encoding
        (RPC_path.op_divcolon
          (RPC_path.op_div (RPC_path.op_div custom_root &quot;context&quot;) &quot;nonces&quot;)
          Alpha_context.Raw_level.rpc_arg).
  End S.
  
  Definition register (function_parameter : unit) : unit :=
    let '_ := function_parameter in
    Services_registration.register1 S.get
      (fun ctxt =&gt;
        fun raw_level =&gt;
          fun function_parameter =&gt;
            let '_ := function_parameter in
            fun function_parameter =&gt;
              let '_ := function_parameter in
              let level := Alpha_context.Level.from_raw ctxt None raw_level in
              let= function_parameter := Alpha_context.Nonce.get ctxt level in
              match function_parameter with
              | Pervasives.Ok (Storage.Revealed __nonce_value) =&gt;
                Error_monad.__return (Revealed __nonce_value)
              |
                Pervasives.Ok
                  (Storage.Unrevealed {|
                    Storage.unrevealed_nonce.nonce_hash := nonce_hash |}) =&gt;
                Error_monad.__return (Missing nonce_hash)
              | Pervasives.Error _ =&gt; Error_monad.__return Forgotten
              end).
  
  Definition get {A : Set}
    (ctxt : RPC_context.simple A) (block : A)
    (level : Alpha_context.Raw_level.raw_level)
    : Lwt.t (Error_monad.shell_tzresult info) :=
    RPC_context.make_call1 S.get ctxt block level tt tt.
End Nonce.

Module Contract := Contract_services.

Module Constants := Constants_services.

Module Delegate := Delegate_services.

Module Helpers := Helpers_services.

Module Forge := Helpers_services.Forge.

Module Parse := Helpers_services.Parse.

Module Voting := Voting_services.

Definition register (function_parameter : unit) : unit :=
  let '_ := function_parameter in
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  Voting.register tt.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="alpha_services.mli">
  <div style="margin: 20px;">
    <h3>Alpha_services_mli</h3>
    <ul>
      <li>OCaml size: 47 lines</li>
      <li>Coq size: 53 lines (+12% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#alpha_services.mli"><code>alpha_services.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

module Seed : sig
  val get : 'a #RPC_context.simple -&gt; 'a -&gt; Seed.seed shell_tzresult Lwt.t
end

module Nonce : sig
  type info = Revealed of Nonce.t | Missing of Nonce_hash.t | Forgotten

  val get :
    'a #RPC_context.simple -&gt; 'a -&gt; Raw_level.t -&gt; info shell_tzresult Lwt.t
end

module Contract = Contract_services
module Constants = Constants_services
module Delegate = Delegate_services
module Helpers = Helpers_services
module Forge = Helpers_services.Forge
module Parse = Helpers_services.Parse
module Voting = Voting_services

val register : unit -&gt; unit
</pre>
  </div>
  <div class="col-md-6">
    <a href="#alpha_services.mli"><code>Alpha_services_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Constants_services.
Require Tezos.Contract_services.
Require Tezos.Delegate_services.
Require Tezos.Helpers_services.
Require Tezos.Nonce_hash.
Require Tezos.Voting_services.

Import Alpha_context.

Module Seed.
  Parameter get : forall {a : Set},
    RPC_context.simple a -&gt; a -&gt;
    Lwt.t (Error_monad.shell_tzresult Alpha_context.Seed.seed).
End Seed.

Module Nonce.
  Inductive info : Set :=
  | Revealed : Alpha_context.Nonce.t -&gt; info
  | Missing : Nonce_hash.t -&gt; info
  | Forgotten : info.
  
  Parameter get : forall {a : Set},
    RPC_context.simple a -&gt; a -&gt; Alpha_context.Raw_level.t -&gt;
    Lwt.t (Error_monad.shell_tzresult info).
End Nonce.

Module Contract := Contract_services.

Module Constants := Constants_services.

Module Delegate := Delegate_services.

Module Helpers := Helpers_services.

Module Forge := Helpers_services.Forge.

Module Parse := Helpers_services.Parse.

Module Voting := Voting_services.

Parameter register : unit -&gt; unit.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="amendment.ml">
  <div style="margin: 20px;">
    <h3>Amendment</h3>
    <ul>
      <li>OCaml size: 323 lines</li>
      <li>Coq size: 262 lines (-19% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#amendment.ml"><code>amendment.ml</code></a>&nbsp;<span class="label label-warning">11 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

(** Returns the proposal submitted by the most delegates.
    Returns None in case of a tie, if proposal quorum is below required
    minimum or if there are no proposals. *)
let select_winning_proposal ctxt =
  Vote.get_proposals ctxt
  &gt;&gt;=? fun proposals -&gt;
  let merge proposal vote winners =
    match winners with
    | None -&gt;
        Some ([proposal], vote)
    | Some (winners, winners_vote) as previous -&gt;
        if Compare.Int32.(vote = winners_vote) then
          Some (proposal :: winners, winners_vote)
        else if Compare.Int32.(vote &gt; winners_vote) then Some ([proposal], vote)
        else previous
  in
  match Protocol_hash.Map.fold merge proposals None with
  | Some ([proposal], vote) -&gt;
      Vote.listing_size ctxt
      &gt;&gt;=? fun max_vote -&gt;
      let min_proposal_quorum = Constants.min_proposal_quorum ctxt in
      let min_vote_to_pass =
        Int32.div (Int32.mul min_proposal_quorum max_vote) 100_00l
      in
      if Compare.Int32.(vote &gt;= min_vote_to_pass) then return_some proposal
      else return_none
  | _ -&gt;
      return_none

(* in case of a tie, let's do nothing. *)

(** A proposal is approved if it has supermajority and the participation reaches
    the current quorum.
    Supermajority means the yays are more 8/10 of casted votes.
    The participation is the ratio of all received votes, including passes, with
    respect to the number of possible votes.
    The participation EMA (exponential moving average) uses the last
    participation EMA and the current participation./
    The expected quorum is calculated using the last participation EMA, capped
    by the min/max quorum protocol constants. *)
let check_approval_and_update_participation_ema ctxt =
  Vote.get_ballots ctxt
  &gt;&gt;=? fun ballots -&gt;
  Vote.listing_size ctxt
  &gt;&gt;=? fun maximum_vote -&gt;
  Vote.get_participation_ema ctxt
  &gt;&gt;=? fun participation_ema -&gt;
  Vote.get_current_quorum ctxt
  &gt;&gt;=? fun expected_quorum -&gt;
  (* Note overflows: considering a maximum of 8e8 tokens, with roll size as
     small as 1e3, there is a maximum of 8e5 rolls and thus votes.
     In 'participation' an Int64 is used because in the worst case 'all_votes is
     8e5 and after the multiplication is 8e9, making it potentially overflow a
     signed Int32 which is 2e9. *)
  let casted_votes = Int32.add ballots.yay ballots.nay in
  let all_votes = Int32.add casted_votes ballots.pass in
  let supermajority = Int32.div (Int32.mul 8l casted_votes) 10l in
  let participation =
    (* in centile of percentage *)
    Int64.(
      to_int32 (div (mul (of_int32 all_votes) 100_00L) (of_int32 maximum_vote)))
  in
  let outcome =
    Compare.Int32.(
      participation &gt;= expected_quorum &amp;&amp; ballots.yay &gt;= supermajority)
  in
  let new_participation_ema =
    Int32.(div (add (mul 8l participation_ema) (mul 2l participation)) 10l)
  in
  Vote.set_participation_ema ctxt new_participation_ema
  &gt;&gt;=? fun ctxt -&gt; return (ctxt, outcome)

(** Implements the state machine of the amendment procedure.
    Note that [freeze_listings], that computes the vote weight of each delegate,
    is run at the beginning of each voting period.
*)
let start_new_voting_period ctxt =
  Vote.get_current_period_kind ctxt
  &gt;&gt;=? function
  | Proposal -&gt; (
      select_winning_proposal ctxt
      &gt;&gt;=? fun proposal -&gt;
      Vote.clear_proposals ctxt
      &gt;&gt;= fun ctxt -&gt;
      Vote.clear_listings ctxt
      &gt;&gt;=? fun ctxt -&gt;
      match proposal with
      | None -&gt;
          Vote.freeze_listings ctxt &gt;&gt;=? fun ctxt -&gt; return ctxt
      | Some proposal -&gt;
          Vote.init_current_proposal ctxt proposal
          &gt;&gt;=? fun ctxt -&gt;
          Vote.freeze_listings ctxt
          &gt;&gt;=? fun ctxt -&gt;
          Vote.set_current_period_kind ctxt Testing_vote
          &gt;&gt;=? fun ctxt -&gt; return ctxt )
  | Testing_vote -&gt;
      check_approval_and_update_participation_ema ctxt
      &gt;&gt;=? fun (ctxt, approved) -&gt;
      Vote.clear_ballots ctxt
      &gt;&gt;= fun ctxt -&gt;
      Vote.clear_listings ctxt
      &gt;&gt;=? fun ctxt -&gt;
      if approved then
        let expiration =
          (* in two days maximum... *)
          Time.add
            (Timestamp.current ctxt)
            (Constants.test_chain_duration ctxt)
        in
        Vote.get_current_proposal ctxt
        &gt;&gt;=? fun proposal -&gt;
        fork_test_chain ctxt proposal expiration
        &gt;&gt;= fun ctxt -&gt;
        Vote.set_current_period_kind ctxt Testing &gt;&gt;=? fun ctxt -&gt; return ctxt
      else
        Vote.clear_current_proposal ctxt
        &gt;&gt;=? fun ctxt -&gt;
        Vote.freeze_listings ctxt
        &gt;&gt;=? fun ctxt -&gt;
        Vote.set_current_period_kind ctxt Proposal &gt;&gt;=? fun ctxt -&gt; return ctxt
  | Testing -&gt;
      Vote.freeze_listings ctxt
      &gt;&gt;=? fun ctxt -&gt;
      Vote.set_current_period_kind ctxt Promotion_vote
      &gt;&gt;=? fun ctxt -&gt; return ctxt
  | Promotion_vote -&gt;
      check_approval_and_update_participation_ema ctxt
      &gt;&gt;=? fun (ctxt, approved) -&gt;
      ( if approved then
        Vote.get_current_proposal ctxt
        &gt;&gt;=? fun proposal -&gt; activate ctxt proposal &gt;&gt;= fun ctxt -&gt; return ctxt
      else return ctxt )
      &gt;&gt;=? fun ctxt -&gt;
      Vote.clear_ballots ctxt
      &gt;&gt;= fun ctxt -&gt;
      Vote.clear_listings ctxt
      &gt;&gt;=? fun ctxt -&gt;
      Vote.clear_current_proposal ctxt
      &gt;&gt;=? fun ctxt -&gt;
      Vote.freeze_listings ctxt
      &gt;&gt;=? fun ctxt -&gt;
      Vote.set_current_period_kind ctxt Proposal &gt;&gt;=? fun ctxt -&gt; return ctxt

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | (* `Branch *)
      Invalid_proposal
  | Unexpected_proposal
  | Unauthorized_proposal
  | Too_many_proposals
  | Empty_proposal
  | Unexpected_ballot
  | Unauthorized_ballot</abbr>

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  let open Data_encoding in
  (* Invalid proposal *)
  register_error_kind
    `Branch
    ~id:&quot;invalid_proposal&quot;
    ~title:&quot;Invalid proposal&quot;
    ~description:&quot;Ballot provided for a proposal that is not the current one.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Invalid proposal&quot;)
    empty
    (function Invalid_proposal -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Invalid_proposal) ;
  (* Unexpected proposal *)
  register_error_kind
    `Branch
    ~id:&quot;unexpected_proposal&quot;
    ~title:&quot;Unexpected proposal&quot;
    ~description:&quot;Proposal recorded outside of a proposal period.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Unexpected proposal&quot;)
    empty
    (function Unexpected_proposal -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Unexpected_proposal) ;
  (* Unauthorized proposal *)
  register_error_kind
    `Branch
    ~id:&quot;unauthorized_proposal&quot;
    ~title:&quot;Unauthorized proposal&quot;
    ~description:
      &quot;The delegate provided for the proposal is not in the voting listings.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Unauthorized proposal&quot;)
    empty
    (function Unauthorized_proposal -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Unauthorized_proposal) ;
  (* Unexpected ballot *)
  register_error_kind
    `Branch
    ~id:&quot;unexpected_ballot&quot;
    ~title:&quot;Unexpected ballot&quot;
    ~description:&quot;Ballot recorded outside of a voting period.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Unexpected ballot&quot;)
    empty
    (function Unexpected_ballot -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Unexpected_ballot) ;
  (* Unauthorized ballot *)
  register_error_kind
    `Branch
    ~id:&quot;unauthorized_ballot&quot;
    ~title:&quot;Unauthorized ballot&quot;
    ~description:
      &quot;The delegate provided for the ballot is not in the voting listings.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Unauthorized ballot&quot;)
    empty
    (function Unauthorized_ballot -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Unauthorized_ballot) ;
  (* Too many proposals *)
  register_error_kind
    `Branch
    ~id:&quot;too_many_proposals&quot;
    ~title:&quot;Too many proposals&quot;
    ~description:
      &quot;The delegate reached the maximum number of allowed proposals.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Too many proposals&quot;)
    empty
    (function Too_many_proposals -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Too_many_proposals) ;
  (* Empty proposal *)
  register_error_kind
    `Branch
    ~id:&quot;empty_proposal&quot;
    ~title:&quot;Empty proposal&quot;
    ~description:&quot;Proposal lists cannot be empty.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Empty proposal&quot;)
    empty
    (function Empty_proposal -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Empty_proposal)</abbr>

(* @return [true] if [List.length l] &gt; [n] w/o computing length *)
let rec longer_than l n =
  if Compare.Int.(n &lt; 0) then <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
  else
    match l with
    | [] -&gt;
        false
    | _ :: rest -&gt;
        if Compare.Int.(n = 0) then true
        else (* n &gt; 0 *)
          longer_than rest (n - 1)

let record_proposals ctxt delegate proposals =
  (match proposals with [] -&gt; fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Empty_proposal</abbr> | _ :: _ -&gt; return_unit)
  &gt;&gt;=? fun () -&gt;
  Vote.get_current_period_kind ctxt
  &gt;&gt;=? function
  | Proposal -&gt;
      Vote.in_listings ctxt delegate
      &gt;&gt;= fun in_listings -&gt;
      if in_listings then
        Vote.recorded_proposal_count_for_delegate ctxt delegate
        &gt;&gt;=? fun count -&gt;
        fail_when
          (longer_than proposals (Constants.max_proposals_per_delegate - count))
          <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Too_many_proposals</abbr>
        &gt;&gt;=? fun () -&gt;
        fold_left_s
          (fun ctxt proposal -&gt; Vote.record_proposal ctxt proposal delegate)
          ctxt
          proposals
        &gt;&gt;=? fun ctxt -&gt; return ctxt
      else fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Unauthorized_proposal</abbr>
  | Testing_vote | Testing | Promotion_vote -&gt;
      fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Unexpected_proposal</abbr>

let record_ballot ctxt delegate proposal ballot =
  Vote.get_current_period_kind ctxt
  &gt;&gt;=? function
  | Testing_vote | Promotion_vote -&gt;
      Vote.get_current_proposal ctxt
      &gt;&gt;=? fun current_proposal -&gt;
      fail_unless
        (Protocol_hash.equal proposal current_proposal)
        <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_proposal</abbr>
      &gt;&gt;=? fun () -&gt;
      Vote.has_recorded_ballot ctxt delegate
      &gt;&gt;= fun has_ballot -&gt;
      fail_when has_ballot <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Unauthorized_ballot</abbr>
      &gt;&gt;=? fun () -&gt;
      Vote.in_listings ctxt delegate
      &gt;&gt;= fun in_listings -&gt;
      if in_listings then Vote.record_ballot ctxt delegate ballot
      else fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Unauthorized_ballot</abbr>
  | Testing | Proposal -&gt;
      fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Unexpected_ballot</abbr>

let last_of_a_voting_period ctxt l =
  Compare.Int32.(
    Int32.succ l.Level.voting_period_position
    = Constants.blocks_per_voting_period ctxt)

let may_start_new_voting_period ctxt =
  let level = Level.current ctxt in
  if last_of_a_voting_period ctxt level then start_new_voting_period ctxt
  else return ctxt
</pre>
  </div>
  <div class="col-md-6">
    <a href="#amendment.ml"><code>Amendment.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.

Import Alpha_context.

Definition select_winning_proposal (ctxt : Alpha_context.context)
  : Lwt.t
    (Error_monad.tzresult
      (option (|Protocol_hash|).(S.HASH.Map).(S.INDEXES_Map.key))) :=
  let=? proposals := Alpha_context.Vote.get_proposals ctxt in
  let merge {A : Set}
    (proposal : A) (vote : (|Compare.Int32|).(Compare.S.t))
    (winners : option (list A * (|Compare.Int32|).(Compare.S.t)))
    : option (list A * (|Compare.Int32|).(Compare.S.t)) :=
    match winners with
    | None =&gt; Some ([ proposal ], vote)
    | (Some (winners, winners_vote)) as previous =&gt;
      if (|Compare.Int32|).(Compare.S.op_eq) vote winners_vote then
        Some ((cons proposal winners), winners_vote)
      else
        if (|Compare.Int32|).(Compare.S.op_gt) vote winners_vote then
          Some ([ proposal ], vote)
        else
          previous
    end in
  match (|Protocol_hash|).(S.HASH.Map).(S.INDEXES_Map.fold) merge proposals None
    with
  | Some (cons proposal [], vote) =&gt;
    let=? max_vote := Alpha_context.Vote.listing_size ctxt in
    let min_proposal_quorum := Alpha_context.Constants.min_proposal_quorum ctxt
      in
    let min_vote_to_pass :=
      Int32.div (Int32.mul min_proposal_quorum max_vote)
        (* ‚ùå Constant of type int32 is converted to int *)
        10000 in
    if (|Compare.Int32|).(Compare.S.op_gteq) vote min_vote_to_pass then
      Error_monad.return_some proposal
    else
      Error_monad.return_none
  | _ =&gt; Error_monad.return_none
  end.

Definition check_approval_and_update_participation_ema
  (ctxt : Alpha_context.context)
  : Lwt.t (Error_monad.tzresult (Alpha_context.context * bool)) :=
  let=? ballots := Alpha_context.Vote.get_ballots ctxt in
  let=? maximum_vote := Alpha_context.Vote.listing_size ctxt in
  let=? participation_ema := Alpha_context.Vote.get_participation_ema ctxt in
  let=? expected_quorum := Alpha_context.Vote.get_current_quorum ctxt in
  let casted_votes :=
    Int32.add ballots.(Alpha_context.Vote.ballots.yay)
      ballots.(Alpha_context.Vote.ballots.nay) in
  let all_votes :=
    Int32.add casted_votes ballots.(Alpha_context.Vote.ballots.pass) in
  let supermajority :=
    Int32.div
      (Int32.mul
        (* ‚ùå Constant of type int32 is converted to int *)
        8 casted_votes)
      (* ‚ùå Constant of type int32 is converted to int *)
      10 in
  let participation :=
    Int64.to_int32
      (Int64.div
        (Int64.mul (Int64.of_int32 all_votes)
          (* ‚ùå Constant of type int64 is converted to int *)
          10000) (Int64.of_int32 maximum_vote)) in
  let outcome :=
    Pervasives.op_andand
      ((|Compare.Int32|).(Compare.S.op_gteq) participation expected_quorum)
      ((|Compare.Int32|).(Compare.S.op_gteq)
        ballots.(Alpha_context.Vote.ballots.yay) supermajority) in
  let new_participation_ema :=
    Int32.div
      (Int32.add
        (Int32.mul
          (* ‚ùå Constant of type int32 is converted to int *)
          8 participation_ema)
        (Int32.mul
          (* ‚ùå Constant of type int32 is converted to int *)
          2 participation))
      (* ‚ùå Constant of type int32 is converted to int *)
      10 in
  let=? ctxt :=
    Alpha_context.Vote.set_participation_ema ctxt new_participation_ema in
  Error_monad.__return (ctxt, outcome).

Definition start_new_voting_period (ctxt : Alpha_context.context)
  : Lwt.t (Error_monad.tzresult Alpha_context.context) :=
  let=? function_parameter := Alpha_context.Vote.get_current_period_kind ctxt in
  match function_parameter with
  | Alpha_context.Voting_period.Proposal =&gt;
    let=? proposal := select_winning_proposal ctxt in
    let= ctxt := Alpha_context.Vote.clear_proposals ctxt in
    let=? ctxt := Alpha_context.Vote.clear_listings ctxt in
    match proposal with
    | None =&gt;
      let=? ctxt := Alpha_context.Vote.freeze_listings ctxt in
      Error_monad.__return ctxt
    | Some proposal =&gt;
      let=? ctxt := Alpha_context.Vote.init_current_proposal ctxt proposal in
      let=? ctxt := Alpha_context.Vote.freeze_listings ctxt in
      let=? ctxt :=
        Alpha_context.Vote.set_current_period_kind ctxt
          Alpha_context.Voting_period.Testing_vote in
      Error_monad.__return ctxt
    end
  | Alpha_context.Voting_period.Testing_vote =&gt;
    let=? '(ctxt, approved) := check_approval_and_update_participation_ema ctxt
      in
    let= ctxt := Alpha_context.Vote.clear_ballots ctxt in
    let=? ctxt := Alpha_context.Vote.clear_listings ctxt in
    if approved then
      let expiration :=
        Time.add (Alpha_context.Timestamp.current ctxt)
          (Alpha_context.Constants.test_chain_duration ctxt) in
      let=? proposal := Alpha_context.Vote.get_current_proposal ctxt in
      let= ctxt := Alpha_context.fork_test_chain ctxt proposal expiration in
      let=? ctxt :=
        Alpha_context.Vote.set_current_period_kind ctxt
          Alpha_context.Voting_period.Testing in
      Error_monad.__return ctxt
    else
      let=? ctxt := Alpha_context.Vote.clear_current_proposal ctxt in
      let=? ctxt := Alpha_context.Vote.freeze_listings ctxt in
      let=? ctxt :=
        Alpha_context.Vote.set_current_period_kind ctxt
          Alpha_context.Voting_period.Proposal in
      Error_monad.__return ctxt
  | Alpha_context.Voting_period.Testing =&gt;
    let=? ctxt := Alpha_context.Vote.freeze_listings ctxt in
    let=? ctxt :=
      Alpha_context.Vote.set_current_period_kind ctxt
        Alpha_context.Voting_period.Promotion_vote in
    Error_monad.__return ctxt
  | Alpha_context.Voting_period.Promotion_vote =&gt;
    let=? '(ctxt, approved) := check_approval_and_update_participation_ema ctxt
      in
    let=? ctxt :=
      if approved then
        let=? proposal := Alpha_context.Vote.get_current_proposal ctxt in
        let= ctxt := Alpha_context.activate ctxt proposal in
        Error_monad.__return ctxt
      else
        Error_monad.__return ctxt in
    let= ctxt := Alpha_context.Vote.clear_ballots ctxt in
    let=? ctxt := Alpha_context.Vote.clear_listings ctxt in
    let=? ctxt := Alpha_context.Vote.clear_current_proposal ctxt in
    let=? ctxt := Alpha_context.Vote.freeze_listings ctxt in
    let=? ctxt :=
      Alpha_context.Vote.set_current_period_kind ctxt
        Alpha_context.Voting_period.Proposal in
    Error_monad.__return ctxt
  end.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)

Fixpoint longer_than {A : Set} (l : list A) (n : (|Compare.Int|).(Compare.S.t))
  : bool :=
  if (|Compare.Int|).(Compare.S.op_lt) n 0 then
    (* ‚ùå Assert instruction is not handled. *)
    assert bool false
  else
    match l with
    | [] =&gt; false
    | cons _ rest =&gt;
      if (|Compare.Int|).(Compare.S.op_eq) n 0 then
        true
      else
        longer_than rest (Pervasives.op_minus n 1)
    end.

Definition record_proposals
  (ctxt : Alpha_context.context) (delegate : Alpha_context.public_key_hash)
  (proposals : list (|Protocol_hash|).(S.HASH.t))
  : Lwt.t (Error_monad.tzresult Alpha_context.context) :=
  let=? '_ :=
    match proposals with
    | [] =&gt; Error_monad.fail extensible_type_value
    | cons _ _ =&gt; Error_monad.return_unit
    end in
  let=? function_parameter := Alpha_context.Vote.get_current_period_kind ctxt in
  match function_parameter with
  | Alpha_context.Voting_period.Proposal =&gt;
    let= in_listings := Alpha_context.Vote.in_listings ctxt delegate in
    if in_listings then
      let=? count :=
        Alpha_context.Vote.recorded_proposal_count_for_delegate ctxt delegate in
      let=? '_ :=
        Error_monad.fail_when
          (longer_than proposals
            (Pervasives.op_minus
              Alpha_context.Constants.max_proposals_per_delegate count))
          extensible_type_value in
      let=? ctxt :=
        Error_monad.fold_left_s
          (fun ctxt =&gt;
            fun proposal =&gt;
              Alpha_context.Vote.record_proposal ctxt proposal delegate) ctxt
          proposals in
      Error_monad.__return ctxt
    else
      Error_monad.fail extensible_type_value
  |
    (Alpha_context.Voting_period.Testing_vote |
    Alpha_context.Voting_period.Testing |
    Alpha_context.Voting_period.Promotion_vote) =&gt;
    Error_monad.fail extensible_type_value
  end.

Definition record_ballot
  (ctxt : Alpha_context.context) (delegate : Alpha_context.public_key_hash)
  (proposal : (|Protocol_hash|).(S.HASH.t)) (ballot : Alpha_context.Vote.ballot)
  : Lwt.t (Error_monad.tzresult Alpha_context.context) :=
  let=? function_parameter := Alpha_context.Vote.get_current_period_kind ctxt in
  match function_parameter with
  |
    (Alpha_context.Voting_period.Testing_vote |
    Alpha_context.Voting_period.Promotion_vote) =&gt;
    let=? current_proposal := Alpha_context.Vote.get_current_proposal ctxt in
    let=? '_ :=
      Error_monad.fail_unless
        ((|Protocol_hash|).(S.HASH.equal) proposal current_proposal)
        extensible_type_value in
    let= has_ballot := Alpha_context.Vote.has_recorded_ballot ctxt delegate in
    let=? '_ := Error_monad.fail_when has_ballot extensible_type_value in
    let= in_listings := Alpha_context.Vote.in_listings ctxt delegate in
    if in_listings then
      Alpha_context.Vote.record_ballot ctxt delegate ballot
    else
      Error_monad.fail extensible_type_value
  | (Alpha_context.Voting_period.Testing | Alpha_context.Voting_period.Proposal)
    =&gt; Error_monad.fail extensible_type_value
  end.

Definition last_of_a_voting_period
  (ctxt : Alpha_context.context) (l : Alpha_context.Level.t) : bool :=
  (|Compare.Int32|).(Compare.S.op_eq)
    (Int32.succ l.(Alpha_context.Level.t.voting_period_position))
    (Alpha_context.Constants.blocks_per_voting_period ctxt).

Definition may_start_new_voting_period (ctxt : Alpha_context.context)
  : Lwt.t (Error_monad.tzresult Alpha_context.context) :=
  let level := Alpha_context.Level.current ctxt in
  if last_of_a_voting_period ctxt level then
    start_new_voting_period ctxt
  else
    Error_monad.__return ctxt.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="amendment.mli">
  <div style="margin: 20px;">
    <h3>Amendment_mli</h3>
    <ul>
      <li>OCaml size: 75 lines</li>
      <li>Coq size: 31 lines (-59% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#amendment.mli"><code>amendment.mli</code></a>&nbsp;<span class="label label-warning">2 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(**
   Only delegates with at least one roll take part in the amendment procedure.
   It works as follows:
   - Proposal period: delegates can submit protocol amendment proposals using
     the proposal operation. At the end of a proposal period, the proposal with
     most supporters is selected and we move to a testing_vote period.
     If there are no proposals, or a tie between proposals, a new proposal
     period starts.
   - Testing_vote period: delegates can cast votes to test or not the winning
     proposal using the ballot operation.
     At the end of a testing_vote period if participation reaches the quorum
     and the proposal has a supermajority in favor, we proceed to a testing
     period. Otherwise we go back to a proposal period.
     In any case, if there is enough participation the quorum is updated.
   - Testing period: a test chain is forked for the lengh of the period.
     At the end of a testing period we move to a promotion_vote period.
   - Promotion_vote period: delegates can cast votes to promote or not the
     tested proposal using the ballot operation.
     At the end of a promotion_vote period if participation reaches the quorum
     and the tested proposal has a supermajority in favor, it is activated as
     the new protocol. Otherwise we go back to a proposal period.
     In any case, if there is enough participation the quorum is updated.
*)

open Alpha_context

(** If at the end of a voting period, moves to the next one following
    the state machine of the amendment procedure. *)
val may_start_new_voting_period : context -&gt; context tzresult Lwt.t

<abbr class="mark-warning" title="Extensible types are not handled.">type error +=
  | Unexpected_proposal
  | Unauthorized_proposal
  | Too_many_proposals
  | Empty_proposal</abbr>

(** Records a list of proposals for a delegate.
    @raise Unexpected_proposal if [ctxt] is not in a proposal period.
    @raise Unauthorized_proposal if [delegate] is not in the listing. *)
val record_proposals :
  context -&gt; public_key_hash -&gt; Protocol_hash.t list -&gt; context tzresult Lwt.t

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Invalid_proposal | Unexpected_ballot | Unauthorized_ballot</abbr>

val record_ballot :
  context -&gt;
  public_key_hash -&gt;
  Protocol_hash.t -&gt;
  Vote.ballot -&gt;
  context tzresult Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#amendment.mli"><code>Amendment_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.

Import Alpha_context.

Parameter may_start_new_voting_period :
  Alpha_context.context -&gt; Lwt.t (Error_monad.tzresult Alpha_context.context).

(* extensible_type_definition `error` *)

Parameter record_proposals :
  Alpha_context.context -&gt; Alpha_context.public_key_hash -&gt;
  list (|Protocol_hash|).(S.HASH.t) -&gt;
  Lwt.t (Error_monad.tzresult Alpha_context.context).

(* extensible_type_definition `error` *)

Parameter record_ballot :
  Alpha_context.context -&gt; Alpha_context.public_key_hash -&gt;
  (|Protocol_hash|).(S.HASH.t) -&gt; Alpha_context.Vote.ballot -&gt;
  Lwt.t (Error_monad.tzresult Alpha_context.context).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="apply.ml">
  <div style="margin: 20px;">
    <h3>Apply</h3>
    <ul>
      <li>OCaml size: 1493 lines</li>
      <li>Coq size: 1359 lines (-9% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#apply.ml"><code>apply.ml</code></a>&nbsp;<span class="label label-warning">51 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Tezos Protocol Implementation - Main Entry Points *)

open Alpha_context

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Wrong_voting_period of Voting_period.t * Voting_period.t</abbr>

(* `Temporary *)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Wrong_endorsement_predecessor of Block_hash.t * Block_hash.t</abbr>

(* `Temporary *)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Duplicate_endorsement of Signature.Public_key_hash.t</abbr>

(* `Branch *)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Invalid_endorsement_level</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Invalid_commitment of {expected : bool}</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Internal_operation_replay of packed_internal_operation</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Invalid_double_endorsement_evidence</abbr> (* `Permanent *)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | Inconsistent_double_endorsement_evidence of {
      delegate1 : Signature.Public_key_hash.t;
      delegate2 : Signature.Public_key_hash.t;
    }</abbr>

(* `Permanent *)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Unrequired_double_endorsement_evidence</abbr> (* `Branch*)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | Too_early_double_endorsement_evidence of {
      level : Raw_level.t;
      current : Raw_level.t;
    }</abbr>

(* `Temporary *)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | Outdated_double_endorsement_evidence of {
      level : Raw_level.t;
      last : Raw_level.t;
    }</abbr>

(* `Permanent *)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | Invalid_double_baking_evidence of {
      hash1 : Block_hash.t;
      level1 : Int32.t;
      hash2 : Block_hash.t;
      level2 : Int32.t;
    }</abbr>

(* `Permanent *)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | Inconsistent_double_baking_evidence of {
      delegate1 : Signature.Public_key_hash.t;
      delegate2 : Signature.Public_key_hash.t;
    }</abbr>

(* `Permanent *)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Unrequired_double_baking_evidence</abbr> (* `Branch*)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | Too_early_double_baking_evidence of {
      level : Raw_level.t;
      current : Raw_level.t;
    }</abbr>

(* `Temporary *)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | Outdated_double_baking_evidence of {
      level : Raw_level.t;
      last : Raw_level.t;
    }</abbr>

(* `Permanent *)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Invalid_activation of {pkh : Ed25519.Public_key_hash.t}</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Multiple_revelation</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Gas_quota_exceeded_init_deserialize</abbr> (* Permanent *)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | Not_enough_endorsements_for_priority of {
      required : int;
      priority : int;
      endorsements : int;
      timestamp : Time.t;
    }</abbr>

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  register_error_kind
    `Temporary
    ~id:&quot;operation.wrong_endorsement_predecessor&quot;
    ~title:&quot;Wrong endorsement predecessor&quot;
    ~description:
      &quot;Trying to include an endorsement in a block that is not the successor \
       of the endorsed one&quot;
    ~pp:(fun ppf (e, p) -&gt;
      Format.fprintf
        ppf
        &quot;Wrong predecessor %a, expected %a&quot;
        Block_hash.pp
        p
        Block_hash.pp
        e)
    Data_encoding.(
      obj2
        (req &quot;expected&quot; Block_hash.encoding)
        (req &quot;provided&quot; Block_hash.encoding))
    (function
      | Wrong_endorsement_predecessor (e, p) -&gt; Some (e, p) | _ -&gt; None)
    (fun (e, p) -&gt; Wrong_endorsement_predecessor (e, p)) ;
  register_error_kind
    `Temporary
    ~id:&quot;operation.wrong_voting_period&quot;
    ~title:&quot;Wrong voting period&quot;
    ~description:
      &quot;Trying to onclude a proposal or ballot meant for another voting period&quot;
    ~pp:(fun ppf (e, p) -&gt;
      Format.fprintf
        ppf
        &quot;Wrong voting period %a, current is %a&quot;
        Voting_period.pp
        p
        Voting_period.pp
        e)
    Data_encoding.(
      obj2
        (req &quot;current&quot; Voting_period.encoding)
        (req &quot;provided&quot; Voting_period.encoding))
    (function Wrong_voting_period (e, p) -&gt; Some (e, p) | _ -&gt; None)
    (fun (e, p) -&gt; Wrong_voting_period (e, p)) ;
  register_error_kind
    `Branch
    ~id:&quot;operation.duplicate_endorsement&quot;
    ~title:&quot;Duplicate endorsement&quot;
    ~description:&quot;Two endorsements received from same delegate&quot;
    ~pp:(fun ppf k -&gt;
      Format.fprintf
        ppf
        &quot;Duplicate endorsement from delegate %a (possible replay attack).&quot;
        Signature.Public_key_hash.pp_short
        k)
    Data_encoding.(obj1 (req &quot;delegate&quot; Signature.Public_key_hash.encoding))
    (function Duplicate_endorsement k -&gt; Some k | _ -&gt; None)
    (fun k -&gt; Duplicate_endorsement k) ;
  register_error_kind
    `Temporary
    ~id:&quot;operation.invalid_endorsement_level&quot;
    ~title:&quot;Unexpected level in endorsement&quot;
    ~description:
      &quot;The level of an endorsement is inconsistent with the  provided block \
       hash.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Unexpected level in endorsement.&quot;)
    Data_encoding.unit
    (function Invalid_endorsement_level -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Invalid_endorsement_level) ;
  register_error_kind
    `Permanent
    ~id:&quot;block.invalid_commitment&quot;
    ~title:&quot;Invalid commitment in block header&quot;
    ~description:&quot;The block header has invalid commitment.&quot;
    ~pp:(fun ppf expected -&gt;
      if expected then
        Format.fprintf ppf &quot;Missing seed's nonce commitment in block header.&quot;
      else
        Format.fprintf
          ppf
          &quot;Unexpected seed's nonce commitment in block header.&quot;)
    Data_encoding.(obj1 (req &quot;expected&quot; bool))
    (function Invalid_commitment {expected} -&gt; Some expected | _ -&gt; None)
    (fun expected -&gt; Invalid_commitment {expected}) ;
  register_error_kind
    `Permanent
    ~id:&quot;internal_operation_replay&quot;
    ~title:&quot;Internal operation replay&quot;
    ~description:&quot;An internal operation was emitted twice by a script&quot;
    ~pp:(fun ppf (Internal_operation {nonce; _}) -&gt;
      Format.fprintf
        ppf
        &quot;Internal operation %d was emitted twice by a script&quot;
        nonce)
    Operation.internal_operation_encoding
    (function Internal_operation_replay op -&gt; Some op | _ -&gt; None)
    (fun op -&gt; Internal_operation_replay op) ;
  register_error_kind
    `Permanent
    ~id:&quot;block.invalid_double_endorsement_evidence&quot;
    ~title:&quot;Invalid double endorsement evidence&quot;
    ~description:&quot;A double-endorsement evidence is malformed&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf ppf &quot;Malformed double-endorsement evidence&quot;)
    Data_encoding.empty
    (function Invalid_double_endorsement_evidence -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Invalid_double_endorsement_evidence) ;
  register_error_kind
    `Permanent
    ~id:&quot;block.inconsistent_double_endorsement_evidence&quot;
    ~title:&quot;Inconsistent double endorsement evidence&quot;
    ~description:
      &quot;A double-endorsement evidence is inconsistent  (two distinct delegates)&quot;
    ~pp:(fun ppf (delegate1, delegate2) -&gt;
      Format.fprintf
        ppf
        &quot;Inconsistent double-endorsement evidence  (distinct delegate: %a and \
         %a)&quot;
        Signature.Public_key_hash.pp_short
        delegate1
        Signature.Public_key_hash.pp_short
        delegate2)
    Data_encoding.(
      obj2
        (req &quot;delegate1&quot; Signature.Public_key_hash.encoding)
        (req &quot;delegate2&quot; Signature.Public_key_hash.encoding))
    (function
      | Inconsistent_double_endorsement_evidence {delegate1; delegate2} -&gt;
          Some (delegate1, delegate2)
      | _ -&gt;
          None)
    (fun (delegate1, delegate2) -&gt;
      Inconsistent_double_endorsement_evidence {delegate1; delegate2}) ;
  register_error_kind
    `Branch
    ~id:&quot;block.unrequired_double_endorsement_evidence&quot;
    ~title:&quot;Unrequired double endorsement evidence&quot;
    ~description:&quot;A double-endorsement evidence is unrequired&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf
        ppf
        &quot;A valid double-endorsement operation cannot  be applied: the \
         associated delegate  has previously been denunciated in this cycle.&quot;)
    Data_encoding.empty
    (function Unrequired_double_endorsement_evidence -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Unrequired_double_endorsement_evidence) ;
  register_error_kind
    `Temporary
    ~id:&quot;block.too_early_double_endorsement_evidence&quot;
    ~title:&quot;Too early double endorsement evidence&quot;
    ~description:&quot;A double-endorsement evidence is in the future&quot;
    ~pp:(fun ppf (level, current) -&gt;
      Format.fprintf
        ppf
        &quot;A double-endorsement evidence is in the future  (current level: %a, \
         endorsement level: %a)&quot;
        Raw_level.pp
        current
        Raw_level.pp
        level)
    Data_encoding.(
      obj2 (req &quot;level&quot; Raw_level.encoding) (req &quot;current&quot; Raw_level.encoding))
    (function
      | Too_early_double_endorsement_evidence {level; current} -&gt;
          Some (level, current)
      | _ -&gt;
          None)
    (fun (level, current) -&gt;
      Too_early_double_endorsement_evidence {level; current}) ;
  register_error_kind
    `Permanent
    ~id:&quot;block.outdated_double_endorsement_evidence&quot;
    ~title:&quot;Outdated double endorsement evidence&quot;
    ~description:&quot;A double-endorsement evidence is outdated.&quot;
    ~pp:(fun ppf (level, last) -&gt;
      Format.fprintf
        ppf
        &quot;A double-endorsement evidence is outdated  (last acceptable level: \
         %a, endorsement level: %a)&quot;
        Raw_level.pp
        last
        Raw_level.pp
        level)
    Data_encoding.(
      obj2 (req &quot;level&quot; Raw_level.encoding) (req &quot;last&quot; Raw_level.encoding))
    (function
      | Outdated_double_endorsement_evidence {level; last} -&gt;
          Some (level, last)
      | _ -&gt;
          None)
    (fun (level, last) -&gt; Outdated_double_endorsement_evidence {level; last}) ;
  register_error_kind
    `Permanent
    ~id:&quot;block.invalid_double_baking_evidence&quot;
    ~title:&quot;Invalid double baking evidence&quot;
    ~description:
      &quot;A double-baking evidence is inconsistent  (two distinct level)&quot;
    ~pp:(fun ppf (hash1, level1, hash2, level2) -&gt;
      Format.fprintf
        ppf
        &quot;Invalid double-baking evidence (hash: %a and %a, levels: %ld and %ld)&quot;
        Block_hash.pp
        hash1
        Block_hash.pp
        hash2
        level1
        level2)
    Data_encoding.(
      obj4
        (req &quot;hash1&quot; Block_hash.encoding)
        (req &quot;level1&quot; int32)
        (req &quot;hash2&quot; Block_hash.encoding)
        (req &quot;level2&quot; int32))
    (function
      | Invalid_double_baking_evidence {hash1; level1; hash2; level2} -&gt;
          Some (hash1, level1, hash2, level2)
      | _ -&gt;
          None)
    (fun (hash1, level1, hash2, level2) -&gt;
      Invalid_double_baking_evidence {hash1; level1; hash2; level2}) ;
  register_error_kind
    `Permanent
    ~id:&quot;block.inconsistent_double_baking_evidence&quot;
    ~title:&quot;Inconsistent double baking evidence&quot;
    ~description:
      &quot;A double-baking evidence is inconsistent  (two distinct delegates)&quot;
    ~pp:(fun ppf (delegate1, delegate2) -&gt;
      Format.fprintf
        ppf
        &quot;Inconsistent double-baking evidence  (distinct delegate: %a and %a)&quot;
        Signature.Public_key_hash.pp_short
        delegate1
        Signature.Public_key_hash.pp_short
        delegate2)
    Data_encoding.(
      obj2
        (req &quot;delegate1&quot; Signature.Public_key_hash.encoding)
        (req &quot;delegate2&quot; Signature.Public_key_hash.encoding))
    (function
      | Inconsistent_double_baking_evidence {delegate1; delegate2} -&gt;
          Some (delegate1, delegate2)
      | _ -&gt;
          None)
    (fun (delegate1, delegate2) -&gt;
      Inconsistent_double_baking_evidence {delegate1; delegate2}) ;
  register_error_kind
    `Branch
    ~id:&quot;block.unrequired_double_baking_evidence&quot;
    ~title:&quot;Unrequired double baking evidence&quot;
    ~description:&quot;A double-baking evidence is unrequired&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf
        ppf
        &quot;A valid double-baking operation cannot  be applied: the associated \
         delegate  has previously been denunciated in this cycle.&quot;)
    Data_encoding.empty
    (function Unrequired_double_baking_evidence -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Unrequired_double_baking_evidence) ;
  register_error_kind
    `Temporary
    ~id:&quot;block.too_early_double_baking_evidence&quot;
    ~title:&quot;Too early double baking evidence&quot;
    ~description:&quot;A double-baking evidence is in the future&quot;
    ~pp:(fun ppf (level, current) -&gt;
      Format.fprintf
        ppf
        &quot;A double-baking evidence is in the future  (current level: %a, \
         baking level: %a)&quot;
        Raw_level.pp
        current
        Raw_level.pp
        level)
    Data_encoding.(
      obj2 (req &quot;level&quot; Raw_level.encoding) (req &quot;current&quot; Raw_level.encoding))
    (function
      | Too_early_double_baking_evidence {level; current} -&gt;
          Some (level, current)
      | _ -&gt;
          None)
    (fun (level, current) -&gt; Too_early_double_baking_evidence {level; current}) ;
  register_error_kind
    `Permanent
    ~id:&quot;block.outdated_double_baking_evidence&quot;
    ~title:&quot;Outdated double baking evidence&quot;
    ~description:&quot;A double-baking evidence is outdated.&quot;
    ~pp:(fun ppf (level, last) -&gt;
      Format.fprintf
        ppf
        &quot;A double-baking evidence is outdated  (last acceptable level: %a, \
         baking level: %a)&quot;
        Raw_level.pp
        last
        Raw_level.pp
        level)
    Data_encoding.(
      obj2 (req &quot;level&quot; Raw_level.encoding) (req &quot;last&quot; Raw_level.encoding))
    (function
      | Outdated_double_baking_evidence {level; last} -&gt;
          Some (level, last)
      | _ -&gt;
          None)
    (fun (level, last) -&gt; Outdated_double_baking_evidence {level; last}) ;
  register_error_kind
    `Permanent
    ~id:&quot;operation.invalid_activation&quot;
    ~title:&quot;Invalid activation&quot;
    ~description:
      &quot;The given key and secret do not correspond to any existing \
       preallocated contract&quot;
    ~pp:(fun ppf pkh -&gt;
      Format.fprintf
        ppf
        &quot;Invalid activation. The public key %a does not match any commitment.&quot;
        Ed25519.Public_key_hash.pp
        pkh)
    Data_encoding.(obj1 (req &quot;pkh&quot; Ed25519.Public_key_hash.encoding))
    (function Invalid_activation {pkh} -&gt; Some pkh | _ -&gt; None)
    (fun pkh -&gt; Invalid_activation {pkh}) ;
  register_error_kind
    `Permanent
    ~id:&quot;block.multiple_revelation&quot;
    ~title:&quot;Multiple revelations were included in a manager operation&quot;
    ~description:
      &quot;A manager operation should not contain more than one revelation&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf
        ppf
        &quot;Multiple revelations were included in a manager operation&quot;)
    Data_encoding.empty
    (function Multiple_revelation -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Multiple_revelation) ;
  register_error_kind
    `Permanent
    ~id:&quot;gas_exhausted.init_deserialize&quot;
    ~title:&quot;Not enough gas for initial deserialization of script expresions&quot;
    ~description:
      &quot;Gas limit was not high enough to deserialize the transaction \
       parameters or origination script code or initial storage, making the \
       operation impossible to parse within the provided gas bounds.&quot;
    Data_encoding.empty
    (function Gas_quota_exceeded_init_deserialize -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Gas_quota_exceeded_init_deserialize) ;
  register_error_kind
    `Permanent
    ~id:&quot;operation.not_enought_endorsements_for_priority&quot;
    ~title:&quot;Not enough endorsements for priority&quot;
    ~description:
      &quot;The block being validated does not include the required minimum number \
       of endorsements for this priority.&quot;
    ~pp:(fun ppf (required, endorsements, priority, timestamp) -&gt;
      Format.fprintf
        ppf
        &quot;Wrong number of endorsements (%i) for priority (%i), %i are expected \
         at %a&quot;
        endorsements
        priority
        required
        Time.pp_hum
        timestamp)
    Data_encoding.(
      obj4
        (req &quot;required&quot; int31)
        (req &quot;endorsements&quot; int31)
        (req &quot;priority&quot; int31)
        (req &quot;timestamp&quot; Time.encoding))
    (function
      | Not_enough_endorsements_for_priority
          {required; endorsements; priority; timestamp} -&gt;
          Some (required, endorsements, priority, timestamp)
      | _ -&gt;
          None)
    (fun (required, endorsements, priority, timestamp) -&gt;
      Not_enough_endorsements_for_priority
        {required; endorsements; priority; timestamp})</abbr>

open Apply_results

let apply_manager_operation_content :
    type kind.
    Alpha_context.t -&gt;
    Script_ir_translator.unparsing_mode -&gt;
    payer:Contract.t -&gt;
    source:Contract.t -&gt;
    chain_id:Chain_id.t -&gt;
    internal:bool -&gt;
    kind manager_operation -&gt;
    ( context
    * kind successful_manager_operation_result
    * packed_internal_operation list )
    tzresult
    Lwt.t =
 fun ctxt mode ~payer ~source ~chain_id ~internal operation -&gt;
  let before_operation =
    (* This context is not used for backtracking. Only to compute
         gas consumption and originations for the operation result. *)
    ctxt
  in
  Contract.must_exist ctxt source
  &gt;&gt;=? fun () -&gt;
  Lwt.return (Gas.consume ctxt Michelson_v1_gas.Cost_of.manager_operation)
  &gt;&gt;=? fun ctxt -&gt;
  match operation with
  | Reveal _ -&gt;
      return
        (* No-op: action already performed by `precheck_manager_contents`. *)
        ( ctxt,
          ( Reveal_result
              {consumed_gas = Gas.consumed ~since:before_operation ~until:ctxt}
            : kind successful_manager_operation_result ),
          [] )
  | Transaction {amount; parameters; destination; entrypoint} -&gt; (
      Contract.spend ctxt source amount
      &gt;&gt;=? fun ctxt -&gt;
      ( match Contract.is_implicit destination with
      | None -&gt;
          return (ctxt, [], false)
      | Some _ -&gt; (
          Contract.allocated ctxt destination
          &gt;&gt;=? function
          | true -&gt;
              return (ctxt, [], false)
          | false -&gt;
              Fees.origination_burn ctxt
              &gt;&gt;=? fun (ctxt, origination_burn) -&gt;
              return
                ( ctxt,
                  [(Delegate.Contract payer, Delegate.Debited origination_burn)],
                  true ) ) )
      &gt;&gt;=? fun (ctxt, maybe_burn_balance_update, allocated_destination_contract)
               -&gt;
      Contract.credit ctxt destination amount
      &gt;&gt;=? fun ctxt -&gt;
      Contract.get_script ctxt destination
      &gt;&gt;=? fun (ctxt, script) -&gt;
      match script with
      | None -&gt;
          ( match entrypoint with
          | &quot;default&quot; -&gt;
              return ()
          | entrypoint -&gt;
              fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Script_tc_errors.No_such_entrypoint entrypoint)</abbr> )
          &gt;&gt;=? (fun () -&gt;
                 Script.force_decode_in_context ctxt parameters
                 &gt;&gt;=? fun (arg, ctxt) -&gt;
                 (* see [note] *)
                 (* [note]: for toplevel ops, cost is nil since the
               lazy value has already been forced at precheck, so
               we compute and consume the full cost again *)
                 let cost_arg = Script.deserialized_cost arg in
                 Lwt.return (Gas.consume ctxt cost_arg)
                 &gt;&gt;=? fun ctxt -&gt;
                 match Micheline.root arg with
                 | Prim (_, D_Unit, [], _) -&gt;
                     (* Allow [Unit] parameter to non-scripted contracts. *)
                     return ctxt
                 | _ -&gt;
                     fail
                       <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Script_interpreter.Bad_contract_parameter destination)</abbr>)
          &gt;&gt;=? fun ctxt -&gt;
          let result =
            Transaction_result
              {
                storage = None;
                big_map_diff = None;
                balance_updates =
                  Delegate.cleanup_balance_updates
                    ( [ (Delegate.Contract source, Delegate.Debited amount);
                        (Contract destination, Credited amount) ]
                    @ maybe_burn_balance_update );
                originated_contracts = [];
                consumed_gas = Gas.consumed ~since:before_operation ~until:ctxt;
                storage_size = Z.zero;
                paid_storage_size_diff = Z.zero;
                allocated_destination_contract;
              }
          in
          return (ctxt, result, [])
      | Some script -&gt;
          Script.force_decode_in_context ctxt parameters
          &gt;&gt;=? fun (parameter, ctxt) -&gt;
          (* see [note] *)
          let cost_parameter = Script.deserialized_cost parameter in
          Lwt.return (Gas.consume ctxt cost_parameter)
          &gt;&gt;=? fun ctxt -&gt;
          let step_constants =
            let open Script_interpreter in
            {source; payer; self = destination; amount; chain_id}
          in
          Script_interpreter.execute_wrapper
            ctxt
            mode
            step_constants
            ~script
            ~parameter
            ~entrypoint
          &gt;&gt;=? fun {ctxt; storage; big_map_diff; operations} -&gt;
          Contract.update_script_storage ctxt destination storage big_map_diff
          &gt;&gt;=? fun ctxt -&gt;
          Fees.record_paid_storage_space ctxt destination
          &gt;&gt;=? fun (ctxt, new_size, paid_storage_size_diff, fees) -&gt;
          Contract.originated_from_current_nonce
            ~since:before_operation
            ~until:ctxt
          &gt;&gt;=? fun originated_contracts -&gt;
          let result =
            Transaction_result
              {
                storage = Some storage;
                big_map_diff;
                balance_updates =
                  Delegate.cleanup_balance_updates
                    [ (Contract payer, Debited fees);
                      (Contract source, Debited amount);
                      (Contract destination, Credited amount) ];
                originated_contracts;
                consumed_gas = Gas.consumed ~since:before_operation ~until:ctxt;
                storage_size = new_size;
                paid_storage_size_diff;
                allocated_destination_contract;
              }
          in
          return (ctxt, result, operations) )
  | Origination {delegate; script; preorigination; credit} -&gt;
      Script.force_decode_in_context ctxt script.storage
      &gt;&gt;=? fun (unparsed_storage, ctxt) -&gt;
      (* see [note] *)
      Lwt.return (Gas.consume ctxt (Script.deserialized_cost unparsed_storage))
      &gt;&gt;=? fun ctxt -&gt;
      Script.force_decode_in_context ctxt script.code
      &gt;&gt;=? fun (unparsed_code, ctxt) -&gt;
      (* see [note] *)
      Lwt.return (Gas.consume ctxt (Script.deserialized_cost unparsed_code))
      &gt;&gt;=? fun ctxt -&gt;
      Script_ir_translator.parse_script ctxt ~legacy:false script
      &gt;&gt;=? fun (Ex_script parsed_script, ctxt) -&gt;
      Script_ir_translator.collect_big_maps
        ctxt
        parsed_script.storage_type
        parsed_script.storage
      &gt;&gt;=? fun (to_duplicate, ctxt) -&gt;
      let to_update = Script_ir_translator.no_big_map_id in
      Script_ir_translator.extract_big_map_diff
        ctxt
        Optimized
        parsed_script.storage_type
        parsed_script.storage
        ~to_duplicate
        ~to_update
        ~temporary:false
      &gt;&gt;=? fun (storage, big_map_diff, ctxt) -&gt;
      Script_ir_translator.unparse_data
        ctxt
        Optimized
        parsed_script.storage_type
        storage
      &gt;&gt;=? fun (storage, ctxt) -&gt;
      let storage = Script.lazy_expr (Micheline.strip_locations storage) in
      let script = {script with storage} in
      Contract.spend ctxt source credit
      &gt;&gt;=? fun ctxt -&gt;
      ( match preorigination with
      | Some contract -&gt;
          <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert internal</abbr> ;
          (* The preorigination field is only used to early return
                 the address of an originated contract in Michelson.
                 It cannot come from the outside. *)
          return (ctxt, contract)
      | None -&gt;
          Contract.fresh_contract_from_current_nonce ctxt )
      &gt;&gt;=? fun (ctxt, contract) -&gt;
      Contract.originate
        ctxt
        contract
        ~delegate
        ~balance:credit
        ~script:(script, big_map_diff)
      &gt;&gt;=? fun ctxt -&gt;
      Fees.origination_burn ctxt
      &gt;&gt;=? fun (ctxt, origination_burn) -&gt;
      Fees.record_paid_storage_space ctxt contract
      &gt;&gt;=? fun (ctxt, size, paid_storage_size_diff, fees) -&gt;
      let result =
        Origination_result
          {
            big_map_diff;
            balance_updates =
              Delegate.cleanup_balance_updates
                [ (Contract payer, Debited fees);
                  (Contract payer, Debited origination_burn);
                  (Contract source, Debited credit);
                  (Contract contract, Credited credit) ];
            originated_contracts = [contract];
            consumed_gas = Gas.consumed ~since:before_operation ~until:ctxt;
            storage_size = size;
            paid_storage_size_diff;
          }
      in
      return (ctxt, result, [])
  | Delegation delegate -&gt;
      Delegate.set ctxt source delegate
      &gt;&gt;=? fun ctxt -&gt;
      return
        ( ctxt,
          Delegation_result
            {consumed_gas = Gas.consumed ~since:before_operation ~until:ctxt},
          [] )

type success_or_failure = Success of t | Failure

let apply_internal_manager_operations ctxt mode ~payer ~chain_id ops =
  let rec apply ctxt applied worklist =
    match worklist with
    | [] -&gt;
        Lwt.return (Success ctxt, List.rev applied)
    | Internal_operation ({source; operation; nonce} as op) :: rest -&gt; (
        ( if internal_nonce_already_recorded ctxt nonce then
          fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Internal_operation_replay (Internal_operation op))</abbr>
        else
          let ctxt = record_internal_nonce ctxt nonce in
          apply_manager_operation_content
            ctxt
            mode
            ~source
            ~payer
            ~chain_id
            ~internal:true
            operation )
        &gt;&gt;= function
        | Error errors -&gt;
            let result =
              Internal_operation_result
                (op, Failed (manager_kind op.operation, errors))
            in
            let skipped =
              List.rev_map
                (fun (Internal_operation op) -&gt;
                  Internal_operation_result
                    (op, Skipped (manager_kind op.operation)))
                rest
            in
            Lwt.return (Failure, List.rev (skipped @ (result :: applied)))
        | Ok (ctxt, result, emitted) -&gt;
            apply
              ctxt
              (Internal_operation_result (op, Applied result) :: applied)
              (rest @ emitted) )
  in
  apply ctxt [] ops

let precheck_manager_contents (type kind) ctxt chain_id raw_operation
    (op : kind Kind.manager contents) : context tzresult Lwt.t =
  match[@coq_match_with_default] op with
  | Manager_operation
      {source; fee; counter; operation; gas_limit; storage_limit} -&gt;
      Lwt.return (Gas.check_limit ctxt gas_limit)
      &gt;&gt;=? fun () -&gt;
      let ctxt = Gas.set_limit ctxt gas_limit in
      Lwt.return (Fees.check_storage_limit ctxt storage_limit)
      &gt;&gt;=? fun () -&gt;
      Contract.must_be_allocated ctxt (Contract.implicit_contract source)
      &gt;&gt;=? fun () -&gt;
      Contract.check_counter_increment ctxt source counter
      &gt;&gt;=? fun () -&gt;
      ( match operation with
      | Reveal pk -&gt;
          Contract.reveal_manager_key ctxt source pk
      | Transaction {parameters; _} -&gt;
          (* Fail quickly if not enough gas for minimal deserialization cost *)
          Lwt.return
          @@ record_trace <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Gas_quota_exceeded_init_deserialize</abbr>
          @@ Gas.check_enough ctxt (Script.minimal_deserialize_cost parameters)
          &gt;&gt;=? fun () -&gt;
          (* Fail if not enough gas for complete deserialization cost *)
          trace <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Gas_quota_exceeded_init_deserialize</abbr>
          @@ Script.force_decode_in_context ctxt parameters
          &gt;&gt;|? fun (_arg, ctxt) -&gt; ctxt
      | Origination {script; _} -&gt;
          (* Fail quickly if not enough gas for minimal deserialization cost *)
          Lwt.return
          @@ record_trace <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Gas_quota_exceeded_init_deserialize</abbr>
          @@ ( Gas.consume ctxt (Script.minimal_deserialize_cost script.code)
             &gt;&gt;? fun ctxt -&gt;
             Gas.check_enough
               ctxt
               (Script.minimal_deserialize_cost script.storage) )
          &gt;&gt;=? fun () -&gt;
          (* Fail if not enough gas for complete deserialization cost *)
          trace <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Gas_quota_exceeded_init_deserialize</abbr>
          @@ Script.force_decode_in_context ctxt script.code
          &gt;&gt;=? fun (_code, ctxt) -&gt;
          trace <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Gas_quota_exceeded_init_deserialize</abbr>
          @@ Script.force_decode_in_context ctxt script.storage
          &gt;&gt;|? fun (_storage, ctxt) -&gt; ctxt
      | _ -&gt;
          return ctxt )
      &gt;&gt;=? fun ctxt -&gt;
      Contract.get_manager_key ctxt source
      &gt;&gt;=? fun public_key -&gt;
      (* Currently, the `raw_operation` only contains one signature, so
     all operations are required to be from the same manager. This may
     change in the future, allowing several managers to group-sign a
     sequence of transactions.  *)
      Operation.check_signature public_key chain_id raw_operation
      &gt;&gt;=? fun () -&gt;
      Contract.increment_counter ctxt source
      &gt;&gt;=? fun ctxt -&gt;
      Contract.spend ctxt (Contract.implicit_contract source) fee
      &gt;&gt;=? fun ctxt -&gt; add_fees ctxt fee &gt;&gt;=? fun ctxt -&gt; return ctxt

let apply_manager_contents (type kind) ctxt mode chain_id
    (op : kind Kind.manager contents) :
    ( success_or_failure
    * kind manager_operation_result
    * packed_internal_operation_result list )
    Lwt.t =
  match[@coq_match_with_default] op with
  | Manager_operation {source; operation; gas_limit; storage_limit} -&gt; (
      let ctxt = Gas.set_limit ctxt gas_limit in
      let ctxt = Fees.start_counting_storage_fees ctxt in
      let source = Contract.implicit_contract source in
      apply_manager_operation_content
        ctxt
        mode
        ~source
        ~payer:source
        ~internal:false
        ~chain_id
        operation
      &gt;&gt;= function
      | Ok (ctxt, operation_results, internal_operations) -&gt; (
          apply_internal_manager_operations
            ctxt
            mode
            ~payer:source
            ~chain_id
            internal_operations
          &gt;&gt;= function
          | (Success ctxt, internal_operations_results) -&gt; (
              Fees.burn_storage_fees ctxt ~storage_limit ~payer:source
              &gt;&gt;= function
              | Ok ctxt -&gt;
                  Lwt.return
                    ( Success ctxt,
                      Applied operation_results,
                      internal_operations_results )
              | Error errors -&gt;
                  Lwt.return
                    ( Failure,
                      Backtracked (operation_results, Some errors),
                      internal_operations_results ) )
          | (Failure, internal_operations_results) -&gt;
              Lwt.return
                ( Failure,
                  Applied operation_results,
                  internal_operations_results ) )
      | Error errors -&gt;
          Lwt.return (Failure, Failed (manager_kind operation, errors), []) )

let skipped_operation_result :
    type kind. kind manager_operation -&gt; kind manager_operation_result =
  function
  | operation -&gt; (
    match operation with
    | Reveal _ -&gt;
        Applied
          ( Reveal_result {consumed_gas = Z.zero}
            : kind successful_manager_operation_result )
    | _ -&gt;
        Skipped (manager_kind operation) )

let rec mark_skipped :
    type kind.
    baker:Signature.Public_key_hash.t -&gt;
    Level.t -&gt;
    kind Kind.manager contents_list -&gt;
    kind Kind.manager contents_result_list =
 fun ~baker level -&gt; function[@coq_match_with_default]
  | Single (Manager_operation {source; fee; operation}) -&gt;
      let source = Contract.implicit_contract source in
      Single_result
        (Manager_operation_result
           {
             balance_updates =
               Delegate.cleanup_balance_updates
                 [ (Contract source, Debited fee);
                   (Fees (baker, level.cycle), Credited fee) ];
             operation_result = skipped_operation_result operation;
             internal_operation_results = [];
           })
  | Cons (Manager_operation {source; fee; operation}, rest) -&gt;
      let source = Contract.implicit_contract source in
      Cons_result
        ( Manager_operation_result
            {
              balance_updates =
                Delegate.cleanup_balance_updates
                  [ (Contract source, Debited fee);
                    (Fees (baker, level.cycle), Credited fee) ];
              operation_result = skipped_operation_result operation;
              internal_operation_results = [];
            },
          mark_skipped ~baker level rest )

let rec precheck_manager_contents_list :
    type kind.
    Alpha_context.t -&gt;
    Chain_id.t -&gt;
    _ Operation.t -&gt;
    kind Kind.manager contents_list -&gt;
    context tzresult Lwt.t =
 fun ctxt chain_id raw_operation contents_list -&gt;
  match[@coq_match_with_default] contents_list with
  | Single (Manager_operation _ as op) -&gt;
      precheck_manager_contents ctxt chain_id raw_operation op
  | Cons ((Manager_operation _ as op), rest) -&gt;
      precheck_manager_contents ctxt chain_id raw_operation op
      &gt;&gt;=? fun ctxt -&gt;
      precheck_manager_contents_list ctxt chain_id raw_operation rest

let rec apply_manager_contents_list_rec :
    type kind.
    Alpha_context.t -&gt;
    Script_ir_translator.unparsing_mode -&gt;
    public_key_hash -&gt;
    Chain_id.t -&gt;
    kind Kind.manager contents_list -&gt;
    (success_or_failure * kind Kind.manager contents_result_list) Lwt.t =
 fun ctxt mode baker chain_id contents_list -&gt;
  let level = Level.current ctxt in
  match[@coq_match_with_default] contents_list with
  | Single (Manager_operation {source; fee; _} as op) -&gt;
      let source = Contract.implicit_contract source in
      apply_manager_contents ctxt mode chain_id op
      &gt;&gt;= fun (ctxt_result, operation_result, internal_operation_results) -&gt;
      let result =
        Manager_operation_result
          {
            balance_updates =
              Delegate.cleanup_balance_updates
                [ (Contract source, Debited fee);
                  (Fees (baker, level.cycle), Credited fee) ];
            operation_result;
            internal_operation_results;
          }
      in
      Lwt.return (ctxt_result, Single_result result)
  | Cons ((Manager_operation {source; fee; _} as op), rest) -&gt; (
      let source = Contract.implicit_contract source in
      apply_manager_contents ctxt mode chain_id op
      &gt;&gt;= function
      | (Failure, operation_result, internal_operation_results) -&gt;
          let result =
            Manager_operation_result
              {
                balance_updates =
                  Delegate.cleanup_balance_updates
                    [ (Contract source, Debited fee);
                      (Fees (baker, level.cycle), Credited fee) ];
                operation_result;
                internal_operation_results;
              }
          in
          Lwt.return
            (Failure, Cons_result (result, mark_skipped ~baker level rest))
      | (Success ctxt, operation_result, internal_operation_results) -&gt;
          let result =
            Manager_operation_result
              {
                balance_updates =
                  Delegate.cleanup_balance_updates
                    [ (Contract source, Debited fee);
                      (Fees (baker, level.cycle), Credited fee) ];
                operation_result;
                internal_operation_results;
              }
          in
          apply_manager_contents_list_rec ctxt mode baker chain_id rest
          &gt;&gt;= fun (ctxt_result, results) -&gt;
          Lwt.return (ctxt_result, Cons_result (result, results)) )

let mark_backtracked results =
  let mark_manager_operation_result :
      type kind. kind manager_operation_result -&gt; kind manager_operation_result
      = function
    | (Failed _ | Skipped _ | Backtracked _) as result -&gt;
        result
    | Applied (Reveal_result _) as result -&gt;
        result
    | Applied result -&gt;
        Backtracked (result, None)
  in
  let mark_internal_operation_results
      (Internal_operation_result (kind, result)) =
    Internal_operation_result (kind, mark_manager_operation_result result)
  in
  let rec mark_contents_list :
      type kind.
      kind Kind.manager contents_result_list -&gt;
      kind Kind.manager contents_result_list =
    function[@coq_match_with_default]
    | Single_result (Manager_operation_result op) -&gt;
        Single_result
          (Manager_operation_result
             {
               balance_updates = op.balance_updates;
               operation_result =
                 mark_manager_operation_result op.operation_result;
               internal_operation_results =
                 List.map
                   mark_internal_operation_results
                   op.internal_operation_results;
             })
    | Cons_result (Manager_operation_result op, rest) -&gt;
        Cons_result
          ( Manager_operation_result
              {
                balance_updates = op.balance_updates;
                operation_result =
                  mark_manager_operation_result op.operation_result;
                internal_operation_results =
                  List.map
                    mark_internal_operation_results
                    op.internal_operation_results;
              },
            mark_contents_list rest )
  in
  mark_contents_list results

let apply_manager_contents_list ctxt mode baker chain_id contents_list =
  apply_manager_contents_list_rec ctxt mode baker chain_id contents_list
  &gt;&gt;= fun (ctxt_result, results) -&gt;
  match ctxt_result with
  | Failure -&gt;
      Lwt.return (ctxt (* backtracked *), mark_backtracked results)
  | Success ctxt -&gt;
      Big_map.cleanup_temporary ctxt &gt;&gt;= fun ctxt -&gt; Lwt.return (ctxt, results)

let apply_contents_list (type kind) ctxt chain_id mode pred_block baker
    (operation : kind operation) (contents_list : kind contents_list) :
    (context * kind contents_result_list) tzresult Lwt.t =
  match[@coq_match_with_default] contents_list with
  | Single (Endorsement {level}) -&gt;
      let block = operation.shell.branch in
      fail_unless
        (Block_hash.equal block pred_block)
        <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Wrong_endorsement_predecessor (pred_block, block))</abbr>
      &gt;&gt;=? fun () -&gt;
      let current_level = (Level.current ctxt).level in
      fail_unless
        Raw_level.(succ level = current_level)
        <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_endorsement_level</abbr>
      &gt;&gt;=? fun () -&gt;
      Baking.check_endorsement_rights ctxt chain_id operation
      &gt;&gt;=? fun (delegate, slots, used) -&gt;
      if used then fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Duplicate_endorsement delegate)</abbr>
      else
        let ctxt = record_endorsement ctxt delegate in
        let gap = List.length slots in
        Lwt.return
          Tez.(Constants.endorsement_security_deposit ctxt *? Int64.of_int gap)
        &gt;&gt;=? fun deposit -&gt;
        Delegate.freeze_deposit ctxt delegate deposit
        &gt;&gt;=? fun ctxt -&gt;
        Global.get_block_priority ctxt
        &gt;&gt;=? fun block_priority -&gt;
        Baking.endorsing_reward ctxt ~block_priority gap
        &gt;&gt;=? fun reward -&gt;
        Delegate.freeze_rewards ctxt delegate reward
        &gt;&gt;=? fun ctxt -&gt;
        let level = Level.from_raw ctxt level in
        return
          ( ctxt,
            Single_result
              (Endorsement_result
                 {
                   balance_updates =
                     Delegate.cleanup_balance_updates
                       [ ( Contract (Contract.implicit_contract delegate),
                           Debited deposit );
                         (Deposits (delegate, level.cycle), Credited deposit);
                         (Rewards (delegate, level.cycle), Credited reward) ];
                   delegate;
                   slots;
                 }) )
  | Single (Seed_nonce_revelation {level; nonce}) -&gt;
      let level = Level.from_raw ctxt level in
      Nonce.reveal ctxt level nonce
      &gt;&gt;=? fun ctxt -&gt;
      let seed_nonce_revelation_tip =
        Constants.seed_nonce_revelation_tip ctxt
      in
      add_rewards ctxt seed_nonce_revelation_tip
      &gt;&gt;=? fun ctxt -&gt;
      return
        ( ctxt,
          Single_result
            (Seed_nonce_revelation_result
               [ ( Rewards (baker, level.cycle),
                   Credited seed_nonce_revelation_tip ) ]) )
  | Single (Double_endorsement_evidence {op1; op2}) -&gt; (
    match (op1.protocol_data.contents, op2.protocol_data.contents) with
    | (Single (Endorsement e1), Single (Endorsement e2))
      when Raw_level.(e1.level = e2.level)
           &amp;&amp; not (Block_hash.equal op1.shell.branch op2.shell.branch) -&gt;
        let level = Level.from_raw ctxt e1.level in
        let oldest_level = Level.last_allowed_fork_level ctxt in
        fail_unless
          Level.(level &lt; Level.current ctxt)
          <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Too_early_double_endorsement_evidence
             {level = level.level; current = (Level.current ctxt).level})</abbr>
        &gt;&gt;=? fun () -&gt;
        fail_unless
          Raw_level.(oldest_level &lt;= level.level)
          <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Outdated_double_endorsement_evidence
             {level = level.level; last = oldest_level})</abbr>
        &gt;&gt;=? fun () -&gt;
        Baking.check_endorsement_rights ctxt chain_id op1
        &gt;&gt;=? fun (delegate1, _, _) -&gt;
        Baking.check_endorsement_rights ctxt chain_id op2
        &gt;&gt;=? fun (delegate2, _, _) -&gt;
        fail_unless
          (Signature.Public_key_hash.equal delegate1 delegate2)
          <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Inconsistent_double_endorsement_evidence {delegate1; delegate2})</abbr>
        &gt;&gt;=? fun () -&gt;
        Delegate.has_frozen_balance ctxt delegate1 level.cycle
        &gt;&gt;=? fun valid -&gt;
        fail_unless valid <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Unrequired_double_endorsement_evidence</abbr>
        &gt;&gt;=? fun () -&gt;
        Delegate.punish ctxt delegate1 level.cycle
        &gt;&gt;=? fun (ctxt, balance) -&gt;
        Lwt.return Tez.(balance.deposit +? balance.fees)
        &gt;&gt;=? fun burned -&gt;
        let reward =
          match Tez.(burned /? 2L) with Ok v -&gt; v | Error _ -&gt; Tez.zero
        in
        add_rewards ctxt reward
        &gt;&gt;=? fun ctxt -&gt;
        let current_cycle = (Level.current ctxt).cycle in
        return
          ( ctxt,
            Single_result
              (Double_endorsement_evidence_result
                 (Delegate.cleanup_balance_updates
                    [ ( Deposits (delegate1, level.cycle),
                        Debited balance.deposit );
                      (Fees (delegate1, level.cycle), Debited balance.fees);
                      ( Rewards (delegate1, level.cycle),
                        Debited balance.rewards );
                      (Rewards (baker, current_cycle), Credited reward) ])) )
    | (_, _) -&gt;
        fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_double_endorsement_evidence</abbr> )
  | Single (Double_baking_evidence {bh1; bh2}) -&gt;
      let hash1 = Block_header.hash bh1 in
      let hash2 = Block_header.hash bh2 in
      fail_unless
        ( Compare.Int32.(bh1.shell.level = bh2.shell.level)
        &amp;&amp; not (Block_hash.equal hash1 hash2) )
        <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_double_baking_evidence
           {hash1; level1 = bh1.shell.level; hash2; level2 = bh2.shell.level})</abbr>
      &gt;&gt;=? fun () -&gt;
      Lwt.return (Raw_level.of_int32 bh1.shell.level)
      &gt;&gt;=? fun raw_level -&gt;
      let oldest_level = Level.last_allowed_fork_level ctxt in
      fail_unless
        Raw_level.(raw_level &lt; (Level.current ctxt).level)
        <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Too_early_double_baking_evidence
           {level = raw_level; current = (Level.current ctxt).level})</abbr>
      &gt;&gt;=? fun () -&gt;
      fail_unless
        Raw_level.(oldest_level &lt;= raw_level)
        <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Outdated_double_baking_evidence
           {level = raw_level; last = oldest_level})</abbr>
      &gt;&gt;=? fun () -&gt;
      let level = Level.from_raw ctxt raw_level in
      Roll.baking_rights_owner
        ctxt
        level
        ~priority:bh1.protocol_data.contents.priority
      &gt;&gt;=? fun delegate1 -&gt;
      Baking.check_signature bh1 chain_id delegate1
      &gt;&gt;=? fun () -&gt;
      Roll.baking_rights_owner
        ctxt
        level
        ~priority:bh2.protocol_data.contents.priority
      &gt;&gt;=? fun delegate2 -&gt;
      Baking.check_signature bh2 chain_id delegate2
      &gt;&gt;=? fun () -&gt;
      fail_unless
        (Signature.Public_key.equal delegate1 delegate2)
        <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Inconsistent_double_baking_evidence
           {
             delegate1 = Signature.Public_key.hash delegate1;
             delegate2 = Signature.Public_key.hash delegate2;
           })</abbr>
      &gt;&gt;=? fun () -&gt;
      let delegate = Signature.Public_key.hash delegate1 in
      Delegate.has_frozen_balance ctxt delegate level.cycle
      &gt;&gt;=? fun valid -&gt;
      fail_unless valid <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Unrequired_double_baking_evidence</abbr>
      &gt;&gt;=? fun () -&gt;
      Delegate.punish ctxt delegate level.cycle
      &gt;&gt;=? fun (ctxt, balance) -&gt;
      Lwt.return Tez.(balance.deposit +? balance.fees)
      &gt;&gt;=? fun burned -&gt;
      let reward =
        match Tez.(burned /? 2L) with Ok v -&gt; v | Error _ -&gt; Tez.zero
      in
      add_rewards ctxt reward
      &gt;&gt;=? fun ctxt -&gt;
      let current_cycle = (Level.current ctxt).cycle in
      return
        ( ctxt,
          Single_result
            (Double_baking_evidence_result
               (Delegate.cleanup_balance_updates
                  [ (Deposits (delegate, level.cycle), Debited balance.deposit);
                    (Fees (delegate, level.cycle), Debited balance.fees);
                    (Rewards (delegate, level.cycle), Debited balance.rewards);
                    (Rewards (baker, current_cycle), Credited reward) ])) )
  | Single (Activate_account {id = pkh; activation_code}) -&gt; (
      let blinded_pkh =
        Blinded_public_key_hash.of_ed25519_pkh activation_code pkh
      in
      Commitment.get_opt ctxt blinded_pkh
      &gt;&gt;=? function
      | None -&gt;
          fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_activation {pkh})</abbr>
      | Some amount -&gt;
          Commitment.delete ctxt blinded_pkh
          &gt;&gt;=? fun ctxt -&gt;
          let contract =
            Contract.implicit_contract (Signature.Ed25519Hash pkh)
          in
          Contract.(credit ctxt contract amount)
          &gt;&gt;=? fun ctxt -&gt;
          return
            ( ctxt,
              Single_result
                (Activate_account_result [(Contract contract, Credited amount)])
            ) )
  | Single (Proposals {source; period; proposals}) -&gt;
      Roll.delegate_pubkey ctxt source
      &gt;&gt;=? fun delegate -&gt;
      Operation.check_signature delegate chain_id operation
      &gt;&gt;=? fun () -&gt;
      let level = Level.current ctxt in
      fail_unless
        Voting_period.(level.voting_period = period)
        <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Wrong_voting_period (level.voting_period, period))</abbr>
      &gt;&gt;=? fun () -&gt;
      Amendment.record_proposals ctxt source proposals
      &gt;&gt;=? fun ctxt -&gt; return (ctxt, Single_result Proposals_result)
  | Single (Ballot {source; period; proposal; ballot}) -&gt;
      Roll.delegate_pubkey ctxt source
      &gt;&gt;=? fun delegate -&gt;
      Operation.check_signature delegate chain_id operation
      &gt;&gt;=? fun () -&gt;
      let level = Level.current ctxt in
      fail_unless
        Voting_period.(level.voting_period = period)
        <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Wrong_voting_period (level.voting_period, period))</abbr>
      &gt;&gt;=? fun () -&gt;
      Amendment.record_ballot ctxt source proposal ballot
      &gt;&gt;=? fun ctxt -&gt; return (ctxt, Single_result Ballot_result)
  | Single (Manager_operation _) as op -&gt;
      precheck_manager_contents_list ctxt chain_id operation op
      &gt;&gt;=? fun ctxt -&gt;
      apply_manager_contents_list ctxt mode baker chain_id op
      &gt;&gt;= fun (ctxt, result) -&gt; return (ctxt, result)
  | Cons (Manager_operation _, _) as op -&gt;
      precheck_manager_contents_list ctxt chain_id operation op
      &gt;&gt;=? fun ctxt -&gt;
      apply_manager_contents_list ctxt mode baker chain_id op
      &gt;&gt;= fun (ctxt, result) -&gt; return (ctxt, result)

let apply_operation ctxt chain_id mode pred_block baker hash operation =
  let ctxt = Contract.init_origination_nonce ctxt hash in
  apply_contents_list
    ctxt
    chain_id
    mode
    pred_block
    baker
    operation
    operation.protocol_data.contents
  &gt;&gt;=? fun (ctxt, result) -&gt;
  let ctxt = Gas.set_unlimited ctxt in
  let ctxt = Contract.unset_origination_nonce ctxt in
  return (ctxt, {contents = result})

let may_snapshot_roll ctxt =
  let level = Alpha_context.Level.current ctxt in
  let blocks_per_roll_snapshot = Constants.blocks_per_roll_snapshot ctxt in
  if
    Compare.Int32.equal
      (Int32.rem level.cycle_position blocks_per_roll_snapshot)
      (Int32.pred blocks_per_roll_snapshot)
  then Alpha_context.Roll.snapshot_rolls ctxt &gt;&gt;=? fun ctxt -&gt; return ctxt
  else return ctxt

let may_start_new_cycle ctxt =
  Baking.dawn_of_a_new_cycle ctxt
  &gt;&gt;=? function
  | None -&gt;
      return (ctxt, [], [])
  | Some last_cycle -&gt;
      Seed.cycle_end ctxt last_cycle
      &gt;&gt;=? fun (ctxt, unrevealed) -&gt;
      Roll.cycle_end ctxt last_cycle
      &gt;&gt;=? fun ctxt -&gt;
      Delegate.cycle_end ctxt last_cycle unrevealed
      &gt;&gt;=? fun (ctxt, update_balances, deactivated) -&gt;
      Bootstrap.cycle_end ctxt last_cycle
      &gt;&gt;=? fun ctxt -&gt; return (ctxt, update_balances, deactivated)

let begin_full_construction ctxt pred_timestamp protocol_data =
  Alpha_context.Global.set_block_priority
    ctxt
    protocol_data.Block_header_repr.priority
  &gt;&gt;=? fun ctxt -&gt;
  Baking.check_baking_rights ctxt protocol_data pred_timestamp
  &gt;&gt;=? fun (delegate_pk, block_delay) -&gt;
  let ctxt = Fitness.increase ctxt in
  match Level.pred ctxt (Level.current ctxt) with
  | None -&gt;
      <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr> (* genesis *)
  | Some pred_level -&gt;
      Baking.endorsement_rights ctxt pred_level
      &gt;&gt;=? fun rights -&gt;
      let ctxt = init_endorsements ctxt rights in
      return (ctxt, protocol_data, delegate_pk, block_delay)

let begin_partial_construction ctxt =
  let ctxt = Fitness.increase ctxt in
  match Level.pred ctxt (Level.current ctxt) with
  | None -&gt;
      <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr> (* genesis *)
  | Some pred_level -&gt;
      Baking.endorsement_rights ctxt pred_level
      &gt;&gt;=? fun rights -&gt;
      let ctxt = init_endorsements ctxt rights in
      return ctxt

let begin_application ctxt chain_id block_header pred_timestamp =
  Alpha_context.Global.set_block_priority
    ctxt
    block_header.Block_header_repr.protocol_data.contents.priority
  &gt;&gt;=? fun ctxt -&gt;
  let current_level = Alpha_context.Level.current ctxt in
  Baking.check_proof_of_work_stamp ctxt block_header
  &gt;&gt;=? fun () -&gt;
  Baking.check_fitness_gap ctxt block_header
  &gt;&gt;=? fun () -&gt;
  Baking.check_baking_rights
    ctxt
    block_header.protocol_data.contents
    pred_timestamp
  &gt;&gt;=? fun (delegate_pk, block_delay) -&gt;
  Baking.check_signature block_header chain_id delegate_pk
  &gt;&gt;=? fun () -&gt;
  let has_commitment =
    match block_header.protocol_data.contents.seed_nonce_hash with
    | None -&gt;
        false
    | Some _ -&gt;
        true
  in
  fail_unless
    Compare.Bool.(has_commitment = current_level.expected_commitment)
    <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_commitment {expected = current_level.expected_commitment})</abbr>
  &gt;&gt;=? fun () -&gt;
  let ctxt = Fitness.increase ctxt in
  match Level.pred ctxt (Level.current ctxt) with
  | None -&gt;
      <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr> (* genesis *)
  | Some pred_level -&gt;
      Baking.endorsement_rights ctxt pred_level
      &gt;&gt;=? fun rights -&gt;
      let ctxt = init_endorsements ctxt rights in
      return (ctxt, delegate_pk, block_delay)

let check_minimum_endorsements ctxt protocol_data block_delay
    included_endorsements =
  let minimum = Baking.minimum_allowed_endorsements ctxt ~block_delay in
  let timestamp = Timestamp.current ctxt in
  fail_unless
    Compare.Int.(included_endorsements &gt;= minimum)
    <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Not_enough_endorsements_for_priority
       {
         required = minimum;
         priority = protocol_data.Block_header_repr.priority;
         endorsements = included_endorsements;
         timestamp;
       })</abbr>

let finalize_application ctxt protocol_data delegate ~block_delay =
  let included_endorsements = included_endorsements ctxt in
  check_minimum_endorsements
    ctxt
    protocol_data
    block_delay
    included_endorsements
  &gt;&gt;=? fun () -&gt;
  let deposit = Constants.block_security_deposit ctxt in
  add_deposit ctxt delegate deposit
  &gt;&gt;=? fun ctxt -&gt;
  Baking.baking_reward
    ctxt
    ~block_priority:protocol_data.priority
    ~included_endorsements
  &gt;&gt;=? fun reward -&gt;
  add_rewards ctxt reward
  &gt;&gt;=? fun ctxt -&gt;
  Signature.Public_key_hash.Map.fold
    (fun delegate deposit ctxt -&gt;
      ctxt &gt;&gt;=? fun ctxt -&gt; Delegate.freeze_deposit ctxt delegate deposit)
    (get_deposits ctxt)
    (return ctxt)
  &gt;&gt;=? fun ctxt -&gt;
  (* end of level (from this point nothing should fail) *)
  let fees = Alpha_context.get_fees ctxt in
  Delegate.freeze_fees ctxt delegate fees
  &gt;&gt;=? fun ctxt -&gt;
  let rewards = Alpha_context.get_rewards ctxt in
  Delegate.freeze_rewards ctxt delegate rewards
  &gt;&gt;=? fun ctxt -&gt;
  ( match protocol_data.Block_header_repr.seed_nonce_hash with
  | None -&gt;
      return ctxt
  | Some nonce_hash -&gt;
      Nonce.record_hash ctxt {nonce_hash; delegate; rewards; fees} )
  &gt;&gt;=? fun ctxt -&gt;
  (* end of cycle *)
  may_snapshot_roll ctxt
  &gt;&gt;=? fun ctxt -&gt;
  may_start_new_cycle ctxt
  &gt;&gt;=? fun (ctxt, balance_updates, deactivated) -&gt;
  Amendment.may_start_new_voting_period ctxt
  &gt;&gt;=? fun ctxt -&gt;
  let cycle = (Level.current ctxt).cycle in
  let balance_updates =
    Delegate.(
      cleanup_balance_updates
        ( [ (Contract (Contract.implicit_contract delegate), Debited deposit);
            (Deposits (delegate, cycle), Credited deposit);
            (Rewards (delegate, cycle), Credited reward) ]
        @ balance_updates ))
  in
  let consumed_gas =
    Z.sub
      (Constants.hard_gas_limit_per_block ctxt)
      (Alpha_context.Gas.block_level ctxt)
  in
  Alpha_context.Vote.get_current_period_kind ctxt
  &gt;&gt;=? fun voting_period_kind -&gt;
  let receipt =
    Apply_results.
      {
        baker = delegate;
        level = Level.current ctxt;
        voting_period_kind;
        nonce_hash = protocol_data.seed_nonce_hash;
        consumed_gas;
        deactivated;
        balance_updates;
      }
  in
  return (ctxt, receipt)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#apply.ml"><code>Apply.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Amendment.
Require Tezos.Apply_results.
Require Tezos.Baking.
Require Tezos.Blinded_public_key_hash.
Require Tezos.Block_header_repr.
Require Tezos.Michelson_v1_gas.
Require Tezos.Nonce_hash.
Require Tezos.Script_interpreter.
Require Tezos.Script_ir_translator.
Require Tezos.Script_typed_ir.
Require Tezos.Storage_mli. Module Storage := Storage_mli.

Import Alpha_context.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)

Import Apply_results.

Definition apply_manager_operation_content
  (ctxt : Alpha_context.t) (mode : Script_ir_translator.unparsing_mode)
  (payer : Alpha_context.Contract.t) (source : Alpha_context.Contract.t)
  (chain_id : (|Chain_id|).(S.HASH.t)) (internal : bool)
  (operation : Alpha_context.manager_operation)
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context * Apply_results.successful_manager_operation_result
        * list Alpha_context.packed_internal_operation)) :=
  let before_operation := ctxt in
  let=? '_ := Alpha_context.Contract.must_exist ctxt source in
  let=? ctxt :=
    Lwt.__return
      (Alpha_context.Gas.consume ctxt Michelson_v1_gas.Cost_of.manager_operation)
    in
  match operation with
  | Alpha_context.Reveal _ =&gt;
    Error_monad.__return
      (ctxt,
        (Apply_results.Reveal_result
          {|
            Apply_results.successful_manager_operation_result.Reveal_result.consumed_gas :=
              Alpha_context.Gas.consumed before_operation ctxt |}), nil)
  |
    Alpha_context.Transaction {|
      Alpha_context.manager_operation.Transaction.amount := amount;
        Alpha_context.manager_operation.Transaction.parameters := parameters;
        Alpha_context.manager_operation.Transaction.entrypoint := entrypoint;
        Alpha_context.manager_operation.Transaction.destination := destination
        |} =&gt;
    let=? ctxt := Alpha_context.Contract.spend ctxt source amount in
    let=? '(ctxt, maybe_burn_balance_update, allocated_destination_contract) :=
      match Alpha_context.Contract.is_implicit destination with
      | None =&gt; Error_monad.__return (ctxt, nil, false)
      | Some _ =&gt;
        let=? function_parameter :=
          Alpha_context.Contract.allocated ctxt destination in
        match function_parameter with
        | true =&gt; Error_monad.__return (ctxt, nil, false)
        | false =&gt;
          let=? '(ctxt, origination_burn) :=
            Alpha_context.Fees.origination_burn ctxt in
          Error_monad.__return
            (ctxt,
              [
                ((Alpha_context.Delegate.Contract payer),
                  (Alpha_context.Delegate.Debited origination_burn))
              ], true)
        end
      end in
    let=? ctxt := Alpha_context.Contract.credit ctxt destination amount in
    let=? '(ctxt, script) := Alpha_context.Contract.get_script ctxt destination
      in
    match script with
    | None =&gt;
      let=? ctxt :=
        let=? '_ :=
          match entrypoint with
          | &quot;default&quot; =&gt; Error_monad.__return tt
          | entrypoint =&gt; Error_monad.fail extensible_type_value
          end in
        let=? '(arg, ctxt) :=
          Alpha_context.Script.force_decode_in_context ctxt parameters in
        let cost_arg := Alpha_context.Script.deserialized_cost arg in
        let=? ctxt := Lwt.__return (Alpha_context.Gas.consume ctxt cost_arg) in
        match Micheline.root arg with
        | Micheline.Prim _ Alpha_context.Script.D_Unit [] _ =&gt;
          Error_monad.__return ctxt
        | _ =&gt; Error_monad.fail extensible_type_value
        end in
      let __result_value :=
        Apply_results.Transaction_result
          {|
            Apply_results.successful_manager_operation_result.Transaction_result.storage :=
              None;
            Apply_results.successful_manager_operation_result.Transaction_result.big_map_diff :=
              None;
            Apply_results.successful_manager_operation_result.Transaction_result.balance_updates :=
              Alpha_context.Delegate.cleanup_balance_updates
                (Pervasives.op_at
                  [
                    ((Alpha_context.Delegate.Contract source),
                      (Alpha_context.Delegate.Debited amount));
                    ((Alpha_context.Delegate.Contract destination),
                      (Alpha_context.Delegate.Credited amount))
                  ] maybe_burn_balance_update);
            Apply_results.successful_manager_operation_result.Transaction_result.originated_contracts :=
              nil;
            Apply_results.successful_manager_operation_result.Transaction_result.consumed_gas :=
              Alpha_context.Gas.consumed before_operation ctxt;
            Apply_results.successful_manager_operation_result.Transaction_result.storage_size :=
              Z.zero;
            Apply_results.successful_manager_operation_result.Transaction_result.paid_storage_size_diff :=
              Z.zero;
            Apply_results.successful_manager_operation_result.Transaction_result.allocated_destination_contract :=
              allocated_destination_contract |} in
      Error_monad.__return (ctxt, __result_value, nil)
    | Some script =&gt;
      let=? '(parameter, ctxt) :=
        Alpha_context.Script.force_decode_in_context ctxt parameters in
      let cost_parameter := Alpha_context.Script.deserialized_cost parameter in
      let=? ctxt := Lwt.__return (Alpha_context.Gas.consume ctxt cost_parameter)
        in
      let step_constants :=
        {| Script_interpreter.step_constants.source := source;
          Script_interpreter.step_constants.payer := payer;
          Script_interpreter.step_constants.self := destination;
          Script_interpreter.step_constants.amount := amount;
          Script_interpreter.step_constants.chain_id := chain_id |} in
      let=? '{|
        Script_interpreter.execution_result.ctxt := ctxt;
          Script_interpreter.execution_result.storage := storage;
          Script_interpreter.execution_result.big_map_diff := big_map_diff;
          Script_interpreter.execution_result.operations := operations
          |} :=
        Script_interpreter.execute_wrapper ctxt mode step_constants script
          entrypoint parameter in
      let=? ctxt :=
        Alpha_context.Contract.update_script_storage ctxt destination storage
          big_map_diff in
      let=? '(ctxt, new_size, paid_storage_size_diff, fees) :=
        Alpha_context.Fees.record_paid_storage_space ctxt destination in
      let=? originated_contracts :=
        Alpha_context.Contract.originated_from_current_nonce before_operation
          ctxt in
      let __result_value :=
        Apply_results.Transaction_result
          {|
            Apply_results.successful_manager_operation_result.Transaction_result.storage :=
              Some storage;
            Apply_results.successful_manager_operation_result.Transaction_result.big_map_diff :=
              big_map_diff;
            Apply_results.successful_manager_operation_result.Transaction_result.balance_updates :=
              Alpha_context.Delegate.cleanup_balance_updates
                [
                  ((Alpha_context.Delegate.Contract payer),
                    (Alpha_context.Delegate.Debited fees));
                  ((Alpha_context.Delegate.Contract source),
                    (Alpha_context.Delegate.Debited amount));
                  ((Alpha_context.Delegate.Contract destination),
                    (Alpha_context.Delegate.Credited amount))
                ];
            Apply_results.successful_manager_operation_result.Transaction_result.originated_contracts :=
              originated_contracts;
            Apply_results.successful_manager_operation_result.Transaction_result.consumed_gas :=
              Alpha_context.Gas.consumed before_operation ctxt;
            Apply_results.successful_manager_operation_result.Transaction_result.storage_size :=
              new_size;
            Apply_results.successful_manager_operation_result.Transaction_result.paid_storage_size_diff :=
              paid_storage_size_diff;
            Apply_results.successful_manager_operation_result.Transaction_result.allocated_destination_contract :=
              allocated_destination_contract |} in
      Error_monad.__return (ctxt, __result_value, operations)
    end
  |
    Alpha_context.Origination {|
      Alpha_context.manager_operation.Origination.delegate := delegate;
        Alpha_context.manager_operation.Origination.script := script;
        Alpha_context.manager_operation.Origination.credit := credit;
        Alpha_context.manager_operation.Origination.preorigination :=
          preorigination
        |} =&gt;
    let=? '(unparsed_storage, ctxt) :=
      Alpha_context.Script.force_decode_in_context ctxt
        script.(Alpha_context.Script.t.storage) in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt
          (Alpha_context.Script.deserialized_cost unparsed_storage)) in
    let=? '(unparsed_code, ctxt) :=
      Alpha_context.Script.force_decode_in_context ctxt
        script.(Alpha_context.Script.t.code) in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt
          (Alpha_context.Script.deserialized_cost unparsed_code)) in
    let=? '(Script_ir_translator.Ex_script parsed_script, ctxt) :=
      Script_ir_translator.parse_script None ctxt false script in
    let 'existT _ __Ex_script_'b [parsed_script, ctxt] :=
      existT (A := Set)
        (fun __Ex_script_'b =&gt;
          [Script_typed_ir.script __Ex_script_'b ** Alpha_context.context]) _
        [parsed_script, ctxt] in
    let=? '(to_duplicate, ctxt) :=
      Script_ir_translator.collect_big_maps ctxt
        parsed_script.(Script_typed_ir.script.storage_type)
        parsed_script.(Script_typed_ir.script.storage) in
    let to_update := Script_ir_translator.no_big_map_id in
    let=? '(storage, big_map_diff, ctxt) :=
      Script_ir_translator.extract_big_map_diff ctxt
        Script_ir_translator.Optimized false to_duplicate to_update
        parsed_script.(Script_typed_ir.script.storage_type)
        parsed_script.(Script_typed_ir.script.storage) in
    let=? '(storage, ctxt) :=
      Script_ir_translator.unparse_data ctxt Script_ir_translator.Optimized
        parsed_script.(Script_typed_ir.script.storage_type) storage in
    let storage :=
      Alpha_context.Script.__lazy_expr_value (Micheline.strip_locations storage)
      in
    let script := Alpha_context.Script.t.with_storage storage script in
    let=? ctxt := Alpha_context.Contract.spend ctxt source credit in
    let=? '(ctxt, contract) :=
      match preorigination with
      | Some contract =&gt;
        (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
        (* ‚ùå instruction_sequence &quot;;&quot; *)
        Error_monad.__return (ctxt, contract)
      | None =&gt; Alpha_context.Contract.fresh_contract_from_current_nonce ctxt
      end in
    let=? ctxt :=
      Alpha_context.Contract.originate ctxt contract credit
        (script, big_map_diff) delegate in
    let=? '(ctxt, origination_burn) := Alpha_context.Fees.origination_burn ctxt
      in
    let=? '(ctxt, size, paid_storage_size_diff, fees) :=
      Alpha_context.Fees.record_paid_storage_space ctxt contract in
    let __result_value :=
      Apply_results.Origination_result
        {|
          Apply_results.successful_manager_operation_result.Origination_result.big_map_diff :=
            big_map_diff;
          Apply_results.successful_manager_operation_result.Origination_result.balance_updates :=
            Alpha_context.Delegate.cleanup_balance_updates
              [
                ((Alpha_context.Delegate.Contract payer),
                  (Alpha_context.Delegate.Debited fees));
                ((Alpha_context.Delegate.Contract payer),
                  (Alpha_context.Delegate.Debited origination_burn));
                ((Alpha_context.Delegate.Contract source),
                  (Alpha_context.Delegate.Debited credit));
                ((Alpha_context.Delegate.Contract contract),
                  (Alpha_context.Delegate.Credited credit))
              ];
          Apply_results.successful_manager_operation_result.Origination_result.originated_contracts :=
            [ contract ];
          Apply_results.successful_manager_operation_result.Origination_result.consumed_gas :=
            Alpha_context.Gas.consumed before_operation ctxt;
          Apply_results.successful_manager_operation_result.Origination_result.storage_size :=
            size;
          Apply_results.successful_manager_operation_result.Origination_result.paid_storage_size_diff :=
            paid_storage_size_diff |} in
    Error_monad.__return (ctxt, __result_value, nil)
  | Alpha_context.Delegation delegate =&gt;
    let=? ctxt := Alpha_context.Delegate.set ctxt source delegate in
    Error_monad.__return
      (ctxt,
        (Apply_results.Delegation_result
          {|
            Apply_results.successful_manager_operation_result.Delegation_result.consumed_gas :=
              Alpha_context.Gas.consumed before_operation ctxt |}), nil)
  end.

Inductive success_or_failure : Set :=
| Success : Alpha_context.t -&gt; success_or_failure
| Failure : success_or_failure.

Definition apply_internal_manager_operations
  (ctxt : Alpha_context.t) (mode : Script_ir_translator.unparsing_mode)
  (payer : Alpha_context.Contract.t) (chain_id : (|Chain_id|).(S.HASH.t))
  (ops : list Alpha_context.packed_internal_operation)
  : Lwt.t
    (success_or_failure * list Apply_results.packed_internal_operation_result) :=
  let fix apply
    (ctxt : Alpha_context.t)
    (applied : list Apply_results.packed_internal_operation_result)
    (worklist : list Alpha_context.packed_internal_operation) {struct ctxt}
    : Lwt.t
      (success_or_failure * list Apply_results.packed_internal_operation_result) :=
    match worklist with
    | [] =&gt; Lwt.__return ((Success ctxt), (List.rev applied))
    |
      cons
        (Alpha_context.Internal_operation
          ({|
            Alpha_context.internal_operation.source := source;
              Alpha_context.internal_operation.operation := operation;
              Alpha_context.internal_operation.nonce := __nonce_value
              |} as op)) rest =&gt;
      let= function_parameter :=
        if Alpha_context.internal_nonce_already_recorded ctxt __nonce_value then
          Error_monad.fail extensible_type_value
        else
          let ctxt := Alpha_context.record_internal_nonce ctxt __nonce_value in
          apply_manager_operation_content ctxt mode payer source chain_id true
            operation in
      match function_parameter with
      | Pervasives.Error errors =&gt;
        let __result_value :=
          Apply_results.Internal_operation_result op
            (Apply_results.Failed
              (Alpha_context.manager_kind
                op.(Alpha_context.internal_operation.operation)) errors) in
        let skipped :=
          List.rev_map
            (fun function_parameter =&gt;
              let 'Alpha_context.Internal_operation op := function_parameter in
              Apply_results.Internal_operation_result op
                (Apply_results.Skipped
                  (Alpha_context.manager_kind
                    op.(Alpha_context.internal_operation.operation)))) rest in
        Lwt.__return
          (Failure,
            (List.rev (Pervasives.op_at skipped (cons __result_value applied))))
      | Pervasives.Ok (ctxt, __result_value, emitted) =&gt;
        apply ctxt
          (cons
            (Apply_results.Internal_operation_result op
              (Apply_results.Applied __result_value)) applied)
          (Pervasives.op_at rest emitted)
      end
    end in
  apply ctxt nil ops.

Definition precheck_manager_contents
  (ctxt : Alpha_context.context) (chain_id : (|Chain_id|).(S.HASH.t))
  (raw_operation : Alpha_context.operation) (op : Alpha_context.contents)
  : Lwt.t (Error_monad.tzresult Alpha_context.context) :=
  match op with
  |
    Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.source := source;
        Alpha_context.contents.Manager_operation.fee := fee;
        Alpha_context.contents.Manager_operation.counter := counter;
        Alpha_context.contents.Manager_operation.operation := operation;
        Alpha_context.contents.Manager_operation.gas_limit := gas_limit;
        Alpha_context.contents.Manager_operation.storage_limit := storage_limit
        |} =&gt;
    let=? '_ := Lwt.__return (Alpha_context.Gas.check_limit ctxt gas_limit) in
    let ctxt := Alpha_context.Gas.set_limit ctxt gas_limit in
    let=? '_ :=
      Lwt.__return (Alpha_context.Fees.check_storage_limit ctxt storage_limit)
      in
    let=? '_ :=
      Alpha_context.Contract.must_be_allocated ctxt
        (Alpha_context.Contract.implicit_contract source) in
    let=? '_ :=
      Alpha_context.Contract.check_counter_increment ctxt source counter in
    let=? ctxt :=
      match operation with
      | Alpha_context.Reveal pk =&gt;
        Alpha_context.Contract.reveal_manager_key ctxt source pk
      |
        Alpha_context.Transaction {|
          Alpha_context.manager_operation.Transaction.parameters := parameters
            |} =&gt;
        let=? '_ :=
          Lwt.__return
            ((Error_monad.record_trace extensible_type_value)
              (Alpha_context.Gas.check_enough ctxt
                (Alpha_context.Script.minimal_deserialize_cost parameters))) in
        Error_monad.op_gtgtpipequestion
          ((Error_monad.trace extensible_type_value)
            (Alpha_context.Script.force_decode_in_context ctxt parameters))
          (fun function_parameter =&gt;
            let '(_arg, ctxt) := function_parameter in
            ctxt)
      |
        Alpha_context.Origination {|
          Alpha_context.manager_operation.Origination.script := script |} =&gt;
        let=? '_ :=
          Lwt.__return
            ((Error_monad.record_trace extensible_type_value)
              (let? ctxt :=
                Alpha_context.Gas.consume ctxt
                  (Alpha_context.Script.minimal_deserialize_cost
                    script.(Alpha_context.Script.t.code)) in
              Alpha_context.Gas.check_enough ctxt
                (Alpha_context.Script.minimal_deserialize_cost
                  script.(Alpha_context.Script.t.storage)))) in
        let=? '(_code, ctxt) :=
          (Error_monad.trace extensible_type_value)
            (Alpha_context.Script.force_decode_in_context ctxt
              script.(Alpha_context.Script.t.code)) in
        Error_monad.op_gtgtpipequestion
          ((Error_monad.trace extensible_type_value)
            (Alpha_context.Script.force_decode_in_context ctxt
              script.(Alpha_context.Script.t.storage)))
          (fun function_parameter =&gt;
            let '(_storage, ctxt) := function_parameter in
            ctxt)
      | _ =&gt; Error_monad.__return ctxt
      end in
    let=? public_key := Alpha_context.Contract.get_manager_key ctxt source in
    let=? '_ :=
      Alpha_context.Operation.check_signature public_key chain_id raw_operation
      in
    let=? ctxt := Alpha_context.Contract.increment_counter ctxt source in
    let=? ctxt :=
      Alpha_context.Contract.spend ctxt
        (Alpha_context.Contract.implicit_contract source) fee in
    let=? ctxt := Alpha_context.add_fees ctxt fee in
    Error_monad.__return ctxt
  | _ =&gt; unreachable_gadt_branch
  end.

Definition apply_manager_contents
  (ctxt : Alpha_context.context) (mode : Script_ir_translator.unparsing_mode)
  (chain_id : (|Chain_id|).(S.HASH.t)) (op : Alpha_context.contents)
  : Lwt.t
    (success_or_failure * Apply_results.manager_operation_result *
      list Apply_results.packed_internal_operation_result) :=
  match op with
  |
    Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.source := source;
        Alpha_context.contents.Manager_operation.operation := operation;
        Alpha_context.contents.Manager_operation.gas_limit := gas_limit;
        Alpha_context.contents.Manager_operation.storage_limit := storage_limit
        |} =&gt;
    let ctxt := Alpha_context.Gas.set_limit ctxt gas_limit in
    let ctxt := Alpha_context.Fees.start_counting_storage_fees ctxt in
    let source := Alpha_context.Contract.implicit_contract source in
    let= function_parameter :=
      apply_manager_operation_content ctxt mode source source chain_id false
        operation in
    match function_parameter with
    | Pervasives.Ok (ctxt, operation_results, internal_operations) =&gt;
      let= function_parameter :=
        apply_internal_manager_operations ctxt mode source chain_id
          internal_operations in
      match function_parameter with
      | (Success ctxt, internal_operations_results) =&gt;
        let= function_parameter :=
          Alpha_context.Fees.burn_storage_fees ctxt storage_limit source in
        match function_parameter with
        | Pervasives.Ok ctxt =&gt;
          Lwt.__return
            ((Success ctxt), (Apply_results.Applied operation_results),
              internal_operations_results)
        | Pervasives.Error errors =&gt;
          Lwt.__return
            (Failure,
              (Apply_results.Backtracked operation_results (Some errors)),
              internal_operations_results)
        end
      | (Failure, internal_operations_results) =&gt;
        Lwt.__return
          (Failure, (Apply_results.Applied operation_results),
            internal_operations_results)
      end
    | Pervasives.Error errors =&gt;
      Lwt.__return
        (Failure,
          (Apply_results.Failed (Alpha_context.manager_kind operation) errors),
          nil)
    end
  | _ =&gt; unreachable_gadt_branch
  end.

Definition skipped_operation_result
  (operation : Alpha_context.manager_operation)
  : Apply_results.manager_operation_result :=
  match operation with
  | Alpha_context.Reveal _ =&gt;
    Apply_results.Applied
      (Apply_results.Reveal_result
        {|
          Apply_results.successful_manager_operation_result.Reveal_result.consumed_gas :=
            Z.zero |})
  | _ =&gt; Apply_results.Skipped (Alpha_context.manager_kind operation)
  end.

Fixpoint mark_skipped
  (baker : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  (level : Alpha_context.Level.t)
  (function_parameter : Alpha_context.contents_list) {struct baker}
  : Apply_results.contents_result_list :=
  match function_parameter with
  |
    Alpha_context.Single
      (Alpha_context.Manager_operation {|
        Alpha_context.contents.Manager_operation.source := source;
          Alpha_context.contents.Manager_operation.fee := fee;
          Alpha_context.contents.Manager_operation.operation := operation
          |}) =&gt;
    let source := Alpha_context.Contract.implicit_contract source in
    Apply_results.Single_result
      (Apply_results.Manager_operation_result
        {|
          Apply_results.contents_result.Manager_operation_result.balance_updates :=
            Alpha_context.Delegate.cleanup_balance_updates
              [
                ((Alpha_context.Delegate.Contract source),
                  (Alpha_context.Delegate.Debited fee));
                ((Alpha_context.Delegate.Fees baker
                  level.(Alpha_context.Level.t.cycle)),
                  (Alpha_context.Delegate.Credited fee))
              ];
          Apply_results.contents_result.Manager_operation_result.operation_result :=
            skipped_operation_result operation;
          Apply_results.contents_result.Manager_operation_result.internal_operation_results :=
            nil |})
  |
    Alpha_context.Cons
      (Alpha_context.Manager_operation {|
        Alpha_context.contents.Manager_operation.source := source;
          Alpha_context.contents.Manager_operation.fee := fee;
          Alpha_context.contents.Manager_operation.operation := operation
          |}) rest =&gt;
    let source := Alpha_context.Contract.implicit_contract source in
    Apply_results.Cons_result
      (Apply_results.Manager_operation_result
        {|
          Apply_results.contents_result.Manager_operation_result.balance_updates :=
            Alpha_context.Delegate.cleanup_balance_updates
              [
                ((Alpha_context.Delegate.Contract source),
                  (Alpha_context.Delegate.Debited fee));
                ((Alpha_context.Delegate.Fees baker
                  level.(Alpha_context.Level.t.cycle)),
                  (Alpha_context.Delegate.Credited fee))
              ];
          Apply_results.contents_result.Manager_operation_result.operation_result :=
            skipped_operation_result operation;
          Apply_results.contents_result.Manager_operation_result.internal_operation_results :=
            nil |}) (mark_skipped baker level rest)
  | _ =&gt; unreachable_gadt_branch
  end.

Fixpoint precheck_manager_contents_list
  (ctxt : Alpha_context.t) (chain_id : (|Chain_id|).(S.HASH.t))
  (raw_operation : Alpha_context.Operation.t)
  (contents_list : Alpha_context.contents_list) {struct ctxt}
  : Lwt.t (Error_monad.tzresult Alpha_context.context) :=
  match contents_list with
  | Alpha_context.Single ((Alpha_context.Manager_operation _) as op) =&gt;
    precheck_manager_contents ctxt chain_id raw_operation op
  | Alpha_context.Cons ((Alpha_context.Manager_operation _) as op) rest =&gt;
    let=? ctxt := precheck_manager_contents ctxt chain_id raw_operation op in
    precheck_manager_contents_list ctxt chain_id raw_operation rest
  | _ =&gt; unreachable_gadt_branch
  end.

Fixpoint apply_manager_contents_list_rec
  (ctxt : Alpha_context.t) (mode : Script_ir_translator.unparsing_mode)
  (baker : Alpha_context.public_key_hash) (chain_id : (|Chain_id|).(S.HASH.t))
  (contents_list : Alpha_context.contents_list) {struct ctxt}
  : Lwt.t (success_or_failure * Apply_results.contents_result_list) :=
  let level := Alpha_context.Level.current ctxt in
  match contents_list with
  |
    Alpha_context.Single
      ((Alpha_context.Manager_operation {|
        Alpha_context.contents.Manager_operation.source := source;
          Alpha_context.contents.Manager_operation.fee := fee
          |}) as op) =&gt;
    let source := Alpha_context.Contract.implicit_contract source in
    let= '(ctxt_result, operation_result, internal_operation_results) :=
      apply_manager_contents ctxt mode chain_id op in
    let __result_value :=
      Apply_results.Manager_operation_result
        {|
          Apply_results.contents_result.Manager_operation_result.balance_updates :=
            Alpha_context.Delegate.cleanup_balance_updates
              [
                ((Alpha_context.Delegate.Contract source),
                  (Alpha_context.Delegate.Debited fee));
                ((Alpha_context.Delegate.Fees baker
                  level.(Alpha_context.Level.t.cycle)),
                  (Alpha_context.Delegate.Credited fee))
              ];
          Apply_results.contents_result.Manager_operation_result.operation_result :=
            operation_result;
          Apply_results.contents_result.Manager_operation_result.internal_operation_results :=
            internal_operation_results |} in
    Lwt.__return (ctxt_result, (Apply_results.Single_result __result_value))
  |
    Alpha_context.Cons
      ((Alpha_context.Manager_operation {|
        Alpha_context.contents.Manager_operation.source := source;
          Alpha_context.contents.Manager_operation.fee := fee
          |}) as op) rest =&gt;
    let source := Alpha_context.Contract.implicit_contract source in
    let= function_parameter := apply_manager_contents ctxt mode chain_id op in
    match function_parameter with
    | (Failure, operation_result, internal_operation_results) =&gt;
      let __result_value :=
        Apply_results.Manager_operation_result
          {|
            Apply_results.contents_result.Manager_operation_result.balance_updates :=
              Alpha_context.Delegate.cleanup_balance_updates
                [
                  ((Alpha_context.Delegate.Contract source),
                    (Alpha_context.Delegate.Debited fee));
                  ((Alpha_context.Delegate.Fees baker
                    level.(Alpha_context.Level.t.cycle)),
                    (Alpha_context.Delegate.Credited fee))
                ];
            Apply_results.contents_result.Manager_operation_result.operation_result :=
              operation_result;
            Apply_results.contents_result.Manager_operation_result.internal_operation_results :=
              internal_operation_results |} in
      Lwt.__return
        (Failure,
          (Apply_results.Cons_result __result_value
            (mark_skipped baker level rest)))
    | (Success ctxt, operation_result, internal_operation_results) =&gt;
      let __result_value :=
        Apply_results.Manager_operation_result
          {|
            Apply_results.contents_result.Manager_operation_result.balance_updates :=
              Alpha_context.Delegate.cleanup_balance_updates
                [
                  ((Alpha_context.Delegate.Contract source),
                    (Alpha_context.Delegate.Debited fee));
                  ((Alpha_context.Delegate.Fees baker
                    level.(Alpha_context.Level.t.cycle)),
                    (Alpha_context.Delegate.Credited fee))
                ];
            Apply_results.contents_result.Manager_operation_result.operation_result :=
              operation_result;
            Apply_results.contents_result.Manager_operation_result.internal_operation_results :=
              internal_operation_results |} in
      let= '(ctxt_result, results) :=
        apply_manager_contents_list_rec ctxt mode baker chain_id rest in
      Lwt.__return
        (ctxt_result, (Apply_results.Cons_result __result_value results))
    end
  | _ =&gt; unreachable_gadt_branch
  end.

Definition mark_backtracked (results : Apply_results.contents_result_list)
  : Apply_results.contents_result_list :=
  let mark_manager_operation_result
    (function_parameter : Apply_results.manager_operation_result)
    : Apply_results.manager_operation_result :=
    match function_parameter with
    |
      (Apply_results.Failed _ _ | Apply_results.Skipped _ |
      Apply_results.Backtracked _ _) as __result_value =&gt; __result_value
    | (Apply_results.Applied (Apply_results.Reveal_result _)) as __result_value
      =&gt; __result_value
    | Apply_results.Applied __result_value =&gt;
      Apply_results.Backtracked __result_value None
    end in
  let mark_internal_operation_results
    (function_parameter : Apply_results.packed_internal_operation_result)
    : Apply_results.packed_internal_operation_result :=
    let 'Apply_results.Internal_operation_result kind __result_value :=
      function_parameter in
    Apply_results.Internal_operation_result kind
      (mark_manager_operation_result __result_value) in
  let fix mark_contents_list
    (function_parameter : Apply_results.contents_result_list)
    {struct function_parameter} : Apply_results.contents_result_list :=
    match function_parameter with
    | Apply_results.Single_result (Apply_results.Manager_operation_result op) =&gt;
      Apply_results.Single_result
        (Apply_results.Manager_operation_result
          {|
            Apply_results.contents_result.Manager_operation_result.balance_updates :=
              op.(Apply_results.contents_result.Manager_operation_result.balance_updates);
            Apply_results.contents_result.Manager_operation_result.operation_result :=
              mark_manager_operation_result
                op.(Apply_results.contents_result.Manager_operation_result.operation_result);
            Apply_results.contents_result.Manager_operation_result.internal_operation_results :=
              List.map mark_internal_operation_results
                op.(Apply_results.contents_result.Manager_operation_result.internal_operation_results)
            |})
    | Apply_results.Cons_result (Apply_results.Manager_operation_result op) rest
      =&gt;
      Apply_results.Cons_result
        (Apply_results.Manager_operation_result
          {|
            Apply_results.contents_result.Manager_operation_result.balance_updates :=
              op.(Apply_results.contents_result.Manager_operation_result.balance_updates);
            Apply_results.contents_result.Manager_operation_result.operation_result :=
              mark_manager_operation_result
                op.(Apply_results.contents_result.Manager_operation_result.operation_result);
            Apply_results.contents_result.Manager_operation_result.internal_operation_results :=
              List.map mark_internal_operation_results
                op.(Apply_results.contents_result.Manager_operation_result.internal_operation_results)
            |}) (mark_contents_list rest)
    | _ =&gt; unreachable_gadt_branch
    end in
  mark_contents_list results.

Definition apply_manager_contents_list
  (ctxt : Alpha_context.t) (mode : Script_ir_translator.unparsing_mode)
  (baker : Alpha_context.public_key_hash) (chain_id : (|Chain_id|).(S.HASH.t))
  (contents_list : Alpha_context.contents_list)
  : Lwt.t (Alpha_context.t * Apply_results.contents_result_list) :=
  let= '(ctxt_result, results) :=
    apply_manager_contents_list_rec ctxt mode baker chain_id contents_list in
  match ctxt_result with
  | Failure =&gt; Lwt.__return (ctxt, (mark_backtracked results))
  | Success ctxt =&gt;
    let= ctxt := Alpha_context.Big_map.cleanup_temporary ctxt in
    Lwt.__return (ctxt, results)
  end.

Definition apply_contents_list
  (ctxt : Alpha_context.context) (chain_id : (|Chain_id|).(S.HASH.t))
  (mode : Script_ir_translator.unparsing_mode)
  (pred_block : (|Block_hash|).(S.HASH.t))
  (baker : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  (operation : Alpha_context.operation)
  (contents_list : Alpha_context.contents_list)
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context * Apply_results.contents_result_list)) :=
  match contents_list with
  |
    Alpha_context.Single
      (Alpha_context.Endorsement {|
        Alpha_context.contents.Endorsement.level := level |}) =&gt;
    let block :=
      operation.(Alpha_context.operation.shell).(Operation.shell_header.branch)
      in
    let=? '_ :=
      Error_monad.fail_unless ((|Block_hash|).(S.HASH.equal) block pred_block)
        extensible_type_value in
    let current_level :=
      (Alpha_context.Level.current ctxt).(Alpha_context.Level.t.level) in
    let=? '_ :=
      Error_monad.fail_unless
        (Alpha_context.Raw_level.op_eq (Alpha_context.Raw_level.succ level)
          current_level) extensible_type_value in
    let=? '(delegate, slots, used) :=
      Baking.check_endorsement_rights ctxt chain_id operation in
    if used then
      Error_monad.fail extensible_type_value
    else
      let ctxt := Alpha_context.record_endorsement ctxt delegate in
      let gap := List.length slots in
      let=? deposit :=
        Lwt.__return
          (Alpha_context.Tez.op_starquestion
            (Alpha_context.Constants.endorsement_security_deposit ctxt)
            (Int64.of_int gap)) in
      let=? ctxt := Alpha_context.Delegate.freeze_deposit ctxt delegate deposit
        in
      let=? block_priority := Alpha_context.Global.get_block_priority ctxt in
      let=? reward := Baking.endorsing_reward ctxt block_priority gap in
      let=? ctxt := Alpha_context.Delegate.freeze_rewards ctxt delegate reward
        in
      let level := Alpha_context.Level.from_raw ctxt None level in
      Error_monad.__return
        (ctxt,
          (Apply_results.Single_result
            (Apply_results.Endorsement_result
              {|
                Apply_results.contents_result.Endorsement_result.balance_updates :=
                  Alpha_context.Delegate.cleanup_balance_updates
                    [
                      ((Alpha_context.Delegate.Contract
                        (Alpha_context.Contract.implicit_contract
                          delegate)),
                        (Alpha_context.Delegate.Debited
                          deposit));
                      ((Alpha_context.Delegate.Deposits delegate
                        level.(Alpha_context.Level.t.cycle)),
                        (Alpha_context.Delegate.Credited
                          deposit));
                      ((Alpha_context.Delegate.Rewards delegate
                        level.(Alpha_context.Level.t.cycle)),
                        (Alpha_context.Delegate.Credited
                          reward))
                    ];
                Apply_results.contents_result.Endorsement_result.delegate :=
                  delegate;
                Apply_results.contents_result.Endorsement_result.slots := slots
                |})))
  |
    Alpha_context.Single
      (Alpha_context.Seed_nonce_revelation {|
        Alpha_context.contents.Seed_nonce_revelation.level := level;
          Alpha_context.contents.Seed_nonce_revelation.nonce := __nonce_value
          |}) =&gt;
    let level := Alpha_context.Level.from_raw ctxt None level in
    let=? ctxt := Alpha_context.Nonce.reveal ctxt level __nonce_value in
    let seed_nonce_revelation_tip :=
      Alpha_context.Constants.seed_nonce_revelation_tip ctxt in
    let=? ctxt := Alpha_context.add_rewards ctxt seed_nonce_revelation_tip in
    Error_monad.__return
      (ctxt,
        (Apply_results.Single_result
          (Apply_results.Seed_nonce_revelation_result
            [
              ((Alpha_context.Delegate.Rewards baker
                level.(Alpha_context.Level.t.cycle)),
                (Alpha_context.Delegate.Credited
                  seed_nonce_revelation_tip))
            ])))
  |
    Alpha_context.Single
      (Alpha_context.Double_endorsement_evidence {|
        Alpha_context.contents.Double_endorsement_evidence.op1 := op1;
          Alpha_context.contents.Double_endorsement_evidence.op2 := op2
          |}) =&gt;
    match
      ((op1.(Alpha_context.operation.protocol_data).(Alpha_context.protocol_data.contents),
        op2.(Alpha_context.operation.protocol_data).(Alpha_context.protocol_data.contents)),
        match
          (op1.(Alpha_context.operation.protocol_data).(Alpha_context.protocol_data.contents),
            op2.(Alpha_context.operation.protocol_data).(Alpha_context.protocol_data.contents))
          with
        |
          (Alpha_context.Single (Alpha_context.Endorsement e1),
            Alpha_context.Single (Alpha_context.Endorsement e2)) =&gt;
          Pervasives.op_andand
            (Alpha_context.Raw_level.op_eq
              e1.(Alpha_context.contents.Endorsement.level)
              e2.(Alpha_context.contents.Endorsement.level))
            (Pervasives.not
              ((|Block_hash|).(S.HASH.equal)
                op1.(Alpha_context.operation.shell).(Operation.shell_header.branch)
                op2.(Alpha_context.operation.shell).(Operation.shell_header.branch)))
        | _ =&gt; false
        end) with
    |
      ((Alpha_context.Single (Alpha_context.Endorsement e1),
        Alpha_context.Single (Alpha_context.Endorsement e2)), true) =&gt;
      let level :=
        Alpha_context.Level.from_raw ctxt None
          e1.(Alpha_context.contents.Endorsement.level) in
      let oldest_level := Alpha_context.Level.last_allowed_fork_level ctxt in
      let=? '_ :=
        Error_monad.fail_unless
          (Alpha_context.Level.op_lt level (Alpha_context.Level.current ctxt))
          extensible_type_value in
      let=? '_ :=
        Error_monad.fail_unless
          (Alpha_context.Raw_level.op_lteq oldest_level
            level.(Alpha_context.Level.t.level)) extensible_type_value in
      let=? '(delegate1, _, _) :=
        Baking.check_endorsement_rights ctxt chain_id op1 in
      let=? '(delegate2, _, _) :=
        Baking.check_endorsement_rights ctxt chain_id op2 in
      let=? '_ :=
        Error_monad.fail_unless
          ((|Signature.Public_key_hash|).(S.SPublic_key_hash.equal) delegate1
            delegate2) extensible_type_value in
      let=? valid :=
        Alpha_context.Delegate.has_frozen_balance ctxt delegate1
          level.(Alpha_context.Level.t.cycle) in
      let=? '_ := Error_monad.fail_unless valid extensible_type_value in
      let=? '(ctxt, balance) :=
        Alpha_context.Delegate.punish ctxt delegate1
          level.(Alpha_context.Level.t.cycle) in
      let=? burned :=
        Lwt.__return
          (Alpha_context.Tez.op_plusquestion
            balance.(Alpha_context.Delegate.frozen_balance.deposit)
            balance.(Alpha_context.Delegate.frozen_balance.fees)) in
      let reward :=
        match
          Alpha_context.Tez.op_divquestion burned
            (* ‚ùå Constant of type int64 is converted to int *)
            2 with
        | Pervasives.Ok v =&gt; v
        | Pervasives.Error _ =&gt; Alpha_context.Tez.zero
        end in
      let=? ctxt := Alpha_context.add_rewards ctxt reward in
      let current_cycle :=
        (Alpha_context.Level.current ctxt).(Alpha_context.Level.t.cycle) in
      Error_monad.__return
        (ctxt,
          (Apply_results.Single_result
            (Apply_results.Double_endorsement_evidence_result
              (Alpha_context.Delegate.cleanup_balance_updates
                [
                  ((Alpha_context.Delegate.Deposits delegate1
                    level.(Alpha_context.Level.t.cycle)),
                    (Alpha_context.Delegate.Debited
                      balance.(Alpha_context.Delegate.frozen_balance.deposit)));
                  ((Alpha_context.Delegate.Fees delegate1
                    level.(Alpha_context.Level.t.cycle)),
                    (Alpha_context.Delegate.Debited
                      balance.(Alpha_context.Delegate.frozen_balance.fees)));
                  ((Alpha_context.Delegate.Rewards delegate1
                    level.(Alpha_context.Level.t.cycle)),
                    (Alpha_context.Delegate.Debited
                      balance.(Alpha_context.Delegate.frozen_balance.rewards)));
                  ((Alpha_context.Delegate.Rewards baker current_cycle),
                    (Alpha_context.Delegate.Credited reward))
                ]))))
    | ((_, _), _) =&gt; Error_monad.fail extensible_type_value
    end
  |
    Alpha_context.Single
      (Alpha_context.Double_baking_evidence {|
        Alpha_context.contents.Double_baking_evidence.bh1 := bh1;
          Alpha_context.contents.Double_baking_evidence.bh2 := bh2
          |}) =&gt;
    let hash1 := Alpha_context.Block_header.__hash_value bh1 in
    let hash2 := Alpha_context.Block_header.__hash_value bh2 in
    let=? '_ :=
      Error_monad.fail_unless
        (Pervasives.op_andand
          ((|Compare.Int32|).(Compare.S.op_eq)
            bh1.(Alpha_context.Block_header.block_header.shell).(Block_header.shell_header.level)
            bh2.(Alpha_context.Block_header.block_header.shell).(Block_header.shell_header.level))
          (Pervasives.not ((|Block_hash|).(S.HASH.equal) hash1 hash2)))
        extensible_type_value in
    let=? raw_level :=
      Lwt.__return
        (Alpha_context.Raw_level.of_int32
          bh1.(Alpha_context.Block_header.block_header.shell).(Block_header.shell_header.level))
      in
    let oldest_level := Alpha_context.Level.last_allowed_fork_level ctxt in
    let=? '_ :=
      Error_monad.fail_unless
        (Alpha_context.Raw_level.op_lt raw_level
          (Alpha_context.Level.current ctxt).(Alpha_context.Level.t.level))
        extensible_type_value in
    let=? '_ :=
      Error_monad.fail_unless
        (Alpha_context.Raw_level.op_lteq oldest_level raw_level)
        extensible_type_value in
    let level := Alpha_context.Level.from_raw ctxt None raw_level in
    let=? delegate1 :=
      Alpha_context.Roll.baking_rights_owner ctxt level
        bh1.(Alpha_context.Block_header.block_header.protocol_data).(Alpha_context.Block_header.protocol_data.contents).(Alpha_context.Block_header.contents.priority)
      in
    let=? '_ := Baking.check_signature bh1 chain_id delegate1 in
    let=? delegate2 :=
      Alpha_context.Roll.baking_rights_owner ctxt level
        bh2.(Alpha_context.Block_header.block_header.protocol_data).(Alpha_context.Block_header.protocol_data.contents).(Alpha_context.Block_header.contents.priority)
      in
    let=? '_ := Baking.check_signature bh2 chain_id delegate2 in
    let=? '_ :=
      Error_monad.fail_unless
        ((|Signature.Public_key|).(S.SPublic_key.equal) delegate1 delegate2)
        extensible_type_value in
    let delegate :=
      (|Signature.Public_key|).(S.SPublic_key.__hash_value) delegate1 in
    let=? valid :=
      Alpha_context.Delegate.has_frozen_balance ctxt delegate
        level.(Alpha_context.Level.t.cycle) in
    let=? '_ := Error_monad.fail_unless valid extensible_type_value in
    let=? '(ctxt, balance) :=
      Alpha_context.Delegate.punish ctxt delegate
        level.(Alpha_context.Level.t.cycle) in
    let=? burned :=
      Lwt.__return
        (Alpha_context.Tez.op_plusquestion
          balance.(Alpha_context.Delegate.frozen_balance.deposit)
          balance.(Alpha_context.Delegate.frozen_balance.fees)) in
    let reward :=
      match
        Alpha_context.Tez.op_divquestion burned
          (* ‚ùå Constant of type int64 is converted to int *)
          2 with
      | Pervasives.Ok v =&gt; v
      | Pervasives.Error _ =&gt; Alpha_context.Tez.zero
      end in
    let=? ctxt := Alpha_context.add_rewards ctxt reward in
    let current_cycle :=
      (Alpha_context.Level.current ctxt).(Alpha_context.Level.t.cycle) in
    Error_monad.__return
      (ctxt,
        (Apply_results.Single_result
          (Apply_results.Double_baking_evidence_result
            (Alpha_context.Delegate.cleanup_balance_updates
              [
                ((Alpha_context.Delegate.Deposits delegate
                  level.(Alpha_context.Level.t.cycle)),
                  (Alpha_context.Delegate.Debited
                    balance.(Alpha_context.Delegate.frozen_balance.deposit)));
                ((Alpha_context.Delegate.Fees delegate
                  level.(Alpha_context.Level.t.cycle)),
                  (Alpha_context.Delegate.Debited
                    balance.(Alpha_context.Delegate.frozen_balance.fees)));
                ((Alpha_context.Delegate.Rewards delegate
                  level.(Alpha_context.Level.t.cycle)),
                  (Alpha_context.Delegate.Debited
                    balance.(Alpha_context.Delegate.frozen_balance.rewards)));
                ((Alpha_context.Delegate.Rewards baker current_cycle),
                  (Alpha_context.Delegate.Credited reward))
              ]))))
  |
    Alpha_context.Single
      (Alpha_context.Activate_account {|
        Alpha_context.contents.Activate_account.id := pkh;
          Alpha_context.contents.Activate_account.activation_code :=
            activation_code
          |}) =&gt;
    let blinded_pkh :=
      Blinded_public_key_hash.of_ed25519_pkh activation_code pkh in
    let=? function_parameter :=
      Alpha_context.Commitment.get_opt ctxt blinded_pkh in
    match function_parameter with
    | None =&gt; Error_monad.fail extensible_type_value
    | Some amount =&gt;
      let=? ctxt := Alpha_context.Commitment.delete ctxt blinded_pkh in
      let contract :=
        Alpha_context.Contract.implicit_contract (Signature.Ed25519Hash pkh) in
      let=? ctxt := Alpha_context.Contract.credit ctxt contract amount in
      Error_monad.__return
        (ctxt,
          (Apply_results.Single_result
            (Apply_results.Activate_account_result
              [
                ((Alpha_context.Delegate.Contract contract),
                  (Alpha_context.Delegate.Credited amount))
              ])))
    end
  |
    Alpha_context.Single
      (Alpha_context.Proposals {|
        Alpha_context.contents.Proposals.source := source;
          Alpha_context.contents.Proposals.period := period;
          Alpha_context.contents.Proposals.proposals := proposals
          |}) =&gt;
    let=? delegate := Alpha_context.Roll.delegate_pubkey ctxt source in
    let=? '_ :=
      Alpha_context.Operation.check_signature delegate chain_id operation in
    let level := Alpha_context.Level.current ctxt in
    let=? '_ :=
      Error_monad.fail_unless
        (Alpha_context.Voting_period.op_eq
          level.(Alpha_context.Level.t.voting_period) period)
        extensible_type_value in
    let=? ctxt := Amendment.record_proposals ctxt source proposals in
    Error_monad.__return
      (ctxt, (Apply_results.Single_result Apply_results.Proposals_result))
  |
    Alpha_context.Single
      (Alpha_context.Ballot {|
        Alpha_context.contents.Ballot.source := source;
          Alpha_context.contents.Ballot.period := period;
          Alpha_context.contents.Ballot.proposal := proposal;
          Alpha_context.contents.Ballot.ballot := ballot
          |}) =&gt;
    let=? delegate := Alpha_context.Roll.delegate_pubkey ctxt source in
    let=? '_ :=
      Alpha_context.Operation.check_signature delegate chain_id operation in
    let level := Alpha_context.Level.current ctxt in
    let=? '_ :=
      Error_monad.fail_unless
        (Alpha_context.Voting_period.op_eq
          level.(Alpha_context.Level.t.voting_period) period)
        extensible_type_value in
    let=? ctxt := Amendment.record_ballot ctxt source proposal ballot in
    Error_monad.__return
      (ctxt, (Apply_results.Single_result Apply_results.Ballot_result))
  | (Alpha_context.Single (Alpha_context.Manager_operation _)) as op =&gt;
    let=? ctxt := precheck_manager_contents_list ctxt chain_id operation op in
    let= '(ctxt, __result_value) :=
      apply_manager_contents_list ctxt mode baker chain_id op in
    Error_monad.__return (ctxt, __result_value)
  | (Alpha_context.Cons (Alpha_context.Manager_operation _) _) as op =&gt;
    let=? ctxt := precheck_manager_contents_list ctxt chain_id operation op in
    let= '(ctxt, __result_value) :=
      apply_manager_contents_list ctxt mode baker chain_id op in
    Error_monad.__return (ctxt, __result_value)
  | _ =&gt; unreachable_gadt_branch
  end.

Definition apply_operation
  (ctxt : Alpha_context.context) (chain_id : (|Chain_id|).(S.HASH.t))
  (mode : Script_ir_translator.unparsing_mode)
  (pred_block : (|Block_hash|).(S.HASH.t))
  (baker : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  (__hash_value : (|Operation_hash|).(S.HASH.t))
  (operation : Alpha_context.operation)
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context * Apply_results.operation_metadata)) :=
  let ctxt := Alpha_context.Contract.init_origination_nonce ctxt __hash_value in
  let=? '(ctxt, __result_value) :=
    apply_contents_list ctxt chain_id mode pred_block baker operation
      operation.(Alpha_context.operation.protocol_data).(Alpha_context.protocol_data.contents)
    in
  let ctxt := Alpha_context.Gas.set_unlimited ctxt in
  let ctxt := Alpha_context.Contract.unset_origination_nonce ctxt in
  Error_monad.__return
    (ctxt, {| Apply_results.operation_metadata.contents := __result_value |}).

Definition may_snapshot_roll (ctxt : Alpha_context.context)
  : Lwt.t (Error_monad.tzresult Alpha_context.context) :=
  let level := Alpha_context.Level.current ctxt in
  let blocks_per_roll_snapshot :=
    Alpha_context.Constants.blocks_per_roll_snapshot ctxt in
  if
    (|Compare.Int32|).(Compare.S.equal)
      (Int32.rem level.(Alpha_context.Level.t.cycle_position)
        blocks_per_roll_snapshot) (Int32.pred blocks_per_roll_snapshot) then
    let=? ctxt := Alpha_context.Roll.snapshot_rolls ctxt in
    Error_monad.__return ctxt
  else
    Error_monad.__return ctxt.

Definition may_start_new_cycle (ctxt : Alpha_context.context)
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context * Alpha_context.Delegate.balance_updates *
        list (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))) :=
  let=? function_parameter := Baking.dawn_of_a_new_cycle ctxt in
  match function_parameter with
  | None =&gt; Error_monad.__return (ctxt, nil, nil)
  | Some last_cycle =&gt;
    let=? '(ctxt, unrevealed) := Alpha_context.Seed.cycle_end ctxt last_cycle in
    let=? ctxt := Alpha_context.Roll.cycle_end ctxt last_cycle in
    let=? '(ctxt, update_balances, deactivated) :=
      Alpha_context.Delegate.cycle_end ctxt last_cycle unrevealed in
    let=? ctxt := Alpha_context.Bootstrap.cycle_end ctxt last_cycle in
    Error_monad.__return (ctxt, update_balances, deactivated)
  end.

Definition begin_full_construction
  (ctxt : Alpha_context.context) (pred_timestamp : Time.t)
  (protocol_data : Block_header_repr.contents)
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context * Block_header_repr.contents *
        Alpha_context.public_key * Alpha_context.Period.t)) :=
  let=? ctxt :=
    Alpha_context.Global.set_block_priority ctxt
      protocol_data.(Block_header_repr.contents.priority) in
  let=? '(delegate_pk, block_delay) :=
    Baking.check_baking_rights ctxt protocol_data pred_timestamp in
  let ctxt := Alpha_context.Fitness.increase None ctxt in
  match Alpha_context.Level.pred ctxt (Alpha_context.Level.current ctxt) with
  | None =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * Block_header_repr.contents *
            Alpha_context.public_key * Alpha_context.Period.t))) false
  | Some pred_level =&gt;
    let=? rights := Baking.endorsement_rights ctxt pred_level in
    let ctxt := Alpha_context.init_endorsements ctxt rights in
    Error_monad.__return (ctxt, protocol_data, delegate_pk, block_delay)
  end.

Definition begin_partial_construction (ctxt : Alpha_context.context)
  : Lwt.t (Error_monad.tzresult Alpha_context.context) :=
  let ctxt := Alpha_context.Fitness.increase None ctxt in
  match Alpha_context.Level.pred ctxt (Alpha_context.Level.current ctxt) with
  | None =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert (Lwt.t (Error_monad.tzresult Alpha_context.context)) false
  | Some pred_level =&gt;
    let=? rights := Baking.endorsement_rights ctxt pred_level in
    let ctxt := Alpha_context.init_endorsements ctxt rights in
    Error_monad.__return ctxt
  end.

Definition begin_application
  (ctxt : Alpha_context.context) (chain_id : (|Chain_id|).(S.HASH.t))
  (block_header : Block_header_repr.block_header) (pred_timestamp : Time.t)
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context * Alpha_context.public_key * Alpha_context.Period.t)) :=
  let=? ctxt :=
    Alpha_context.Global.set_block_priority ctxt
      block_header.(Block_header_repr.block_header.protocol_data).(Block_header_repr.protocol_data.contents).(Block_header_repr.contents.priority)
    in
  let current_level := Alpha_context.Level.current ctxt in
  let=? '_ := Baking.check_proof_of_work_stamp ctxt block_header in
  let=? '_ := Baking.check_fitness_gap ctxt block_header in
  let=? '(delegate_pk, block_delay) :=
    Baking.check_baking_rights ctxt
      block_header.(Block_header_repr.block_header.protocol_data).(Block_header_repr.protocol_data.contents)
      pred_timestamp in
  let=? '_ := Baking.check_signature block_header chain_id delegate_pk in
  let has_commitment :=
    match
      block_header.(Block_header_repr.block_header.protocol_data).(Block_header_repr.protocol_data.contents).(Block_header_repr.contents.seed_nonce_hash)
      with
    | None =&gt; false
    | Some _ =&gt; true
    end in
  let=? '_ :=
    Error_monad.fail_unless
      ((|Compare.Bool|).(Compare.S.op_eq) has_commitment
        current_level.(Alpha_context.Level.t.expected_commitment))
      extensible_type_value in
  let ctxt := Alpha_context.Fitness.increase None ctxt in
  match Alpha_context.Level.pred ctxt (Alpha_context.Level.current ctxt) with
  | None =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * Alpha_context.public_key *
            Alpha_context.Period.t))) false
  | Some pred_level =&gt;
    let=? rights := Baking.endorsement_rights ctxt pred_level in
    let ctxt := Alpha_context.init_endorsements ctxt rights in
    Error_monad.__return (ctxt, delegate_pk, block_delay)
  end.

Definition check_minimum_endorsements
  (ctxt : Alpha_context.context) (protocol_data : Block_header_repr.contents)
  (block_delay : Alpha_context.Period.t)
  (included_endorsements : (|Compare.Int|).(Compare.S.t))
  : Lwt.t (Error_monad.tzresult unit) :=
  let minimum := Baking.minimum_allowed_endorsements ctxt block_delay in
  let timestamp := Alpha_context.Timestamp.current ctxt in
  Error_monad.fail_unless
    ((|Compare.Int|).(Compare.S.op_gteq) included_endorsements minimum)
    extensible_type_value.

Definition finalize_application
  (ctxt : Alpha_context.context) (protocol_data : Block_header_repr.contents)
  (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  (block_delay : Alpha_context.Period.t)
  : Lwt.t
    (Error_monad.tzresult (Alpha_context.context * Apply_results.block_metadata)) :=
  let included_endorsements := Alpha_context.included_endorsements ctxt in
  let=? '_ :=
    check_minimum_endorsements ctxt protocol_data block_delay
      included_endorsements in
  let deposit := Alpha_context.Constants.block_security_deposit ctxt in
  let=? ctxt := Alpha_context.add_deposit ctxt delegate deposit in
  let=? reward :=
    Baking.baking_reward ctxt
      protocol_data.(Block_header_repr.contents.priority) included_endorsements
    in
  let=? ctxt := Alpha_context.add_rewards ctxt reward in
  let=? ctxt :=
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.fold)
      (fun delegate =&gt;
        fun deposit =&gt;
          fun ctxt =&gt;
            let=? ctxt := ctxt in
            Alpha_context.Delegate.freeze_deposit ctxt delegate deposit)
      (Alpha_context.get_deposits ctxt) (Error_monad.__return ctxt) in
  let fees := Alpha_context.get_fees ctxt in
  let=? ctxt := Alpha_context.Delegate.freeze_fees ctxt delegate fees in
  let rewards := Alpha_context.get_rewards ctxt in
  let=? ctxt := Alpha_context.Delegate.freeze_rewards ctxt delegate rewards in
  let=? ctxt :=
    match protocol_data.(Block_header_repr.contents.seed_nonce_hash) with
    | None =&gt; Error_monad.__return ctxt
    | Some nonce_hash =&gt;
      Alpha_context.Nonce.record_hash ctxt
        {| Storage.unrevealed_nonce.nonce_hash := nonce_hash;
          Storage.unrevealed_nonce.delegate := delegate;
          Storage.unrevealed_nonce.rewards := rewards;
          Storage.unrevealed_nonce.fees := fees |}
    end in
  let=? ctxt := may_snapshot_roll ctxt in
  let=? '(ctxt, balance_updates, deactivated) := may_start_new_cycle ctxt in
  let=? ctxt := Amendment.may_start_new_voting_period ctxt in
  let cycle := (Alpha_context.Level.current ctxt).(Alpha_context.Level.t.cycle)
    in
  let balance_updates :=
    Alpha_context.Delegate.cleanup_balance_updates
      (Pervasives.op_at
        [
          ((Alpha_context.Delegate.Contract
            (Alpha_context.Contract.implicit_contract delegate)),
            (Alpha_context.Delegate.Debited deposit));
          ((Alpha_context.Delegate.Deposits delegate cycle),
            (Alpha_context.Delegate.Credited deposit));
          ((Alpha_context.Delegate.Rewards delegate cycle),
            (Alpha_context.Delegate.Credited reward))
        ] balance_updates) in
  let consumed_gas :=
    Z.sub (Alpha_context.Constants.hard_gas_limit_per_block ctxt)
      (Alpha_context.Gas.block_level ctxt) in
  let=? voting_period_kind := Alpha_context.Vote.get_current_period_kind ctxt in
  let receipt :=
    {| Apply_results.block_metadata.baker := delegate;
      Apply_results.block_metadata.level := Alpha_context.Level.current ctxt;
      Apply_results.block_metadata.voting_period_kind := voting_period_kind;
      Apply_results.block_metadata.nonce_hash :=
        protocol_data.(Block_header_repr.contents.seed_nonce_hash);
      Apply_results.block_metadata.consumed_gas := consumed_gas;
      Apply_results.block_metadata.deactivated := deactivated;
      Apply_results.block_metadata.balance_updates := balance_updates |} in
  Error_monad.__return (ctxt, receipt).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="apply_results.ml">
  <div style="margin: 20px;">
    <h3>Apply_results</h3>
    <ul>
      <li>OCaml size: 1198 lines</li>
      <li>Coq size: 2135 lines (+78% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#apply_results.ml"><code>apply_results.ml</code></a>&nbsp;<span class="label label-warning">7 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context
open Data_encoding

let error_encoding =
  def
    &quot;error&quot;
    ~description:
      &quot;The full list of RPC errors would be too long to include.\n\
       It is available at RPC `/errors` (GET).\n\
       Errors specific to protocol Alpha have an id that starts with \
       `proto.alpha`.&quot;
  @@ splitted
       ~json:
         (conv
            (fun err -&gt;
              Data_encoding.Json.construct Error_monad.error_encoding err)
            (fun json -&gt;
              Data_encoding.Json.destruct Error_monad.error_encoding json)
            json)
       ~binary:Error_monad.error_encoding

type _ successful_manager_operation_result =
  | Reveal_result : {
      consumed_gas : Z.t;
    }
      -&gt; Kind.reveal successful_manager_operation_result
  | Transaction_result : {
      storage : Script.expr option;
      big_map_diff : Contract.big_map_diff option;
      balance_updates : Delegate.balance_updates;
      originated_contracts : Contract.t list;
      consumed_gas : Z.t;
      storage_size : Z.t;
      paid_storage_size_diff : Z.t;
      allocated_destination_contract : bool;
    }
      -&gt; Kind.transaction successful_manager_operation_result
  | Origination_result : {
      big_map_diff : Contract.big_map_diff option;
      balance_updates : Delegate.balance_updates;
      originated_contracts : Contract.t list;
      consumed_gas : Z.t;
      storage_size : Z.t;
      paid_storage_size_diff : Z.t;
    }
      -&gt; Kind.origination successful_manager_operation_result
  | Delegation_result : {
      consumed_gas : Z.t;
    }
      -&gt; Kind.delegation successful_manager_operation_result

type packed_successful_manager_operation_result =
  | Successful_manager_result :
      'kind successful_manager_operation_result
      -&gt; packed_successful_manager_operation_result

type 'kind manager_operation_result =
  | Applied of 'kind successful_manager_operation_result
  | Backtracked of
      'kind successful_manager_operation_result * error list option
  | Failed : 'kind Kind.manager * error list -&gt; 'kind manager_operation_result
  | Skipped : 'kind Kind.manager -&gt; 'kind manager_operation_result
[@@coq_force_gadt]

type packed_internal_operation_result =
  | Internal_operation_result :
      'kind internal_operation * 'kind manager_operation_result
      -&gt; packed_internal_operation_result

module Manager_result = struct
  type 'kind case =
    | MCase : {
        op_case : 'kind Operation.Encoding.Manager_operations.case;
        encoding : 'a Data_encoding.t;
        kind : 'kind Kind.manager;
        iselect :
          packed_internal_operation_result -&gt;
          ('kind internal_operation * 'kind manager_operation_result) option;
        select :
          packed_successful_manager_operation_result -&gt;
          'kind successful_manager_operation_result option;
        proj : 'kind successful_manager_operation_result -&gt; 'a;
        inj : 'a -&gt; 'kind successful_manager_operation_result;
        t : 'kind manager_operation_result Data_encoding.t;
      }
        -&gt; 'kind case
  [@@coq_force_gadt]

  let make ~op_case ~encoding ~kind ~iselect ~select ~proj ~inj =
    let (Operation.Encoding.Manager_operations.MCase {name; _}) = op_case in
    let t =
      def (Format.asprintf &quot;operation.alpha.operation_result.%s&quot; name)
      @@ union
           ~tag_size:`Uint8
           [ case
               (Tag 0)
               ~title:&quot;Applied&quot;
               (merge_objs (obj1 (req &quot;status&quot; (constant &quot;applied&quot;))) encoding)
               (fun o -&gt;
                 match o with
                 | Skipped _ | Failed _ | Backtracked _ -&gt;
                     None
                 | Applied o -&gt; (
                   match select (Successful_manager_result o) with
                   | None -&gt;
                       None
                   | Some o -&gt;
                       Some ((), proj o) ))
               (fun ((), x) -&gt; Applied (inj x));
             case
               (Tag 1)
               ~title:&quot;Failed&quot;
               (obj2
                  (req &quot;status&quot; (constant &quot;failed&quot;))
                  (req &quot;errors&quot; (list error_encoding)))
               (function Failed (_, errs) -&gt; Some ((), errs) | _ -&gt; None)
               (fun ((), errs) -&gt; Failed (kind, errs));
             case
               (Tag 2)
               ~title:&quot;Skipped&quot;
               (obj1 (req &quot;status&quot; (constant &quot;skipped&quot;)))
               (function Skipped _ -&gt; Some () | _ -&gt; None)
               (fun () -&gt; Skipped kind);
             case
               (Tag 3)
               ~title:&quot;Backtracked&quot;
               (merge_objs
                  (obj2
                     (req &quot;status&quot; (constant &quot;backtracked&quot;))
                     (opt &quot;errors&quot; (list error_encoding)))
                  encoding)
               (fun o -&gt;
                 match o with
                 | Skipped _ | Failed _ | Applied _ -&gt;
                     None
                 | Backtracked (o, errs) -&gt; (
                   match select (Successful_manager_result o) with
                   | None -&gt;
                       None
                   | Some o -&gt;
                       Some (((), errs), proj o) ))
               (fun (((), errs), x) -&gt; Backtracked (inj x, errs)) ]
    in
    MCase {op_case; encoding; kind; iselect; select; proj; inj; t}

  let reveal_case : Kind.reveal case =
    make
      ~op_case:Operation.Encoding.Manager_operations.reveal_case
      ~encoding:Data_encoding.(obj1 (dft &quot;consumed_gas&quot; z Z.zero))
      ~iselect:(function
        | Internal_operation_result (({operation = Reveal _; _} as op), res) -&gt;
            Some (op, res)
        | _ -&gt;
            None)
      ~select:(function
        | Successful_manager_result (Reveal_result _ as op) -&gt;
            Some op
        | _ -&gt;
            None)
      ~kind:Kind.Reveal_manager_kind
      ~proj:(function[@coq_match_with_default]
        | Reveal_result {consumed_gas} -&gt; consumed_gas)
      ~inj:(fun consumed_gas -&gt; Reveal_result {consumed_gas})

  let transaction_case =
    make
      ~op_case:Operation.Encoding.Manager_operations.transaction_case
      ~encoding:
        (obj8
           (opt &quot;storage&quot; Script.expr_encoding)
           (opt &quot;big_map_diff&quot; Contract.big_map_diff_encoding)
           (dft &quot;balance_updates&quot; Delegate.balance_updates_encoding [])
           (dft &quot;originated_contracts&quot; (list Contract.encoding) [])
           (dft &quot;consumed_gas&quot; z Z.zero)
           (dft &quot;storage_size&quot; z Z.zero)
           (dft &quot;paid_storage_size_diff&quot; z Z.zero)
           (dft &quot;allocated_destination_contract&quot; bool false))
      ~iselect:(function
        | Internal_operation_result
            (({operation = Transaction _; _} as op), res) -&gt;
            Some (op, res)
        | _ -&gt;
            None)
      ~select:(function
        | Successful_manager_result (Transaction_result _ as op) -&gt;
            Some op
        | _ -&gt;
            None)
      ~kind:Kind.Transaction_manager_kind
      ~proj:(function[@coq_match_with_default]
        | Transaction_result
            { storage;
              big_map_diff;
              balance_updates;
              originated_contracts;
              consumed_gas;
              storage_size;
              paid_storage_size_diff;
              allocated_destination_contract } -&gt;
            ( storage,
              big_map_diff,
              balance_updates,
              originated_contracts,
              consumed_gas,
              storage_size,
              paid_storage_size_diff,
              allocated_destination_contract ))
      ~inj:
        (fun ( storage,
               big_map_diff,
               balance_updates,
               originated_contracts,
               consumed_gas,
               storage_size,
               paid_storage_size_diff,
               allocated_destination_contract ) -&gt;
        Transaction_result
          {
            storage;
            big_map_diff;
            balance_updates;
            originated_contracts;
            consumed_gas;
            storage_size;
            paid_storage_size_diff;
            allocated_destination_contract;
          })

  let origination_case =
    make
      ~op_case:Operation.Encoding.Manager_operations.origination_case
      ~encoding:
        (obj6
           (opt &quot;big_map_diff&quot; Contract.big_map_diff_encoding)
           (dft &quot;balance_updates&quot; Delegate.balance_updates_encoding [])
           (dft &quot;originated_contracts&quot; (list Contract.encoding) [])
           (dft &quot;consumed_gas&quot; z Z.zero)
           (dft &quot;storage_size&quot; z Z.zero)
           (dft &quot;paid_storage_size_diff&quot; z Z.zero))
      ~iselect:(function
        | Internal_operation_result
            (({operation = Origination _; _} as op), res) -&gt;
            Some (op, res)
        | _ -&gt;
            None)
      ~select:(function
        | Successful_manager_result (Origination_result _ as op) -&gt;
            Some op
        | _ -&gt;
            None)
      ~proj:(function[@coq_match_with_default]
        | Origination_result
            { big_map_diff;
              balance_updates;
              originated_contracts;
              consumed_gas;
              storage_size;
              paid_storage_size_diff } -&gt;
            ( big_map_diff,
              balance_updates,
              originated_contracts,
              consumed_gas,
              storage_size,
              paid_storage_size_diff ))
      ~kind:Kind.Origination_manager_kind
      ~inj:
        (fun ( big_map_diff,
               balance_updates,
               originated_contracts,
               consumed_gas,
               storage_size,
               paid_storage_size_diff ) -&gt;
        Origination_result
          {
            big_map_diff;
            balance_updates;
            originated_contracts;
            consumed_gas;
            storage_size;
            paid_storage_size_diff;
          })

  let delegation_case =
    make
      ~op_case:Operation.Encoding.Manager_operations.delegation_case
      ~encoding:Data_encoding.(obj1 (dft &quot;consumed_gas&quot; z Z.zero))
      ~iselect:(function
        | Internal_operation_result (({operation = Delegation _; _} as op), res)
          -&gt;
            Some (op, res)
        | _ -&gt;
            None)
      ~select:(function
        | Successful_manager_result (Delegation_result _ as op) -&gt;
            Some op
        | _ -&gt;
            None)
      ~kind:Kind.Delegation_manager_kind
      ~proj:(function[@coq_match_with_default]
        | Delegation_result {consumed_gas} -&gt; consumed_gas)
      ~inj:(fun consumed_gas -&gt; Delegation_result {consumed_gas})
end

let internal_operation_result_encoding :
    packed_internal_operation_result Data_encoding.t =
  let make (type kind)
      (Manager_result.MCase res_case : kind Manager_result.case) =
    let (Operation.Encoding.Manager_operations.MCase op_case) =
      res_case.op_case
    in
    case
      (Tag op_case.tag)
      ~title:op_case.name
      (merge_objs
         (obj3
            (req &quot;kind&quot; (constant op_case.name))
            (req &quot;source&quot; Contract.encoding)
            (req &quot;nonce&quot; uint16))
         (merge_objs op_case.encoding (obj1 (req &quot;result&quot; res_case.t))))
      (fun op -&gt;
        match res_case.iselect op with
        | Some (op, res) -&gt;
            Some (((), op.source, op.nonce), (op_case.proj op.operation, res))
        | None -&gt;
            None)
      (fun (((), source, nonce), (op, res)) -&gt;
        let op = {source; operation = op_case.inj op; nonce} in
        Internal_operation_result (op, res))
  in
  def &quot;operation.alpha.internal_operation_result&quot;
  @@ union
       [ make Manager_result.reveal_case;
         make Manager_result.transaction_case;
         make Manager_result.origination_case;
         make Manager_result.delegation_case ]

type 'kind contents_result =
  | Endorsement_result : {
      balance_updates : Delegate.balance_updates;
      delegate : Signature.Public_key_hash.t;
      slots : int list;
    }
      -&gt; Kind.endorsement contents_result
  | Seed_nonce_revelation_result :
      Delegate.balance_updates
      -&gt; Kind.seed_nonce_revelation contents_result
  | Double_endorsement_evidence_result :
      Delegate.balance_updates
      -&gt; Kind.double_endorsement_evidence contents_result
  | Double_baking_evidence_result :
      Delegate.balance_updates
      -&gt; Kind.double_baking_evidence contents_result
  | Activate_account_result :
      Delegate.balance_updates
      -&gt; Kind.activate_account contents_result
  | Proposals_result : Kind.proposals contents_result
  | Ballot_result : Kind.ballot contents_result
  | Manager_operation_result : {
      balance_updates : Delegate.balance_updates;
      operation_result : 'kind manager_operation_result;
      internal_operation_results : packed_internal_operation_result list;
    }
      -&gt; 'kind Kind.manager contents_result

type packed_contents_result =
  | Contents_result : 'kind contents_result -&gt; packed_contents_result

type packed_contents_and_result =
  | Contents_and_result :
      'kind Operation.contents * 'kind contents_result
      -&gt; packed_contents_and_result

type ('a, 'b) eq = Eq : ('a, 'a) eq

let equal_manager_kind :
    type a b. a Kind.manager -&gt; b Kind.manager -&gt; (a, b) eq option =
 fun ka kb -&gt;
  match (ka, kb) with
  | (Kind.Reveal_manager_kind, Kind.Reveal_manager_kind) -&gt;
      Some Eq
  | (Kind.Reveal_manager_kind, _) -&gt;
      None
  | (Kind.Transaction_manager_kind, Kind.Transaction_manager_kind) -&gt;
      Some Eq
  | (Kind.Transaction_manager_kind, _) -&gt;
      None
  | (Kind.Origination_manager_kind, Kind.Origination_manager_kind) -&gt;
      Some Eq
  | (Kind.Origination_manager_kind, _) -&gt;
      None
  | (Kind.Delegation_manager_kind, Kind.Delegation_manager_kind) -&gt;
      Some Eq
  | (Kind.Delegation_manager_kind, _) -&gt;
      None

module Encoding = struct
  type 'kind case =
    | Case : {
        op_case : 'kind Operation.Encoding.case;
        encoding : 'a Data_encoding.t;
        select : packed_contents_result -&gt; 'kind contents_result option;
        mselect :
          packed_contents_and_result -&gt;
          ('kind contents * 'kind contents_result) option;
        proj : 'kind contents_result -&gt; 'a;
        inj : 'a -&gt; 'kind contents_result;
      }
        -&gt; 'kind case
  [@@coq_force_gadt]

  let tagged_case tag name args proj inj =
    let open Data_encoding in
    case
      tag
      ~title:(String.capitalize_ascii name)
      (merge_objs (obj1 (req &quot;kind&quot; (constant name))) args)
      (fun x -&gt; match proj x with None -&gt; None | Some x -&gt; Some ((), x))
      (fun ((), x) -&gt; inj x)

  let endorsement_case =
    Case
      {
        op_case = Operation.Encoding.endorsement_case;
        encoding =
          obj3
            (req &quot;balance_updates&quot; Delegate.balance_updates_encoding)
            (req &quot;delegate&quot; Signature.Public_key_hash.encoding)
            (req &quot;slots&quot; (list uint8));
        select =
          (function
          | Contents_result (Endorsement_result _ as op) -&gt; Some op | _ -&gt; None);
        mselect =
          (function
          | Contents_and_result ((Endorsement _ as op), res) -&gt;
              Some (op, res)
          | _ -&gt;
              None);
        proj =
          (function[@coq_match_with_default]
          | Endorsement_result {balance_updates; delegate; slots} -&gt;
              (balance_updates, delegate, slots));
        inj =
          (fun (balance_updates, delegate, slots) -&gt;
            Endorsement_result {balance_updates; delegate; slots});
      }

  let seed_nonce_revelation_case =
    Case
      {
        op_case = Operation.Encoding.seed_nonce_revelation_case;
        encoding =
          obj1 (req &quot;balance_updates&quot; Delegate.balance_updates_encoding);
        select =
          (function
          | Contents_result (Seed_nonce_revelation_result _ as op) -&gt;
              Some op
          | _ -&gt;
              None);
        mselect =
          (function
          | Contents_and_result ((Seed_nonce_revelation _ as op), res) -&gt;
              Some (op, res)
          | _ -&gt;
              None);
        proj =
          (fun [@coq_match_with_default] (Seed_nonce_revelation_result bus) -&gt;
            bus);
        inj = (fun bus -&gt; Seed_nonce_revelation_result bus);
      }

  let double_endorsement_evidence_case =
    Case
      {
        op_case = Operation.Encoding.double_endorsement_evidence_case;
        encoding =
          obj1 (req &quot;balance_updates&quot; Delegate.balance_updates_encoding);
        select =
          (function
          | Contents_result (Double_endorsement_evidence_result _ as op) -&gt;
              Some op
          | _ -&gt;
              None);
        mselect =
          (function
          | Contents_and_result ((Double_endorsement_evidence _ as op), res) -&gt;
              Some (op, res)
          | _ -&gt;
              None);
        proj =
          (fun [@coq_match_with_default] (Double_endorsement_evidence_result
                                           bus) -&gt;
            bus);
        inj = (fun bus -&gt; Double_endorsement_evidence_result bus);
      }

  let double_baking_evidence_case =
    Case
      {
        op_case = Operation.Encoding.double_baking_evidence_case;
        encoding =
          obj1 (req &quot;balance_updates&quot; Delegate.balance_updates_encoding);
        select =
          (function
          | Contents_result (Double_baking_evidence_result _ as op) -&gt;
              Some op
          | _ -&gt;
              None);
        mselect =
          (function
          | Contents_and_result ((Double_baking_evidence _ as op), res) -&gt;
              Some (op, res)
          | _ -&gt;
              None);
        proj =
          (fun [@coq_match_with_default] (Double_baking_evidence_result bus) -&gt;
            bus);
        inj = (fun bus -&gt; Double_baking_evidence_result bus);
      }

  let activate_account_case =
    Case
      {
        op_case = Operation.Encoding.activate_account_case;
        encoding =
          obj1 (req &quot;balance_updates&quot; Delegate.balance_updates_encoding);
        select =
          (function
          | Contents_result (Activate_account_result _ as op) -&gt;
              Some op
          | _ -&gt;
              None);
        mselect =
          (function
          | Contents_and_result ((Activate_account _ as op), res) -&gt;
              Some (op, res)
          | _ -&gt;
              None);
        proj =
          (fun [@coq_match_with_default] (Activate_account_result bus) -&gt; bus);
        inj = (fun bus -&gt; Activate_account_result bus);
      }

  let proposals_case =
    Case
      {
        op_case = Operation.Encoding.proposals_case;
        encoding = Data_encoding.empty;
        select =
          (function
          | Contents_result (Proposals_result as op) -&gt; Some op | _ -&gt; None);
        mselect =
          (function
          | Contents_and_result ((Proposals _ as op), res) -&gt;
              Some (op, res)
          | _ -&gt;
              None);
        proj = (fun [@coq_match_with_default] Proposals_result -&gt; ());
        inj = (fun () -&gt; Proposals_result);
      }

  let ballot_case =
    Case
      {
        op_case = Operation.Encoding.ballot_case;
        encoding = Data_encoding.empty;
        select =
          (function
          | Contents_result (Ballot_result as op) -&gt; Some op | _ -&gt; None);
        mselect =
          (function
          | Contents_and_result ((Ballot _ as op), res) -&gt;
              Some (op, res)
          | _ -&gt;
              None);
        proj = (fun [@coq_match_with_default] Ballot_result -&gt; ());
        inj = (fun () -&gt; Ballot_result);
      }

  let make_manager_case (type kind)
      (Operation.Encoding.Case op_case :
        kind Kind.manager Operation.Encoding.case)
      (Manager_result.MCase res_case : kind Manager_result.case) mselect =
    Case
      {
        op_case = Operation.Encoding.Case op_case;
        encoding =
          obj3
            (req &quot;balance_updates&quot; Delegate.balance_updates_encoding)
            (req &quot;operation_result&quot; res_case.t)
            (dft
               &quot;internal_operation_results&quot;
               (list internal_operation_result_encoding)
               []);
        select =
          (function
          | Contents_result
              (Manager_operation_result
                ({operation_result = Applied res; _} as op)) -&gt; (
            match res_case.select (Successful_manager_result res) with
            | Some res -&gt;
                Some
                  (Manager_operation_result
                     {op with operation_result = Applied res})
            | None -&gt;
                None )
          | Contents_result
              (Manager_operation_result
                ({operation_result = Backtracked (res, errs); _} as op)) -&gt; (
            match res_case.select (Successful_manager_result res) with
            | Some res -&gt;
                Some
                  (Manager_operation_result
                     {op with operation_result = Backtracked (res, errs)})
            | None -&gt;
                None )
          | Contents_result
              (Manager_operation_result
                ({operation_result = Skipped kind; _} as op)) -&gt; (
            match equal_manager_kind kind res_case.kind with
            | None -&gt;
                None
            | Some Eq -&gt;
                Some
                  (Manager_operation_result
                     {op with operation_result = Skipped kind}) )
          | Contents_result
              (Manager_operation_result
                ({operation_result = Failed (kind, errs); _} as op)) -&gt; (
            match equal_manager_kind kind res_case.kind with
            | None -&gt;
                None
            | Some Eq -&gt;
                Some
                  (Manager_operation_result
                     {op with operation_result = Failed (kind, errs)}) )
          | Contents_result Ballot_result -&gt;
              None
          | Contents_result (Endorsement_result _) -&gt;
              None
          | Contents_result (Seed_nonce_revelation_result _) -&gt;
              None
          | Contents_result (Double_endorsement_evidence_result _) -&gt;
              None
          | Contents_result (Double_baking_evidence_result _) -&gt;
              None
          | Contents_result (Activate_account_result _) -&gt;
              None
          | Contents_result Proposals_result -&gt;
              None);
        mselect;
        proj =
          (fun [@coq_match_with_default] (Manager_operation_result
                                           { balance_updates = bus;
                                             operation_result = r;
                                             internal_operation_results = rs }) -&gt;
            (bus, r, rs));
        inj =
          (fun (bus, r, rs) -&gt;
            Manager_operation_result
              {
                balance_updates = bus;
                operation_result = r;
                internal_operation_results = rs;
              });
      }

  let reveal_case =
    make_manager_case
      Operation.Encoding.reveal_case
      Manager_result.reveal_case
      (function
        | Contents_and_result
            ((Manager_operation {operation = Reveal _; _} as op), res) -&gt;
            Some (op, res)
        | _ -&gt;
            None)

  let transaction_case =
    make_manager_case
      Operation.Encoding.transaction_case
      Manager_result.transaction_case
      (function
        | Contents_and_result
            ((Manager_operation {operation = Transaction _; _} as op), res) -&gt;
            Some (op, res)
        | _ -&gt;
            None)

  let origination_case =
    make_manager_case
      Operation.Encoding.origination_case
      Manager_result.origination_case
      (function
        | Contents_and_result
            ((Manager_operation {operation = Origination _; _} as op), res) -&gt;
            Some (op, res)
        | _ -&gt;
            None)

  let delegation_case =
    make_manager_case
      Operation.Encoding.delegation_case
      Manager_result.delegation_case
      (function
        | Contents_and_result
            ((Manager_operation {operation = Delegation _; _} as op), res) -&gt;
            Some (op, res)
        | _ -&gt;
            None)
end

let contents_result_encoding =
  let make
      (Encoding.Case
        { op_case = Operation.Encoding.Case {tag; name; _};
          encoding;
          mselect = _;
          select;
          proj;
          inj }) =
    let proj x =
      match select x with None -&gt; None | Some x -&gt; Some (proj x)
    in
    let inj x = Contents_result (inj x) in
    Encoding.tagged_case (Tag tag) name encoding proj inj
  in
  def &quot;operation.alpha.contents_result&quot;
  @@ union
       [ make Encoding.endorsement_case;
         make Encoding.seed_nonce_revelation_case;
         make Encoding.double_endorsement_evidence_case;
         make Encoding.double_baking_evidence_case;
         make Encoding.activate_account_case;
         make Encoding.proposals_case;
         make Encoding.ballot_case;
         make Encoding.reveal_case;
         make Encoding.transaction_case;
         make Encoding.origination_case;
         make Encoding.delegation_case ]

let contents_and_result_encoding =
  let make
      (Encoding.Case
        { op_case = Operation.Encoding.Case {tag; name; encoding; proj; inj; _};
          mselect;
          encoding = meta_encoding;
          proj = meta_proj;
          inj = meta_inj;
          _ }) =
    let proj c =
      match mselect c with
      | Some (op, res) -&gt;
          Some (proj op, meta_proj res)
      | _ -&gt;
          None
    in
    let inj (op, res) = Contents_and_result (inj op, meta_inj res) in
    let encoding = merge_objs encoding (obj1 (req &quot;metadata&quot; meta_encoding)) in
    Encoding.tagged_case (Tag tag) name encoding proj inj
  in
  def &quot;operation.alpha.operation_contents_and_result&quot;
  @@ union
       [ make Encoding.endorsement_case;
         make Encoding.seed_nonce_revelation_case;
         make Encoding.double_endorsement_evidence_case;
         make Encoding.double_baking_evidence_case;
         make Encoding.activate_account_case;
         make Encoding.proposals_case;
         make Encoding.ballot_case;
         make Encoding.reveal_case;
         make Encoding.transaction_case;
         make Encoding.origination_case;
         make Encoding.delegation_case ]

type 'kind contents_result_list =
  | Single_result : 'kind contents_result -&gt; 'kind contents_result_list
  | Cons_result :
      'kind Kind.manager contents_result
      * 'rest Kind.manager contents_result_list
      -&gt; ('kind * 'rest) Kind.manager contents_result_list

type packed_contents_result_list =
  | Contents_result_list :
      'kind contents_result_list
      -&gt; packed_contents_result_list

let contents_result_list_encoding =
  let rec to_list = function
    | Contents_result_list (Single_result o) -&gt;
        [Contents_result o]
    | Contents_result_list (Cons_result (o, os)) -&gt;
        Contents_result o :: to_list (Contents_result_list os)
  in
  let rec of_list = function
    | [] -&gt;
        Pervasives.failwith &quot;cannot decode empty operation result&quot;
    | [Contents_result o] -&gt;
        Contents_result_list (Single_result o)
    | Contents_result o :: os -&gt; (
        let (Contents_result_list os) = of_list os in
        match (o, os) with
        | ( Manager_operation_result _,
            Single_result (Manager_operation_result _) ) -&gt;
            Contents_result_list (Cons_result (o, os))
        | (Manager_operation_result _, Cons_result _) -&gt;
            Contents_result_list (Cons_result (o, os))
        | _ -&gt;
            Pervasives.failwith &quot;cannot decode ill-formed operation result&quot; )
  in
  def &quot;operation.alpha.contents_list_result&quot;
  @@ conv to_list of_list (list contents_result_encoding)

type 'kind contents_and_result_list =
  | Single_and_result :
      'kind Alpha_context.contents * 'kind contents_result
      -&gt; 'kind contents_and_result_list
  | Cons_and_result :
      'kind Kind.manager Alpha_context.contents
      * 'kind Kind.manager contents_result
      * 'rest Kind.manager contents_and_result_list
      -&gt; ('kind * 'rest) Kind.manager contents_and_result_list

type packed_contents_and_result_list =
  | Contents_and_result_list :
      'kind contents_and_result_list
      -&gt; packed_contents_and_result_list

let contents_and_result_list_encoding =
  let rec to_list = function
    | Contents_and_result_list (Single_and_result (op, res)) -&gt;
        [Contents_and_result (op, res)]
    | Contents_and_result_list (Cons_and_result (op, res, rest)) -&gt;
        Contents_and_result (op, res)
        :: to_list (Contents_and_result_list rest)
  in
  let rec of_list = function
    | [] -&gt;
        Pervasives.failwith &quot;cannot decode empty combined operation result&quot;
    | [Contents_and_result (op, res)] -&gt;
        Contents_and_result_list (Single_and_result (op, res))
    | Contents_and_result (op, res) :: rest -&gt; (
        let (Contents_and_result_list rest) = of_list rest in
        match (op, rest) with
        | (Manager_operation _, Single_and_result (Manager_operation _, _)) -&gt;
            Contents_and_result_list (Cons_and_result (op, res, rest))
        | (Manager_operation _, Cons_and_result (_, _, _)) -&gt;
            Contents_and_result_list (Cons_and_result (op, res, rest))
        | _ -&gt;
            Pervasives.failwith
              &quot;cannot decode ill-formed combined operation result&quot; )
  in
  conv to_list of_list (Variable.list contents_and_result_encoding)

type 'kind operation_metadata = {contents : 'kind contents_result_list}

type packed_operation_metadata =
  | Operation_metadata : 'kind operation_metadata -&gt; packed_operation_metadata
  | No_operation_metadata : packed_operation_metadata

let operation_metadata_encoding =
  def &quot;operation.alpha.result&quot;
  @@ union
       [ case
           (Tag 0)
           ~title:&quot;Operation_metadata&quot;
           contents_result_list_encoding
           (function
             | Operation_metadata {contents} -&gt;
                 Some (Contents_result_list contents)
             | _ -&gt;
                 None)
           (fun (Contents_result_list contents) -&gt;
             Operation_metadata {contents});
         case
           (Tag 1)
           ~title:&quot;No_operation_metadata&quot;
           empty
           (function No_operation_metadata -&gt; Some () | _ -&gt; None)
           (fun () -&gt; No_operation_metadata) ]

let kind_equal :
    type kind kind2.
    kind contents -&gt; kind2 contents_result -&gt; (kind, kind2) eq option =
 fun op res -&gt;
  match (op, res) with
  | (Endorsement _, Endorsement_result _) -&gt;
      Some Eq
  | (Endorsement _, _) -&gt;
      None
  | (Seed_nonce_revelation _, Seed_nonce_revelation_result _) -&gt;
      Some Eq
  | (Seed_nonce_revelation _, _) -&gt;
      None
  | (Double_endorsement_evidence _, Double_endorsement_evidence_result _) -&gt;
      Some Eq
  | (Double_endorsement_evidence _, _) -&gt;
      None
  | (Double_baking_evidence _, Double_baking_evidence_result _) -&gt;
      Some Eq
  | (Double_baking_evidence _, _) -&gt;
      None
  | (Activate_account _, Activate_account_result _) -&gt;
      Some Eq
  | (Activate_account _, _) -&gt;
      None
  | (Proposals _, Proposals_result) -&gt;
      Some Eq
  | (Proposals _, _) -&gt;
      None
  | (Ballot _, Ballot_result) -&gt;
      Some Eq
  | (Ballot _, _) -&gt;
      None
  | ( Manager_operation {operation = Reveal _; _},
      Manager_operation_result {operation_result = Applied (Reveal_result _); _}
    ) -&gt;
      Some Eq
  | ( Manager_operation {operation = Reveal _; _},
      Manager_operation_result
        {operation_result = Backtracked (Reveal_result _, _); _} ) -&gt;
      Some Eq
  | ( Manager_operation {operation = Reveal _; _},
      Manager_operation_result
        { operation_result = Failed (Alpha_context.Kind.Reveal_manager_kind, _);
          _ } ) -&gt;
      Some Eq
  | ( Manager_operation {operation = Reveal _; _},
      Manager_operation_result
        {operation_result = Skipped Alpha_context.Kind.Reveal_manager_kind; _}
    ) -&gt;
      Some Eq
  | (Manager_operation {operation = Reveal _; _}, _) -&gt;
      None
  | ( Manager_operation {operation = Transaction _; _},
      Manager_operation_result
        {operation_result = Applied (Transaction_result _); _} ) -&gt;
      Some Eq
  | ( Manager_operation {operation = Transaction _; _},
      Manager_operation_result
        {operation_result = Backtracked (Transaction_result _, _); _} ) -&gt;
      Some Eq
  | ( Manager_operation {operation = Transaction _; _},
      Manager_operation_result
        { operation_result =
            Failed (Alpha_context.Kind.Transaction_manager_kind, _);
          _ } ) -&gt;
      Some Eq
  | ( Manager_operation {operation = Transaction _; _},
      Manager_operation_result
        { operation_result = Skipped Alpha_context.Kind.Transaction_manager_kind;
          _ } ) -&gt;
      Some Eq
  | (Manager_operation {operation = Transaction _; _}, _) -&gt;
      None
  | ( Manager_operation {operation = Origination _; _},
      Manager_operation_result
        {operation_result = Applied (Origination_result _); _} ) -&gt;
      Some Eq
  | ( Manager_operation {operation = Origination _; _},
      Manager_operation_result
        {operation_result = Backtracked (Origination_result _, _); _} ) -&gt;
      Some Eq
  | ( Manager_operation {operation = Origination _; _},
      Manager_operation_result
        { operation_result =
            Failed (Alpha_context.Kind.Origination_manager_kind, _);
          _ } ) -&gt;
      Some Eq
  | ( Manager_operation {operation = Origination _; _},
      Manager_operation_result
        { operation_result = Skipped Alpha_context.Kind.Origination_manager_kind;
          _ } ) -&gt;
      Some Eq
  | (Manager_operation {operation = Origination _; _}, _) -&gt;
      None
  | ( Manager_operation {operation = Delegation _; _},
      Manager_operation_result
        {operation_result = Applied (Delegation_result _); _} ) -&gt;
      Some Eq
  | ( Manager_operation {operation = Delegation _; _},
      Manager_operation_result
        {operation_result = Backtracked (Delegation_result _, _); _} ) -&gt;
      Some Eq
  | ( Manager_operation {operation = Delegation _; _},
      Manager_operation_result
        { operation_result =
            Failed (Alpha_context.Kind.Delegation_manager_kind, _);
          _ } ) -&gt;
      Some Eq
  | ( Manager_operation {operation = Delegation _; _},
      Manager_operation_result
        { operation_result = Skipped Alpha_context.Kind.Delegation_manager_kind;
          _ } ) -&gt;
      Some Eq
  | (Manager_operation {operation = Delegation _; _}, _) -&gt;
      None

let rec kind_equal_list :
    type kind kind2.
    kind contents_list -&gt; kind2 contents_result_list -&gt; (kind, kind2) eq option
    =
 fun contents res -&gt;
  match (contents, res) with
  | (Single op, Single_result res) -&gt; (
    match kind_equal op res with None -&gt; None | Some Eq -&gt; Some Eq )
  | (Cons (op, ops), Cons_result (res, ress)) -&gt; (
    match kind_equal op res with
    | None -&gt;
        None
    | Some Eq -&gt; (
      match kind_equal_list ops ress with None -&gt; None | Some Eq -&gt; Some Eq ) )
  | _ -&gt;
      None

let rec pack_contents_list :
    type kind.
    kind contents_list -&gt;
    kind contents_result_list -&gt;
    kind contents_and_result_list =
 fun contents res -&gt;
  match[@coq_match_with_default] (contents, res) with
  | (Single op, Single_result res) -&gt;
      Single_and_result (op, res)
  | (Cons (op, ops), Cons_result (res, ress)) -&gt;
      Cons_and_result (op, res, pack_contents_list ops ress)
  | ( Single (Manager_operation _),
      Cons_result (Manager_operation_result _, Single_result _) ) -&gt;
      <abbr class="mark-warning" title="Unreachable expressions are not supported">.</abbr>
  | ( Cons (_, _),
      Single_result (Manager_operation_result {operation_result = Failed _; _})
    ) -&gt;
      <abbr class="mark-warning" title="Unreachable expressions are not supported">.</abbr>
  | ( Cons (_, _),
      Single_result
        (Manager_operation_result {operation_result = Skipped _; _}) ) -&gt;
      <abbr class="mark-warning" title="Unreachable expressions are not supported">.</abbr>
  | ( Cons (_, _),
      Single_result
        (Manager_operation_result {operation_result = Applied _; _}) ) -&gt;
      <abbr class="mark-warning" title="Unreachable expressions are not supported">.</abbr>
  | ( Cons (_, _),
      Single_result
        (Manager_operation_result {operation_result = Backtracked _; _}) ) -&gt;
      <abbr class="mark-warning" title="Unreachable expressions are not supported">.</abbr>
  | (Single _, Cons_result _) -&gt;
      <abbr class="mark-warning" title="Unreachable expressions are not supported">.</abbr>

let rec unpack_contents_list :
    type kind.
    kind contents_and_result_list -&gt;
    kind contents_list * kind contents_result_list = function
  | Single_and_result (op, res) -&gt;
      (Single op, Single_result res)
  | Cons_and_result (op, res, rest) -&gt;
      let (ops, ress) = unpack_contents_list rest in
      (Cons (op, ops), Cons_result (res, ress))

let rec to_list = function
  | Contents_result_list (Single_result o) -&gt;
      [Contents_result o]
  | Contents_result_list (Cons_result (o, os)) -&gt;
      Contents_result o :: to_list (Contents_result_list os)

let rec of_list = function
  | [] -&gt;
      <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
  | [Contents_result o] -&gt;
      Contents_result_list (Single_result o)
  | Contents_result o :: os -&gt; (
      let (Contents_result_list os) = of_list os in
      match (o, os) with
      | (Manager_operation_result _, Single_result (Manager_operation_result _))
        -&gt;
          Contents_result_list (Cons_result (o, os))
      | (Manager_operation_result _, Cons_result _) -&gt;
          Contents_result_list (Cons_result (o, os))
      | _ -&gt;
          Pervasives.failwith
            &quot;Operation result list of length &gt; 1 should only contains manager \
             operations result.&quot; )

let operation_data_and_metadata_encoding =
  def &quot;operation.alpha.operation_with_metadata&quot;
  @@ union
       [ case
           (Tag 0)
           ~title:&quot;Operation_with_metadata&quot;
           (obj2
              (req &quot;contents&quot; (dynamic_size contents_and_result_list_encoding))
              (opt &quot;signature&quot; Signature.encoding))
           (function
             | (Operation_data _, No_operation_metadata) -&gt;
                 None
             | (Operation_data op, Operation_metadata res) -&gt; (
               match kind_equal_list op.contents res.contents with
               | None -&gt;
                   Pervasives.failwith
                     &quot;cannot decode inconsistent combined operation result&quot;
               | Some Eq -&gt;
                   Some
                     ( Contents_and_result_list
                         (pack_contents_list op.contents res.contents),
                       op.signature ) ))
           (fun (Contents_and_result_list contents, signature) -&gt;
             let (op_contents, res_contents) = unpack_contents_list contents in
             ( Operation_data {contents = op_contents; signature},
               Operation_metadata {contents = res_contents} ));
         case
           (Tag 1)
           ~title:&quot;Operation_without_metadata&quot;
           (obj2
              (req &quot;contents&quot; (dynamic_size Operation.contents_list_encoding))
              (opt &quot;signature&quot; Signature.encoding))
           (function
             | (Operation_data op, No_operation_metadata) -&gt;
                 Some (Contents_list op.contents, op.signature)
             | (Operation_data _, Operation_metadata _) -&gt;
                 None)
           (fun (Contents_list contents, signature) -&gt;
             (Operation_data {contents; signature}, No_operation_metadata)) ]

type block_metadata = {
  baker : Signature.Public_key_hash.t;
  level : Level.t;
  voting_period_kind : Voting_period.kind;
  nonce_hash : Nonce_hash.t option;
  consumed_gas : Z.t;
  deactivated : Signature.Public_key_hash.t list;
  balance_updates : Delegate.balance_updates;
}

let block_metadata_encoding =
  let open Data_encoding in
  def &quot;block_header.alpha.metadata&quot;
  @@ conv
       (fun { baker;
              level;
              voting_period_kind;
              nonce_hash;
              consumed_gas;
              deactivated;
              balance_updates } -&gt;
         ( baker,
           level,
           voting_period_kind,
           nonce_hash,
           consumed_gas,
           deactivated,
           balance_updates ))
       (fun ( baker,
              level,
              voting_period_kind,
              nonce_hash,
              consumed_gas,
              deactivated,
              balance_updates ) -&gt;
         {
           baker;
           level;
           voting_period_kind;
           nonce_hash;
           consumed_gas;
           deactivated;
           balance_updates;
         })
       (obj7
          (req &quot;baker&quot; Signature.Public_key_hash.encoding)
          (req &quot;level&quot; Level.encoding)
          (req &quot;voting_period_kind&quot; Voting_period.kind_encoding)
          (req &quot;nonce_hash&quot; (option Nonce_hash.encoding))
          (req &quot;consumed_gas&quot; (check_size 10 n))
          (req &quot;deactivated&quot; (list Signature.Public_key_hash.encoding))
          (req &quot;balance_updates&quot; Delegate.balance_updates_encoding))
</pre>
  </div>
  <div class="col-md-6">
    <a href="#apply_results.ml"><code>Apply_results.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Nonce_hash.

Import Alpha_context.

Import Data_encoding.

Definition error_encoding : Data_encoding.encoding Error_monad.__error :=
  (let arg :=
    Data_encoding.def &quot;error&quot;
      (Some
        &quot;The full list of RPC errors would be too long to include.\nIt is available at RPC `/errors` (GET).\nErrors specific to protocol Alpha have an id that starts with `proto.alpha`.&quot;)
    in
  fun eta =&gt; arg None eta)
    (Data_encoding.splitted
      (Data_encoding.conv
        (fun err =&gt; Data_encoding.Json.construct Error_monad.error_encoding err)
        (fun __json_value =&gt;
          Data_encoding.Json.destruct Error_monad.error_encoding __json_value)
        None Data_encoding.__json_value) Error_monad.error_encoding).

Module ConstructorRecords_successful_manager_operation_result.
  Module successful_manager_operation_result.
    Module Reveal_result.
      Record record {consumed_gas : Set} : Set := Build {
        consumed_gas : consumed_gas }.
      Arguments record : clear implicits.
      Definition with_consumed_gas {t_consumed_gas} consumed_gas
        (r : record t_consumed_gas) :=
        Build t_consumed_gas consumed_gas.
    End Reveal_result.
    Definition Reveal_result_skeleton := Reveal_result.record.
    
    Module Transaction_result.
      Record record {storage big_map_diff balance_updates originated_contracts
        consumed_gas storage_size paid_storage_size_diff
        allocated_destination_contract : Set} : Set := Build {
        storage : storage;
        big_map_diff : big_map_diff;
        balance_updates : balance_updates;
        originated_contracts : originated_contracts;
        consumed_gas : consumed_gas;
        storage_size : storage_size;
        paid_storage_size_diff : paid_storage_size_diff;
        allocated_destination_contract : allocated_destination_contract }.
      Arguments record : clear implicits.
      Definition with_storage
        {t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract} storage
        (r :
          record t_storage t_big_map_diff t_balance_updates
            t_originated_contracts t_consumed_gas t_storage_size
            t_paid_storage_size_diff t_allocated_destination_contract) :=
        Build t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract storage r.(big_map_diff)
          r.(balance_updates) r.(originated_contracts) r.(consumed_gas)
          r.(storage_size) r.(paid_storage_size_diff)
          r.(allocated_destination_contract).
      Definition with_big_map_diff
        {t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract} big_map_diff
        (r :
          record t_storage t_big_map_diff t_balance_updates
            t_originated_contracts t_consumed_gas t_storage_size
            t_paid_storage_size_diff t_allocated_destination_contract) :=
        Build t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract r.(storage) big_map_diff
          r.(balance_updates) r.(originated_contracts) r.(consumed_gas)
          r.(storage_size) r.(paid_storage_size_diff)
          r.(allocated_destination_contract).
      Definition with_balance_updates
        {t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract} balance_updates
        (r :
          record t_storage t_big_map_diff t_balance_updates
            t_originated_contracts t_consumed_gas t_storage_size
            t_paid_storage_size_diff t_allocated_destination_contract) :=
        Build t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract r.(storage) r.(big_map_diff)
          balance_updates r.(originated_contracts) r.(consumed_gas)
          r.(storage_size) r.(paid_storage_size_diff)
          r.(allocated_destination_contract).
      Definition with_originated_contracts
        {t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract} originated_contracts
        (r :
          record t_storage t_big_map_diff t_balance_updates
            t_originated_contracts t_consumed_gas t_storage_size
            t_paid_storage_size_diff t_allocated_destination_contract) :=
        Build t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract r.(storage) r.(big_map_diff)
          r.(balance_updates) originated_contracts r.(consumed_gas)
          r.(storage_size) r.(paid_storage_size_diff)
          r.(allocated_destination_contract).
      Definition with_consumed_gas
        {t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract} consumed_gas
        (r :
          record t_storage t_big_map_diff t_balance_updates
            t_originated_contracts t_consumed_gas t_storage_size
            t_paid_storage_size_diff t_allocated_destination_contract) :=
        Build t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract r.(storage) r.(big_map_diff)
          r.(balance_updates) r.(originated_contracts) consumed_gas
          r.(storage_size) r.(paid_storage_size_diff)
          r.(allocated_destination_contract).
      Definition with_storage_size
        {t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract} storage_size
        (r :
          record t_storage t_big_map_diff t_balance_updates
            t_originated_contracts t_consumed_gas t_storage_size
            t_paid_storage_size_diff t_allocated_destination_contract) :=
        Build t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract r.(storage) r.(big_map_diff)
          r.(balance_updates) r.(originated_contracts) r.(consumed_gas)
          storage_size r.(paid_storage_size_diff)
          r.(allocated_destination_contract).
      Definition with_paid_storage_size_diff
        {t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract} paid_storage_size_diff
        (r :
          record t_storage t_big_map_diff t_balance_updates
            t_originated_contracts t_consumed_gas t_storage_size
            t_paid_storage_size_diff t_allocated_destination_contract) :=
        Build t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract r.(storage) r.(big_map_diff)
          r.(balance_updates) r.(originated_contracts) r.(consumed_gas)
          r.(storage_size) paid_storage_size_diff
          r.(allocated_destination_contract).
      Definition with_allocated_destination_contract
        {t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract} allocated_destination_contract
        (r :
          record t_storage t_big_map_diff t_balance_updates
            t_originated_contracts t_consumed_gas t_storage_size
            t_paid_storage_size_diff t_allocated_destination_contract) :=
        Build t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract r.(storage) r.(big_map_diff)
          r.(balance_updates) r.(originated_contracts) r.(consumed_gas)
          r.(storage_size) r.(paid_storage_size_diff)
          allocated_destination_contract.
    End Transaction_result.
    Definition Transaction_result_skeleton := Transaction_result.record.
    
    Module Origination_result.
      Record record {big_map_diff balance_updates originated_contracts
        consumed_gas storage_size paid_storage_size_diff : Set} : Set := Build {
        big_map_diff : big_map_diff;
        balance_updates : balance_updates;
        originated_contracts : originated_contracts;
        consumed_gas : consumed_gas;
        storage_size : storage_size;
        paid_storage_size_diff : paid_storage_size_diff }.
      Arguments record : clear implicits.
      Definition with_big_map_diff
        {t_big_map_diff t_balance_updates t_originated_contracts t_consumed_gas
          t_storage_size t_paid_storage_size_diff} big_map_diff
        (r :
          record t_big_map_diff t_balance_updates t_originated_contracts
            t_consumed_gas t_storage_size t_paid_storage_size_diff) :=
        Build t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff big_map_diff
          r.(balance_updates) r.(originated_contracts) r.(consumed_gas)
          r.(storage_size) r.(paid_storage_size_diff).
      Definition with_balance_updates
        {t_big_map_diff t_balance_updates t_originated_contracts t_consumed_gas
          t_storage_size t_paid_storage_size_diff} balance_updates
        (r :
          record t_big_map_diff t_balance_updates t_originated_contracts
            t_consumed_gas t_storage_size t_paid_storage_size_diff) :=
        Build t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          r.(big_map_diff) balance_updates r.(originated_contracts)
          r.(consumed_gas) r.(storage_size) r.(paid_storage_size_diff).
      Definition with_originated_contracts
        {t_big_map_diff t_balance_updates t_originated_contracts t_consumed_gas
          t_storage_size t_paid_storage_size_diff} originated_contracts
        (r :
          record t_big_map_diff t_balance_updates t_originated_contracts
            t_consumed_gas t_storage_size t_paid_storage_size_diff) :=
        Build t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          r.(big_map_diff) r.(balance_updates) originated_contracts
          r.(consumed_gas) r.(storage_size) r.(paid_storage_size_diff).
      Definition with_consumed_gas
        {t_big_map_diff t_balance_updates t_originated_contracts t_consumed_gas
          t_storage_size t_paid_storage_size_diff} consumed_gas
        (r :
          record t_big_map_diff t_balance_updates t_originated_contracts
            t_consumed_gas t_storage_size t_paid_storage_size_diff) :=
        Build t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          r.(big_map_diff) r.(balance_updates) r.(originated_contracts)
          consumed_gas r.(storage_size) r.(paid_storage_size_diff).
      Definition with_storage_size
        {t_big_map_diff t_balance_updates t_originated_contracts t_consumed_gas
          t_storage_size t_paid_storage_size_diff} storage_size
        (r :
          record t_big_map_diff t_balance_updates t_originated_contracts
            t_consumed_gas t_storage_size t_paid_storage_size_diff) :=
        Build t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          r.(big_map_diff) r.(balance_updates) r.(originated_contracts)
          r.(consumed_gas) storage_size r.(paid_storage_size_diff).
      Definition with_paid_storage_size_diff
        {t_big_map_diff t_balance_updates t_originated_contracts t_consumed_gas
          t_storage_size t_paid_storage_size_diff} paid_storage_size_diff
        (r :
          record t_big_map_diff t_balance_updates t_originated_contracts
            t_consumed_gas t_storage_size t_paid_storage_size_diff) :=
        Build t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          r.(big_map_diff) r.(balance_updates) r.(originated_contracts)
          r.(consumed_gas) r.(storage_size) paid_storage_size_diff.
    End Origination_result.
    Definition Origination_result_skeleton := Origination_result.record.
    
    Module Delegation_result.
      Record record {consumed_gas : Set} : Set := Build {
        consumed_gas : consumed_gas }.
      Arguments record : clear implicits.
      Definition with_consumed_gas {t_consumed_gas} consumed_gas
        (r : record t_consumed_gas) :=
        Build t_consumed_gas consumed_gas.
    End Delegation_result.
    Definition Delegation_result_skeleton := Delegation_result.record.
  End successful_manager_operation_result.
End ConstructorRecords_successful_manager_operation_result.
Import ConstructorRecords_successful_manager_operation_result.

Reserved Notation &quot;'successful_manager_operation_result.Reveal_result&quot;.
Reserved Notation &quot;'successful_manager_operation_result.Transaction_result&quot;.
Reserved Notation &quot;'successful_manager_operation_result.Origination_result&quot;.
Reserved Notation &quot;'successful_manager_operation_result.Delegation_result&quot;.

Inductive successful_manager_operation_result : Set :=
| Reveal_result :
  'successful_manager_operation_result.Reveal_result -&gt;
  successful_manager_operation_result
| Transaction_result :
  'successful_manager_operation_result.Transaction_result -&gt;
  successful_manager_operation_result
| Origination_result :
  'successful_manager_operation_result.Origination_result -&gt;
  successful_manager_operation_result
| Delegation_result :
  'successful_manager_operation_result.Delegation_result -&gt;
  successful_manager_operation_result

where &quot;'successful_manager_operation_result.Reveal_result&quot; :=
  (successful_manager_operation_result.Reveal_result_skeleton Z.t)
and &quot;'successful_manager_operation_result.Transaction_result&quot; :=
  (successful_manager_operation_result.Transaction_result_skeleton
    (option Alpha_context.Script.expr)
    (option Alpha_context.Contract.big_map_diff)
    Alpha_context.Delegate.balance_updates (list Alpha_context.Contract.t) Z.t
    Z.t Z.t bool)
and &quot;'successful_manager_operation_result.Origination_result&quot; :=
  (successful_manager_operation_result.Origination_result_skeleton
    (option Alpha_context.Contract.big_map_diff)
    Alpha_context.Delegate.balance_updates (list Alpha_context.Contract.t) Z.t
    Z.t Z.t)
and &quot;'successful_manager_operation_result.Delegation_result&quot; :=
  (successful_manager_operation_result.Delegation_result_skeleton Z.t).

Module successful_manager_operation_result.
  Include ConstructorRecords_successful_manager_operation_result.successful_manager_operation_result.
  Definition Reveal_result :=
    'successful_manager_operation_result.Reveal_result.
  Definition Transaction_result :=
    'successful_manager_operation_result.Transaction_result.
  Definition Origination_result :=
    'successful_manager_operation_result.Origination_result.
  Definition Delegation_result :=
    'successful_manager_operation_result.Delegation_result.
End successful_manager_operation_result.

Inductive packed_successful_manager_operation_result : Set :=
| Successful_manager_result :
  successful_manager_operation_result -&gt;
  packed_successful_manager_operation_result.

Inductive manager_operation_result : Set :=
| Applied : successful_manager_operation_result -&gt; manager_operation_result
| Backtracked :
  successful_manager_operation_result -&gt; option (list Error_monad.__error) -&gt;
  manager_operation_result
| Failed :
  Alpha_context.Kind.manager -&gt; list Error_monad.__error -&gt;
  manager_operation_result
| Skipped : Alpha_context.Kind.manager -&gt; manager_operation_result.

Inductive packed_internal_operation_result : Set :=
| Internal_operation_result :
  Alpha_context.internal_operation -&gt; manager_operation_result -&gt;
  packed_internal_operation_result.

Module Manager_result.
  Module ConstructorRecords_case.
    Module case.
      Module MCase.
        Record record {op_case encoding kind iselect select proj inj t : Set} :
          Set := Build {
          op_case : op_case;
          encoding : encoding;
          kind : kind;
          iselect : iselect;
          select : select;
          proj : proj;
          inj : inj;
          t : t }.
        Arguments record : clear implicits.
        Definition with_op_case
          {t_op_case t_encoding t_kind t_iselect t_select t_proj t_inj t_t}
          op_case
          (r :
            record t_op_case t_encoding t_kind t_iselect t_select t_proj t_inj
              t_t) :=
          Build t_op_case t_encoding t_kind t_iselect t_select t_proj t_inj t_t
            op_case r.(encoding) r.(kind) r.(iselect) r.(select) r.(proj)
            r.(inj) r.(t).
        Definition with_encoding
          {t_op_case t_encoding t_kind t_iselect t_select t_proj t_inj t_t}
          encoding
          (r :
            record t_op_case t_encoding t_kind t_iselect t_select t_proj t_inj
              t_t) :=
          Build t_op_case t_encoding t_kind t_iselect t_select t_proj t_inj t_t
            r.(op_case) encoding r.(kind) r.(iselect) r.(select) r.(proj)
            r.(inj) r.(t).
        Definition with_kind
          {t_op_case t_encoding t_kind t_iselect t_select t_proj t_inj t_t} kind
          (r :
            record t_op_case t_encoding t_kind t_iselect t_select t_proj t_inj
              t_t) :=
          Build t_op_case t_encoding t_kind t_iselect t_select t_proj t_inj t_t
            r.(op_case) r.(encoding) kind r.(iselect) r.(select) r.(proj)
            r.(inj) r.(t).
        Definition with_iselect
          {t_op_case t_encoding t_kind t_iselect t_select t_proj t_inj t_t}
          iselect
          (r :
            record t_op_case t_encoding t_kind t_iselect t_select t_proj t_inj
              t_t) :=
          Build t_op_case t_encoding t_kind t_iselect t_select t_proj t_inj t_t
            r.(op_case) r.(encoding) r.(kind) iselect r.(select) r.(proj)
            r.(inj) r.(t).
        Definition with_select
          {t_op_case t_encoding t_kind t_iselect t_select t_proj t_inj t_t}
          select
          (r :
            record t_op_case t_encoding t_kind t_iselect t_select t_proj t_inj
              t_t) :=
          Build t_op_case t_encoding t_kind t_iselect t_select t_proj t_inj t_t
            r.(op_case) r.(encoding) r.(kind) r.(iselect) select r.(proj)
            r.(inj) r.(t).
        Definition with_proj
          {t_op_case t_encoding t_kind t_iselect t_select t_proj t_inj t_t} proj
          (r :
            record t_op_case t_encoding t_kind t_iselect t_select t_proj t_inj
              t_t) :=
          Build t_op_case t_encoding t_kind t_iselect t_select t_proj t_inj t_t
            r.(op_case) r.(encoding) r.(kind) r.(iselect) r.(select) proj
            r.(inj) r.(t).
        Definition with_inj
          {t_op_case t_encoding t_kind t_iselect t_select t_proj t_inj t_t} inj
          (r :
            record t_op_case t_encoding t_kind t_iselect t_select t_proj t_inj
              t_t) :=
          Build t_op_case t_encoding t_kind t_iselect t_select t_proj t_inj t_t
            r.(op_case) r.(encoding) r.(kind) r.(iselect) r.(select) r.(proj)
            inj r.(t).
        Definition with_t
          {t_op_case t_encoding t_kind t_iselect t_select t_proj t_inj t_t} t
          (r :
            record t_op_case t_encoding t_kind t_iselect t_select t_proj t_inj
              t_t) :=
          Build t_op_case t_encoding t_kind t_iselect t_select t_proj t_inj t_t
            r.(op_case) r.(encoding) r.(kind) r.(iselect) r.(select) r.(proj)
            r.(inj) t.
      End MCase.
      Definition MCase_skeleton := MCase.record.
    End case.
  End ConstructorRecords_case.
  Import ConstructorRecords_case.
  
  Reserved Notation &quot;'case.MCase&quot;.
  
  Inductive case : Set :=
  | MCase : forall {a : Set}, 'case.MCase a -&gt; case
  
  where &quot;'case.MCase&quot; := (fun (t_a : Set) =&gt;
    case.MCase_skeleton Alpha_context.Operation.Encoding.Manager_operations.case
      (Data_encoding.t t_a) Alpha_context.Kind.manager
      (packed_internal_operation_result -&gt;
      option (Alpha_context.internal_operation * manager_operation_result))
      (packed_successful_manager_operation_result -&gt;
      option successful_manager_operation_result)
      (successful_manager_operation_result -&gt; t_a)
      (t_a -&gt; successful_manager_operation_result)
      (Data_encoding.t manager_operation_result)).
  
  Module case.
    Include ConstructorRecords_case.case.
    Definition MCase := 'case.MCase.
  End case.
  
  Definition make {A : Set}
    (op_case : Alpha_context.Operation.Encoding.Manager_operations.case)
    (encoding : Data_encoding.encoding A) (kind : Alpha_context.Kind.manager)
    (iselect :
      packed_internal_operation_result -&gt;
      option (Alpha_context.internal_operation * manager_operation_result))
    (select :
      packed_successful_manager_operation_result -&gt;
      option successful_manager_operation_result)
    (proj : successful_manager_operation_result -&gt; A)
    (inj : A -&gt; successful_manager_operation_result) : case :=
    let
      'Alpha_context.Operation.Encoding.Manager_operations.MCase {|
        Alpha_context.Operation.Encoding.Manager_operations.case.MCase.name := name
          |} := op_case in
    let __t_value :=
      (let arg :=
        Data_encoding.def
          (Format.asprintf
            (CamlinternalFormatBasics.Format
              (CamlinternalFormatBasics.String_literal
                &quot;operation.alpha.operation_result.&quot;
                (CamlinternalFormatBasics.String
                  CamlinternalFormatBasics.No_padding
                  CamlinternalFormatBasics.End_of_format))
              &quot;operation.alpha.operation_result.%s&quot;) name) in
      fun eta =&gt; arg None None eta)
        (Data_encoding.union (Some Data_encoding.Uint8)
          [
            Data_encoding.__case_value &quot;Applied&quot; None (Data_encoding.Tag 0)
              (Data_encoding.merge_objs
                (Data_encoding.obj1
                  (Data_encoding.req None None &quot;status&quot;
                    (Data_encoding.constant
                      &quot;applied&quot;)))
                encoding)
              (fun o =&gt;
                match o with
                | (Skipped _ | Failed _ _ | Backtracked _ _) =&gt;
                  None
                | Applied o =&gt;
                  match
                    select
                      (Successful_manager_result
                        o) with
                  | None =&gt; None
                  | Some o =&gt; Some (tt, (proj o))
                  end
                end)
              (fun function_parameter =&gt;
                let '(_, x) := function_parameter in
                Applied (inj x));
            Data_encoding.__case_value &quot;Failed&quot; None (Data_encoding.Tag 1)
              (Data_encoding.obj2
                (Data_encoding.req None None &quot;status&quot;
                  (Data_encoding.constant &quot;failed&quot;))
                (Data_encoding.req None None &quot;errors&quot;
                  (Data_encoding.__list_value None
                    error_encoding)))
              (fun function_parameter =&gt;
                match function_parameter with
                | Failed _ errs =&gt; Some (tt, errs)
                | _ =&gt; None
                end)
              (fun function_parameter =&gt;
                let '(_, errs) := function_parameter in
                Failed kind errs);
            Data_encoding.__case_value &quot;Skipped&quot; None (Data_encoding.Tag 2)
              (Data_encoding.obj1
                (Data_encoding.req None None &quot;status&quot;
                  (Data_encoding.constant &quot;skipped&quot;)))
              (fun function_parameter =&gt;
                match function_parameter with
                | Skipped _ =&gt; Some tt
                | _ =&gt; None
                end)
              (fun function_parameter =&gt;
                let '_ := function_parameter in
                Skipped kind);
            Data_encoding.__case_value &quot;Backtracked&quot; None (Data_encoding.Tag 3)
              (Data_encoding.merge_objs
                (Data_encoding.obj2
                  (Data_encoding.req None None &quot;status&quot;
                    (Data_encoding.constant
                      &quot;backtracked&quot;))
                  (Data_encoding.opt None None &quot;errors&quot;
                    (Data_encoding.__list_value
                      None
                      error_encoding)))
                encoding)
              (fun o =&gt;
                match o with
                | (Skipped _ | Failed _ _ | Applied _) =&gt; None
                | Backtracked o errs =&gt;
                  match
                    select
                      (Successful_manager_result
                        o) with
                  | None =&gt; None
                  | Some o =&gt;
                    Some ((tt, errs), (proj o))
                  end
                end)
              (fun function_parameter =&gt;
                let '((_, errs), x) := function_parameter in
                Backtracked (inj x) errs)
          ]) in
    MCase
      {| case.MCase.op_case := op_case; case.MCase.encoding := encoding;
        case.MCase.kind := kind; case.MCase.iselect := iselect;
        case.MCase.select := select; case.MCase.proj := proj;
        case.MCase.inj := inj; case.MCase.t := __t_value |}.
  
  Definition reveal_case : case :=
    make Alpha_context.Operation.Encoding.Manager_operations.reveal_case
      (Data_encoding.obj1
        (Data_encoding.dft None None &quot;consumed_gas&quot; Data_encoding.z Z.zero))
      Alpha_context.Kind.Reveal_manager_kind
      (fun function_parameter =&gt;
        match function_parameter with
        |
          Internal_operation_result
            ({|
              Alpha_context.internal_operation.operation := Alpha_context.Reveal _
                |} as op) res =&gt; Some (op, res)
        | _ =&gt; None
        end)
      (fun function_parameter =&gt;
        match function_parameter with
        | Successful_manager_result ((Reveal_result _) as op) =&gt; Some op
        | _ =&gt; None
        end)
      (fun function_parameter =&gt;
        match function_parameter with
        |
          Reveal_result {|
            successful_manager_operation_result.Reveal_result.consumed_gas := consumed_gas
              |} =&gt; consumed_gas
        | _ =&gt; unreachable_gadt_branch
        end)
      (fun consumed_gas =&gt;
        Reveal_result
          {|
            successful_manager_operation_result.Reveal_result.consumed_gas :=
              consumed_gas |}).
  
  Definition transaction_case : case :=
    make Alpha_context.Operation.Encoding.Manager_operations.transaction_case
      (Data_encoding.obj8
        (Data_encoding.opt None None &quot;storage&quot;
          Alpha_context.Script.expr_encoding)
        (Data_encoding.opt None None &quot;big_map_diff&quot;
          Alpha_context.Contract.big_map_diff_encoding)
        (Data_encoding.dft None None &quot;balance_updates&quot;
          Alpha_context.Delegate.balance_updates_encoding nil)
        (Data_encoding.dft None None &quot;originated_contracts&quot;
          (Data_encoding.__list_value None Alpha_context.Contract.encoding) nil)
        (Data_encoding.dft None None &quot;consumed_gas&quot; Data_encoding.z Z.zero)
        (Data_encoding.dft None None &quot;storage_size&quot; Data_encoding.z Z.zero)
        (Data_encoding.dft None None &quot;paid_storage_size_diff&quot; Data_encoding.z
          Z.zero)
        (Data_encoding.dft None None &quot;allocated_destination_contract&quot;
          Data_encoding.__bool_value false))
      Alpha_context.Kind.Transaction_manager_kind
      (fun function_parameter =&gt;
        match function_parameter with
        |
          Internal_operation_result
            ({|
              Alpha_context.internal_operation.operation := Alpha_context.Transaction _
                |} as op) res =&gt; Some (op, res)
        | _ =&gt; None
        end)
      (fun function_parameter =&gt;
        match function_parameter with
        | Successful_manager_result ((Transaction_result _) as op) =&gt; Some op
        | _ =&gt; None
        end)
      (fun function_parameter =&gt;
        match function_parameter with
        |
          Transaction_result {|
            successful_manager_operation_result.Transaction_result.storage := storage;
              successful_manager_operation_result.Transaction_result.big_map_diff
                := big_map_diff;
              successful_manager_operation_result.Transaction_result.balance_updates
                := balance_updates;
              successful_manager_operation_result.Transaction_result.originated_contracts
                := originated_contracts;
              successful_manager_operation_result.Transaction_result.consumed_gas
                := consumed_gas;
              successful_manager_operation_result.Transaction_result.storage_size
                := storage_size;
              successful_manager_operation_result.Transaction_result.paid_storage_size_diff
                := paid_storage_size_diff;
              successful_manager_operation_result.Transaction_result.allocated_destination_contract
                := allocated_destination_contract
              |} =&gt;
          (storage, big_map_diff, balance_updates, originated_contracts,
            consumed_gas, storage_size, paid_storage_size_diff,
            allocated_destination_contract)
        | _ =&gt; unreachable_gadt_branch
        end)
      (fun function_parameter =&gt;
        let
          '(storage, big_map_diff, balance_updates, originated_contracts,
            consumed_gas, storage_size, paid_storage_size_diff,
            allocated_destination_contract) := function_parameter in
        Transaction_result
          {|
            successful_manager_operation_result.Transaction_result.storage :=
              storage;
            successful_manager_operation_result.Transaction_result.big_map_diff :=
              big_map_diff;
            successful_manager_operation_result.Transaction_result.balance_updates :=
              balance_updates;
            successful_manager_operation_result.Transaction_result.originated_contracts :=
              originated_contracts;
            successful_manager_operation_result.Transaction_result.consumed_gas :=
              consumed_gas;
            successful_manager_operation_result.Transaction_result.storage_size :=
              storage_size;
            successful_manager_operation_result.Transaction_result.paid_storage_size_diff :=
              paid_storage_size_diff;
            successful_manager_operation_result.Transaction_result.allocated_destination_contract :=
              allocated_destination_contract |}).
  
  Definition origination_case : case :=
    make Alpha_context.Operation.Encoding.Manager_operations.origination_case
      (Data_encoding.obj6
        (Data_encoding.opt None None &quot;big_map_diff&quot;
          Alpha_context.Contract.big_map_diff_encoding)
        (Data_encoding.dft None None &quot;balance_updates&quot;
          Alpha_context.Delegate.balance_updates_encoding nil)
        (Data_encoding.dft None None &quot;originated_contracts&quot;
          (Data_encoding.__list_value None Alpha_context.Contract.encoding) nil)
        (Data_encoding.dft None None &quot;consumed_gas&quot; Data_encoding.z Z.zero)
        (Data_encoding.dft None None &quot;storage_size&quot; Data_encoding.z Z.zero)
        (Data_encoding.dft None None &quot;paid_storage_size_diff&quot; Data_encoding.z
          Z.zero)) Alpha_context.Kind.Origination_manager_kind
      (fun function_parameter =&gt;
        match function_parameter with
        |
          Internal_operation_result
            ({|
              Alpha_context.internal_operation.operation := Alpha_context.Origination _
                |} as op) res =&gt; Some (op, res)
        | _ =&gt; None
        end)
      (fun function_parameter =&gt;
        match function_parameter with
        | Successful_manager_result ((Origination_result _) as op) =&gt; Some op
        | _ =&gt; None
        end)
      (fun function_parameter =&gt;
        match function_parameter with
        |
          Origination_result {|
            successful_manager_operation_result.Origination_result.big_map_diff :=
              big_map_diff;
              successful_manager_operation_result.Origination_result.balance_updates
                := balance_updates;
              successful_manager_operation_result.Origination_result.originated_contracts
                := originated_contracts;
              successful_manager_operation_result.Origination_result.consumed_gas
                := consumed_gas;
              successful_manager_operation_result.Origination_result.storage_size
                := storage_size;
              successful_manager_operation_result.Origination_result.paid_storage_size_diff
                := paid_storage_size_diff
              |} =&gt;
          (big_map_diff, balance_updates, originated_contracts, consumed_gas,
            storage_size, paid_storage_size_diff)
        | _ =&gt; unreachable_gadt_branch
        end)
      (fun function_parameter =&gt;
        let
          '(big_map_diff, balance_updates, originated_contracts, consumed_gas,
            storage_size, paid_storage_size_diff) := function_parameter in
        Origination_result
          {|
            successful_manager_operation_result.Origination_result.big_map_diff :=
              big_map_diff;
            successful_manager_operation_result.Origination_result.balance_updates :=
              balance_updates;
            successful_manager_operation_result.Origination_result.originated_contracts :=
              originated_contracts;
            successful_manager_operation_result.Origination_result.consumed_gas :=
              consumed_gas;
            successful_manager_operation_result.Origination_result.storage_size :=
              storage_size;
            successful_manager_operation_result.Origination_result.paid_storage_size_diff :=
              paid_storage_size_diff |}).
  
  Definition delegation_case : case :=
    make Alpha_context.Operation.Encoding.Manager_operations.delegation_case
      (Data_encoding.obj1
        (Data_encoding.dft None None &quot;consumed_gas&quot; Data_encoding.z Z.zero))
      Alpha_context.Kind.Delegation_manager_kind
      (fun function_parameter =&gt;
        match function_parameter with
        |
          Internal_operation_result
            ({|
              Alpha_context.internal_operation.operation := Alpha_context.Delegation _
                |} as op) res =&gt; Some (op, res)
        | _ =&gt; None
        end)
      (fun function_parameter =&gt;
        match function_parameter with
        | Successful_manager_result ((Delegation_result _) as op) =&gt; Some op
        | _ =&gt; None
        end)
      (fun function_parameter =&gt;
        match function_parameter with
        |
          Delegation_result {|
            successful_manager_operation_result.Delegation_result.consumed_gas :=
              consumed_gas
              |} =&gt; consumed_gas
        | _ =&gt; unreachable_gadt_branch
        end)
      (fun consumed_gas =&gt;
        Delegation_result
          {|
            successful_manager_operation_result.Delegation_result.consumed_gas :=
              consumed_gas |}).
End Manager_result.

Definition internal_operation_result_encoding
  : Data_encoding.t packed_internal_operation_result :=
  let make (function_parameter : Manager_result.case)
    : Data_encoding.case packed_internal_operation_result :=
    let 'Manager_result.MCase res_case := function_parameter in
    let 'existT _ __MCase_'a res_case :=
      existT (A := Set) (fun __MCase_'a =&gt; Manager_result.case.MCase __MCase_'a)
        _ res_case in
    let 'Alpha_context.Operation.Encoding.Manager_operations.MCase op_case :=
      res_case.(Manager_result.case.MCase.op_case) in
    let 'existT _ __MCase_'a1 op_case :=
      existT (A := Set)
        (fun __MCase_'a1 =&gt;
          Alpha_context.Operation.Encoding.Manager_operations.case.MCase
            __MCase_'a1) _ op_case in
    Data_encoding.__case_value
      op_case.(Alpha_context.Operation.Encoding.Manager_operations.case.MCase.name)
      None
      (Data_encoding.Tag
        op_case.(Alpha_context.Operation.Encoding.Manager_operations.case.MCase.tag))
      (Data_encoding.merge_objs
        (Data_encoding.obj3
          (Data_encoding.req None None &quot;kind&quot;
            (Data_encoding.constant
              op_case.(Alpha_context.Operation.Encoding.Manager_operations.case.MCase.name)))
          (Data_encoding.req None None &quot;source&quot; Alpha_context.Contract.encoding)
          (Data_encoding.req None None &quot;nonce&quot; Data_encoding.uint16))
        (Data_encoding.merge_objs
          op_case.(Alpha_context.Operation.Encoding.Manager_operations.case.MCase.encoding)
          (Data_encoding.obj1
            (Data_encoding.req None None &quot;result&quot;
              res_case.(Manager_result.case.MCase.t)))))
      (fun op =&gt;
        match res_case.(Manager_result.case.MCase.iselect) op with
        | Some (op, res) =&gt;
          Some
            ((tt, op.(Alpha_context.internal_operation.source),
              op.(Alpha_context.internal_operation.nonce)),
              ((op_case.(Alpha_context.Operation.Encoding.Manager_operations.case.MCase.proj)
                op.(Alpha_context.internal_operation.operation)), res))
        | None =&gt; None
        end)
      (fun function_parameter =&gt;
        let '((_, source, __nonce_value), (op, res)) := function_parameter in
        let op :=
          {| Alpha_context.internal_operation.source := source;
            Alpha_context.internal_operation.operation :=
              op_case.(Alpha_context.Operation.Encoding.Manager_operations.case.MCase.inj)
                op; Alpha_context.internal_operation.nonce := __nonce_value |}
          in
        Internal_operation_result op res) in
  (let arg := Data_encoding.def &quot;operation.alpha.internal_operation_result&quot; in
  fun eta =&gt; arg None None eta)
    (Data_encoding.union None
      [
        make Manager_result.reveal_case;
        make Manager_result.transaction_case;
        make Manager_result.origination_case;
        make Manager_result.delegation_case
      ]).

Module ConstructorRecords_contents_result.
  Module contents_result.
    Module Endorsement_result.
      Record record {balance_updates delegate slots : Set} : Set := Build {
        balance_updates : balance_updates;
        delegate : delegate;
        slots : slots }.
      Arguments record : clear implicits.
      Definition with_balance_updates {t_balance_updates t_delegate t_slots}
        balance_updates (r : record t_balance_updates t_delegate t_slots) :=
        Build t_balance_updates t_delegate t_slots balance_updates r.(delegate)
          r.(slots).
      Definition with_delegate {t_balance_updates t_delegate t_slots} delegate
        (r : record t_balance_updates t_delegate t_slots) :=
        Build t_balance_updates t_delegate t_slots r.(balance_updates) delegate
          r.(slots).
      Definition with_slots {t_balance_updates t_delegate t_slots} slots
        (r : record t_balance_updates t_delegate t_slots) :=
        Build t_balance_updates t_delegate t_slots r.(balance_updates)
          r.(delegate) slots.
    End Endorsement_result.
    Definition Endorsement_result_skeleton := Endorsement_result.record.
    
    Module Manager_operation_result.
      Record record {balance_updates operation_result internal_operation_results
        : Set} : Set := Build {
        balance_updates : balance_updates;
        operation_result : operation_result;
        internal_operation_results : internal_operation_results }.
      Arguments record : clear implicits.
      Definition with_balance_updates
        {t_balance_updates t_operation_result t_internal_operation_results}
        balance_updates
        (r :
          record t_balance_updates t_operation_result
            t_internal_operation_results) :=
        Build t_balance_updates t_operation_result t_internal_operation_results
          balance_updates r.(operation_result) r.(internal_operation_results).
      Definition with_operation_result
        {t_balance_updates t_operation_result t_internal_operation_results}
        operation_result
        (r :
          record t_balance_updates t_operation_result
            t_internal_operation_results) :=
        Build t_balance_updates t_operation_result t_internal_operation_results
          r.(balance_updates) operation_result r.(internal_operation_results).
      Definition with_internal_operation_results
        {t_balance_updates t_operation_result t_internal_operation_results}
        internal_operation_results
        (r :
          record t_balance_updates t_operation_result
            t_internal_operation_results) :=
        Build t_balance_updates t_operation_result t_internal_operation_results
          r.(balance_updates) r.(operation_result) internal_operation_results.
    End Manager_operation_result.
    Definition Manager_operation_result_skeleton :=
      Manager_operation_result.record.
  End contents_result.
End ConstructorRecords_contents_result.
Import ConstructorRecords_contents_result.

Reserved Notation &quot;'contents_result.Endorsement_result&quot;.
Reserved Notation &quot;'contents_result.Manager_operation_result&quot;.

Inductive contents_result : Set :=
| Endorsement_result : 'contents_result.Endorsement_result -&gt; contents_result
| Seed_nonce_revelation_result :
  Alpha_context.Delegate.balance_updates -&gt; contents_result
| Double_endorsement_evidence_result :
  Alpha_context.Delegate.balance_updates -&gt; contents_result
| Double_baking_evidence_result :
  Alpha_context.Delegate.balance_updates -&gt; contents_result
| Activate_account_result :
  Alpha_context.Delegate.balance_updates -&gt; contents_result
| Proposals_result : contents_result
| Ballot_result : contents_result
| Manager_operation_result :
  'contents_result.Manager_operation_result -&gt; contents_result

where &quot;'contents_result.Endorsement_result&quot; :=
  (contents_result.Endorsement_result_skeleton
    Alpha_context.Delegate.balance_updates
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) (list int))
and &quot;'contents_result.Manager_operation_result&quot; :=
  (contents_result.Manager_operation_result_skeleton
    Alpha_context.Delegate.balance_updates manager_operation_result
    (list packed_internal_operation_result)).

Module contents_result.
  Include ConstructorRecords_contents_result.contents_result.
  Definition Endorsement_result := 'contents_result.Endorsement_result.
  Definition Manager_operation_result :=
    'contents_result.Manager_operation_result.
End contents_result.

Inductive packed_contents_result : Set :=
| Contents_result : contents_result -&gt; packed_contents_result.

Inductive packed_contents_and_result : Set :=
| Contents_and_result :
  Alpha_context.Operation.contents -&gt; contents_result -&gt;
  packed_contents_and_result.

Inductive eq : Set :=
| Eq : eq.

Definition equal_manager_kind
  (ka : Alpha_context.Kind.manager) (kb : Alpha_context.Kind.manager)
  : option eq :=
  match (ka, kb) with
  |
    (Alpha_context.Kind.Reveal_manager_kind,
      Alpha_context.Kind.Reveal_manager_kind) =&gt; Some Eq
  | (Alpha_context.Kind.Reveal_manager_kind, _) =&gt; None
  |
    (Alpha_context.Kind.Transaction_manager_kind,
      Alpha_context.Kind.Transaction_manager_kind) =&gt; Some Eq
  | (Alpha_context.Kind.Transaction_manager_kind, _) =&gt; None
  |
    (Alpha_context.Kind.Origination_manager_kind,
      Alpha_context.Kind.Origination_manager_kind) =&gt; Some Eq
  | (Alpha_context.Kind.Origination_manager_kind, _) =&gt; None
  |
    (Alpha_context.Kind.Delegation_manager_kind,
      Alpha_context.Kind.Delegation_manager_kind) =&gt; Some Eq
  | (Alpha_context.Kind.Delegation_manager_kind, _) =&gt; None
  end.

Module Encoding.
  Module ConstructorRecords_case.
    Module case.
      Module Case.
        Record record {op_case encoding select mselect proj inj : Set} : Set := Build {
          op_case : op_case;
          encoding : encoding;
          select : select;
          mselect : mselect;
          proj : proj;
          inj : inj }.
        Arguments record : clear implicits.
        Definition with_op_case
          {t_op_case t_encoding t_select t_mselect t_proj t_inj} op_case
          (r : record t_op_case t_encoding t_select t_mselect t_proj t_inj) :=
          Build t_op_case t_encoding t_select t_mselect t_proj t_inj op_case
            r.(encoding) r.(select) r.(mselect) r.(proj) r.(inj).
        Definition with_encoding
          {t_op_case t_encoding t_select t_mselect t_proj t_inj} encoding
          (r : record t_op_case t_encoding t_select t_mselect t_proj t_inj) :=
          Build t_op_case t_encoding t_select t_mselect t_proj t_inj r.(op_case)
            encoding r.(select) r.(mselect) r.(proj) r.(inj).
        Definition with_select
          {t_op_case t_encoding t_select t_mselect t_proj t_inj} select
          (r : record t_op_case t_encoding t_select t_mselect t_proj t_inj) :=
          Build t_op_case t_encoding t_select t_mselect t_proj t_inj r.(op_case)
            r.(encoding) select r.(mselect) r.(proj) r.(inj).
        Definition with_mselect
          {t_op_case t_encoding t_select t_mselect t_proj t_inj} mselect
          (r : record t_op_case t_encoding t_select t_mselect t_proj t_inj) :=
          Build t_op_case t_encoding t_select t_mselect t_proj t_inj r.(op_case)
            r.(encoding) r.(select) mselect r.(proj) r.(inj).
        Definition with_proj
          {t_op_case t_encoding t_select t_mselect t_proj t_inj} proj
          (r : record t_op_case t_encoding t_select t_mselect t_proj t_inj) :=
          Build t_op_case t_encoding t_select t_mselect t_proj t_inj r.(op_case)
            r.(encoding) r.(select) r.(mselect) proj r.(inj).
        Definition with_inj
          {t_op_case t_encoding t_select t_mselect t_proj t_inj} inj
          (r : record t_op_case t_encoding t_select t_mselect t_proj t_inj) :=
          Build t_op_case t_encoding t_select t_mselect t_proj t_inj r.(op_case)
            r.(encoding) r.(select) r.(mselect) r.(proj) inj.
      End Case.
      Definition Case_skeleton := Case.record.
    End case.
  End ConstructorRecords_case.
  Import ConstructorRecords_case.
  
  Reserved Notation &quot;'case.Case&quot;.
  
  Inductive case : Set :=
  | Case : forall {a : Set}, 'case.Case a -&gt; case
  
  where &quot;'case.Case&quot; := (fun (t_a : Set) =&gt;
    case.Case_skeleton Alpha_context.Operation.Encoding.case
      (Data_encoding.t t_a) (packed_contents_result -&gt; option contents_result)
      (packed_contents_and_result -&gt;
      option (Alpha_context.contents * contents_result))
      (contents_result -&gt; t_a) (t_a -&gt; contents_result)).
  
  Module case.
    Include ConstructorRecords_case.case.
    Definition Case := 'case.Case.
  End case.
  
  Definition tagged_case {A B : Set}
    (tag : Data_encoding.case_tag) (name : string)
    (args : Data_encoding.encoding A) (proj : B -&gt; option A) (inj : A -&gt; B)
    : Data_encoding.case B :=
    Data_encoding.__case_value (String.capitalize_ascii name) None tag
      (Data_encoding.merge_objs
        (Data_encoding.obj1
          (Data_encoding.req None None &quot;kind&quot; (Data_encoding.constant name)))
        args)
      (fun x =&gt;
        match proj x with
        | None =&gt; None
        | Some x =&gt; Some (tt, x)
        end)
      (fun function_parameter =&gt;
        let '(_, x) := function_parameter in
        inj x).
  
  Definition endorsement_case : case :=
    Case
      {| case.Case.op_case := Alpha_context.Operation.Encoding.endorsement_case;
        case.Case.encoding :=
          Data_encoding.obj3
            (Data_encoding.req None None &quot;balance_updates&quot;
              Alpha_context.Delegate.balance_updates_encoding)
            (Data_encoding.req None None &quot;delegate&quot;
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding))
            (Data_encoding.req None None &quot;slots&quot;
              (Data_encoding.__list_value None Data_encoding.uint8));
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents_result ((Endorsement_result _) as op) =&gt; Some op
            | _ =&gt; None
            end;
        case.Case.mselect :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents_and_result ((Alpha_context.Endorsement _) as op) res =&gt;
              Some (op, res)
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            match function_parameter with
            |
              Endorsement_result {|
                contents_result.Endorsement_result.balance_updates := balance_updates;
                  contents_result.Endorsement_result.delegate := delegate;
                  contents_result.Endorsement_result.slots := slots
                  |} =&gt; (balance_updates, delegate, slots)
            | _ =&gt; unreachable_gadt_branch
            end;
        case.Case.inj :=
          fun function_parameter =&gt;
            let '(balance_updates, delegate, slots) := function_parameter in
            Endorsement_result
              {|
                contents_result.Endorsement_result.balance_updates :=
                  balance_updates;
                contents_result.Endorsement_result.delegate := delegate;
                contents_result.Endorsement_result.slots := slots |} |}.
  
  Definition seed_nonce_revelation_case : case :=
    Case
      {|
        case.Case.op_case :=
          Alpha_context.Operation.Encoding.seed_nonce_revelation_case;
        case.Case.encoding :=
          Data_encoding.obj1
            (Data_encoding.req None None &quot;balance_updates&quot;
              Alpha_context.Delegate.balance_updates_encoding);
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents_result ((Seed_nonce_revelation_result _) as op) =&gt;
              Some op
            | _ =&gt; None
            end;
        case.Case.mselect :=
          fun function_parameter =&gt;
            match function_parameter with
            |
              Contents_and_result
                ((Alpha_context.Seed_nonce_revelation _) as op) res =&gt;
              Some (op, res)
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            match function_parameter with
            | Seed_nonce_revelation_result bus =&gt; bus
            | _ =&gt; unreachable_gadt_branch
            end; case.Case.inj := fun bus =&gt; Seed_nonce_revelation_result bus |}.
  
  Definition double_endorsement_evidence_case : case :=
    Case
      {|
        case.Case.op_case :=
          Alpha_context.Operation.Encoding.double_endorsement_evidence_case;
        case.Case.encoding :=
          Data_encoding.obj1
            (Data_encoding.req None None &quot;balance_updates&quot;
              Alpha_context.Delegate.balance_updates_encoding);
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents_result ((Double_endorsement_evidence_result _) as op) =&gt;
              Some op
            | _ =&gt; None
            end;
        case.Case.mselect :=
          fun function_parameter =&gt;
            match function_parameter with
            |
              Contents_and_result
                ((Alpha_context.Double_endorsement_evidence _) as op) res =&gt;
              Some (op, res)
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            match function_parameter with
            | Double_endorsement_evidence_result bus =&gt; bus
            | _ =&gt; unreachable_gadt_branch
            end;
        case.Case.inj := fun bus =&gt; Double_endorsement_evidence_result bus |}.
  
  Definition double_baking_evidence_case : case :=
    Case
      {|
        case.Case.op_case :=
          Alpha_context.Operation.Encoding.double_baking_evidence_case;
        case.Case.encoding :=
          Data_encoding.obj1
            (Data_encoding.req None None &quot;balance_updates&quot;
              Alpha_context.Delegate.balance_updates_encoding);
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents_result ((Double_baking_evidence_result _) as op) =&gt;
              Some op
            | _ =&gt; None
            end;
        case.Case.mselect :=
          fun function_parameter =&gt;
            match function_parameter with
            |
              Contents_and_result
                ((Alpha_context.Double_baking_evidence _) as op) res =&gt;
              Some (op, res)
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            match function_parameter with
            | Double_baking_evidence_result bus =&gt; bus
            | _ =&gt; unreachable_gadt_branch
            end; case.Case.inj := fun bus =&gt; Double_baking_evidence_result bus
        |}.
  
  Definition activate_account_case : case :=
    Case
      {|
        case.Case.op_case :=
          Alpha_context.Operation.Encoding.activate_account_case;
        case.Case.encoding :=
          Data_encoding.obj1
            (Data_encoding.req None None &quot;balance_updates&quot;
              Alpha_context.Delegate.balance_updates_encoding);
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents_result ((Activate_account_result _) as op) =&gt; Some op
            | _ =&gt; None
            end;
        case.Case.mselect :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents_and_result ((Alpha_context.Activate_account _) as op) res
              =&gt; Some (op, res)
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            match function_parameter with
            | Activate_account_result bus =&gt; bus
            | _ =&gt; unreachable_gadt_branch
            end; case.Case.inj := fun bus =&gt; Activate_account_result bus |}.
  
  Definition proposals_case : case :=
    Case
      {| case.Case.op_case := Alpha_context.Operation.Encoding.proposals_case;
        case.Case.encoding := Data_encoding.empty;
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents_result (Proposals_result as op) =&gt; Some op
            | _ =&gt; None
            end;
        case.Case.mselect :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents_and_result ((Alpha_context.Proposals _) as op) res =&gt;
              Some (op, res)
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            match function_parameter with
            | Proposals_result =&gt; tt
            | _ =&gt; unreachable_gadt_branch
            end;
        case.Case.inj :=
          fun function_parameter =&gt;
            let '_ := function_parameter in
            Proposals_result |}.
  
  Definition ballot_case : case :=
    Case
      {| case.Case.op_case := Alpha_context.Operation.Encoding.ballot_case;
        case.Case.encoding := Data_encoding.empty;
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents_result (Ballot_result as op) =&gt; Some op
            | _ =&gt; None
            end;
        case.Case.mselect :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents_and_result ((Alpha_context.Ballot _) as op) res =&gt;
              Some (op, res)
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            match function_parameter with
            | Ballot_result =&gt; tt
            | _ =&gt; unreachable_gadt_branch
            end;
        case.Case.inj :=
          fun function_parameter =&gt;
            let '_ := function_parameter in
            Ballot_result |}.
  
  Definition make_manager_case
    (function_parameter : Alpha_context.Operation.Encoding.case)
    : Manager_result.case -&gt;
    (packed_contents_and_result -&gt;
    option (Alpha_context.contents * contents_result)) -&gt; case :=
    let 'Alpha_context.Operation.Encoding.Case op_case := function_parameter in
    let 'existT _ __Case_'a op_case :=
      existT (A := Set)
        (fun __Case_'a =&gt; Alpha_context.Operation.Encoding.case.Case __Case_'a)
        _ op_case in
    fun function_parameter =&gt;
      let 'Manager_result.MCase res_case := function_parameter in
      let 'existT _ __MCase_'a res_case :=
        existT (A := Set)
          (fun __MCase_'a =&gt; Manager_result.case.MCase __MCase_'a) _ res_case in
      fun mselect =&gt;
        Case
          {| case.Case.op_case := Alpha_context.Operation.Encoding.Case op_case;
            case.Case.encoding :=
              Data_encoding.obj3
                (Data_encoding.req None None &quot;balance_updates&quot;
                  Alpha_context.Delegate.balance_updates_encoding)
                (Data_encoding.req None None &quot;operation_result&quot;
                  res_case.(Manager_result.case.MCase.t))
                (Data_encoding.dft None None &quot;internal_operation_results&quot;
                  (Data_encoding.__list_value None
                    internal_operation_result_encoding) nil);
            case.Case.select :=
              fun function_parameter =&gt;
                match function_parameter with
                |
                  Contents_result
                    (Manager_operation_result
                      ({|
                        contents_result.Manager_operation_result.operation_result := Applied res
                          |} as op)) =&gt;
                  match
                    res_case.(Manager_result.case.MCase.select)
                      (Successful_manager_result res) with
                  | Some res =&gt;
                    Some
                      (Manager_operation_result
                        (contents_result.Manager_operation_result.with_operation_result
                          (Applied res) op))
                  | None =&gt; None
                  end
                |
                  Contents_result
                    (Manager_operation_result
                      ({|
                        contents_result.Manager_operation_result.operation_result :=
                          Backtracked res errs
                          |} as op)) =&gt;
                  match
                    res_case.(Manager_result.case.MCase.select)
                      (Successful_manager_result res) with
                  | Some res =&gt;
                    Some
                      (Manager_operation_result
                        (contents_result.Manager_operation_result.with_operation_result
                          (Backtracked res errs) op))
                  | None =&gt; None
                  end
                |
                  Contents_result
                    (Manager_operation_result
                      ({|
                        contents_result.Manager_operation_result.operation_result := Skipped kind
                          |} as op)) =&gt;
                  match
                    equal_manager_kind kind
                      res_case.(Manager_result.case.MCase.kind) with
                  | None =&gt; None
                  | Some Eq =&gt;
                    Some
                      (Manager_operation_result
                        (contents_result.Manager_operation_result.with_operation_result
                          (Skipped kind) op))
                  end
                |
                  Contents_result
                    (Manager_operation_result
                      ({|
                        contents_result.Manager_operation_result.operation_result := Failed kind errs
                          |} as op)) =&gt;
                  match
                    equal_manager_kind kind
                      res_case.(Manager_result.case.MCase.kind) with
                  | None =&gt; None
                  | Some Eq =&gt;
                    Some
                      (Manager_operation_result
                        (contents_result.Manager_operation_result.with_operation_result
                          (Failed kind errs) op))
                  end
                | Contents_result Ballot_result =&gt; None
                | Contents_result (Endorsement_result _) =&gt; None
                | Contents_result (Seed_nonce_revelation_result _) =&gt; None
                | Contents_result (Double_endorsement_evidence_result _) =&gt; None
                | Contents_result (Double_baking_evidence_result _) =&gt; None
                | Contents_result (Activate_account_result _) =&gt; None
                | Contents_result Proposals_result =&gt; None
                end; case.Case.mselect := mselect;
            case.Case.proj :=
              fun function_parameter =&gt;
                match function_parameter with
                |
                  Manager_operation_result {|
                    contents_result.Manager_operation_result.balance_updates := bus;
                      contents_result.Manager_operation_result.operation_result
                        := __r_value;
                      contents_result.Manager_operation_result.internal_operation_results
                        := rs
                      |} =&gt; (bus, __r_value, rs)
                | _ =&gt; unreachable_gadt_branch
                end;
            case.Case.inj :=
              fun function_parameter =&gt;
                let '(bus, __r_value, rs) := function_parameter in
                Manager_operation_result
                  {|
                    contents_result.Manager_operation_result.balance_updates :=
                      bus;
                    contents_result.Manager_operation_result.operation_result :=
                      __r_value;
                    contents_result.Manager_operation_result.internal_operation_results :=
                      rs |} |}.
  
  Definition reveal_case : case :=
    make_manager_case Alpha_context.Operation.Encoding.reveal_case
      Manager_result.reveal_case
      (fun function_parameter =&gt;
        match function_parameter with
        |
          Contents_and_result
            ((Alpha_context.Manager_operation {|
              Alpha_context.contents.Manager_operation.operation := Alpha_context.Reveal _
                |}) as op) res =&gt; Some (op, res)
        | _ =&gt; None
        end).
  
  Definition transaction_case : case :=
    make_manager_case Alpha_context.Operation.Encoding.transaction_case
      Manager_result.transaction_case
      (fun function_parameter =&gt;
        match function_parameter with
        |
          Contents_and_result
            ((Alpha_context.Manager_operation {|
              Alpha_context.contents.Manager_operation.operation :=
                Alpha_context.Transaction _
                |}) as op) res =&gt; Some (op, res)
        | _ =&gt; None
        end).
  
  Definition origination_case : case :=
    make_manager_case Alpha_context.Operation.Encoding.origination_case
      Manager_result.origination_case
      (fun function_parameter =&gt;
        match function_parameter with
        |
          Contents_and_result
            ((Alpha_context.Manager_operation {|
              Alpha_context.contents.Manager_operation.operation :=
                Alpha_context.Origination _
                |}) as op) res =&gt; Some (op, res)
        | _ =&gt; None
        end).
  
  Definition delegation_case : case :=
    make_manager_case Alpha_context.Operation.Encoding.delegation_case
      Manager_result.delegation_case
      (fun function_parameter =&gt;
        match function_parameter with
        |
          Contents_and_result
            ((Alpha_context.Manager_operation {|
              Alpha_context.contents.Manager_operation.operation :=
                Alpha_context.Delegation _
                |}) as op) res =&gt; Some (op, res)
        | _ =&gt; None
        end).
End Encoding.

Definition contents_result_encoding
  : Data_encoding.encoding packed_contents_result :=
  let make (function_parameter : Encoding.case)
    : Data_encoding.case packed_contents_result :=
    let
      'Encoding.Case {|
        Encoding.case.Case.op_case :=
          Alpha_context.Operation.Encoding.Case {|
            Alpha_context.Operation.Encoding.case.Case.tag := tag;
              Alpha_context.Operation.Encoding.case.Case.name :=
                name
              |};
          Encoding.case.Case.encoding := encoding;
          Encoding.case.Case.select := select;
          Encoding.case.Case.mselect := _;
          Encoding.case.Case.proj := proj;
          Encoding.case.Case.inj := inj
          |} := function_parameter in
    let 'existT _ __Case_'a [tag, name, encoding, select, proj, inj] :=
      existT (A := Set)
        (fun __Case_'a =&gt;
          [int ** string ** Data_encoding.t __Case_'a **
            packed_contents_result -&gt; option contents_result **
            contents_result -&gt; __Case_'a ** __Case_'a -&gt; contents_result]) _
        [tag, name, encoding, select, proj, inj] in
    let proj (x : packed_contents_result) : option __Case_'a :=
      match select x with
      | None =&gt; None
      | Some x =&gt; Some (proj x)
      end in
    let inj (x : __Case_'a) : packed_contents_result :=
      Contents_result (inj x) in
    Encoding.tagged_case (Data_encoding.Tag tag) name encoding proj inj in
  (let arg := Data_encoding.def &quot;operation.alpha.contents_result&quot; in
  fun eta =&gt; arg None None eta)
    (Data_encoding.union None
      [
        make Encoding.endorsement_case;
        make Encoding.seed_nonce_revelation_case;
        make Encoding.double_endorsement_evidence_case;
        make Encoding.double_baking_evidence_case;
        make Encoding.activate_account_case;
        make Encoding.proposals_case;
        make Encoding.ballot_case;
        make Encoding.reveal_case;
        make Encoding.transaction_case;
        make Encoding.origination_case;
        make Encoding.delegation_case
      ]).

Definition contents_and_result_encoding
  : Data_encoding.encoding packed_contents_and_result :=
  let make (function_parameter : Encoding.case)
    : Data_encoding.case packed_contents_and_result :=
    let
      'Encoding.Case {|
        Encoding.case.Case.op_case :=
          Alpha_context.Operation.Encoding.Case {|
            Alpha_context.Operation.Encoding.case.Case.tag := tag;
              Alpha_context.Operation.Encoding.case.Case.name :=
                name;
              Alpha_context.Operation.Encoding.case.Case.encoding :=
                encoding;
              Alpha_context.Operation.Encoding.case.Case.proj :=
                proj;
              Alpha_context.Operation.Encoding.case.Case.inj := inj
              |};
          Encoding.case.Case.encoding := meta_encoding;
          Encoding.case.Case.mselect := mselect;
          Encoding.case.Case.proj := meta_proj;
          Encoding.case.Case.inj := meta_inj
          |} := function_parameter in
    let 'existT _ [__Case_'a, __Case_'a1]
      [tag, name, encoding, proj, inj, meta_encoding, mselect, meta_proj,
        meta_inj] :=
      existT (A := [Set ** Set])
        (fun '[__Case_'a, __Case_'a1] =&gt;
          [int ** string ** Data_encoding.t __Case_'a1 **
            Alpha_context.Operation.contents -&gt; __Case_'a1 **
            __Case_'a1 -&gt; Alpha_context.Operation.contents **
            Data_encoding.t __Case_'a **
            packed_contents_and_result -&gt;
            option (Alpha_context.contents * contents_result) **
            contents_result -&gt; __Case_'a ** __Case_'a -&gt; contents_result]) [_,
        _]
        [tag, name, encoding, proj, inj, meta_encoding, mselect, meta_proj,
          meta_inj] in
    let proj (c : packed_contents_and_result)
      : option (__Case_'a1 * __Case_'a) :=
      match mselect c with
      | Some (op, res) =&gt; Some ((proj op), (meta_proj res))
      | _ =&gt; None
      end in
    let inj (function_parameter : __Case_'a1 * __Case_'a)
      : packed_contents_and_result :=
      let '(op, res) := function_parameter in
      Contents_and_result (inj op) (meta_inj res) in
    let encoding :=
      Data_encoding.merge_objs encoding
        (Data_encoding.obj1
          (Data_encoding.req None None &quot;metadata&quot; meta_encoding)) in
    Encoding.tagged_case (Data_encoding.Tag tag) name encoding proj inj in
  (let arg := Data_encoding.def &quot;operation.alpha.operation_contents_and_result&quot;
    in
  fun eta =&gt; arg None None eta)
    (Data_encoding.union None
      [
        make Encoding.endorsement_case;
        make Encoding.seed_nonce_revelation_case;
        make Encoding.double_endorsement_evidence_case;
        make Encoding.double_baking_evidence_case;
        make Encoding.activate_account_case;
        make Encoding.proposals_case;
        make Encoding.ballot_case;
        make Encoding.reveal_case;
        make Encoding.transaction_case;
        make Encoding.origination_case;
        make Encoding.delegation_case
      ]).

Inductive contents_result_list : Set :=
| Single_result : contents_result -&gt; contents_result_list
| Cons_result : contents_result -&gt; contents_result_list -&gt; contents_result_list.

Inductive packed_contents_result_list : Set :=
| Contents_result_list : contents_result_list -&gt; packed_contents_result_list.

Definition contents_result_list_encoding
  : Data_encoding.encoding packed_contents_result_list :=
  let fix to_list (function_parameter : packed_contents_result_list)
    {struct function_parameter} : list packed_contents_result :=
    match function_parameter with
    | Contents_result_list (Single_result o) =&gt; [ Contents_result o ]
    | Contents_result_list (Cons_result o os) =&gt;
      cons (Contents_result o) (to_list (Contents_result_list os))
    end in
  let fix of_list (function_parameter : list packed_contents_result)
    {struct function_parameter} : packed_contents_result_list :=
    match function_parameter with
    | [] =&gt; Pervasives.failwith &quot;cannot decode empty operation result&quot;
    | cons (Contents_result o) [] =&gt; Contents_result_list (Single_result o)
    | cons (Contents_result o) os =&gt;
      let 'Contents_result_list os := of_list os in
      match (o, os) with
      | (Manager_operation_result _, Single_result (Manager_operation_result _))
        =&gt; Contents_result_list (Cons_result o os)
      | (Manager_operation_result _, Cons_result _ _) =&gt;
        Contents_result_list (Cons_result o os)
      | _ =&gt; Pervasives.failwith &quot;cannot decode ill-formed operation result&quot;
      end
    end in
  (let arg := Data_encoding.def &quot;operation.alpha.contents_list_result&quot; in
  fun eta =&gt; arg None None eta)
    (Data_encoding.conv to_list of_list None
      (Data_encoding.__list_value None contents_result_encoding)).

Inductive contents_and_result_list : Set :=
| Single_and_result :
  Alpha_context.contents -&gt; contents_result -&gt; contents_and_result_list
| Cons_and_result :
  Alpha_context.contents -&gt; contents_result -&gt; contents_and_result_list -&gt;
  contents_and_result_list.

Inductive packed_contents_and_result_list : Set :=
| Contents_and_result_list :
  contents_and_result_list -&gt; packed_contents_and_result_list.

Definition contents_and_result_list_encoding
  : Data_encoding.encoding packed_contents_and_result_list :=
  let fix to_list (function_parameter : packed_contents_and_result_list)
    {struct function_parameter} : list packed_contents_and_result :=
    match function_parameter with
    | Contents_and_result_list (Single_and_result op res) =&gt;
      [ Contents_and_result op res ]
    | Contents_and_result_list (Cons_and_result op res rest) =&gt;
      cons (Contents_and_result op res)
        (to_list (Contents_and_result_list rest))
    end in
  let fix of_list (function_parameter : list packed_contents_and_result)
    {struct function_parameter} : packed_contents_and_result_list :=
    match function_parameter with
    | [] =&gt; Pervasives.failwith &quot;cannot decode empty combined operation result&quot;
    | cons (Contents_and_result op res) [] =&gt;
      Contents_and_result_list (Single_and_result op res)
    | cons (Contents_and_result op res) rest =&gt;
      let 'Contents_and_result_list rest := of_list rest in
      match (op, rest) with
      |
        (Alpha_context.Manager_operation _,
          Single_and_result (Alpha_context.Manager_operation _) _) =&gt;
        Contents_and_result_list (Cons_and_result op res rest)
      | (Alpha_context.Manager_operation _, Cons_and_result _ _ _) =&gt;
        Contents_and_result_list (Cons_and_result op res rest)
      | _ =&gt;
        Pervasives.failwith &quot;cannot decode ill-formed combined operation result&quot;
      end
    end in
  Data_encoding.conv to_list of_list None
    (Data_encoding.__Variable.__list_value None contents_and_result_encoding).

Module operation_metadata.
  Record record : Set := Build {
    contents : contents_result_list }.
  Definition with_contents contents (r : record) :=
    Build contents.
End operation_metadata.
Definition operation_metadata := operation_metadata.record.

Inductive packed_operation_metadata : Set :=
| Operation_metadata : operation_metadata -&gt; packed_operation_metadata
| No_operation_metadata : packed_operation_metadata.

Definition operation_metadata_encoding
  : Data_encoding.encoding packed_operation_metadata :=
  (let arg := Data_encoding.def &quot;operation.alpha.result&quot; in
  fun eta =&gt; arg None None eta)
    (Data_encoding.union None
      [
        Data_encoding.__case_value &quot;Operation_metadata&quot; None
          (Data_encoding.Tag 0) contents_result_list_encoding
          (fun function_parameter =&gt;
            match function_parameter with
            |
              Operation_metadata {|
                operation_metadata.contents := contents
                  |} =&gt; Some (Contents_result_list contents)
            | _ =&gt; None
            end)
          (fun function_parameter =&gt;
            let 'Contents_result_list contents := function_parameter in
            Operation_metadata
              {| operation_metadata.contents := contents |});
        Data_encoding.__case_value &quot;No_operation_metadata&quot; None
          (Data_encoding.Tag 1) Data_encoding.empty
          (fun function_parameter =&gt;
            match function_parameter with
            | No_operation_metadata =&gt; Some tt
            | _ =&gt; None
            end)
          (fun function_parameter =&gt;
            let '_ := function_parameter in
            No_operation_metadata)
      ]).

Definition kind_equal (op : Alpha_context.contents) (res : contents_result)
  : option eq :=
  match (op, res) with
  | (Alpha_context.Endorsement _, Endorsement_result _) =&gt; Some Eq
  | (Alpha_context.Endorsement _, _) =&gt; None
  | (Alpha_context.Seed_nonce_revelation _, Seed_nonce_revelation_result _) =&gt;
    Some Eq
  | (Alpha_context.Seed_nonce_revelation _, _) =&gt; None
  |
    (Alpha_context.Double_endorsement_evidence _,
      Double_endorsement_evidence_result _) =&gt; Some Eq
  | (Alpha_context.Double_endorsement_evidence _, _) =&gt; None
  | (Alpha_context.Double_baking_evidence _, Double_baking_evidence_result _) =&gt;
    Some Eq
  | (Alpha_context.Double_baking_evidence _, _) =&gt; None
  | (Alpha_context.Activate_account _, Activate_account_result _) =&gt; Some Eq
  | (Alpha_context.Activate_account _, _) =&gt; None
  | (Alpha_context.Proposals _, Proposals_result) =&gt; Some Eq
  | (Alpha_context.Proposals _, _) =&gt; None
  | (Alpha_context.Ballot _, Ballot_result) =&gt; Some Eq
  | (Alpha_context.Ballot _, _) =&gt; None
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation := Alpha_context.Reveal _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Applied (Reveal_result _)
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation := Alpha_context.Reveal _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Backtracked (Reveal_result _) _
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation := Alpha_context.Reveal _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Failed Alpha_context.Kind.Reveal_manager_kind _
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation := Alpha_context.Reveal _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Skipped Alpha_context.Kind.Reveal_manager_kind
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation := Alpha_context.Reveal _
        |}, _) =&gt; None
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Transaction _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Applied (Transaction_result _)
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Transaction _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Backtracked (Transaction_result _) _
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Transaction _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Failed Alpha_context.Kind.Transaction_manager_kind _
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Transaction _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Skipped Alpha_context.Kind.Transaction_manager_kind
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Transaction _
        |}, _) =&gt; None
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Origination _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Applied (Origination_result _)
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Origination _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Backtracked (Origination_result _) _
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Origination _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Failed Alpha_context.Kind.Origination_manager_kind _
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Origination _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Skipped Alpha_context.Kind.Origination_manager_kind
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Origination _
        |}, _) =&gt; None
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Delegation _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Applied (Delegation_result _)
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Delegation _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Backtracked (Delegation_result _) _
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Delegation _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Failed Alpha_context.Kind.Delegation_manager_kind _
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Delegation _
        |},
      Manager_operation_result {|
        contents_result.Manager_operation_result.operation_result :=
          Skipped Alpha_context.Kind.Delegation_manager_kind
          |}) =&gt; Some Eq
  |
    (Alpha_context.Manager_operation {|
      Alpha_context.contents.Manager_operation.operation :=
        Alpha_context.Delegation _
        |}, _) =&gt; None
  end.

Fixpoint kind_equal_list
  (contents : Alpha_context.contents_list) (res : contents_result_list)
  {struct contents} : option eq :=
  match (contents, res) with
  | (Alpha_context.Single op, Single_result res) =&gt;
    match kind_equal op res with
    | None =&gt; None
    | Some Eq =&gt; Some Eq
    end
  | (Alpha_context.Cons op ops, Cons_result res ress) =&gt;
    match kind_equal op res with
    | None =&gt; None
    | Some Eq =&gt;
      match kind_equal_list ops ress with
      | None =&gt; None
      | Some Eq =&gt; Some Eq
      end
    end
  | _ =&gt; None
  end.

Fixpoint pack_contents_list
  (contents : Alpha_context.contents_list) (res : contents_result_list)
  {struct contents} : contents_and_result_list :=
  match (contents, res) with
  | (Alpha_context.Single op, Single_result res) =&gt; Single_and_result op res
  | (Alpha_context.Cons op ops, Cons_result res ress) =&gt;
    Cons_and_result op res (pack_contents_list ops ress)
  |
    (Alpha_context.Single (Alpha_context.Manager_operation _),
      Cons_result (Manager_operation_result _) (Single_result _)) =&gt;
    (* ‚ùå Unreachable expressions are not supported *)
    unreachable
  |
    (Alpha_context.Cons _ _,
      Single_result
        (Manager_operation_result {|
          contents_result.Manager_operation_result.operation_result := Failed _ _
            |})) =&gt;
    (* ‚ùå Unreachable expressions are not supported *)
    unreachable
  |
    (Alpha_context.Cons _ _,
      Single_result
        (Manager_operation_result {|
          contents_result.Manager_operation_result.operation_result := Skipped _
            |})) =&gt;
    (* ‚ùå Unreachable expressions are not supported *)
    unreachable
  |
    (Alpha_context.Cons _ _,
      Single_result
        (Manager_operation_result {|
          contents_result.Manager_operation_result.operation_result := Applied _
            |})) =&gt;
    (* ‚ùå Unreachable expressions are not supported *)
    unreachable
  |
    (Alpha_context.Cons _ _,
      Single_result
        (Manager_operation_result {|
          contents_result.Manager_operation_result.operation_result := Backtracked _ _
            |})) =&gt;
    (* ‚ùå Unreachable expressions are not supported *)
    unreachable
  | (Alpha_context.Single _, Cons_result _ _) =&gt;
    (* ‚ùå Unreachable expressions are not supported *)
    unreachable
  | _ =&gt; unreachable_gadt_branch
  end.

Fixpoint unpack_contents_list (function_parameter : contents_and_result_list)
  {struct function_parameter}
  : Alpha_context.contents_list * contents_result_list :=
  match function_parameter with
  | Single_and_result op res =&gt; ((Alpha_context.Single op), (Single_result res))
  | Cons_and_result op res rest =&gt;
    let '(ops, ress) := unpack_contents_list rest in
    ((Alpha_context.Cons op ops), (Cons_result res ress))
  end.

Fixpoint to_list (function_parameter : packed_contents_result_list)
  {struct function_parameter} : list packed_contents_result :=
  match function_parameter with
  | Contents_result_list (Single_result o) =&gt; [ Contents_result o ]
  | Contents_result_list (Cons_result o os) =&gt;
    cons (Contents_result o) (to_list (Contents_result_list os))
  end.

Fixpoint of_list (function_parameter : list packed_contents_result)
  {struct function_parameter} : packed_contents_result_list :=
  match function_parameter with
  | [] =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert packed_contents_result_list false
  | cons (Contents_result o) [] =&gt; Contents_result_list (Single_result o)
  | cons (Contents_result o) os =&gt;
    let 'Contents_result_list os := of_list os in
    match (o, os) with
    | (Manager_operation_result _, Single_result (Manager_operation_result _))
      =&gt; Contents_result_list (Cons_result o os)
    | (Manager_operation_result _, Cons_result _ _) =&gt;
      Contents_result_list (Cons_result o os)
    | _ =&gt;
      Pervasives.failwith
        &quot;Operation result list of length &gt; 1 should only contains manager operations result.&quot;
    end
  end.

Definition operation_data_and_metadata_encoding
  : Data_encoding.encoding
    (Alpha_context.packed_protocol_data * packed_operation_metadata) :=
  (let arg := Data_encoding.def &quot;operation.alpha.operation_with_metadata&quot; in
  fun eta =&gt; arg None None eta)
    (Data_encoding.union None
      [
        Data_encoding.__case_value &quot;Operation_with_metadata&quot; None
          (Data_encoding.Tag 0)
          (Data_encoding.obj2
            (Data_encoding.req None None &quot;contents&quot;
              (Data_encoding.dynamic_size None
                contents_and_result_list_encoding))
            (Data_encoding.opt None None &quot;signature&quot; Signature.encoding))
          (fun function_parameter =&gt;
            match function_parameter with
            | (Alpha_context.Operation_data _, No_operation_metadata) =&gt;
              None
            | (Alpha_context.Operation_data op, Operation_metadata res)
              =&gt;
              match
                kind_equal_list
                  op.(Alpha_context.protocol_data.contents)
                  res.(operation_metadata.contents) with
              | None =&gt;
                Pervasives.failwith
                  &quot;cannot decode inconsistent combined operation result&quot;
              | Some Eq =&gt;
                Some
                  ((Contents_and_result_list
                    (pack_contents_list
                      op.(Alpha_context.protocol_data.contents)
                      res.(operation_metadata.contents))),
                    op.(Alpha_context.protocol_data.signature))
              end
            end)
          (fun function_parameter =&gt;
            let '(Contents_and_result_list contents, signature) :=
              function_parameter in
            let '(op_contents, res_contents) :=
              unpack_contents_list contents in
            ((Alpha_context.Operation_data
              {|
                Alpha_context.protocol_data.contents :=
                  op_contents;
                Alpha_context.protocol_data.signature :=
                  signature |}),
              (Operation_metadata
                {| operation_metadata.contents := res_contents
                  |})));
        Data_encoding.__case_value &quot;Operation_without_metadata&quot; None
          (Data_encoding.Tag 1)
          (Data_encoding.obj2
            (Data_encoding.req None None &quot;contents&quot;
              (Data_encoding.dynamic_size None
                Alpha_context.Operation.contents_list_encoding))
            (Data_encoding.opt None None &quot;signature&quot; Signature.encoding))
          (fun function_parameter =&gt;
            match function_parameter with
            | (Alpha_context.Operation_data op, No_operation_metadata)
              =&gt;
              Some
                ((Alpha_context.Contents_list
                  op.(Alpha_context.protocol_data.contents)),
                  op.(Alpha_context.protocol_data.signature))
            | (Alpha_context.Operation_data _, Operation_metadata _) =&gt;
              None
            end)
          (fun function_parameter =&gt;
            let '(Alpha_context.Contents_list contents, signature) :=
              function_parameter in
            ((Alpha_context.Operation_data
              {| Alpha_context.protocol_data.contents := contents;
                Alpha_context.protocol_data.signature :=
                  signature |}), No_operation_metadata))
      ]).

Module block_metadata.
  Record record : Set := Build {
    baker : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t);
    level : Alpha_context.Level.t;
    voting_period_kind : Alpha_context.Voting_period.kind;
    nonce_hash : option Nonce_hash.t;
    consumed_gas : Z.t;
    deactivated : list (|Signature.Public_key_hash|).(S.SPublic_key_hash.t);
    balance_updates : Alpha_context.Delegate.balance_updates }.
  Definition with_baker baker (r : record) :=
    Build baker r.(level) r.(voting_period_kind) r.(nonce_hash) r.(consumed_gas)
      r.(deactivated) r.(balance_updates).
  Definition with_level level (r : record) :=
    Build r.(baker) level r.(voting_period_kind) r.(nonce_hash) r.(consumed_gas)
      r.(deactivated) r.(balance_updates).
  Definition with_voting_period_kind voting_period_kind (r : record) :=
    Build r.(baker) r.(level) voting_period_kind r.(nonce_hash) r.(consumed_gas)
      r.(deactivated) r.(balance_updates).
  Definition with_nonce_hash nonce_hash (r : record) :=
    Build r.(baker) r.(level) r.(voting_period_kind) nonce_hash r.(consumed_gas)
      r.(deactivated) r.(balance_updates).
  Definition with_consumed_gas consumed_gas (r : record) :=
    Build r.(baker) r.(level) r.(voting_period_kind) r.(nonce_hash) consumed_gas
      r.(deactivated) r.(balance_updates).
  Definition with_deactivated deactivated (r : record) :=
    Build r.(baker) r.(level) r.(voting_period_kind) r.(nonce_hash)
      r.(consumed_gas) deactivated r.(balance_updates).
  Definition with_balance_updates balance_updates (r : record) :=
    Build r.(baker) r.(level) r.(voting_period_kind) r.(nonce_hash)
      r.(consumed_gas) r.(deactivated) balance_updates.
End block_metadata.
Definition block_metadata := block_metadata.record.

Definition block_metadata_encoding : Data_encoding.encoding block_metadata :=
  (let arg := Data_encoding.def &quot;block_header.alpha.metadata&quot; in
  fun eta =&gt; arg None None eta)
    (Data_encoding.conv
      (fun function_parameter =&gt;
        let '{|
          block_metadata.baker := baker;
            block_metadata.level := level;
            block_metadata.voting_period_kind := voting_period_kind;
            block_metadata.nonce_hash := nonce_hash;
            block_metadata.consumed_gas := consumed_gas;
            block_metadata.deactivated := deactivated;
            block_metadata.balance_updates := balance_updates
            |} := function_parameter in
        (baker, level, voting_period_kind, nonce_hash, consumed_gas,
          deactivated, balance_updates))
      (fun function_parameter =&gt;
        let
          '(baker, level, voting_period_kind, nonce_hash, consumed_gas,
            deactivated, balance_updates) := function_parameter in
        {| block_metadata.baker := baker; block_metadata.level := level;
          block_metadata.voting_period_kind := voting_period_kind;
          block_metadata.nonce_hash := nonce_hash;
          block_metadata.consumed_gas := consumed_gas;
          block_metadata.deactivated := deactivated;
          block_metadata.balance_updates := balance_updates |}) None
      (Data_encoding.obj7
        (Data_encoding.req None None &quot;baker&quot;
          (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding))
        (Data_encoding.req None None &quot;level&quot; Alpha_context.Level.encoding)
        (Data_encoding.req None None &quot;voting_period_kind&quot;
          Alpha_context.Voting_period.kind_encoding)
        (Data_encoding.req None None &quot;nonce_hash&quot;
          (Data_encoding.__option_value Nonce_hash.encoding))
        (Data_encoding.req None None &quot;consumed_gas&quot;
          (Data_encoding.check_size 10 Data_encoding.n))
        (Data_encoding.req None None &quot;deactivated&quot;
          (Data_encoding.__list_value None
            (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding)))
        (Data_encoding.req None None &quot;balance_updates&quot;
          Alpha_context.Delegate.balance_updates_encoding))).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="apply_results.mli">
  <div style="margin: 20px;">
    <h3>Apply_results_mli</h3>
    <ul>
      <li>OCaml size: 191 lines</li>
      <li>Coq size: 500 lines (+161% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#apply_results.mli"><code>apply_results.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Result of applying an operation, can be used for experimenting
    with protocol updates, by clients to print out a summary of the
    operation at pre-injection simulation and at confirmation time,
    and by block explorers. *)

open Alpha_context

type packed_operation_metadata =
  | Operation_metadata : 'kind operation_metadata -&gt; packed_operation_metadata
  | No_operation_metadata : packed_operation_metadata

(** Result of applying a {!Operation.contents_list}. Follows the same structure. *)
and 'kind contents_result_list =
  | Single_result : 'kind contents_result -&gt; 'kind contents_result_list
  | Cons_result :
      'kind Kind.manager contents_result
      * 'rest Kind.manager contents_result_list
      -&gt; ('kind * 'rest) Kind.manager contents_result_list

(** Result of applying a {!Operation.t}. Follows the same structure. *)
and 'kind operation_metadata = {contents : 'kind contents_result_list}

and packed_contents_result_list =
  | Contents_result_list :
      'kind contents_result_list
      -&gt; packed_contents_result_list

(** Result of applying an {!Operation.contents}. Follows the same structure. *)
and 'kind contents_result =
  | Endorsement_result : {
      balance_updates : Delegate.balance_updates;
      delegate : Signature.Public_key_hash.t;
      slots : int list;
    }
      -&gt; Kind.endorsement contents_result
  | Seed_nonce_revelation_result :
      Delegate.balance_updates
      -&gt; Kind.seed_nonce_revelation contents_result
  | Double_endorsement_evidence_result :
      Delegate.balance_updates
      -&gt; Kind.double_endorsement_evidence contents_result
  | Double_baking_evidence_result :
      Delegate.balance_updates
      -&gt; Kind.double_baking_evidence contents_result
  | Activate_account_result :
      Delegate.balance_updates
      -&gt; Kind.activate_account contents_result
  | Proposals_result : Kind.proposals contents_result
  | Ballot_result : Kind.ballot contents_result
  | Manager_operation_result : {
      balance_updates : Delegate.balance_updates;
      operation_result : 'kind manager_operation_result;
      internal_operation_results : packed_internal_operation_result list;
    }
      -&gt; 'kind Kind.manager contents_result

and packed_contents_result =
  | Contents_result : 'kind contents_result -&gt; packed_contents_result

(** The result of an operation in the queue. [Skipped] ones should
    always be at the tail, and after a single [Failed]. *)
and 'kind manager_operation_result =
  | Applied of 'kind successful_manager_operation_result
  | Backtracked of
      'kind successful_manager_operation_result * error list option
  | Failed : 'kind Kind.manager * error list -&gt; 'kind manager_operation_result
  | Skipped : 'kind Kind.manager -&gt; 'kind manager_operation_result
[@@coq_force_gadt]

(** Result of applying a {!manager_operation_content}, either internal
    or external. *)
and _ successful_manager_operation_result =
  | Reveal_result : {
      consumed_gas : Z.t;
    }
      -&gt; Kind.reveal successful_manager_operation_result
  | Transaction_result : {
      storage : Script.expr option;
      big_map_diff : Contract.big_map_diff option;
      balance_updates : Delegate.balance_updates;
      originated_contracts : Contract.t list;
      consumed_gas : Z.t;
      storage_size : Z.t;
      paid_storage_size_diff : Z.t;
      allocated_destination_contract : bool;
    }
      -&gt; Kind.transaction successful_manager_operation_result
  | Origination_result : {
      big_map_diff : Contract.big_map_diff option;
      balance_updates : Delegate.balance_updates;
      originated_contracts : Contract.t list;
      consumed_gas : Z.t;
      storage_size : Z.t;
      paid_storage_size_diff : Z.t;
    }
      -&gt; Kind.origination successful_manager_operation_result
  | Delegation_result : {
      consumed_gas : Z.t;
    }
      -&gt; Kind.delegation successful_manager_operation_result

and packed_successful_manager_operation_result =
  | Successful_manager_result :
      'kind successful_manager_operation_result
      -&gt; packed_successful_manager_operation_result

and packed_internal_operation_result =
  | Internal_operation_result :
      'kind internal_operation * 'kind manager_operation_result
      -&gt; packed_internal_operation_result

(** Serializer for {!packed_operation_result}. *)
val operation_metadata_encoding : packed_operation_metadata Data_encoding.t

val operation_data_and_metadata_encoding :
  (Operation.packed_protocol_data * packed_operation_metadata) Data_encoding.t

type 'kind contents_and_result_list =
  | Single_and_result :
      'kind Alpha_context.contents * 'kind contents_result
      -&gt; 'kind contents_and_result_list
  | Cons_and_result :
      'kind Kind.manager Alpha_context.contents
      * 'kind Kind.manager contents_result
      * 'rest Kind.manager contents_and_result_list
      -&gt; ('kind * 'rest) Kind.manager contents_and_result_list

type packed_contents_and_result_list =
  | Contents_and_result_list :
      'kind contents_and_result_list
      -&gt; packed_contents_and_result_list

val contents_and_result_list_encoding :
  packed_contents_and_result_list Data_encoding.t

val pack_contents_list :
  'kind contents_list -&gt;
  'kind contents_result_list -&gt;
  'kind contents_and_result_list

val unpack_contents_list :
  'kind contents_and_result_list -&gt;
  'kind contents_list * 'kind contents_result_list

val to_list : packed_contents_result_list -&gt; packed_contents_result list

val of_list : packed_contents_result list -&gt; packed_contents_result_list

type ('a, 'b) eq = Eq : ('a, 'a) eq

val kind_equal_list :
  'kind contents_list -&gt;
  'kind2 contents_result_list -&gt;
  ('kind, 'kind2) eq option

type block_metadata = {
  baker : Signature.Public_key_hash.t;
  level : Level.t;
  voting_period_kind : Voting_period.kind;
  nonce_hash : Nonce_hash.t option;
  consumed_gas : Z.t;
  deactivated : Signature.Public_key_hash.t list;
  balance_updates : Delegate.balance_updates;
}

val block_metadata_encoding : block_metadata Data_encoding.encoding
</pre>
  </div>
  <div class="col-md-6">
    <a href="#apply_results.mli"><code>Apply_results_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Nonce_hash.

Import Alpha_context.

Module
  ConstructorRecords_packed_operation_metadata_contents_result_list_packed_contents_result_list_contents_result_packed_contents_result_manager_operation_result_successful_manager_operation_result_packed_successful_manager_operation_result_packed_internal_operation_result.
  Module contents_result.
    Module Endorsement_result.
      Record record {balance_updates delegate slots : Set} : Set := Build {
        balance_updates : balance_updates;
        delegate : delegate;
        slots : slots }.
      Arguments record : clear implicits.
      Definition with_balance_updates {t_balance_updates t_delegate t_slots}
        balance_updates (r : record t_balance_updates t_delegate t_slots) :=
        Build t_balance_updates t_delegate t_slots balance_updates r.(delegate)
          r.(slots).
      Definition with_delegate {t_balance_updates t_delegate t_slots} delegate
        (r : record t_balance_updates t_delegate t_slots) :=
        Build t_balance_updates t_delegate t_slots r.(balance_updates) delegate
          r.(slots).
      Definition with_slots {t_balance_updates t_delegate t_slots} slots
        (r : record t_balance_updates t_delegate t_slots) :=
        Build t_balance_updates t_delegate t_slots r.(balance_updates)
          r.(delegate) slots.
    End Endorsement_result.
    Definition Endorsement_result_skeleton := Endorsement_result.record.
    
    Module Manager_operation_result.
      Record record {balance_updates operation_result internal_operation_results
        : Set} : Set := Build {
        balance_updates : balance_updates;
        operation_result : operation_result;
        internal_operation_results : internal_operation_results }.
      Arguments record : clear implicits.
      Definition with_balance_updates
        {t_balance_updates t_operation_result t_internal_operation_results}
        balance_updates
        (r :
          record t_balance_updates t_operation_result
            t_internal_operation_results) :=
        Build t_balance_updates t_operation_result t_internal_operation_results
          balance_updates r.(operation_result) r.(internal_operation_results).
      Definition with_operation_result
        {t_balance_updates t_operation_result t_internal_operation_results}
        operation_result
        (r :
          record t_balance_updates t_operation_result
            t_internal_operation_results) :=
        Build t_balance_updates t_operation_result t_internal_operation_results
          r.(balance_updates) operation_result r.(internal_operation_results).
      Definition with_internal_operation_results
        {t_balance_updates t_operation_result t_internal_operation_results}
        internal_operation_results
        (r :
          record t_balance_updates t_operation_result
            t_internal_operation_results) :=
        Build t_balance_updates t_operation_result t_internal_operation_results
          r.(balance_updates) r.(operation_result) internal_operation_results.
    End Manager_operation_result.
    Definition Manager_operation_result_skeleton :=
      Manager_operation_result.record.
  End contents_result.
  Module successful_manager_operation_result.
    Module Reveal_result.
      Record record {consumed_gas : Set} : Set := Build {
        consumed_gas : consumed_gas }.
      Arguments record : clear implicits.
      Definition with_consumed_gas {t_consumed_gas} consumed_gas
        (r : record t_consumed_gas) :=
        Build t_consumed_gas consumed_gas.
    End Reveal_result.
    Definition Reveal_result_skeleton := Reveal_result.record.
    
    Module Transaction_result.
      Record record {storage big_map_diff balance_updates originated_contracts
        consumed_gas storage_size paid_storage_size_diff
        allocated_destination_contract : Set} : Set := Build {
        storage : storage;
        big_map_diff : big_map_diff;
        balance_updates : balance_updates;
        originated_contracts : originated_contracts;
        consumed_gas : consumed_gas;
        storage_size : storage_size;
        paid_storage_size_diff : paid_storage_size_diff;
        allocated_destination_contract : allocated_destination_contract }.
      Arguments record : clear implicits.
      Definition with_storage
        {t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract} storage
        (r :
          record t_storage t_big_map_diff t_balance_updates
            t_originated_contracts t_consumed_gas t_storage_size
            t_paid_storage_size_diff t_allocated_destination_contract) :=
        Build t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract storage r.(big_map_diff)
          r.(balance_updates) r.(originated_contracts) r.(consumed_gas)
          r.(storage_size) r.(paid_storage_size_diff)
          r.(allocated_destination_contract).
      Definition with_big_map_diff
        {t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract} big_map_diff
        (r :
          record t_storage t_big_map_diff t_balance_updates
            t_originated_contracts t_consumed_gas t_storage_size
            t_paid_storage_size_diff t_allocated_destination_contract) :=
        Build t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract r.(storage) big_map_diff
          r.(balance_updates) r.(originated_contracts) r.(consumed_gas)
          r.(storage_size) r.(paid_storage_size_diff)
          r.(allocated_destination_contract).
      Definition with_balance_updates
        {t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract} balance_updates
        (r :
          record t_storage t_big_map_diff t_balance_updates
            t_originated_contracts t_consumed_gas t_storage_size
            t_paid_storage_size_diff t_allocated_destination_contract) :=
        Build t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract r.(storage) r.(big_map_diff)
          balance_updates r.(originated_contracts) r.(consumed_gas)
          r.(storage_size) r.(paid_storage_size_diff)
          r.(allocated_destination_contract).
      Definition with_originated_contracts
        {t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract} originated_contracts
        (r :
          record t_storage t_big_map_diff t_balance_updates
            t_originated_contracts t_consumed_gas t_storage_size
            t_paid_storage_size_diff t_allocated_destination_contract) :=
        Build t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract r.(storage) r.(big_map_diff)
          r.(balance_updates) originated_contracts r.(consumed_gas)
          r.(storage_size) r.(paid_storage_size_diff)
          r.(allocated_destination_contract).
      Definition with_consumed_gas
        {t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract} consumed_gas
        (r :
          record t_storage t_big_map_diff t_balance_updates
            t_originated_contracts t_consumed_gas t_storage_size
            t_paid_storage_size_diff t_allocated_destination_contract) :=
        Build t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract r.(storage) r.(big_map_diff)
          r.(balance_updates) r.(originated_contracts) consumed_gas
          r.(storage_size) r.(paid_storage_size_diff)
          r.(allocated_destination_contract).
      Definition with_storage_size
        {t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract} storage_size
        (r :
          record t_storage t_big_map_diff t_balance_updates
            t_originated_contracts t_consumed_gas t_storage_size
            t_paid_storage_size_diff t_allocated_destination_contract) :=
        Build t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract r.(storage) r.(big_map_diff)
          r.(balance_updates) r.(originated_contracts) r.(consumed_gas)
          storage_size r.(paid_storage_size_diff)
          r.(allocated_destination_contract).
      Definition with_paid_storage_size_diff
        {t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract} paid_storage_size_diff
        (r :
          record t_storage t_big_map_diff t_balance_updates
            t_originated_contracts t_consumed_gas t_storage_size
            t_paid_storage_size_diff t_allocated_destination_contract) :=
        Build t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract r.(storage) r.(big_map_diff)
          r.(balance_updates) r.(originated_contracts) r.(consumed_gas)
          r.(storage_size) paid_storage_size_diff
          r.(allocated_destination_contract).
      Definition with_allocated_destination_contract
        {t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract} allocated_destination_contract
        (r :
          record t_storage t_big_map_diff t_balance_updates
            t_originated_contracts t_consumed_gas t_storage_size
            t_paid_storage_size_diff t_allocated_destination_contract) :=
        Build t_storage t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          t_allocated_destination_contract r.(storage) r.(big_map_diff)
          r.(balance_updates) r.(originated_contracts) r.(consumed_gas)
          r.(storage_size) r.(paid_storage_size_diff)
          allocated_destination_contract.
    End Transaction_result.
    Definition Transaction_result_skeleton := Transaction_result.record.
    
    Module Origination_result.
      Record record {big_map_diff balance_updates originated_contracts
        consumed_gas storage_size paid_storage_size_diff : Set} : Set := Build {
        big_map_diff : big_map_diff;
        balance_updates : balance_updates;
        originated_contracts : originated_contracts;
        consumed_gas : consumed_gas;
        storage_size : storage_size;
        paid_storage_size_diff : paid_storage_size_diff }.
      Arguments record : clear implicits.
      Definition with_big_map_diff
        {t_big_map_diff t_balance_updates t_originated_contracts t_consumed_gas
          t_storage_size t_paid_storage_size_diff} big_map_diff
        (r :
          record t_big_map_diff t_balance_updates t_originated_contracts
            t_consumed_gas t_storage_size t_paid_storage_size_diff) :=
        Build t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff big_map_diff
          r.(balance_updates) r.(originated_contracts) r.(consumed_gas)
          r.(storage_size) r.(paid_storage_size_diff).
      Definition with_balance_updates
        {t_big_map_diff t_balance_updates t_originated_contracts t_consumed_gas
          t_storage_size t_paid_storage_size_diff} balance_updates
        (r :
          record t_big_map_diff t_balance_updates t_originated_contracts
            t_consumed_gas t_storage_size t_paid_storage_size_diff) :=
        Build t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          r.(big_map_diff) balance_updates r.(originated_contracts)
          r.(consumed_gas) r.(storage_size) r.(paid_storage_size_diff).
      Definition with_originated_contracts
        {t_big_map_diff t_balance_updates t_originated_contracts t_consumed_gas
          t_storage_size t_paid_storage_size_diff} originated_contracts
        (r :
          record t_big_map_diff t_balance_updates t_originated_contracts
            t_consumed_gas t_storage_size t_paid_storage_size_diff) :=
        Build t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          r.(big_map_diff) r.(balance_updates) originated_contracts
          r.(consumed_gas) r.(storage_size) r.(paid_storage_size_diff).
      Definition with_consumed_gas
        {t_big_map_diff t_balance_updates t_originated_contracts t_consumed_gas
          t_storage_size t_paid_storage_size_diff} consumed_gas
        (r :
          record t_big_map_diff t_balance_updates t_originated_contracts
            t_consumed_gas t_storage_size t_paid_storage_size_diff) :=
        Build t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          r.(big_map_diff) r.(balance_updates) r.(originated_contracts)
          consumed_gas r.(storage_size) r.(paid_storage_size_diff).
      Definition with_storage_size
        {t_big_map_diff t_balance_updates t_originated_contracts t_consumed_gas
          t_storage_size t_paid_storage_size_diff} storage_size
        (r :
          record t_big_map_diff t_balance_updates t_originated_contracts
            t_consumed_gas t_storage_size t_paid_storage_size_diff) :=
        Build t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          r.(big_map_diff) r.(balance_updates) r.(originated_contracts)
          r.(consumed_gas) storage_size r.(paid_storage_size_diff).
      Definition with_paid_storage_size_diff
        {t_big_map_diff t_balance_updates t_originated_contracts t_consumed_gas
          t_storage_size t_paid_storage_size_diff} paid_storage_size_diff
        (r :
          record t_big_map_diff t_balance_updates t_originated_contracts
            t_consumed_gas t_storage_size t_paid_storage_size_diff) :=
        Build t_big_map_diff t_balance_updates t_originated_contracts
          t_consumed_gas t_storage_size t_paid_storage_size_diff
          r.(big_map_diff) r.(balance_updates) r.(originated_contracts)
          r.(consumed_gas) r.(storage_size) paid_storage_size_diff.
    End Origination_result.
    Definition Origination_result_skeleton := Origination_result.record.
    
    Module Delegation_result.
      Record record {consumed_gas : Set} : Set := Build {
        consumed_gas : consumed_gas }.
      Arguments record : clear implicits.
      Definition with_consumed_gas {t_consumed_gas} consumed_gas
        (r : record t_consumed_gas) :=
        Build t_consumed_gas consumed_gas.
    End Delegation_result.
    Definition Delegation_result_skeleton := Delegation_result.record.
  End successful_manager_operation_result.
End
  ConstructorRecords_packed_operation_metadata_contents_result_list_packed_contents_result_list_contents_result_packed_contents_result_manager_operation_result_successful_manager_operation_result_packed_successful_manager_operation_result_packed_internal_operation_result.
Import
  ConstructorRecords_packed_operation_metadata_contents_result_list_packed_contents_result_list_contents_result_packed_contents_result_manager_operation_result_successful_manager_operation_result_packed_successful_manager_operation_result_packed_internal_operation_result.

Module operation_metadata.
  Record record {contents : Set} : Set := Build {
    contents : contents }.
  Arguments record : clear implicits.
  Definition with_contents {t_contents} contents (r : record t_contents) :=
    Build t_contents contents.
End operation_metadata.
Definition operation_metadata_skeleton := operation_metadata.record.

Reserved Notation &quot;'contents_result.Endorsement_result&quot;.
Reserved Notation &quot;'contents_result.Manager_operation_result&quot;.
Reserved Notation &quot;'successful_manager_operation_result.Reveal_result&quot;.
Reserved Notation &quot;'successful_manager_operation_result.Transaction_result&quot;.
Reserved Notation &quot;'successful_manager_operation_result.Origination_result&quot;.
Reserved Notation &quot;'successful_manager_operation_result.Delegation_result&quot;.
Reserved Notation &quot;'operation_metadata&quot;.

Inductive packed_operation_metadata : Set :=
| Operation_metadata : 'operation_metadata -&gt; packed_operation_metadata
| No_operation_metadata : packed_operation_metadata

with contents_result_list : Set :=
| Single_result : contents_result -&gt; contents_result_list
| Cons_result : contents_result -&gt; contents_result_list -&gt; contents_result_list

with packed_contents_result_list : Set :=
| Contents_result_list : contents_result_list -&gt; packed_contents_result_list

with contents_result : Set :=
| Endorsement_result : 'contents_result.Endorsement_result -&gt; contents_result
| Seed_nonce_revelation_result :
  Alpha_context.Delegate.balance_updates -&gt; contents_result
| Double_endorsement_evidence_result :
  Alpha_context.Delegate.balance_updates -&gt; contents_result
| Double_baking_evidence_result :
  Alpha_context.Delegate.balance_updates -&gt; contents_result
| Activate_account_result :
  Alpha_context.Delegate.balance_updates -&gt; contents_result
| Proposals_result : contents_result
| Ballot_result : contents_result
| Manager_operation_result :
  'contents_result.Manager_operation_result -&gt; contents_result

with packed_contents_result : Set :=
| Contents_result : contents_result -&gt; packed_contents_result

with manager_operation_result : Set :=
| Applied : successful_manager_operation_result -&gt; manager_operation_result
| Backtracked :
  successful_manager_operation_result -&gt; option (list Error_monad.__error) -&gt;
  manager_operation_result
| Failed :
  Alpha_context.Kind.manager -&gt; list Error_monad.__error -&gt;
  manager_operation_result
| Skipped : Alpha_context.Kind.manager -&gt; manager_operation_result

with successful_manager_operation_result : Set :=
| Reveal_result :
  'successful_manager_operation_result.Reveal_result -&gt;
  successful_manager_operation_result
| Transaction_result :
  'successful_manager_operation_result.Transaction_result -&gt;
  successful_manager_operation_result
| Origination_result :
  'successful_manager_operation_result.Origination_result -&gt;
  successful_manager_operation_result
| Delegation_result :
  'successful_manager_operation_result.Delegation_result -&gt;
  successful_manager_operation_result

with packed_successful_manager_operation_result : Set :=
| Successful_manager_result :
  successful_manager_operation_result -&gt;
  packed_successful_manager_operation_result

with packed_internal_operation_result : Set :=
| Internal_operation_result :
  Alpha_context.internal_operation -&gt; manager_operation_result -&gt;
  packed_internal_operation_result

where &quot;'operation_metadata&quot; :=
  (operation_metadata_skeleton contents_result_list)
and &quot;'contents_result.Endorsement_result&quot; :=
  (contents_result.Endorsement_result_skeleton
    Alpha_context.Delegate.balance_updates
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) (list int))
and &quot;'contents_result.Manager_operation_result&quot; :=
  (contents_result.Manager_operation_result_skeleton
    Alpha_context.Delegate.balance_updates manager_operation_result
    (list packed_internal_operation_result))
and &quot;'successful_manager_operation_result.Reveal_result&quot; :=
  (successful_manager_operation_result.Reveal_result_skeleton Z.t)
and &quot;'successful_manager_operation_result.Transaction_result&quot; :=
  (successful_manager_operation_result.Transaction_result_skeleton
    (option Alpha_context.Script.expr)
    (option Alpha_context.Contract.big_map_diff)
    Alpha_context.Delegate.balance_updates (list Alpha_context.Contract.t) Z.t
    Z.t Z.t bool)
and &quot;'successful_manager_operation_result.Origination_result&quot; :=
  (successful_manager_operation_result.Origination_result_skeleton
    (option Alpha_context.Contract.big_map_diff)
    Alpha_context.Delegate.balance_updates (list Alpha_context.Contract.t) Z.t
    Z.t Z.t)
and &quot;'successful_manager_operation_result.Delegation_result&quot; :=
  (successful_manager_operation_result.Delegation_result_skeleton Z.t).

Module contents_result.
  Include ConstructorRecords_packed_operation_metadata_contents_result_list_packed_contents_result_list_contents_result_packed_contents_result_manager_operation_result_successful_manager_operation_result_packed_successful_manager_operation_result_packed_internal_operation_result.contents_result.
  Definition Endorsement_result := 'contents_result.Endorsement_result.
  Definition Manager_operation_result :=
    'contents_result.Manager_operation_result.
End contents_result.
Module successful_manager_operation_result.
  Include ConstructorRecords_packed_operation_metadata_contents_result_list_packed_contents_result_list_contents_result_packed_contents_result_manager_operation_result_successful_manager_operation_result_packed_successful_manager_operation_result_packed_internal_operation_result.successful_manager_operation_result.
  Definition Reveal_result :=
    'successful_manager_operation_result.Reveal_result.
  Definition Transaction_result :=
    'successful_manager_operation_result.Transaction_result.
  Definition Origination_result :=
    'successful_manager_operation_result.Origination_result.
  Definition Delegation_result :=
    'successful_manager_operation_result.Delegation_result.
End successful_manager_operation_result.

Definition operation_metadata := 'operation_metadata.

Parameter operation_metadata_encoding :
  Data_encoding.t packed_operation_metadata.

Parameter operation_data_and_metadata_encoding :
  Data_encoding.t
    (Alpha_context.Operation.packed_protocol_data * packed_operation_metadata).

Inductive contents_and_result_list : Set :=
| Single_and_result :
  Alpha_context.contents -&gt; contents_result -&gt; contents_and_result_list
| Cons_and_result :
  Alpha_context.contents -&gt; contents_result -&gt; contents_and_result_list -&gt;
  contents_and_result_list.

Inductive packed_contents_and_result_list : Set :=
| Contents_and_result_list :
  contents_and_result_list -&gt; packed_contents_and_result_list.

Parameter contents_and_result_list_encoding :
  Data_encoding.t packed_contents_and_result_list.

Parameter pack_contents_list :
  Alpha_context.contents_list -&gt; contents_result_list -&gt;
  contents_and_result_list.

Parameter unpack_contents_list :
  contents_and_result_list -&gt; Alpha_context.contents_list * contents_result_list.

Parameter to_list : packed_contents_result_list -&gt; list packed_contents_result.

Parameter of_list : list packed_contents_result -&gt; packed_contents_result_list.

Inductive eq : Set :=
| Eq : eq.

Parameter kind_equal_list :
  Alpha_context.contents_list -&gt; contents_result_list -&gt; option eq.

Module block_metadata.
  Record record : Set := Build {
    baker : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t);
    level : Alpha_context.Level.t;
    voting_period_kind : Alpha_context.Voting_period.kind;
    nonce_hash : option Nonce_hash.t;
    consumed_gas : Z.t;
    deactivated : list (|Signature.Public_key_hash|).(S.SPublic_key_hash.t);
    balance_updates : Alpha_context.Delegate.balance_updates }.
  Definition with_baker baker (r : record) :=
    Build baker r.(level) r.(voting_period_kind) r.(nonce_hash) r.(consumed_gas)
      r.(deactivated) r.(balance_updates).
  Definition with_level level (r : record) :=
    Build r.(baker) level r.(voting_period_kind) r.(nonce_hash) r.(consumed_gas)
      r.(deactivated) r.(balance_updates).
  Definition with_voting_period_kind voting_period_kind (r : record) :=
    Build r.(baker) r.(level) voting_period_kind r.(nonce_hash) r.(consumed_gas)
      r.(deactivated) r.(balance_updates).
  Definition with_nonce_hash nonce_hash (r : record) :=
    Build r.(baker) r.(level) r.(voting_period_kind) nonce_hash r.(consumed_gas)
      r.(deactivated) r.(balance_updates).
  Definition with_consumed_gas consumed_gas (r : record) :=
    Build r.(baker) r.(level) r.(voting_period_kind) r.(nonce_hash) consumed_gas
      r.(deactivated) r.(balance_updates).
  Definition with_deactivated deactivated (r : record) :=
    Build r.(baker) r.(level) r.(voting_period_kind) r.(nonce_hash)
      r.(consumed_gas) deactivated r.(balance_updates).
  Definition with_balance_updates balance_updates (r : record) :=
    Build r.(baker) r.(level) r.(voting_period_kind) r.(nonce_hash)
      r.(consumed_gas) r.(deactivated) balance_updates.
End block_metadata.
Definition block_metadata := block_metadata.record.

Parameter block_metadata_encoding : Data_encoding.encoding block_metadata.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="baking.ml">
  <div style="margin: 20px;">
    <h3>Baking</h3>
    <ul>
      <li>OCaml size: 400 lines</li>
      <li>Coq size: 423 lines (+5% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#baking.ml"><code>baking.ml</code></a>&nbsp;<span class="label label-warning">19 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context
open Misc

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Invalid_fitness_gap of int64 * int64</abbr> (* `Permanent *)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Timestamp_too_early of Timestamp.t * Timestamp.t</abbr>

(* `Permanent *)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Unexpected_endorsement</abbr> (* `Permanent *)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | Invalid_block_signature of Block_hash.t * Signature.Public_key_hash.t</abbr>

(* `Permanent *)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Invalid_signature</abbr> (* `Permanent *)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Invalid_stamp</abbr> (* `Permanent *)

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  register_error_kind
    `Permanent
    ~id:&quot;baking.timestamp_too_early&quot;
    ~title:&quot;Block forged too early&quot;
    ~description:
      &quot;The block timestamp is before the first slot for this baker at this \
       level&quot;
    ~pp:(fun ppf (r, p) -&gt;
      Format.fprintf
        ppf
        &quot;Block forged too early (%a is before %a)&quot;
        Time.pp_hum
        p
        Time.pp_hum
        r)
    Data_encoding.(
      obj2 (req &quot;minimum&quot; Time.encoding) (req &quot;provided&quot; Time.encoding))
    (function Timestamp_too_early (r, p) -&gt; Some (r, p) | _ -&gt; None)
    (fun (r, p) -&gt; Timestamp_too_early (r, p)) ;
  register_error_kind
    `Permanent
    ~id:&quot;baking.invalid_fitness_gap&quot;
    ~title:&quot;Invalid fitness gap&quot;
    ~description:&quot;The gap of fitness is out of bounds&quot;
    ~pp:(fun ppf (m, g) -&gt;
      Format.fprintf ppf &quot;The gap of fitness %Ld is not between 0 and %Ld&quot; g m)
    Data_encoding.(obj2 (req &quot;maximum&quot; int64) (req &quot;provided&quot; int64))
    (function Invalid_fitness_gap (m, g) -&gt; Some (m, g) | _ -&gt; None)
    (fun (m, g) -&gt; Invalid_fitness_gap (m, g)) ;
  register_error_kind
    `Permanent
    ~id:&quot;baking.invalid_block_signature&quot;
    ~title:&quot;Invalid block signature&quot;
    ~description:&quot;A block was not signed with the expected private key.&quot;
    ~pp:(fun ppf (block, pkh) -&gt;
      Format.fprintf
        ppf
        &quot;Invalid signature for block %a. Expected: %a.&quot;
        Block_hash.pp_short
        block
        Signature.Public_key_hash.pp_short
        pkh)
    Data_encoding.(
      obj2
        (req &quot;block&quot; Block_hash.encoding)
        (req &quot;expected&quot; Signature.Public_key_hash.encoding))
    (function
      | Invalid_block_signature (block, pkh) -&gt; Some (block, pkh) | _ -&gt; None)
    (fun (block, pkh) -&gt; Invalid_block_signature (block, pkh)) ;
  register_error_kind
    `Permanent
    ~id:&quot;baking.invalid_signature&quot;
    ~title:&quot;Invalid block signature&quot;
    ~description:&quot;The block's signature is invalid&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Invalid block signature&quot;)
    Data_encoding.empty
    (function Invalid_signature -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Invalid_signature) ;
  register_error_kind
    `Permanent
    ~id:&quot;baking.insufficient_proof_of_work&quot;
    ~title:&quot;Insufficient block proof-of-work stamp&quot;
    ~description:&quot;The block's proof-of-work stamp is insufficient&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Insufficient proof-of-work stamp&quot;)
    Data_encoding.empty
    (function Invalid_stamp -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Invalid_stamp) ;
  register_error_kind
    `Permanent
    ~id:&quot;baking.unexpected_endorsement&quot;
    ~title:&quot;Endorsement from unexpected delegate&quot;
    ~description:
      &quot;The operation is signed by a delegate without endorsement rights.&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf
        ppf
        &quot;The endorsement is signed by a delegate without endorsement rights.&quot;)
    Data_encoding.unit
    (function Unexpected_endorsement -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Unexpected_endorsement)</abbr>

let minimal_time c priority pred_timestamp =
  let priority = Int32.of_int priority in
  let rec cumsum_time_between_blocks acc durations p =
    if Compare.Int32.( &lt;= ) p 0l then ok acc
    else
      match durations with
      | [] -&gt;
          cumsum_time_between_blocks acc [Period.one_minute] p
      | [last] -&gt;
          Period.mult p last &gt;&gt;? fun period -&gt; Timestamp.(acc +? period)
      | first :: durations -&gt;
          Timestamp.(acc +? first)
          &gt;&gt;? fun acc -&gt;
          let p = Int32.pred p in
          cumsum_time_between_blocks acc durations p
  in
  Lwt.return
    (cumsum_time_between_blocks
       pred_timestamp
       (Constants.time_between_blocks c)
       (Int32.succ priority))

let earlier_predecessor_timestamp ctxt level =
  let current = Level.current ctxt in
  let current_timestamp = Timestamp.current ctxt in
  let gap = Level.diff level current in
  let step = List.hd (Constants.time_between_blocks ctxt) in
  if Compare.Int32.(gap &lt; 1l) then
    failwith &quot;Baking.earlier_block_timestamp: past block.&quot;
  else
    Lwt.return (Period.mult (Int32.pred gap) step)
    &gt;&gt;=? fun delay -&gt;
    Lwt.return Timestamp.(current_timestamp +? delay)
    &gt;&gt;=? fun result -&gt; return result

let check_timestamp c priority pred_timestamp =
  minimal_time c priority pred_timestamp
  &gt;&gt;=? fun minimal_time -&gt;
  let timestamp = Alpha_context.Timestamp.current c in
  Lwt.return
    (record_trace
       <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Timestamp_too_early (minimal_time, timestamp))</abbr>
       Timestamp.(timestamp -? minimal_time))

let check_baking_rights c {Block_header_repr.priority; _} pred_timestamp =
  let level = Level.current c in
  Roll.baking_rights_owner c level ~priority
  &gt;&gt;=? fun delegate -&gt;
  check_timestamp c priority pred_timestamp
  &gt;&gt;=? fun block_delay -&gt; return (delegate, block_delay)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Incorrect_priority</abbr> (* `Permanent *)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Incorrect_number_of_endorsements</abbr> (* `Permanent *)

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  register_error_kind
    `Permanent
    ~id:&quot;incorrect_priority&quot;
    ~title:&quot;Incorrect priority&quot;
    ~description:&quot;Block priority must be non-negative.&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf ppf &quot;The block priority must be non-negative.&quot;)
    Data_encoding.unit
    (function Incorrect_priority -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Incorrect_priority)</abbr>

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  let description =
    &quot;The number of endorsements must be non-negative and at most the \
     endosers_per_block constant.&quot;
  in
  register_error_kind
    `Permanent
    ~id:&quot;incorrect_number_of_endorsements&quot;
    ~title:&quot;Incorrect number of endorsements&quot;
    ~description
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;%s&quot; description)
    Data_encoding.unit
    (function Incorrect_number_of_endorsements -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Incorrect_number_of_endorsements)</abbr>

let baking_reward ctxt ~block_priority:prio ~included_endorsements:num_endo =
  fail_unless Compare.Int.(prio &gt;= 0) <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Incorrect_priority</abbr>
  &gt;&gt;=? fun () -&gt;
  let max_endorsements = Constants.endorsers_per_block ctxt in
  fail_unless
    Compare.Int.(num_endo &gt;= 0 &amp;&amp; num_endo &lt;= max_endorsements)
    <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Incorrect_number_of_endorsements</abbr>
  &gt;&gt;=? fun () -&gt;
  let prio_factor_denominator = Int64.(succ (of_int prio)) in
  let endo_factor_numerator =
    Int64.of_int (8 + (2 * num_endo / max_endorsements))
  in
  let endo_factor_denominator = 10L in
  Lwt.return
    Tez.(
      Constants.block_reward ctxt *? endo_factor_numerator
      &gt;&gt;? fun val1 -&gt;
      val1 /? endo_factor_denominator
      &gt;&gt;? fun val2 -&gt; val2 /? prio_factor_denominator)

let endorsing_reward ctxt ~block_priority:prio n =
  if Compare.Int.(prio &gt;= 0) then
    Lwt.return
      Tez.(Constants.endorsement_reward ctxt /? Int64.(succ (of_int prio)))
    &gt;&gt;=? fun tez -&gt; Lwt.return Tez.(tez *? Int64.of_int n)
  else fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Incorrect_priority</abbr>

let baking_priorities c level =
  let rec f priority =
    Roll.baking_rights_owner c level ~priority
    &gt;&gt;=? fun delegate -&gt; return (LCons (delegate, fun () -&gt; f (succ priority)))
  in
  f 0

let endorsement_rights c level =
  fold_left_s
    (fun acc slot -&gt;
      Roll.endorsement_rights_owner c level ~slot
      &gt;&gt;=? fun pk -&gt;
      let pkh = Signature.Public_key.hash pk in
      let right =
        match Signature.Public_key_hash.Map.find_opt pkh acc with
        | None -&gt;
            (pk, [slot], false)
        | Some (pk, slots, used) -&gt;
            (pk, slot :: slots, used)
      in
      return (Signature.Public_key_hash.Map.add pkh right acc))
    Signature.Public_key_hash.Map.empty
    (0 --&gt; (Constants.endorsers_per_block c - 1))

let check_endorsement_rights ctxt chain_id (op : Kind.endorsement Operation.t)
    =
  let current_level = Level.current ctxt in
  match[@coq_match_with_default] op.protocol_data.contents with
  | Single (Endorsement {level; _}) -&gt; (
      ( if Raw_level.(succ level = current_level.level) then
        return (Alpha_context.allowed_endorsements ctxt)
      else endorsement_rights ctxt (Level.from_raw ctxt level) )
      &gt;&gt;=? fun endorsements -&gt;
      match
        Signature.Public_key_hash.Map.fold (* no find_first *)
          (fun pkh (pk, slots, used) acc -&gt;
            match Operation.check_signature_sync pk chain_id op with
            | Error _ -&gt;
                acc
            | Ok () -&gt;
                Some (pkh, slots, used))
          endorsements
          None
      with
      | None -&gt;
          fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Unexpected_endorsement</abbr>
      | Some v -&gt;
          return v )

let select_delegate delegate delegate_list max_priority =
  let rec loop acc l n =
    if Compare.Int.(n &gt;= max_priority) then return (List.rev acc)
    else
      let (LCons (pk, t)) = l in
      let acc =
        if
          Signature.Public_key_hash.equal
            delegate
            (Signature.Public_key.hash pk)
        then n :: acc
        else acc
      in
      t () &gt;&gt;=? fun t -&gt; loop acc t (succ n)
  in
  loop [] delegate_list 0

let first_baking_priorities ctxt ?(max_priority = 32) delegate level =
  baking_priorities ctxt level
  &gt;&gt;=? fun delegate_list -&gt; select_delegate delegate delegate_list max_priority

let check_hash hash stamp_threshold =
  let bytes = Block_hash.to_bytes hash in
  let word = MBytes.get_int64 bytes 0 in
  Compare.Uint64.(word &lt;= stamp_threshold)

let check_header_proof_of_work_stamp shell contents stamp_threshold =
  let hash =
    Block_header.hash
      {shell; protocol_data = {contents; signature = Signature.zero}}
  in
  check_hash hash stamp_threshold

let check_proof_of_work_stamp ctxt block =
  let proof_of_work_threshold = Constants.proof_of_work_threshold ctxt in
  if
    check_header_proof_of_work_stamp
      block.Block_header_repr.shell
      block.protocol_data.contents
      proof_of_work_threshold
  then return_unit
  else fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_stamp</abbr>

let check_signature block chain_id key =
  let check_signature key
      {Block_header_repr.shell; protocol_data = {contents; signature}} =
    let unsigned_header =
      Data_encoding.Binary.to_bytes_exn
        Block_header.unsigned_encoding
        (shell, contents)
    in
    Signature.check
      ~watermark:(Block_header chain_id)
      key
      signature
      unsigned_header
  in
  if check_signature key block then return_unit
  else
    fail
      <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_block_signature
         (Block_header.hash block, Signature.Public_key.hash key))</abbr>

let max_fitness_gap _ctxt = 1L

let check_fitness_gap ctxt (block : Block_header.block_header) =
  let current_fitness = Fitness.current ctxt in
  Lwt.return (Fitness.to_int64 block.shell.fitness)
  &gt;&gt;=? fun announced_fitness -&gt;
  let gap = Int64.sub announced_fitness current_fitness in
  if Compare.Int64.(gap &lt;= 0L || max_fitness_gap ctxt &lt; gap) then
    fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_fitness_gap (max_fitness_gap ctxt, gap))</abbr>
  else return_unit

let last_of_a_cycle ctxt l =
  Compare.Int32.(
    Int32.succ l.Level.cycle_position = Constants.blocks_per_cycle ctxt)

let dawn_of_a_new_cycle ctxt =
  let level = Level.current ctxt in
  if last_of_a_cycle ctxt level then return_some level.cycle else return_none

let minimum_allowed_endorsements ctxt ~block_delay =
  let minimum = Constants.initial_endorsers ctxt in
  let delay_per_missing_endorsement =
    Int64.to_int
      (Period.to_seconds (Constants.delay_per_missing_endorsement ctxt))
  in
  let reduced_time_constraint =
    let delay = Int64.to_int (Period.to_seconds block_delay) in
    if Compare.Int.(delay_per_missing_endorsement = 0) then delay
    else delay / delay_per_missing_endorsement
  in
  Compare.Int.max 0 (minimum - reduced_time_constraint)

let minimal_valid_time ctxt ~priority ~endorsing_power =
  let predecessor_timestamp = Timestamp.current ctxt in
  minimal_time ctxt priority predecessor_timestamp
  &gt;&gt;=? fun minimal_time -&gt;
  let minimal_required_endorsements = Constants.initial_endorsers ctxt in
  let delay_per_missing_endorsement =
    Constants.delay_per_missing_endorsement ctxt
  in
  let missing_endorsements =
    Compare.Int.max 0 (minimal_required_endorsements - endorsing_power)
  in
  match
    Period.mult
      (Int32.of_int missing_endorsements)
      delay_per_missing_endorsement
  with
  | Ok delay -&gt;
      return (Time.add minimal_time (Period.to_seconds delay))
  | Error error -&gt;
      Lwt.return (Error error)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#baking.ml"><code>Baking.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Block_header_repr.
Require Tezos.Misc.

Import Alpha_context.

Import Misc.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition minimal_time
  (c : Alpha_context.context) (priority : int)
  (pred_timestamp : Alpha_context.Timestamp.time)
  : Lwt.t (Error_monad.tzresult Alpha_context.Timestamp.time) :=
  let priority := Int32.of_int priority in
  let fix cumsum_time_between_blocks
    (acc : Alpha_context.Timestamp.time)
    (durations : list Alpha_context.Period.period)
    (__p_value : (|Compare.Int32|).(Compare.S.t)) {struct acc}
    : Error_monad.tzresult Alpha_context.Timestamp.time :=
    if
      (|Compare.Int32|).(Compare.S.op_lteq) __p_value
        (* ‚ùå Constant of type int32 is converted to int *)
        0 then
      Error_monad.ok acc
    else
      match durations with
      | [] =&gt;
        cumsum_time_between_blocks acc [ Alpha_context.Period.one_minute ]
          __p_value
      | cons last [] =&gt;
        let? period := Alpha_context.Period.mult __p_value last in
        Alpha_context.Timestamp.op_plusquestion acc period
      | cons first durations =&gt;
        let? acc := Alpha_context.Timestamp.op_plusquestion acc first in
        let __p_value := Int32.pred __p_value in
        cumsum_time_between_blocks acc durations __p_value
      end in
  Lwt.__return
    (cumsum_time_between_blocks pred_timestamp
      (Alpha_context.Constants.time_between_blocks c) (Int32.succ priority)).

Definition earlier_predecessor_timestamp
  (ctxt : Alpha_context.context) (level : Alpha_context.Level.level)
  : Lwt.t (Error_monad.tzresult Alpha_context.Timestamp.time) :=
  let current := Alpha_context.Level.current ctxt in
  let current_timestamp := Alpha_context.Timestamp.current ctxt in
  let gap := Alpha_context.Level.diff level current in
  let step := List.hd (Alpha_context.Constants.time_between_blocks ctxt) in
  if
    (|Compare.Int32|).(Compare.S.op_lt) gap
      (* ‚ùå Constant of type int32 is converted to int *)
      1 then
    Pervasives.failwith &quot;Baking.earlier_block_timestamp: past block.&quot;
  else
    let=? delay :=
      Lwt.__return (Alpha_context.Period.mult (Int32.pred gap) step) in
    let=? __result_value :=
      Lwt.__return
        (Alpha_context.Timestamp.op_plusquestion current_timestamp delay) in
    Error_monad.__return __result_value.

Definition check_timestamp
  (c : Alpha_context.context) (priority : int)
  (pred_timestamp : Alpha_context.Timestamp.time)
  : Lwt.t (Error_monad.tzresult Alpha_context.Period.t) :=
  let=? minimal_time := minimal_time c priority pred_timestamp in
  let timestamp := Alpha_context.Timestamp.current c in
  Lwt.__return
    (Error_monad.record_trace extensible_type_value
      (Alpha_context.Timestamp.op_minusquestion timestamp minimal_time)).

Definition check_baking_rights
  (c : Alpha_context.context) (function_parameter : Block_header_repr.contents)
  : Alpha_context.Timestamp.time -&gt;
  Lwt.t
    (Error_monad.tzresult (Alpha_context.public_key * Alpha_context.Period.t)) :=
  let '{| Block_header_repr.contents.priority := priority |} :=
    function_parameter in
  fun pred_timestamp =&gt;
    let level := Alpha_context.Level.current c in
    let=? delegate := Alpha_context.Roll.baking_rights_owner c level priority in
    let=? block_delay := check_timestamp c priority pred_timestamp in
    Error_monad.__return (delegate, block_delay).

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition baking_reward
  (ctxt : Alpha_context.context) (prio : (|Compare.Int|).(Compare.S.t))
  (num_endo : (|Compare.Int|).(Compare.S.t))
  : Lwt.t (Error_monad.tzresult Alpha_context.Tez.tez) :=
  let=? '_ :=
    Error_monad.fail_unless ((|Compare.Int|).(Compare.S.op_gteq) prio 0)
      extensible_type_value in
  let max_endorsements := Alpha_context.Constants.endorsers_per_block ctxt in
  let=? '_ :=
    Error_monad.fail_unless
      (Pervasives.op_andand ((|Compare.Int|).(Compare.S.op_gteq) num_endo 0)
        ((|Compare.Int|).(Compare.S.op_lteq) num_endo max_endorsements))
      extensible_type_value in
  let prio_factor_denominator := Int64.succ (Int64.of_int prio) in
  let endo_factor_numerator :=
    Int64.of_int
      (Pervasives.op_plus 8
        (Pervasives.op_div (Pervasives.op_star 2 num_endo) max_endorsements)) in
  let endo_factor_denominator :=
    (* ‚ùå Constant of type int64 is converted to int *)
    10 in
  Lwt.__return
    (let? val1 :=
      Alpha_context.Tez.op_starquestion
        (Alpha_context.Constants.block_reward ctxt) endo_factor_numerator in
    let? val2 := Alpha_context.Tez.op_divquestion val1 endo_factor_denominator
      in
    Alpha_context.Tez.op_divquestion val2 prio_factor_denominator).

Definition endorsing_reward
  (ctxt : Alpha_context.context) (prio : (|Compare.Int|).(Compare.S.t))
  (n : int) : Lwt.t (Error_monad.tzresult Alpha_context.Tez.tez) :=
  if (|Compare.Int|).(Compare.S.op_gteq) prio 0 then
    let=? tez :=
      Lwt.__return
        (Alpha_context.Tez.op_divquestion
          (Alpha_context.Constants.endorsement_reward ctxt)
          (Int64.succ (Int64.of_int prio))) in
    Lwt.__return (Alpha_context.Tez.op_starquestion tez (Int64.of_int n))
  else
    Error_monad.fail extensible_type_value.

Definition baking_priorities
  (c : Alpha_context.context) (level : Alpha_context.Level.t)
  : Lwt.t (Error_monad.tzresult (Misc.lazy_list_t Alpha_context.public_key)) :=
  let fix f (priority : int) {struct priority}
    : Lwt.t (Error_monad.tzresult (Misc.lazy_list_t Alpha_context.public_key)) :=
    let=? delegate := Alpha_context.Roll.baking_rights_owner c level priority in
    Error_monad.__return
      (Misc.LCons delegate
        (fun function_parameter =&gt;
          let '_ := function_parameter in
          f (Pervasives.succ priority))) in
  f 0.

Definition endorsement_rights
  (c : Alpha_context.context) (level : Alpha_context.Level.t)
  : Lwt.t
    (Error_monad.tzresult
      ((|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t)
        (Alpha_context.public_key * list int * bool))) :=
  Error_monad.fold_left_s
    (fun acc =&gt;
      fun slot =&gt;
        let=? pk := Alpha_context.Roll.endorsement_rights_owner c level slot in
        let pkh := (|Signature.Public_key|).(S.SPublic_key.__hash_value) pk in
        let __right :=
          match
            (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.find_opt)
              pkh acc with
          | None =&gt; (pk, [ slot ], false)
          | Some (pk, slots, used) =&gt; (pk, (cons slot slots), used)
          end in
        Error_monad.__return
          ((|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.add)
            pkh __right acc))
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.empty)
    (Misc.op_minusminusgt 0
      (Pervasives.op_minus (Alpha_context.Constants.endorsers_per_block c) 1)).

Definition check_endorsement_rights
  (ctxt : Alpha_context.context) (chain_id : (|Chain_id|).(S.HASH.t))
  (op : Alpha_context.Operation.t)
  : Lwt.t
    (Error_monad.tzresult
      ((|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.key)
        * list int * bool)) :=
  let current_level := Alpha_context.Level.current ctxt in
  match
    op.(Alpha_context.operation.protocol_data).(Alpha_context.protocol_data.contents)
    with
  |
    Alpha_context.Single
      (Alpha_context.Endorsement {|
        Alpha_context.contents.Endorsement.level := level |}) =&gt;
    let=? endorsements :=
      if
        Alpha_context.Raw_level.op_eq (Alpha_context.Raw_level.succ level)
          current_level.(Alpha_context.Level.t.level) then
        Error_monad.__return (Alpha_context.allowed_endorsements ctxt)
      else
        endorsement_rights ctxt (Alpha_context.Level.from_raw ctxt None level)
      in
    match
      (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.fold)
        (fun pkh =&gt;
          fun function_parameter =&gt;
            let '(pk, slots, used) := function_parameter in
            fun acc =&gt;
              match Alpha_context.Operation.check_signature_sync pk chain_id op
                with
              | Pervasives.Error _ =&gt; acc
              | Pervasives.Ok _ =&gt; Some (pkh, slots, used)
              end) endorsements None with
    | None =&gt; Error_monad.fail extensible_type_value
    | Some v =&gt; Error_monad.__return v
    end
  | _ =&gt; unreachable_gadt_branch
  end.

Definition select_delegate
  (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  (delegate_list : Misc.lazy_list_t (|Signature.Public_key|).(S.SPublic_key.t))
  (max_priority : (|Compare.Int|).(Compare.S.t))
  : Lwt.t (Error_monad.tzresult (list (|Compare.Int|).(Compare.S.t))) :=
  let fix loop
    (acc : list (|Compare.Int|).(Compare.S.t))
    (l : Misc.lazy_list_t (|Signature.Public_key|).(S.SPublic_key.t))
    (n : (|Compare.Int|).(Compare.S.t)) {struct acc}
    : Lwt.t (Error_monad.tzresult (list (|Compare.Int|).(Compare.S.t))) :=
    if (|Compare.Int|).(Compare.S.op_gteq) n max_priority then
      Error_monad.__return (List.rev acc)
    else
      let 'Misc.LCons pk __t_value := l in
      let acc :=
        if
          (|Signature.Public_key_hash|).(S.SPublic_key_hash.equal) delegate
            ((|Signature.Public_key|).(S.SPublic_key.__hash_value) pk) then
          cons n acc
        else
          acc in
      let=? __t_value := __t_value tt in
      loop acc __t_value (Pervasives.succ n) in
  loop nil delegate_list 0.

Definition first_baking_priorities
  (ctxt : Alpha_context.context)
  (op_staroptstar : option (|Compare.Int|).(Compare.S.t))
  : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Alpha_context.Level.t -&gt;
  Lwt.t (Error_monad.tzresult (list (|Compare.Int|).(Compare.S.t))) :=
  let max_priority :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; 32
    end in
  fun delegate =&gt;
    fun level =&gt;
      let=? delegate_list := baking_priorities ctxt level in
      select_delegate delegate delegate_list max_priority.

Definition check_hash
  (__hash_value : (|Block_hash|).(S.HASH.t))
  (stamp_threshold : (|Compare.Uint64|).(Compare.S.t)) : bool :=
  let __bytes_value := (|Block_hash|).(S.HASH.to_bytes) __hash_value in
  let word := MBytes.get_int64 __bytes_value 0 in
  (|Compare.Uint64|).(Compare.S.op_lteq) word stamp_threshold.

Definition check_header_proof_of_work_stamp
  (shell : Block_header.shell_header)
  (contents : Alpha_context.Block_header.contents)
  (stamp_threshold : (|Compare.Uint64|).(Compare.S.t)) : bool :=
  let __hash_value :=
    Alpha_context.Block_header.__hash_value
      {| Alpha_context.Block_header.block_header.shell := shell;
        Alpha_context.Block_header.block_header.protocol_data :=
          {| Alpha_context.Block_header.protocol_data.contents := contents;
            Alpha_context.Block_header.protocol_data.signature := Signature.zero
            |} |} in
  check_hash __hash_value stamp_threshold.

Definition check_proof_of_work_stamp
  (ctxt : Alpha_context.context) (block : Block_header_repr.block_header)
  : Lwt.t (Error_monad.tzresult unit) :=
  let proof_of_work_threshold :=
    Alpha_context.Constants.proof_of_work_threshold ctxt in
  if
    check_header_proof_of_work_stamp
      block.(Block_header_repr.block_header.shell)
      block.(Block_header_repr.block_header.protocol_data).(Block_header_repr.protocol_data.contents)
      proof_of_work_threshold then
    Error_monad.return_unit
  else
    Error_monad.fail extensible_type_value.

Definition check_signature
  (block : Block_header_repr.block_header) (chain_id : (|Chain_id|).(S.HASH.t))
  (__key_value : (|Signature.Public_key|).(S.SPublic_key.t))
  : Lwt.t (Error_monad.tzresult unit) :=
  let check_signature
    (__key_value : (|Signature.Public_key|).(S.SPublic_key.t))
    (function_parameter : Block_header_repr.block_header) : bool :=
    let '{|
      Block_header_repr.block_header.shell := shell;
        Block_header_repr.block_header.protocol_data := {|
          Block_header_repr.protocol_data.contents := contents;
            Block_header_repr.protocol_data.signature := signature
            |}
        |} := function_parameter in
    let unsigned_header :=
      Data_encoding.Binary.to_bytes_exn
        Alpha_context.Block_header.unsigned_encoding (shell, contents) in
    Signature.check (Some (Signature.Block_header chain_id)) __key_value
      signature unsigned_header in
  if check_signature __key_value block then
    Error_monad.return_unit
  else
    Error_monad.fail extensible_type_value.

Definition max_fitness_gap {A : Set} (_ctxt : A) : int64 :=
  (* ‚ùå Constant of type int64 is converted to int *)
  1.

Definition check_fitness_gap
  (ctxt : Alpha_context.context)
  (block : Alpha_context.Block_header.block_header)
  : Lwt.t (Error_monad.tzresult unit) :=
  let current_fitness := Alpha_context.Fitness.current ctxt in
  let=? announced_fitness :=
    Lwt.__return
      (Alpha_context.Fitness.to_int64
        block.(Alpha_context.Block_header.block_header.shell).(Block_header.shell_header.fitness))
    in
  let gap := Int64.sub announced_fitness current_fitness in
  if
    Pervasives.op_pipepipe
      ((|Compare.Int64|).(Compare.S.op_lteq) gap
        (* ‚ùå Constant of type int64 is converted to int *)
        0) ((|Compare.Int64|).(Compare.S.op_lt) (max_fitness_gap ctxt) gap) then
    Error_monad.fail extensible_type_value
  else
    Error_monad.return_unit.

Definition last_of_a_cycle
  (ctxt : Alpha_context.context) (l : Alpha_context.Level.t) : bool :=
  (|Compare.Int32|).(Compare.S.op_eq)
    (Int32.succ l.(Alpha_context.Level.t.cycle_position))
    (Alpha_context.Constants.blocks_per_cycle ctxt).

Definition dawn_of_a_new_cycle (ctxt : Alpha_context.context)
  : Lwt.t (Error_monad.tzresult (option Alpha_context.Cycle.t)) :=
  let level := Alpha_context.Level.current ctxt in
  if last_of_a_cycle ctxt level then
    Error_monad.return_some level.(Alpha_context.Level.t.cycle)
  else
    Error_monad.return_none.

Definition minimum_allowed_endorsements
  (ctxt : Alpha_context.context) (block_delay : Alpha_context.Period.period)
  : (|Compare.Int|).(Compare.S.t) :=
  let minimum := Alpha_context.Constants.initial_endorsers ctxt in
  let delay_per_missing_endorsement :=
    Int64.to_int
      (Alpha_context.Period.to_seconds
        (Alpha_context.Constants.delay_per_missing_endorsement ctxt)) in
  let reduced_time_constraint :=
    let delay := Int64.to_int (Alpha_context.Period.to_seconds block_delay) in
    if (|Compare.Int|).(Compare.S.op_eq) delay_per_missing_endorsement 0 then
      delay
    else
      Pervasives.op_div delay delay_per_missing_endorsement in
  (|Compare.Int|).(Compare.S.max) 0
    (Pervasives.op_minus minimum reduced_time_constraint).

Definition minimal_valid_time
  (ctxt : Alpha_context.context) (priority : int) (endorsing_power : int)
  : Lwt.t (Error_monad.tzresult Time.t) :=
  let predecessor_timestamp := Alpha_context.Timestamp.current ctxt in
  let=? minimal_time := minimal_time ctxt priority predecessor_timestamp in
  let minimal_required_endorsements :=
    Alpha_context.Constants.initial_endorsers ctxt in
  let delay_per_missing_endorsement :=
    Alpha_context.Constants.delay_per_missing_endorsement ctxt in
  let missing_endorsements :=
    (|Compare.Int|).(Compare.S.max) 0
      (Pervasives.op_minus minimal_required_endorsements endorsing_power) in
  match
    Alpha_context.Period.mult (Int32.of_int missing_endorsements)
      delay_per_missing_endorsement with
  | Pervasives.Ok delay =&gt;
    Error_monad.__return
      (Time.add minimal_time (Alpha_context.Period.to_seconds delay))
  | Pervasives.Error __error_value =&gt;
    Lwt.__return (Pervasives.Error __error_value)
  end.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="baking.mli">
  <div style="margin: 20px;">
    <h3>Baking_mli</h3>
    <ul>
      <li>OCaml size: 166 lines</li>
      <li>Coq size: 95 lines (-43% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#baking.mli"><code>baking.mli</code></a>&nbsp;<span class="label label-warning">6 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context
open Misc

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Invalid_fitness_gap of int64 * int64</abbr> (* `Permanent *)

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Timestamp_too_early of Timestamp.t * Timestamp.t</abbr>

(* `Permanent *)

<abbr class="mark-warning" title="Extensible types are not handled.">type error +=
  | Invalid_block_signature of Block_hash.t * Signature.Public_key_hash.t</abbr>

(* `Permanent *)

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Unexpected_endorsement</abbr>

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Invalid_signature</abbr> (* `Permanent *)

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Invalid_stamp</abbr> (* `Permanent *)

(** [minimal_time ctxt priority pred_block_time] returns the minimal
    time, given the predecessor block timestamp [pred_block_time],
    after which a baker with priority [priority] is allowed to
    bake. Fail with [Invalid_time_between_blocks_constant] if the minimal
    time cannot be computed. *)
val minimal_time : context -&gt; int -&gt; Time.t -&gt; Time.t tzresult Lwt.t

(** [check_baking_rights ctxt block pred_timestamp] verifies that:
    * the contract that owned the roll at cycle start has the block signer as delegate.
    * the timestamp is coherent with the announced slot.
*)
val check_baking_rights :
  context -&gt;
  Block_header.contents -&gt;
  Time.t -&gt;
  (public_key * Period.t) tzresult Lwt.t

(** For a given level computes who has the right to
    include an endorsement in the next block.
    The result can be stored in Alpha_context.allowed_endorsements *)
val endorsement_rights :
  context -&gt;
  Level.t -&gt;
  (public_key * int list * bool) Signature.Public_key_hash.Map.t tzresult Lwt.t

(** Check that the operation was signed by a delegate allowed
    to endorse at the level specified by the endorsement. *)
val check_endorsement_rights :
  context -&gt;
  Chain_id.t -&gt;
  Kind.endorsement Operation.t -&gt;
  (public_key_hash * int list * bool) tzresult Lwt.t

(** Returns the baking reward calculated w.r.t a given priority [p] and a
    number [e] of included endorsements as follows:
      (block_reward / (p+1)) * (0.8 + 0.2 * e / endorsers_per_block)
*)
val baking_reward :
  context -&gt;
  block_priority:int -&gt;
  included_endorsements:int -&gt;
  Tez.t tzresult Lwt.t

(** Returns the endorsing reward calculated w.r.t a given priority.  *)
val endorsing_reward :
  context -&gt; block_priority:int -&gt; int -&gt; Tez.t tzresult Lwt.t

(** [baking_priorities ctxt level] is the lazy list of contract's
    public key hashes that are allowed to bake for [level]. *)
val baking_priorities : context -&gt; Level.t -&gt; public_key lazy_list

(** [first_baking_priorities ctxt ?max_priority contract_hash level]
    is a list of priorities of max [?max_priority] elements, where the
    delegate of [contract_hash] is allowed to bake for [level]. If
    [?max_priority] is [None], a sensible number of priorities is
    returned. *)
val first_baking_priorities :
  context -&gt;
  ?max_priority:int -&gt;
  public_key_hash -&gt;
  Level.t -&gt;
  int list tzresult Lwt.t

(** [check_signature ctxt chain_id block id] check if the block is
    signed with the given key, and belongs to the given [chain_id] *)
val check_signature :
  Block_header.block_header -&gt; Chain_id.t -&gt; public_key -&gt; unit tzresult Lwt.t

(** Checks if the header that would be built from the given components
    is valid for the given diffculty. The signature is not passed as it
    is does not impact the proof-of-work stamp. The stamp is checked on
    the hash of a block header whose signature has been zeroed-out. *)
val check_header_proof_of_work_stamp :
  Block_header.shell_header -&gt; Block_header.contents -&gt; int64 -&gt; bool

(** verify if the proof of work stamp is valid *)
val check_proof_of_work_stamp :
  context -&gt; Block_header.block_header -&gt; unit tzresult Lwt.t

(** check if the gap between the fitness of the current context
    and the given block is within the protocol parameters *)
val check_fitness_gap :
  context -&gt; Block_header.block_header -&gt; unit tzresult Lwt.t

val dawn_of_a_new_cycle : context -&gt; Cycle.t option tzresult Lwt.t

val earlier_predecessor_timestamp :
  context -&gt; Level.t -&gt; Timestamp.t tzresult Lwt.t

(** Since Emmy+

    A block is valid only if its timestamp has a minimal delay with
    respect to the previous block's timestamp, and this minimal delay
    depends not only on the block's priority but also on the number of
    endorsement operations included in the block.

    In Emmy+, blocks' fitness increases by one unit with each level.

    In this way, Emmy+ simplifies the optimal baking strategy: The
    bakers used to have to choose whether to wait for more endorsements
    to include in their block, or to publish the block immediately,
    without waiting. The incentive for including more endorsements was
    to increase the fitness and win against unknown blocks. However,
    when a block was produced too late in the priority period, there
    was the risk that the block did not reach endorsers before the
    block of next priority. In Emmy+, the baker does not need to take
    such a decision, because the baker cannot publish a block too
    early. *)

(** Given a delay of a block's timestamp with respect to the minimum
    time to bake at the block's priority (as returned by
    `minimum_time`), it returns the minimum number of endorsements that
    the block has to contain *)
val minimum_allowed_endorsements : context -&gt; block_delay:Period.t -&gt; int

(** This is the somehow the dual of the previous function. Given a
    block priority and a number of endorsement slots (given by the
    `endorsing_power` argument), it returns the minimum time at which
    the next block can be baked. *)
val minimal_valid_time :
  context -&gt; priority:int -&gt; endorsing_power:int -&gt; Time.t tzresult Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#baking.mli"><code>Baking_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Misc.

Import Alpha_context.

Import Misc.

(* extensible_type_definition `error` *)

(* extensible_type_definition `error` *)

(* extensible_type_definition `error` *)

(* extensible_type_definition `error` *)

(* extensible_type_definition `error` *)

(* extensible_type_definition `error` *)

Parameter minimal_time :
  Alpha_context.context -&gt; int -&gt; Time.t -&gt; Lwt.t (Error_monad.tzresult Time.t).

Parameter check_baking_rights :
  Alpha_context.context -&gt; Alpha_context.Block_header.contents -&gt; Time.t -&gt;
  Lwt.t
    (Error_monad.tzresult (Alpha_context.public_key * Alpha_context.Period.t)).

Parameter endorsement_rights :
  Alpha_context.context -&gt; Alpha_context.Level.t -&gt;
  Lwt.t
    (Error_monad.tzresult
      ((|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t)
        (Alpha_context.public_key * list int * bool))).

Parameter check_endorsement_rights :
  Alpha_context.context -&gt; (|Chain_id|).(S.HASH.t) -&gt;
  Alpha_context.Operation.t -&gt;
  Lwt.t (Error_monad.tzresult (Alpha_context.public_key_hash * list int * bool)).

Parameter baking_reward :
  Alpha_context.context -&gt; int -&gt; int -&gt;
  Lwt.t (Error_monad.tzresult Alpha_context.Tez.t).

Parameter endorsing_reward :
  Alpha_context.context -&gt; int -&gt; int -&gt;
  Lwt.t (Error_monad.tzresult Alpha_context.Tez.t).

Parameter baking_priorities :
  Alpha_context.context -&gt; Alpha_context.Level.t -&gt;
  Misc.lazy_list Alpha_context.public_key.

Parameter first_baking_priorities :
  Alpha_context.context -&gt; option int -&gt; Alpha_context.public_key_hash -&gt;
  Alpha_context.Level.t -&gt; Lwt.t (Error_monad.tzresult (list int)).

Parameter check_signature :
  Alpha_context.Block_header.block_header -&gt; (|Chain_id|).(S.HASH.t) -&gt;
  Alpha_context.public_key -&gt; Lwt.t (Error_monad.tzresult unit).

Parameter check_header_proof_of_work_stamp :
  Alpha_context.Block_header.shell_header -&gt;
  Alpha_context.Block_header.contents -&gt; int64 -&gt; bool.

Parameter check_proof_of_work_stamp :
  Alpha_context.context -&gt; Alpha_context.Block_header.block_header -&gt;
  Lwt.t (Error_monad.tzresult unit).

Parameter check_fitness_gap :
  Alpha_context.context -&gt; Alpha_context.Block_header.block_header -&gt;
  Lwt.t (Error_monad.tzresult unit).

Parameter dawn_of_a_new_cycle :
  Alpha_context.context -&gt;
  Lwt.t (Error_monad.tzresult (option Alpha_context.Cycle.t)).

Parameter earlier_predecessor_timestamp :
  Alpha_context.context -&gt; Alpha_context.Level.t -&gt;
  Lwt.t (Error_monad.tzresult Alpha_context.Timestamp.t).

Parameter minimum_allowed_endorsements :
  Alpha_context.context -&gt; Alpha_context.Period.t -&gt; int.

Parameter minimal_valid_time :
  Alpha_context.context -&gt; int -&gt; int -&gt; Lwt.t (Error_monad.tzresult Time.t).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="blinded_public_key_hash.ml">
  <div style="margin: 20px;">
    <h3>Blinded_public_key_hash</h3>
    <ul>
      <li>OCaml size: 57 lines</li>
      <li>Coq size: 137 lines (+140% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#blinded_public_key_hash.ml"><code>blinded_public_key_hash.ml</code></a>&nbsp;<span class="label label-warning">2 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

module H =
  Blake2B.Make
    (Base58)
    (struct
      let name = &quot;Blinded public key hash&quot;

      let title = &quot;A blinded public key hash&quot;

      let b58check_prefix = &quot;\001\002\049\223&quot;

      let size = Some Ed25519.Public_key_hash.size
    end)

include H

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () = Base58.check_encoded_prefix b58check_encoding &quot;btz1&quot; 37</abbr>

let of_ed25519_pkh activation_code pkh =
  hash_bytes ~key:activation_code [Ed25519.Public_key_hash.to_bytes pkh]

type activation_code = MBytes.t

let activation_code_size = Ed25519.Public_key_hash.size

let activation_code_encoding = Data_encoding.Fixed.bytes activation_code_size

let activation_code_of_hex h =
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if Compare.Int.(String.length h &lt;&gt; activation_code_size * 2) then
    invalid_arg &quot;Blinded_public_key_hash.activation_code_of_hex&quot;</abbr> ;
  MBytes.of_hex (`Hex h)

module Index : Storage_description.INDEX with type t = t = H
</pre>
  </div>
  <div class="col-md-6">
    <a href="#blinded_public_key_hash.ml"><code>Blinded_public_key_hash.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Storage_description.

Definition H :=
  (Blake2B.Make
    (existT (A := unit) (fun _ =&gt; _) tt
      {|
        Blake2B.SRegister.register_encoding {_} := Base58.register_encoding
      |}))
    (let name := &quot;Blinded public key hash&quot; in
    let title := &quot;A blinded public key hash&quot; in
    let b58check_prefix := &quot;\001\0021\223&quot; in
    let size :=
      Some (|Ed25519|).(S.SIGNATURE.Public_key_hash).(S.SPublic_key_hash.size)
      in
    existT (A := unit) (fun _ =&gt; _) tt
      {|
        Blake2B.PrefixedName.name := name;
        Blake2B.PrefixedName.title := title;
        Blake2B.PrefixedName.size := size;
        Blake2B.PrefixedName.b58check_prefix := b58check_prefix
      |}).

Definition t := (|H|).(S.HASH.t).

Definition name := (|H|).(S.HASH.name).

Definition title := (|H|).(S.HASH.title).

Definition pp := (|H|).(S.HASH.pp).

Definition pp_short := (|H|).(S.HASH.pp_short).

Definition op_eq := (|H|).(S.HASH.op_eq).

Definition op_ltgt := (|H|).(S.HASH.op_ltgt).

Definition op_lt := (|H|).(S.HASH.op_lt).

Definition op_lteq := (|H|).(S.HASH.op_lteq).

Definition op_gteq := (|H|).(S.HASH.op_gteq).

Definition op_gt := (|H|).(S.HASH.op_gt).

Definition compare := (|H|).(S.HASH.compare).

Definition equal := (|H|).(S.HASH.equal).

Definition max := (|H|).(S.HASH.max).

Definition min := (|H|).(S.HASH.min).

Definition hash_bytes := (|H|).(S.HASH.hash_bytes).

Definition hash_string := (|H|).(S.HASH.hash_string).

Definition zero := (|H|).(S.HASH.zero).

Definition size := (|H|).(S.HASH.size).

Definition to_bytes := (|H|).(S.HASH.to_bytes).

Definition of_bytes_opt := (|H|).(S.HASH.of_bytes_opt).

Definition of_bytes_exn := (|H|).(S.HASH.of_bytes_exn).

Definition to_b58check := (|H|).(S.HASH.to_b58check).

Definition to_short_b58check := (|H|).(S.HASH.to_short_b58check).

Definition of_b58check_exn := (|H|).(S.HASH.of_b58check_exn).

Definition of_b58check_opt := (|H|).(S.HASH.of_b58check_opt).

Definition b58check_encoding := (|H|).(S.HASH.b58check_encoding).

Definition encoding := (|H|).(S.HASH.encoding).

Definition rpc_arg := (|H|).(S.HASH.rpc_arg).

Definition to_path := (|H|).(S.HASH.to_path).

Definition of_path := (|H|).(S.HASH.of_path).

Definition of_path_exn := (|H|).(S.HASH.of_path_exn).

Definition prefix_path := (|H|).(S.HASH.prefix_path).

Definition path_length := (|H|).(S.HASH.path_length).

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition of_ed25519_pkh
  (activation_code : MBytes.t)
  (pkh : (|Ed25519|).(S.SIGNATURE.Public_key_hash).(S.SPublic_key_hash.t))
  : t :=
  hash_bytes (Some activation_code)
    [
      (|Ed25519|).(S.SIGNATURE.Public_key_hash).(S.SPublic_key_hash.to_bytes)
        pkh
    ].

Definition activation_code : Set := MBytes.t.

Definition activation_code_size : int :=
  (|Ed25519|).(S.SIGNATURE.Public_key_hash).(S.SPublic_key_hash.size).

Definition activation_code_encoding : Data_encoding.encoding MBytes.t :=
  Data_encoding.Fixed.__bytes_value activation_code_size.

Definition activation_code_of_hex (h : string) : MBytes.t :=
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  MBytes.of_hex (MBytes.Hex h).

Definition Index : {_ : unit &amp; Storage_description.INDEX.signature (t := t)} :=
  existT (A := unit) (fun _ =&gt; _) tt
    {|
      Storage_description.INDEX.path_length := (|H|).(S.HASH.path_length);
      Storage_description.INDEX.to_path := (|H|).(S.HASH.to_path);
      Storage_description.INDEX.of_path := (|H|).(S.HASH.of_path);
      Storage_description.INDEX.rpc_arg := (|H|).(S.HASH.rpc_arg);
      Storage_description.INDEX.encoding := (|H|).(S.HASH.encoding);
      Storage_description.INDEX.compare := (|H|).(S.HASH.compare)
    |}.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="blinded_public_key_hash.mli">
  <div style="margin: 20px;">
    <h3>Blinded_public_key_hash_mli</h3>
    <ul>
      <li>OCaml size: 36 lines</li>
      <li>Coq size: 113 lines (+213% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#blinded_public_key_hash.mli"><code>blinded_public_key_hash.mli</code></a>&nbsp;<span class="label label-warning">1 warning</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

<abbr class="mark-warning" title="Type extension not handled">include S.HASH</abbr>

type activation_code

val activation_code_encoding : activation_code Data_encoding.t

val of_ed25519_pkh : activation_code -&gt; Ed25519.Public_key_hash.t -&gt; t

val activation_code_of_hex : string -&gt; activation_code

module Index : Storage_description.INDEX with type t = t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#blinded_public_key_hash.mli"><code>Blinded_public_key_hash_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Storage_description.

Parameter Included_HASH :
  {'[t, __Set_t, Map_t] : [Set ** Set ** Set -&gt; Set] &amp;
    S.HASH.signature (t := t) (__Set_t := __Set_t) (Map_t := Map_t)}.

Definition t := (|Included_HASH|).(S.HASH.t).

Definition name : string := (|Included_HASH|).(S.HASH.name).

Definition title : string := (|Included_HASH|).(S.HASH.title).

Definition pp : Format.formatter -&gt; t -&gt; unit := (|Included_HASH|).(S.HASH.pp).

Definition pp_short : Format.formatter -&gt; t -&gt; unit :=
  (|Included_HASH|).(S.HASH.pp_short).

Definition op_eq : t -&gt; t -&gt; bool := (|Included_HASH|).(S.HASH.op_eq).

Definition op_ltgt : t -&gt; t -&gt; bool := (|Included_HASH|).(S.HASH.op_ltgt).

Definition op_lt : t -&gt; t -&gt; bool := (|Included_HASH|).(S.HASH.op_lt).

Definition op_lteq : t -&gt; t -&gt; bool := (|Included_HASH|).(S.HASH.op_lteq).

Definition op_gteq : t -&gt; t -&gt; bool := (|Included_HASH|).(S.HASH.op_gteq).

Definition op_gt : t -&gt; t -&gt; bool := (|Included_HASH|).(S.HASH.op_gt).

Definition compare : t -&gt; t -&gt; int := (|Included_HASH|).(S.HASH.compare).

Definition equal : t -&gt; t -&gt; bool := (|Included_HASH|).(S.HASH.equal).

Definition max : t -&gt; t -&gt; t := (|Included_HASH|).(S.HASH.max).

Definition min : t -&gt; t -&gt; t := (|Included_HASH|).(S.HASH.min).

Definition hash_bytes : option MBytes.t -&gt; list MBytes.t -&gt; t :=
  (|Included_HASH|).(S.HASH.hash_bytes).

Definition hash_string : option string -&gt; list string -&gt; t :=
  (|Included_HASH|).(S.HASH.hash_string).

Definition zero : t := (|Included_HASH|).(S.HASH.zero).

Definition size : int := (|Included_HASH|).(S.HASH.size).

Definition to_bytes : t -&gt; MBytes.t := (|Included_HASH|).(S.HASH.to_bytes).

Definition of_bytes_opt : MBytes.t -&gt; option t :=
  (|Included_HASH|).(S.HASH.of_bytes_opt).

Definition of_bytes_exn : MBytes.t -&gt; t :=
  (|Included_HASH|).(S.HASH.of_bytes_exn).

Definition to_b58check : t -&gt; string := (|Included_HASH|).(S.HASH.to_b58check).

Definition to_short_b58check : t -&gt; string :=
  (|Included_HASH|).(S.HASH.to_short_b58check).

Definition of_b58check_exn : string -&gt; t :=
  (|Included_HASH|).(S.HASH.of_b58check_exn).

Definition of_b58check_opt : string -&gt; option t :=
  (|Included_HASH|).(S.HASH.of_b58check_opt).

Definition b58check_encoding : Base58.encoding t :=
  (|Included_HASH|).(S.HASH.b58check_encoding).

Definition encoding : Data_encoding.t t := (|Included_HASH|).(S.HASH.encoding).

Definition rpc_arg : RPC_arg.t t := (|Included_HASH|).(S.HASH.rpc_arg).

Definition to_path : t -&gt; list string -&gt; list string :=
  (|Included_HASH|).(S.HASH.to_path).

Definition of_path : list string -&gt; option t :=
  (|Included_HASH|).(S.HASH.of_path).

Definition of_path_exn : list string -&gt; t :=
  (|Included_HASH|).(S.HASH.of_path_exn).

Definition prefix_path : string -&gt; list string :=
  (|Included_HASH|).(S.HASH.prefix_path).

Definition path_length : int := (|Included_HASH|).(S.HASH.path_length).

Definition __Set := existT (fun _ =&gt; _) tt (|Included_HASH|).(S.HASH.__Set).

Definition Map := existT (fun _ =&gt; _) tt (|Included_HASH|).(S.HASH.Map).

Parameter activation_code : Set.

Parameter activation_code_encoding : Data_encoding.t activation_code.

Parameter of_ed25519_pkh :
  activation_code -&gt;
  (|Ed25519|).(S.SIGNATURE.Public_key_hash).(S.SPublic_key_hash.t) -&gt; t.

Parameter activation_code_of_hex : string -&gt; activation_code.

Parameter Index : {_ : unit &amp; Storage_description.INDEX.signature (t := t)}.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="block_header_repr.ml">
  <div style="margin: 20px;">
    <h3>Block_header_repr</h3>
    <ul>
      <li>OCaml size: 132 lines</li>
      <li>Coq size: 176 lines (+33% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#block_header_repr.ml"><code>block_header_repr.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Block header *)

type contents = {
  priority : int;
  seed_nonce_hash : Nonce_hash.t option;
  proof_of_work_nonce : MBytes.t;
}

type protocol_data = {contents : contents; signature : Signature.t}

type block_header = {
  shell : Block_header.shell_header;
  protocol_data : protocol_data;
}

type raw = Block_header.t

type shell_header = Block_header.shell_header

let raw_encoding = Block_header.encoding

let shell_header_encoding = Block_header.shell_header_encoding

let contents_encoding =
  let open Data_encoding in
  def &quot;block_header.alpha.unsigned_contents&quot;
  @@ conv
       (fun {priority; seed_nonce_hash; proof_of_work_nonce} -&gt;
         (priority, proof_of_work_nonce, seed_nonce_hash))
       (fun (priority, proof_of_work_nonce, seed_nonce_hash) -&gt;
         {priority; seed_nonce_hash; proof_of_work_nonce})
       (obj3
          (req &quot;priority&quot; uint16)
          (req
             &quot;proof_of_work_nonce&quot;
             (Fixed.bytes Constants_repr.proof_of_work_nonce_size))
          (opt &quot;seed_nonce_hash&quot; Nonce_hash.encoding))

let protocol_data_encoding =
  let open Data_encoding in
  def &quot;block_header.alpha.signed_contents&quot;
  @@ conv
       (fun {contents; signature} -&gt; (contents, signature))
       (fun (contents, signature) -&gt; {contents; signature})
       (merge_objs
          contents_encoding
          (obj1 (req &quot;signature&quot; Signature.encoding)))

let raw {shell; protocol_data} =
  let protocol_data =
    Data_encoding.Binary.to_bytes_exn protocol_data_encoding protocol_data
  in
  {Block_header.shell; protocol_data}

let unsigned_encoding =
  let open Data_encoding in
  merge_objs Block_header.shell_header_encoding contents_encoding

let encoding =
  let open Data_encoding in
  def &quot;block_header.alpha.full_header&quot;
  @@ conv
       (fun {shell; protocol_data} -&gt; (shell, protocol_data))
       (fun (shell, protocol_data) -&gt; {shell; protocol_data})
       (merge_objs Block_header.shell_header_encoding protocol_data_encoding)

(** Constants *)

let max_header_length =
  let fake_shell =
    {
      Block_header.level = 0l;
      proto_level = 0;
      predecessor = Block_hash.zero;
      timestamp = Time.of_seconds 0L;
      validation_passes = 0;
      operations_hash = Operation_list_list_hash.zero;
      fitness = Fitness_repr.from_int64 0L;
      context = Context_hash.zero;
    }
  in
  let fake_contents =
    {
      priority = 0;
      proof_of_work_nonce =
        MBytes.create Constants_repr.proof_of_work_nonce_size;
      seed_nonce_hash = Some Nonce_hash.zero;
    }
  in
  Data_encoding.Binary.length
    encoding
    {
      shell = fake_shell;
      protocol_data = {contents = fake_contents; signature = Signature.zero};
    }

(** Header parsing entry point  *)

let hash_raw = Block_header.hash

let hash {shell; protocol_data} =
  Block_header.hash
    {
      shell;
      protocol_data =
        Data_encoding.Binary.to_bytes_exn protocol_data_encoding protocol_data;
    }
</pre>
  </div>
  <div class="col-md-6">
    <a href="#block_header_repr.ml"><code>Block_header_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Constants_repr.
Require Tezos.Fitness_repr.
Require Tezos.Nonce_hash.

Module contents.
  Record record : Set := Build {
    priority : int;
    seed_nonce_hash : option Nonce_hash.t;
    proof_of_work_nonce : MBytes.t }.
  Definition with_priority priority (r : record) :=
    Build priority r.(seed_nonce_hash) r.(proof_of_work_nonce).
  Definition with_seed_nonce_hash seed_nonce_hash (r : record) :=
    Build r.(priority) seed_nonce_hash r.(proof_of_work_nonce).
  Definition with_proof_of_work_nonce proof_of_work_nonce (r : record) :=
    Build r.(priority) r.(seed_nonce_hash) proof_of_work_nonce.
End contents.
Definition contents := contents.record.

Module protocol_data.
  Record record : Set := Build {
    contents : contents;
    signature : Signature.t }.
  Definition with_contents contents (r : record) :=
    Build contents r.(signature).
  Definition with_signature signature (r : record) :=
    Build r.(contents) signature.
End protocol_data.
Definition protocol_data := protocol_data.record.

Module block_header.
  Record record : Set := Build {
    shell : Block_header.shell_header;
    protocol_data : protocol_data }.
  Definition with_shell shell (r : record) :=
    Build shell r.(protocol_data).
  Definition with_protocol_data protocol_data (r : record) :=
    Build r.(shell) protocol_data.
End block_header.
Definition block_header := block_header.record.

Definition raw : Set := Block_header.t.

Definition shell_header : Set := Block_header.shell_header.

Definition raw_encoding : Data_encoding.t Block_header.t :=
  Block_header.encoding.

Definition shell_header_encoding : Data_encoding.t Block_header.shell_header :=
  Block_header.shell_header_encoding.

Definition contents_encoding : Data_encoding.encoding contents :=
  (let arg := Data_encoding.def &quot;block_header.alpha.unsigned_contents&quot; in
  fun eta =&gt; arg None None eta)
    (Data_encoding.conv
      (fun function_parameter =&gt;
        let '{|
          contents.priority := priority;
            contents.seed_nonce_hash := seed_nonce_hash;
            contents.proof_of_work_nonce := proof_of_work_nonce
            |} := function_parameter in
        (priority, proof_of_work_nonce, seed_nonce_hash))
      (fun function_parameter =&gt;
        let '(priority, proof_of_work_nonce, seed_nonce_hash) :=
          function_parameter in
        {| contents.priority := priority;
          contents.seed_nonce_hash := seed_nonce_hash;
          contents.proof_of_work_nonce := proof_of_work_nonce |}) None
      (Data_encoding.obj3
        (Data_encoding.req None None &quot;priority&quot; Data_encoding.uint16)
        (Data_encoding.req None None &quot;proof_of_work_nonce&quot;
          (Data_encoding.Fixed.__bytes_value
            Constants_repr.proof_of_work_nonce_size))
        (Data_encoding.opt None None &quot;seed_nonce_hash&quot; Nonce_hash.encoding))).

Definition protocol_data_encoding : Data_encoding.encoding protocol_data :=
  (let arg := Data_encoding.def &quot;block_header.alpha.signed_contents&quot; in
  fun eta =&gt; arg None None eta)
    (Data_encoding.conv
      (fun function_parameter =&gt;
        let '{|
          protocol_data.contents := contents;
            protocol_data.signature := signature
            |} := function_parameter in
        (contents, signature))
      (fun function_parameter =&gt;
        let '(contents, signature) := function_parameter in
        {| protocol_data.contents := contents;
          protocol_data.signature := signature |}) None
      (Data_encoding.merge_objs contents_encoding
        (Data_encoding.obj1
          (Data_encoding.req None None &quot;signature&quot; Signature.encoding)))).

Definition __raw_value (function_parameter : block_header) : Block_header.t :=
  let '{|
    block_header.shell := shell;
      block_header.protocol_data := protocol_data
      |} := function_parameter in
  let protocol_data :=
    Data_encoding.Binary.to_bytes_exn protocol_data_encoding protocol_data in
  {| Block_header.t.shell := shell;
    Block_header.t.protocol_data := protocol_data |}.

Definition unsigned_encoding
  : Data_encoding.encoding (Block_header.shell_header * contents) :=
  Data_encoding.merge_objs Block_header.shell_header_encoding contents_encoding.

Definition encoding : Data_encoding.encoding block_header :=
  (let arg := Data_encoding.def &quot;block_header.alpha.full_header&quot; in
  fun eta =&gt; arg None None eta)
    (Data_encoding.conv
      (fun function_parameter =&gt;
        let '{|
          block_header.shell := shell;
            block_header.protocol_data := protocol_data
            |} := function_parameter in
        (shell, protocol_data))
      (fun function_parameter =&gt;
        let '(shell, protocol_data) := function_parameter in
        {| block_header.shell := shell;
          block_header.protocol_data := protocol_data |}) None
      (Data_encoding.merge_objs Block_header.shell_header_encoding
        protocol_data_encoding)).

Definition max_header_length : int :=
  let fake_shell :=
    {|
      Block_header.shell_header.level :=
        (* ‚ùå Constant of type int32 is converted to int *)
        0; Block_header.shell_header.proto_level := 0;
      Block_header.shell_header.predecessor := (|Block_hash|).(S.HASH.zero);
      Block_header.shell_header.timestamp :=
        Time.of_seconds
          (* ‚ùå Constant of type int64 is converted to int *)
          0; Block_header.shell_header.validation_passes := 0;
      Block_header.shell_header.operations_hash :=
        (|Operation_list_list_hash|).(S.MERKLE_TREE.zero);
      Block_header.shell_header.fitness :=
        Fitness_repr.from_int64
          (* ‚ùå Constant of type int64 is converted to int *)
          0; Block_header.shell_header.context := (|Context_hash|).(S.HASH.zero)
      |} in
  let fake_contents :=
    {| contents.priority := 0; contents.seed_nonce_hash := Some Nonce_hash.zero;
      contents.proof_of_work_nonce :=
        MBytes.create Constants_repr.proof_of_work_nonce_size |} in
  Data_encoding.Binary.length encoding
    {| block_header.shell := fake_shell;
      block_header.protocol_data :=
        {| protocol_data.contents := fake_contents;
          protocol_data.signature := Signature.zero |} |}.

Definition hash_raw : Block_header.t -&gt; (|Block_hash|).(S.HASH.t) :=
  Block_header.__hash_value.

Definition __hash_value (function_parameter : block_header)
  : (|Block_hash|).(S.HASH.t) :=
  let '{|
    block_header.shell := shell;
      block_header.protocol_data := protocol_data
      |} := function_parameter in
  Block_header.__hash_value
    {| Block_header.t.shell := shell;
      Block_header.t.protocol_data :=
        Data_encoding.Binary.to_bytes_exn protocol_data_encoding protocol_data
      |}.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="block_header_repr.mli">
  <div style="margin: 20px;">
    <h3>Block_header_repr_mli</h3>
    <ul>
      <li>OCaml size: 62 lines</li>
      <li>Coq size: 73 lines (+17% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#block_header_repr.mli"><code>block_header_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type contents = {
  priority : int;
  seed_nonce_hash : Nonce_hash.t option;
  proof_of_work_nonce : MBytes.t;
}

type protocol_data = {contents : contents; signature : Signature.t}

type block_header = {
  shell : Block_header.shell_header;
  protocol_data : protocol_data;
}

type raw = Block_header.t

type shell_header = Block_header.shell_header

val raw : block_header -&gt; raw

val encoding : block_header Data_encoding.encoding

val raw_encoding : raw Data_encoding.t

val contents_encoding : contents Data_encoding.t

val unsigned_encoding : (Block_header.shell_header * contents) Data_encoding.t

val protocol_data_encoding : protocol_data Data_encoding.encoding

val shell_header_encoding : shell_header Data_encoding.encoding

(** The maximum size of block headers in bytes *)
val max_header_length : int

val hash : block_header -&gt; Block_hash.t

val hash_raw : raw -&gt; Block_hash.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#block_header_repr.mli"><code>Block_header_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Nonce_hash.

Module contents.
  Record record : Set := Build {
    priority : int;
    seed_nonce_hash : option Nonce_hash.t;
    proof_of_work_nonce : MBytes.t }.
  Definition with_priority priority (r : record) :=
    Build priority r.(seed_nonce_hash) r.(proof_of_work_nonce).
  Definition with_seed_nonce_hash seed_nonce_hash (r : record) :=
    Build r.(priority) seed_nonce_hash r.(proof_of_work_nonce).
  Definition with_proof_of_work_nonce proof_of_work_nonce (r : record) :=
    Build r.(priority) r.(seed_nonce_hash) proof_of_work_nonce.
End contents.
Definition contents := contents.record.

Module protocol_data.
  Record record : Set := Build {
    contents : contents;
    signature : Signature.t }.
  Definition with_contents contents (r : record) :=
    Build contents r.(signature).
  Definition with_signature signature (r : record) :=
    Build r.(contents) signature.
End protocol_data.
Definition protocol_data := protocol_data.record.

Module block_header.
  Record record : Set := Build {
    shell : Block_header.shell_header;
    protocol_data : protocol_data }.
  Definition with_shell shell (r : record) :=
    Build shell r.(protocol_data).
  Definition with_protocol_data protocol_data (r : record) :=
    Build r.(shell) protocol_data.
End block_header.
Definition block_header := block_header.record.

Definition raw : Set := Block_header.t.

Definition shell_header : Set := Block_header.shell_header.

Parameter __raw_value : block_header -&gt; raw.

Parameter encoding : Data_encoding.encoding block_header.

Parameter raw_encoding : Data_encoding.t raw.

Parameter contents_encoding : Data_encoding.t contents.

Parameter unsigned_encoding :
  Data_encoding.t (Block_header.shell_header * contents).

Parameter protocol_data_encoding : Data_encoding.encoding protocol_data.

Parameter shell_header_encoding : Data_encoding.encoding shell_header.

Parameter max_header_length : int.

Parameter __hash_value : block_header -&gt; (|Block_hash|).(S.HASH.t).

Parameter hash_raw : raw -&gt; (|Block_hash|).(S.HASH.t).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="bootstrap_storage.ml">
  <div style="margin: 20px;">
    <h3>Bootstrap_storage</h3>
    <ul>
      <li>OCaml size: 152 lines</li>
      <li>Coq size: 188 lines (+23% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#bootstrap_storage.ml"><code>bootstrap_storage.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Misc

let init_account ctxt
    ({public_key_hash; public_key; amount} : Parameters_repr.bootstrap_account)
    =
  let contract = Contract_repr.implicit_contract public_key_hash in
  Contract_storage.credit ctxt contract amount
  &gt;&gt;=? fun ctxt -&gt;
  match public_key with
  | Some public_key -&gt;
      Contract_storage.reveal_manager_key ctxt public_key_hash public_key
      &gt;&gt;=? fun ctxt -&gt;
      Delegate_storage.set ctxt contract (Some public_key_hash)
      &gt;&gt;=? fun ctxt -&gt; return ctxt
  | None -&gt;
      return ctxt

let init_contract ~typecheck ctxt
    ({delegate; amount; script} : Parameters_repr.bootstrap_contract) =
  Contract_storage.fresh_contract_from_current_nonce ctxt
  &gt;&gt;=? fun (ctxt, contract) -&gt;
  typecheck ctxt script
  &gt;&gt;=? fun (script, ctxt) -&gt;
  Contract_storage.originate_raw
    ctxt
    contract
    ~balance:amount
    ~prepaid_bootstrap_storage:true
    ~script
    ~delegate:(Some delegate)
  &gt;&gt;=? fun ctxt -&gt; return ctxt

let init ctxt ~typecheck ?ramp_up_cycles ?no_reward_cycles accounts contracts =
  let nonce =
    Operation_hash.hash_bytes [MBytes.of_string &quot;Un festival de GADT.&quot;]
  in
  let ctxt = Raw_context.init_origination_nonce ctxt nonce in
  fold_left_s init_account ctxt accounts
  &gt;&gt;=? fun ctxt -&gt;
  fold_left_s (init_contract ~typecheck) ctxt contracts
  &gt;&gt;=? fun ctxt -&gt;
  ( match no_reward_cycles with
  | None -&gt;
      return ctxt
  | Some cycles -&gt;
      (* Store pending ramp ups. *)
      let constants = Raw_context.constants ctxt in
      (* Start without reward *)
      Raw_context.patch_constants ctxt (fun c -&gt;
          {
            c with
            block_reward = Tez_repr.zero;
            endorsement_reward = Tez_repr.zero;
          })
      &gt;&gt;= fun ctxt -&gt;
      (* Store the final reward. *)
      Storage.Ramp_up.Rewards.init
        ctxt
        (Cycle_repr.of_int32_exn (Int32.of_int cycles))
        (constants.block_reward, constants.endorsement_reward) )
  &gt;&gt;=? fun ctxt -&gt;
  match ramp_up_cycles with
  | None -&gt;
      return ctxt
  | Some cycles -&gt;
      (* Store pending ramp ups. *)
      let constants = Raw_context.constants ctxt in
      Lwt.return
        Tez_repr.(constants.block_security_deposit /? Int64.of_int cycles)
      &gt;&gt;=? fun block_step -&gt;
      Lwt.return
        Tez_repr.(
          constants.endorsement_security_deposit /? Int64.of_int cycles)
      &gt;&gt;=? fun endorsement_step -&gt;
      (* Start without security_deposit *)
      Raw_context.patch_constants ctxt (fun c -&gt;
          {
            c with
            block_security_deposit = Tez_repr.zero;
            endorsement_security_deposit = Tez_repr.zero;
          })
      &gt;&gt;= fun ctxt -&gt;
      fold_left_s
        (fun ctxt cycle -&gt;
          Lwt.return Tez_repr.(block_step *? Int64.of_int cycle)
          &gt;&gt;=? fun block_security_deposit -&gt;
          Lwt.return Tez_repr.(endorsement_step *? Int64.of_int cycle)
          &gt;&gt;=? fun endorsement_security_deposit -&gt;
          let cycle = Cycle_repr.of_int32_exn (Int32.of_int cycle) in
          Storage.Ramp_up.Security_deposits.init
            ctxt
            cycle
            (block_security_deposit, endorsement_security_deposit))
        ctxt
        (1 --&gt; (cycles - 1))
      &gt;&gt;=? fun ctxt -&gt;
      (* Store the final security deposits. *)
      Storage.Ramp_up.Security_deposits.init
        ctxt
        (Cycle_repr.of_int32_exn (Int32.of_int cycles))
        ( constants.block_security_deposit,
          constants.endorsement_security_deposit )
      &gt;&gt;=? fun ctxt -&gt; return ctxt

let cycle_end ctxt last_cycle =
  let next_cycle = Cycle_repr.succ last_cycle in
  Storage.Ramp_up.Rewards.get_option ctxt next_cycle
  &gt;&gt;=? (function
         | None -&gt;
             return ctxt
         | Some (block_reward, endorsement_reward) -&gt;
             Storage.Ramp_up.Rewards.delete ctxt next_cycle
             &gt;&gt;=? fun ctxt -&gt;
             Raw_context.patch_constants ctxt (fun c -&gt;
                 {c with block_reward; endorsement_reward})
             &gt;&gt;= fun ctxt -&gt; return ctxt)
  &gt;&gt;=? fun ctxt -&gt;
  Storage.Ramp_up.Security_deposits.get_option ctxt next_cycle
  &gt;&gt;=? function
  | None -&gt;
      return ctxt
  | Some (block_security_deposit, endorsement_security_deposit) -&gt;
      Storage.Ramp_up.Security_deposits.delete ctxt next_cycle
      &gt;&gt;=? fun ctxt -&gt;
      Raw_context.patch_constants ctxt (fun c -&gt;
          {c with block_security_deposit; endorsement_security_deposit})
      &gt;&gt;= fun ctxt -&gt; return ctxt
</pre>
  </div>
  <div class="col-md-6">
    <a href="#bootstrap_storage.ml"><code>Bootstrap_storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Constants_repr.
Require Tezos.Contract_repr.
Require Tezos.Contract_storage.
Require Tezos.Cycle_repr.
Require Tezos.Delegate_storage.
Require Tezos.Misc.
Require Tezos.Parameters_repr.
Require Tezos.Raw_context.
Require Tezos.Script_repr.
Require Tezos.Storage_mli. Module Storage := Storage_mli.
Require Tezos.Storage_sigs.
Require Tezos.Tez_repr.

Import Misc.

Definition init_account
  (ctxt : Raw_context.t)
  (function_parameter : Parameters_repr.bootstrap_account)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let '{|
    Parameters_repr.bootstrap_account.public_key_hash := public_key_hash;
      Parameters_repr.bootstrap_account.public_key := public_key;
      Parameters_repr.bootstrap_account.amount := amount
      |} := function_parameter in
  let contract := Contract_repr.implicit_contract public_key_hash in
  let=? ctxt := Contract_storage.credit ctxt contract amount in
  match public_key with
  | Some public_key =&gt;
    let=? ctxt :=
      Contract_storage.reveal_manager_key ctxt public_key_hash public_key in
    let=? ctxt := Delegate_storage.set ctxt contract (Some public_key_hash) in
    Error_monad.__return ctxt
  | None =&gt; Error_monad.__return ctxt
  end.

Definition init_contract
  (typecheck :
    Raw_context.t -&gt; Script_repr.t -&gt;
    Lwt.t
      (Error_monad.tzresult
        ((Script_repr.t * option Contract_storage.big_map_diff) * Raw_context.t)))
  (ctxt : Raw_context.t)
  (function_parameter : Parameters_repr.bootstrap_contract)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let '{|
    Parameters_repr.bootstrap_contract.delegate := delegate;
      Parameters_repr.bootstrap_contract.amount := amount;
      Parameters_repr.bootstrap_contract.script := script
      |} := function_parameter in
  let=? '(ctxt, contract) :=
    Contract_storage.fresh_contract_from_current_nonce ctxt in
  let=? '(script, ctxt) := typecheck ctxt script in
  let=? ctxt :=
    Contract_storage.originate_raw ctxt (Some true) contract amount script
      (Some delegate) in
  Error_monad.__return ctxt.

Definition init
  (ctxt : Raw_context.t)
  (typecheck :
    Raw_context.t -&gt; Script_repr.t -&gt;
    Lwt.t
      (Error_monad.tzresult
        ((Script_repr.t * option Contract_storage.big_map_diff) * Raw_context.t)))
  (ramp_up_cycles : option int) (no_reward_cycles : option int)
  (accounts : list Parameters_repr.bootstrap_account)
  (contracts : list Parameters_repr.bootstrap_contract)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let __nonce_value :=
    (|Operation_hash|).(S.HASH.hash_bytes) None
      [ MBytes.of_string &quot;Un festival de GADT.&quot; ] in
  let ctxt := Raw_context.init_origination_nonce ctxt __nonce_value in
  let=? ctxt := Error_monad.fold_left_s init_account ctxt accounts in
  let=? ctxt := Error_monad.fold_left_s (init_contract typecheck) ctxt contracts
    in
  let=? ctxt :=
    match no_reward_cycles with
    | None =&gt; Error_monad.__return ctxt
    | Some cycles =&gt;
      let constants := Raw_context.constants ctxt in
      let= ctxt :=
        Raw_context.patch_constants ctxt
          (fun c =&gt;
            Constants_repr.parametric.with_endorsement_reward Tez_repr.zero
              (Constants_repr.parametric.with_block_reward Tez_repr.zero c)) in
      (|Storage.Ramp_up.Rewards|).(Storage_sigs.Indexed_data_storage.init) ctxt
        (Cycle_repr.of_int32_exn (Int32.of_int cycles))
        (constants.(Constants_repr.parametric.block_reward),
          constants.(Constants_repr.parametric.endorsement_reward))
    end in
  match ramp_up_cycles with
  | None =&gt; Error_monad.__return ctxt
  | Some cycles =&gt;
    let constants := Raw_context.constants ctxt in
    let=? block_step :=
      Lwt.__return
        (Tez_repr.op_divquestion
          constants.(Constants_repr.parametric.block_security_deposit)
          (Int64.of_int cycles)) in
    let=? endorsement_step :=
      Lwt.__return
        (Tez_repr.op_divquestion
          constants.(Constants_repr.parametric.endorsement_security_deposit)
          (Int64.of_int cycles)) in
    let= ctxt :=
      Raw_context.patch_constants ctxt
        (fun c =&gt;
          Constants_repr.parametric.with_endorsement_security_deposit
            Tez_repr.zero
            (Constants_repr.parametric.with_block_security_deposit Tez_repr.zero
              c)) in
    let=? ctxt :=
      Error_monad.fold_left_s
        (fun ctxt =&gt;
          fun cycle =&gt;
            let=? block_security_deposit :=
              Lwt.__return
                (Tez_repr.op_starquestion block_step (Int64.of_int cycle)) in
            let=? endorsement_security_deposit :=
              Lwt.__return
                (Tez_repr.op_starquestion endorsement_step (Int64.of_int cycle))
              in
            let cycle := Cycle_repr.of_int32_exn (Int32.of_int cycle) in
            (|Storage.Ramp_up.Security_deposits|).(Storage_sigs.Indexed_data_storage.init)
              ctxt cycle (block_security_deposit, endorsement_security_deposit))
        ctxt (Misc.op_minusminusgt 1 (Pervasives.op_minus cycles 1)) in
    let=? ctxt :=
      (|Storage.Ramp_up.Security_deposits|).(Storage_sigs.Indexed_data_storage.init)
        ctxt (Cycle_repr.of_int32_exn (Int32.of_int cycles))
        (constants.(Constants_repr.parametric.block_security_deposit),
          constants.(Constants_repr.parametric.endorsement_security_deposit)) in
    Error_monad.__return ctxt
  end.

Definition cycle_end
  (ctxt :
    (|Storage.Ramp_up.Rewards|).(Storage_sigs.Indexed_data_storage.context))
  (last_cycle : Cycle_repr.cycle)
  : Lwt.t
    (Error_monad.tzresult
      (|Storage.Ramp_up.Rewards|).(Storage_sigs.Indexed_data_storage.context)) :=
  let next_cycle := Cycle_repr.succ last_cycle in
  let=? ctxt :=
    let=? function_parameter :=
      (|Storage.Ramp_up.Rewards|).(Storage_sigs.Indexed_data_storage.get_option)
        ctxt next_cycle in
    match function_parameter with
    | None =&gt; Error_monad.__return ctxt
    | Some (block_reward, endorsement_reward) =&gt;
      let=? ctxt :=
        (|Storage.Ramp_up.Rewards|).(Storage_sigs.Indexed_data_storage.delete)
          ctxt next_cycle in
      let= ctxt :=
        Raw_context.patch_constants ctxt
          (fun c =&gt;
            Constants_repr.parametric.with_endorsement_reward endorsement_reward
              (Constants_repr.parametric.with_block_reward block_reward c)) in
      Error_monad.__return ctxt
    end in
  let=? function_parameter :=
    (|Storage.Ramp_up.Security_deposits|).(Storage_sigs.Indexed_data_storage.get_option)
      ctxt next_cycle in
  match function_parameter with
  | None =&gt; Error_monad.__return ctxt
  | Some (block_security_deposit, endorsement_security_deposit) =&gt;
    let=? ctxt :=
      (|Storage.Ramp_up.Security_deposits|).(Storage_sigs.Indexed_data_storage.delete)
        ctxt next_cycle in
    let= ctxt :=
      Raw_context.patch_constants ctxt
        (fun c =&gt;
          Constants_repr.parametric.with_endorsement_security_deposit
            endorsement_security_deposit
            (Constants_repr.parametric.with_block_security_deposit
              block_security_deposit c)) in
    Error_monad.__return ctxt
  end.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="bootstrap_storage.mli">
  <div style="margin: 20px;">
    <h3>Bootstrap_storage_mli</h3>
    <ul>
      <li>OCaml size: 40 lines</li>
      <li>Coq size: 29 lines (-28% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#bootstrap_storage.mli"><code>bootstrap_storage.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

val init :
  Raw_context.t -&gt;
  typecheck:(Raw_context.t -&gt;
            Script_repr.t -&gt;
            ( (Script_repr.t * Contract_storage.big_map_diff option)
            * Raw_context.t )
            tzresult
            Lwt.t) -&gt;
  ?ramp_up_cycles:int -&gt;
  ?no_reward_cycles:int -&gt;
  Parameters_repr.bootstrap_account list -&gt;
  Parameters_repr.bootstrap_contract list -&gt;
  Raw_context.t tzresult Lwt.t

val cycle_end : Raw_context.t -&gt; Cycle_repr.t -&gt; Raw_context.t tzresult Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#bootstrap_storage.mli"><code>Bootstrap_storage_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Contract_storage.
Require Tezos.Cycle_repr.
Require Tezos.Parameters_repr.
Require Tezos.Raw_context.
Require Tezos.Script_repr.

Parameter init :
  Raw_context.t -&gt;
  (Raw_context.t -&gt; Script_repr.t -&gt;
  Lwt.t
    (Error_monad.tzresult
      ((Script_repr.t * option Contract_storage.big_map_diff) * Raw_context.t)))
  -&gt; option int -&gt; option int -&gt; list Parameters_repr.bootstrap_account -&gt;
  list Parameters_repr.bootstrap_contract -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter cycle_end :
  Raw_context.t -&gt; Cycle_repr.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="commitment_repr.ml">
  <div style="margin: 20px;">
    <h3>Commitment_repr</h3>
    <ul>
      <li>OCaml size: 40 lines</li>
      <li>Coq size: 41 lines (+2% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#commitment_repr.ml"><code>commitment_repr.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = {
  blinded_public_key_hash : Blinded_public_key_hash.t;
  amount : Tez_repr.t;
}

let encoding =
  let open Data_encoding in
  conv
    (fun {blinded_public_key_hash; amount} -&gt;
      (blinded_public_key_hash, amount))
    (fun (blinded_public_key_hash, amount) -&gt;
      {blinded_public_key_hash; amount})
    (tup2 Blinded_public_key_hash.encoding Tez_repr.encoding)

let not_first_class_module = ()
</pre>
  </div>
  <div class="col-md-6">
    <a href="#commitment_repr.ml"><code>Commitment_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Blinded_public_key_hash.
Require Tezos.Tez_repr.

Module t.
  Record record : Set := Build {
    blinded_public_key_hash : Blinded_public_key_hash.t;
    amount : Tez_repr.t }.
  Definition with_blinded_public_key_hash blinded_public_key_hash
    (r : record) :=
    Build blinded_public_key_hash r.(amount).
  Definition with_amount amount (r : record) :=
    Build r.(blinded_public_key_hash) amount.
End t.
Definition t := t.record.

Definition encoding : Data_encoding.encoding t :=
  Data_encoding.conv
    (fun function_parameter =&gt;
      let '{|
        t.blinded_public_key_hash := blinded_public_key_hash;
          t.amount := amount
          |} := function_parameter in
      (blinded_public_key_hash, amount))
    (fun function_parameter =&gt;
      let '(blinded_public_key_hash, amount) := function_parameter in
      {| t.blinded_public_key_hash := blinded_public_key_hash;
        t.amount := amount |}) None
    (Data_encoding.tup2 Blinded_public_key_hash.encoding Tez_repr.encoding).

Definition not_first_class_module : unit := tt.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="commitment_repr.mli">
  <div style="margin: 20px;">
    <h3>Commitment_repr_mli</h3>
    <ul>
      <li>OCaml size: 33 lines</li>
      <li>Coq size: 29 lines (-13% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#commitment_repr.mli"><code>commitment_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = {
  blinded_public_key_hash : Blinded_public_key_hash.t;
  amount : Tez_repr.t;
}

val encoding : t Data_encoding.t

val not_first_class_module : unit
</pre>
  </div>
  <div class="col-md-6">
    <a href="#commitment_repr.mli"><code>Commitment_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Blinded_public_key_hash.
Require Tezos.Tez_repr.

Module t.
  Record record : Set := Build {
    blinded_public_key_hash : Blinded_public_key_hash.t;
    amount : Tez_repr.t }.
  Definition with_blinded_public_key_hash blinded_public_key_hash
    (r : record) :=
    Build blinded_public_key_hash r.(amount).
  Definition with_amount amount (r : record) :=
    Build r.(blinded_public_key_hash) amount.
End t.
Definition t := t.record.

Parameter encoding : Data_encoding.t t.

Parameter not_first_class_module : unit.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="commitment_storage.ml">
  <div style="margin: 20px;">
    <h3>Commitment_storage</h3>
    <ul>
      <li>OCaml size: 34 lines</li>
      <li>Coq size: 50 lines (+47% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#commitment_storage.ml"><code>commitment_storage.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

let get_opt = Storage.Commitments.get_option

let delete = Storage.Commitments.delete

let init ctxt commitments =
  let init_commitment ctxt Commitment_repr.{blinded_public_key_hash; amount} =
    Storage.Commitments.init ctxt blinded_public_key_hash amount
  in
  fold_left_s init_commitment ctxt commitments &gt;&gt;=? fun ctxt -&gt; return ctxt
</pre>
  </div>
  <div class="col-md-6">
    <a href="#commitment_storage.ml"><code>Commitment_storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Blinded_public_key_hash.
Require Tezos.Commitment_repr.
Require Tezos.Raw_context.
Require Tezos.Storage_mli. Module Storage := Storage_mli.
Require Tezos.Storage_sigs.
Require Tezos.Tez_repr.

Definition get_opt
  : (|Storage.Commitments|).(Storage_sigs.Indexed_data_storage.context) -&gt;
  (|Storage.Commitments|).(Storage_sigs.Indexed_data_storage.key) -&gt;
  Lwt.t
    (Error_monad.tzresult
      (option (|Storage.Commitments|).(Storage_sigs.Indexed_data_storage.value))) :=
  (|Storage.Commitments|).(Storage_sigs.Indexed_data_storage.get_option).

Definition delete
  : (|Storage.Commitments|).(Storage_sigs.Indexed_data_storage.context) -&gt;
  (|Storage.Commitments|).(Storage_sigs.Indexed_data_storage.key) -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t) :=
  (|Storage.Commitments|).(Storage_sigs.Indexed_data_storage.delete).

Definition init
  (ctxt : (|Storage.Commitments|).(Storage_sigs.Indexed_data_storage.context))
  (commitments : list Commitment_repr.t)
  : Lwt.t
    (Error_monad.tzresult
      (|Storage.Commitments|).(Storage_sigs.Indexed_data_storage.context)) :=
  let init_commitment
    (ctxt : (|Storage.Commitments|).(Storage_sigs.Indexed_data_storage.context))
    (function_parameter : Commitment_repr.t)
    : Lwt.t (Error_monad.tzresult Raw_context.t) :=
    let '{|
      Commitment_repr.t.blinded_public_key_hash := blinded_public_key_hash;
        Commitment_repr.t.amount := amount
        |} := function_parameter in
    (|Storage.Commitments|).(Storage_sigs.Indexed_data_storage.init) ctxt
      blinded_public_key_hash amount in
  let=? ctxt := Error_monad.fold_left_s init_commitment ctxt commitments in
  Error_monad.__return ctxt.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="commitment_storage.mli">
  <div style="margin: 20px;">
    <h3>Commitment_storage_mli</h3>
    <ul>
      <li>OCaml size: 35 lines</li>
      <li>Coq size: 27 lines (-23% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#commitment_storage.mli"><code>commitment_storage.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

val init :
  Raw_context.t -&gt; Commitment_repr.t list -&gt; Raw_context.t tzresult Lwt.t

val get_opt :
  Raw_context.t -&gt;
  Blinded_public_key_hash.t -&gt;
  Tez_repr.t option tzresult Lwt.t

val delete :
  Raw_context.t -&gt; Blinded_public_key_hash.t -&gt; Raw_context.t tzresult Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#commitment_storage.mli"><code>Commitment_storage_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Blinded_public_key_hash.
Require Tezos.Commitment_repr.
Require Tezos.Raw_context.
Require Tezos.Tez_repr.

Parameter init :
  Raw_context.t -&gt; list Commitment_repr.t -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter get_opt :
  Raw_context.t -&gt; Blinded_public_key_hash.t -&gt;
  Lwt.t (Error_monad.tzresult (option Tez_repr.t)).

Parameter delete :
  Raw_context.t -&gt; Blinded_public_key_hash.t -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="constants_repr.ml">
  <div style="margin: 20px;">
    <h3>Constants_repr</h3>
    <ul>
      <li>OCaml size: 238 lines</li>
      <li>Coq size: 604 lines (+153% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#constants_repr.ml"><code>constants_repr.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

let version_number_004 = &quot;\000&quot;

let version_number = &quot;\001&quot;

let proof_of_work_nonce_size = 8

let nonce_length = 32

let max_revelations_per_block = 32

let max_proposals_per_delegate = 20

let max_operation_data_length = 16 * 1024 (* 16kB *)

type fixed = {
  proof_of_work_nonce_size : int;
  nonce_length : int;
  max_revelations_per_block : int;
  max_operation_data_length : int;
  max_proposals_per_delegate : int;
}

let fixed_encoding =
  let open Data_encoding in
  conv
    (fun c -&gt;
      ( c.proof_of_work_nonce_size,
        c.nonce_length,
        c.max_revelations_per_block,
        c.max_operation_data_length,
        c.max_proposals_per_delegate ))
    (fun ( proof_of_work_nonce_size,
           nonce_length,
           max_revelations_per_block,
           max_operation_data_length,
           max_proposals_per_delegate ) -&gt;
      {
        proof_of_work_nonce_size;
        nonce_length;
        max_revelations_per_block;
        max_operation_data_length;
        max_proposals_per_delegate;
      })
    (obj5
       (req &quot;proof_of_work_nonce_size&quot; uint8)
       (req &quot;nonce_length&quot; uint8)
       (req &quot;max_revelations_per_block&quot; uint8)
       (req &quot;max_operation_data_length&quot; int31)
       (req &quot;max_proposals_per_delegate&quot; uint8))

let fixed =
  {
    proof_of_work_nonce_size;
    nonce_length;
    max_revelations_per_block;
    max_operation_data_length;
    max_proposals_per_delegate;
  }

type parametric = {
  preserved_cycles : int;
  blocks_per_cycle : int32;
  blocks_per_commitment : int32;
  blocks_per_roll_snapshot : int32;
  blocks_per_voting_period : int32;
  time_between_blocks : Period_repr.t list;
  endorsers_per_block : int;
  hard_gas_limit_per_operation : Z.t;
  hard_gas_limit_per_block : Z.t;
  proof_of_work_threshold : int64;
  tokens_per_roll : Tez_repr.t;
  michelson_maximum_type_size : int;
  seed_nonce_revelation_tip : Tez_repr.t;
  origination_size : int;
  block_security_deposit : Tez_repr.t;
  endorsement_security_deposit : Tez_repr.t;
  block_reward : Tez_repr.t;
  endorsement_reward : Tez_repr.t;
  cost_per_byte : Tez_repr.t;
  hard_storage_limit_per_operation : Z.t;
  test_chain_duration : int64;
  (* in seconds *)
  quorum_min : int32;
  quorum_max : int32;
  min_proposal_quorum : int32;
  initial_endorsers : int;
  delay_per_missing_endorsement : Period_repr.t;
}

let parametric_encoding =
  let open Data_encoding in
  conv
    (fun c -&gt;
      ( ( c.preserved_cycles,
          c.blocks_per_cycle,
          c.blocks_per_commitment,
          c.blocks_per_roll_snapshot,
          c.blocks_per_voting_period,
          c.time_between_blocks,
          c.endorsers_per_block,
          c.hard_gas_limit_per_operation,
          c.hard_gas_limit_per_block ),
        ( ( c.proof_of_work_threshold,
            c.tokens_per_roll,
            c.michelson_maximum_type_size,
            c.seed_nonce_revelation_tip,
            c.origination_size,
            c.block_security_deposit,
            c.endorsement_security_deposit,
            c.block_reward ),
          ( c.endorsement_reward,
            c.cost_per_byte,
            c.hard_storage_limit_per_operation,
            c.test_chain_duration,
            c.quorum_min,
            c.quorum_max,
            c.min_proposal_quorum,
            c.initial_endorsers,
            c.delay_per_missing_endorsement ) ) ))
    (fun ( ( preserved_cycles,
             blocks_per_cycle,
             blocks_per_commitment,
             blocks_per_roll_snapshot,
             blocks_per_voting_period,
             time_between_blocks,
             endorsers_per_block,
             hard_gas_limit_per_operation,
             hard_gas_limit_per_block ),
           ( ( proof_of_work_threshold,
               tokens_per_roll,
               michelson_maximum_type_size,
               seed_nonce_revelation_tip,
               origination_size,
               block_security_deposit,
               endorsement_security_deposit,
               block_reward ),
             ( endorsement_reward,
               cost_per_byte,
               hard_storage_limit_per_operation,
               test_chain_duration,
               quorum_min,
               quorum_max,
               min_proposal_quorum,
               initial_endorsers,
               delay_per_missing_endorsement ) ) ) -&gt;
      {
        preserved_cycles;
        blocks_per_cycle;
        blocks_per_commitment;
        blocks_per_roll_snapshot;
        blocks_per_voting_period;
        time_between_blocks;
        endorsers_per_block;
        hard_gas_limit_per_operation;
        hard_gas_limit_per_block;
        proof_of_work_threshold;
        tokens_per_roll;
        michelson_maximum_type_size;
        seed_nonce_revelation_tip;
        origination_size;
        block_security_deposit;
        endorsement_security_deposit;
        block_reward;
        endorsement_reward;
        cost_per_byte;
        hard_storage_limit_per_operation;
        test_chain_duration;
        quorum_min;
        quorum_max;
        min_proposal_quorum;
        initial_endorsers;
        delay_per_missing_endorsement;
      })
    (merge_objs
       (obj9
          (req &quot;preserved_cycles&quot; uint8)
          (req &quot;blocks_per_cycle&quot; int32)
          (req &quot;blocks_per_commitment&quot; int32)
          (req &quot;blocks_per_roll_snapshot&quot; int32)
          (req &quot;blocks_per_voting_period&quot; int32)
          (req &quot;time_between_blocks&quot; (list Period_repr.encoding))
          (req &quot;endorsers_per_block&quot; uint16)
          (req &quot;hard_gas_limit_per_operation&quot; z)
          (req &quot;hard_gas_limit_per_block&quot; z))
       (merge_objs
          (obj8
             (req &quot;proof_of_work_threshold&quot; int64)
             (req &quot;tokens_per_roll&quot; Tez_repr.encoding)
             (req &quot;michelson_maximum_type_size&quot; uint16)
             (req &quot;seed_nonce_revelation_tip&quot; Tez_repr.encoding)
             (req &quot;origination_size&quot; int31)
             (req &quot;block_security_deposit&quot; Tez_repr.encoding)
             (req &quot;endorsement_security_deposit&quot; Tez_repr.encoding)
             (req &quot;block_reward&quot; Tez_repr.encoding))
          (obj9
             (req &quot;endorsement_reward&quot; Tez_repr.encoding)
             (req &quot;cost_per_byte&quot; Tez_repr.encoding)
             (req &quot;hard_storage_limit_per_operation&quot; z)
             (req &quot;test_chain_duration&quot; int64)
             (req &quot;quorum_min&quot; int32)
             (req &quot;quorum_max&quot; int32)
             (req &quot;min_proposal_quorum&quot; int32)
             (req &quot;initial_endorsers&quot; uint16)
             (req &quot;delay_per_missing_endorsement&quot; Period_repr.encoding))))

type t = {fixed : fixed; parametric : parametric}

let encoding =
  let open Data_encoding in
  conv
    (fun {fixed; parametric} -&gt; (fixed, parametric))
    (fun (fixed, parametric) -&gt; {fixed; parametric})
    (merge_objs fixed_encoding parametric_encoding)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#constants_repr.ml"><code>Constants_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Period_repr.
Require Tezos.Tez_repr.

Definition version_number_004 : string := &quot;\000&quot;.

Definition version_number : string := &quot;\001&quot;.

Definition proof_of_work_nonce_size : int := 8.

Definition nonce_length : int := 32.

Definition max_revelations_per_block : int := 32.

Definition max_proposals_per_delegate : int := 20.

Definition max_operation_data_length : int := Pervasives.op_star 16 1024.

Module fixed.
  Record record : Set := Build {
    proof_of_work_nonce_size : int;
    nonce_length : int;
    max_revelations_per_block : int;
    max_operation_data_length : int;
    max_proposals_per_delegate : int }.
  Definition with_proof_of_work_nonce_size proof_of_work_nonce_size
    (r : record) :=
    Build proof_of_work_nonce_size r.(nonce_length)
      r.(max_revelations_per_block) r.(max_operation_data_length)
      r.(max_proposals_per_delegate).
  Definition with_nonce_length nonce_length (r : record) :=
    Build r.(proof_of_work_nonce_size) nonce_length
      r.(max_revelations_per_block) r.(max_operation_data_length)
      r.(max_proposals_per_delegate).
  Definition with_max_revelations_per_block max_revelations_per_block
    (r : record) :=
    Build r.(proof_of_work_nonce_size) r.(nonce_length)
      max_revelations_per_block r.(max_operation_data_length)
      r.(max_proposals_per_delegate).
  Definition with_max_operation_data_length max_operation_data_length
    (r : record) :=
    Build r.(proof_of_work_nonce_size) r.(nonce_length)
      r.(max_revelations_per_block) max_operation_data_length
      r.(max_proposals_per_delegate).
  Definition with_max_proposals_per_delegate max_proposals_per_delegate
    (r : record) :=
    Build r.(proof_of_work_nonce_size) r.(nonce_length)
      r.(max_revelations_per_block) r.(max_operation_data_length)
      max_proposals_per_delegate.
End fixed.
Definition fixed := fixed.record.

Definition fixed_encoding : Data_encoding.encoding fixed :=
  Data_encoding.conv
    (fun c =&gt;
      (c.(fixed.proof_of_work_nonce_size), c.(fixed.nonce_length),
        c.(fixed.max_revelations_per_block),
        c.(fixed.max_operation_data_length),
        c.(fixed.max_proposals_per_delegate)))
    (fun function_parameter =&gt;
      let
        '(proof_of_work_nonce_size, nonce_length, max_revelations_per_block,
          max_operation_data_length, max_proposals_per_delegate) :=
        function_parameter in
      {| fixed.proof_of_work_nonce_size := proof_of_work_nonce_size;
        fixed.nonce_length := nonce_length;
        fixed.max_revelations_per_block := max_revelations_per_block;
        fixed.max_operation_data_length := max_operation_data_length;
        fixed.max_proposals_per_delegate := max_proposals_per_delegate |}) None
    (Data_encoding.obj5
      (Data_encoding.req None None &quot;proof_of_work_nonce_size&quot;
        Data_encoding.uint8)
      (Data_encoding.req None None &quot;nonce_length&quot; Data_encoding.uint8)
      (Data_encoding.req None None &quot;max_revelations_per_block&quot;
        Data_encoding.uint8)
      (Data_encoding.req None None &quot;max_operation_data_length&quot;
        Data_encoding.int31)
      (Data_encoding.req None None &quot;max_proposals_per_delegate&quot;
        Data_encoding.uint8)).

Definition __fixed_value : fixed :=
  {| fixed.proof_of_work_nonce_size := proof_of_work_nonce_size;
    fixed.nonce_length := nonce_length;
    fixed.max_revelations_per_block := max_revelations_per_block;
    fixed.max_operation_data_length := max_operation_data_length;
    fixed.max_proposals_per_delegate := max_proposals_per_delegate |}.

Module parametric.
  Record record : Set := Build {
    preserved_cycles : int;
    blocks_per_cycle : int32;
    blocks_per_commitment : int32;
    blocks_per_roll_snapshot : int32;
    blocks_per_voting_period : int32;
    time_between_blocks : list Period_repr.t;
    endorsers_per_block : int;
    hard_gas_limit_per_operation : Z.t;
    hard_gas_limit_per_block : Z.t;
    proof_of_work_threshold : int64;
    tokens_per_roll : Tez_repr.t;
    michelson_maximum_type_size : int;
    seed_nonce_revelation_tip : Tez_repr.t;
    origination_size : int;
    block_security_deposit : Tez_repr.t;
    endorsement_security_deposit : Tez_repr.t;
    block_reward : Tez_repr.t;
    endorsement_reward : Tez_repr.t;
    cost_per_byte : Tez_repr.t;
    hard_storage_limit_per_operation : Z.t;
    test_chain_duration : int64;
    quorum_min : int32;
    quorum_max : int32;
    min_proposal_quorum : int32;
    initial_endorsers : int;
    delay_per_missing_endorsement : Period_repr.t }.
  Definition with_preserved_cycles preserved_cycles (r : record) :=
    Build preserved_cycles r.(blocks_per_cycle) r.(blocks_per_commitment)
      r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
      r.(time_between_blocks) r.(endorsers_per_block)
      r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
      r.(proof_of_work_threshold) r.(tokens_per_roll)
      r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
      r.(origination_size) r.(block_security_deposit)
      r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
      r.(cost_per_byte) r.(hard_storage_limit_per_operation)
      r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
      r.(min_proposal_quorum) r.(initial_endorsers)
      r.(delay_per_missing_endorsement).
  Definition with_blocks_per_cycle blocks_per_cycle (r : record) :=
    Build r.(preserved_cycles) blocks_per_cycle r.(blocks_per_commitment)
      r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
      r.(time_between_blocks) r.(endorsers_per_block)
      r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
      r.(proof_of_work_threshold) r.(tokens_per_roll)
      r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
      r.(origination_size) r.(block_security_deposit)
      r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
      r.(cost_per_byte) r.(hard_storage_limit_per_operation)
      r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
      r.(min_proposal_quorum) r.(initial_endorsers)
      r.(delay_per_missing_endorsement).
  Definition with_blocks_per_commitment blocks_per_commitment (r : record) :=
    Build r.(preserved_cycles) r.(blocks_per_cycle) blocks_per_commitment
      r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
      r.(time_between_blocks) r.(endorsers_per_block)
      r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
      r.(proof_of_work_threshold) r.(tokens_per_roll)
      r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
      r.(origination_size) r.(block_security_deposit)
      r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
      r.(cost_per_byte) r.(hard_storage_limit_per_operation)
      r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
      r.(min_proposal_quorum) r.(initial_endorsers)
      r.(delay_per_missing_endorsement).
  Definition with_blocks_per_roll_snapshot blocks_per_roll_snapshot
    (r : record) :=
    Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
      blocks_per_roll_snapshot r.(blocks_per_voting_period)
      r.(time_between_blocks) r.(endorsers_per_block)
      r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
      r.(proof_of_work_threshold) r.(tokens_per_roll)
      r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
      r.(origination_size) r.(block_security_deposit)
      r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
      r.(cost_per_byte) r.(hard_storage_limit_per_operation)
      r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
      r.(min_proposal_quorum) r.(initial_endorsers)
      r.(delay_per_missing_endorsement).
  Definition with_blocks_per_voting_period blocks_per_voting_period
    (r : record) :=
    Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
      r.(blocks_per_roll_snapshot) blocks_per_voting_period
      r.(time_between_blocks) r.(endorsers_per_block)
      r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
      r.(proof_of_work_threshold) r.(tokens_per_roll)
      r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
      r.(origination_size) r.(block_security_deposit)
      r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
      r.(cost_per_byte) r.(hard_storage_limit_per_operation)
      r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
      r.(min_proposal_quorum) r.(initial_endorsers)
      r.(delay_per_missing_endorsement).
  Definition with_time_between_blocks time_between_blocks (r : record) :=
    Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
      r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
      time_between_blocks r.(endorsers_per_block)
      r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
      r.(proof_of_work_threshold) r.(tokens_per_roll)
      r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
      r.(origination_size) r.(block_security_deposit)
      r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
      r.(cost_per_byte) r.(hard_storage_limit_per_operation)
      r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
      r.(min_proposal_quorum) r.(initial_endorsers)
      r.(delay_per_missing_endorsement).
  Definition with_endorsers_per_block endorsers_per_block (r : record) :=
    Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
      r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
      r.(time_between_blocks) endorsers_per_block
      r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
      r.(proof_of_work_threshold) r.(tokens_per_roll)
      r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
      r.(origination_size) r.(block_security_deposit)
      r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
      r.(cost_per_byte) r.(hard_storage_limit_per_operation)
      r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
      r.(min_proposal_quorum) r.(initial_endorsers)
      r.(delay_per_missing_endorsement).
  Definition with_hard_gas_limit_per_operation hard_gas_limit_per_operation
    (r : record) :=
    Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
      r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
      r.(time_between_blocks) r.(endorsers_per_block)
      hard_gas_limit_per_operation r.(hard_gas_limit_per_block)
      r.(proof_of_work_threshold) r.(tokens_per_roll)
      r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
      r.(origination_size) r.(block_security_deposit)
      r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
      r.(cost_per_byte) r.(hard_storage_limit_per_operation)
      r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
      r.(min_proposal_quorum) r.(initial_endorsers)
      r.(delay_per_missing_endorsement).
  Definition with_hard_gas_limit_per_block hard_gas_limit_per_block
    (r : record) :=
    Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
      r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
      r.(time_between_blocks) r.(endorsers_per_block)
      r.(hard_gas_limit_per_operation) hard_gas_limit_per_block
      r.(proof_of_work_threshold) r.(tokens_per_roll)
      r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
      r.(origination_size) r.(block_security_deposit)
      r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
      r.(cost_per_byte) r.(hard_storage_limit_per_operation)
      r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
      r.(min_proposal_quorum) r.(initial_endorsers)
      r.(delay_per_missing_endorsement).
  Definition with_proof_of_work_threshold proof_of_work_threshold
    (r : record) :=
    Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
      r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
      r.(time_between_blocks) r.(endorsers_per_block)
      r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
      proof_of_work_threshold r.(tokens_per_roll)
      r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
      r.(origination_size) r.(block_security_deposit)
      r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
      r.(cost_per_byte) r.(hard_storage_limit_per_operation)
      r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
      r.(min_proposal_quorum) r.(initial_endorsers)
      r.(delay_per_missing_endorsement).
  Definition with_tokens_per_roll tokens_per_roll (r : record) :=
    Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
      r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
      r.(time_between_blocks) r.(endorsers_per_block)
      r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
      r.(proof_of_work_threshold) tokens_per_roll
      r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
      r.(origination_size) r.(block_security_deposit)
      r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
      r.(cost_per_byte) r.(hard_storage_limit_per_operation)
      r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
      r.(min_proposal_quorum) r.(initial_endorsers)
      r.(delay_per_missing_endorsement).
  Definition with_michelson_maximum_type_size michelson_maximum_type_size
    (r : record) :=
    Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
      r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
      r.(time_between_blocks) r.(endorsers_per_block)
      r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
      r.(proof_of_work_threshold) r.(tokens_per_roll)
      michelson_maximum_type_size r.(seed_nonce_revelation_tip)
      r.(origination_size) r.(block_security_deposit)
      r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
      r.(cost_per_byte) r.(hard_storage_limit_per_operation)
      r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
      r.(min_proposal_quorum) r.(initial_endorsers)
      r.(delay_per_missing_endorsement).
  Definition with_seed_nonce_revelation_tip seed_nonce_revelation_tip
    (r : record) :=
    Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
      r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
      r.(time_between_blocks) r.(endorsers_per_block)
      r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
      r.(proof_of_work_threshold) r.(tokens_per_roll)
      r.(michelson_maximum_type_size) seed_nonce_revelation_tip
      r.(origination_size) r.(block_security_deposit)
      r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
      r.(cost_per_byte) r.(hard_storage_limit_per_operation)
      r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
      r.(min_proposal_quorum) r.(initial_endorsers)
      r.(delay_per_missing_endorsement).
  Definition with_origination_size origination_size (r : record) :=
    Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
      r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
      r.(time_between_blocks) r.(endorsers_per_block)
      r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
      r.(proof_of_work_threshold) r.(tokens_per_roll)
      r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
      origination_size r.(block_security_deposit)
      r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
      r.(cost_per_byte) r.(hard_storage_limit_per_operation)
      r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
      r.(min_proposal_quorum) r.(initial_endorsers)
      r.(delay_per_missing_endorsement).
  Definition with_block_security_deposit block_security_deposit (r : record) :=
    Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
      r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
      r.(time_between_blocks) r.(endorsers_per_block)
      r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
      r.(proof_of_work_threshold) r.(tokens_per_roll)
      r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
      r.(origination_size) block_security_deposit
      r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
      r.(cost_per_byte) r.(hard_storage_limit_per_operation)
      r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
      r.(min_proposal_quorum) r.(initial_endorsers)
      r.(delay_per_missing_endorsement).
  Definition with_endorsement_security_deposit endorsement_security_deposit
    (r : record) :=
    Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
      r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
      r.(time_between_blocks) r.(endorsers_per_block)
      r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
      r.(proof_of_work_threshold) r.(tokens_per_roll)
      r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
      r.(origination_size) r.(block_security_deposit)
      endorsement_security_deposit r.(block_reward) r.(endorsement_reward)
      r.(cost_per_byte) r.(hard_storage_limit_per_operation)
      r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
      r.(min_proposal_quorum) r.(initial_endorsers)
      r.(delay_per_missing_endorsement).
  Definition with_block_reward block_reward (r : record) :=
    Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
      r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
      r.(time_between_blocks) r.(endorsers_per_block)
      r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
      r.(proof_of_work_threshold) r.(tokens_per_roll)
      r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
      r.(origination_size) r.(block_security_deposit)
      r.(endorsement_security_deposit) block_reward r.(endorsement_reward)
      r.(cost_per_byte) r.(hard_storage_limit_per_operation)
      r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
      r.(min_proposal_quorum) r.(initial_endorsers)
      r.(delay_per_missing_endorsement).
  Definition with_endorsement_reward endorsement_reward (r : record) :=
    Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
      r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
      r.(time_between_blocks) r.(endorsers_per_block)
      r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
      r.(proof_of_work_threshold) r.(tokens_per_roll)
      r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
      r.(origination_size) r.(block_security_deposit)
      r.(endorsement_security_deposit) r.(block_reward) endorsement_reward
      r.(cost_per_byte) r.(hard_storage_limit_per_operation)
      r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
      r.(min_proposal_quorum) r.(initial_endorsers)
      r.(delay_per_missing_endorsement).
  Definition with_cost_per_byte cost_per_byte (r : record) :=
    Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
      r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
      r.(time_between_blocks) r.(endorsers_per_block)
      r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
      r.(proof_of_work_threshold) r.(tokens_per_roll)
      r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
      r.(origination_size) r.(block_security_deposit)
      r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
      cost_per_byte r.(hard_storage_limit_per_operation) r.(test_chain_duration)
      r.(quorum_min) r.(quorum_max) r.(min_proposal_quorum)
      r.(initial_endorsers) r.(delay_per_missing_endorsement).
  Definition with_hard_storage_limit_per_operation
    hard_storage_limit_per_operation (r : record) :=
    Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
      r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
      r.(time_between_blocks) r.(endorsers_per_block)
      r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
      r.(proof_of_work_threshold) r.(tokens_per_roll)
      r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
      r.(origination_size) r.(block_security_deposit)
      r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
      r.(cost_per_byte) hard_storage_limit_per_operation r.(test_chain_duration)
      r.(quorum_min) r.(quorum_max) r.(min_proposal_quorum)
      r.(initial_endorsers) r.(delay_per_missing_endorsement).
  Definition with_test_chain_duration test_chain_duration (r : record) :=
    Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
      r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
      r.(time_between_blocks) r.(endorsers_per_block)
      r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
      r.(proof_of_work_threshold) r.(tokens_per_roll)
      r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
      r.(origination_size) r.(block_security_deposit)
      r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
      r.(cost_per_byte) r.(hard_storage_limit_per_operation) test_chain_duration
      r.(quorum_min) r.(quorum_max) r.(min_proposal_quorum)
      r.(initial_endorsers) r.(delay_per_missing_endorsement).
  Definition with_quorum_min quorum_min (r : record) :=
    Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
      r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
      r.(time_between_blocks) r.(endorsers_per_block)
      r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
      r.(proof_of_work_threshold) r.(tokens_per_roll)
      r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
      r.(origination_size) r.(block_security_deposit)
      r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
      r.(cost_per_byte) r.(hard_storage_limit_per_operation)
      r.(test_chain_duration) quorum_min r.(quorum_max) r.(min_proposal_quorum)
      r.(initial_endorsers) r.(delay_per_missing_endorsement).
  Definition with_quorum_max quorum_max (r : record) :=
    Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
      r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
      r.(time_between_blocks) r.(endorsers_per_block)
      r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
      r.(proof_of_work_threshold) r.(tokens_per_roll)
      r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
      r.(origination_size) r.(block_security_deposit)
      r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
      r.(cost_per_byte) r.(hard_storage_limit_per_operation)
      r.(test_chain_duration) r.(quorum_min) quorum_max r.(min_proposal_quorum)
      r.(initial_endorsers) r.(delay_per_missing_endorsement).
  Definition with_min_proposal_quorum min_proposal_quorum (r : record) :=
    Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
      r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
      r.(time_between_blocks) r.(endorsers_per_block)
      r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
      r.(proof_of_work_threshold) r.(tokens_per_roll)
      r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
      r.(origination_size) r.(block_security_deposit)
      r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
      r.(cost_per_byte) r.(hard_storage_limit_per_operation)
      r.(test_chain_duration) r.(quorum_min) r.(quorum_max) min_proposal_quorum
      r.(initial_endorsers) r.(delay_per_missing_endorsement).
  Definition with_initial_endorsers initial_endorsers (r : record) :=
    Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
      r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
      r.(time_between_blocks) r.(endorsers_per_block)
      r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
      r.(proof_of_work_threshold) r.(tokens_per_roll)
      r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
      r.(origination_size) r.(block_security_deposit)
      r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
      r.(cost_per_byte) r.(hard_storage_limit_per_operation)
      r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
      r.(min_proposal_quorum) initial_endorsers
      r.(delay_per_missing_endorsement).
  Definition with_delay_per_missing_endorsement delay_per_missing_endorsement
    (r : record) :=
    Build r.(preserved_cycles) r.(blocks_per_cycle) r.(blocks_per_commitment)
      r.(blocks_per_roll_snapshot) r.(blocks_per_voting_period)
      r.(time_between_blocks) r.(endorsers_per_block)
      r.(hard_gas_limit_per_operation) r.(hard_gas_limit_per_block)
      r.(proof_of_work_threshold) r.(tokens_per_roll)
      r.(michelson_maximum_type_size) r.(seed_nonce_revelation_tip)
      r.(origination_size) r.(block_security_deposit)
      r.(endorsement_security_deposit) r.(block_reward) r.(endorsement_reward)
      r.(cost_per_byte) r.(hard_storage_limit_per_operation)
      r.(test_chain_duration) r.(quorum_min) r.(quorum_max)
      r.(min_proposal_quorum) r.(initial_endorsers)
      delay_per_missing_endorsement.
End parametric.
Definition parametric := parametric.record.

Definition parametric_encoding : Data_encoding.encoding parametric :=
  Data_encoding.conv
    (fun c =&gt;
      ((c.(parametric.preserved_cycles), c.(parametric.blocks_per_cycle),
        c.(parametric.blocks_per_commitment),
        c.(parametric.blocks_per_roll_snapshot),
        c.(parametric.blocks_per_voting_period),
        c.(parametric.time_between_blocks), c.(parametric.endorsers_per_block),
        c.(parametric.hard_gas_limit_per_operation),
        c.(parametric.hard_gas_limit_per_block)),
        ((c.(parametric.proof_of_work_threshold),
          c.(parametric.tokens_per_roll),
          c.(parametric.michelson_maximum_type_size),
          c.(parametric.seed_nonce_revelation_tip),
          c.(parametric.origination_size),
          c.(parametric.block_security_deposit),
          c.(parametric.endorsement_security_deposit),
          c.(parametric.block_reward)),
          (c.(parametric.endorsement_reward), c.(parametric.cost_per_byte),
            c.(parametric.hard_storage_limit_per_operation),
            c.(parametric.test_chain_duration), c.(parametric.quorum_min),
            c.(parametric.quorum_max), c.(parametric.min_proposal_quorum),
            c.(parametric.initial_endorsers),
            c.(parametric.delay_per_missing_endorsement)))))
    (fun function_parameter =&gt;
      let
        '((preserved_cycles, blocks_per_cycle, blocks_per_commitment,
          blocks_per_roll_snapshot, blocks_per_voting_period,
          time_between_blocks, endorsers_per_block,
          hard_gas_limit_per_operation, hard_gas_limit_per_block),
          ((proof_of_work_threshold, tokens_per_roll,
            michelson_maximum_type_size, seed_nonce_revelation_tip,
            origination_size, block_security_deposit,
            endorsement_security_deposit, block_reward),
            (endorsement_reward, cost_per_byte,
              hard_storage_limit_per_operation, test_chain_duration, quorum_min,
              quorum_max, min_proposal_quorum, initial_endorsers,
              delay_per_missing_endorsement))) := function_parameter in
      {| parametric.preserved_cycles := preserved_cycles;
        parametric.blocks_per_cycle := blocks_per_cycle;
        parametric.blocks_per_commitment := blocks_per_commitment;
        parametric.blocks_per_roll_snapshot := blocks_per_roll_snapshot;
        parametric.blocks_per_voting_period := blocks_per_voting_period;
        parametric.time_between_blocks := time_between_blocks;
        parametric.endorsers_per_block := endorsers_per_block;
        parametric.hard_gas_limit_per_operation := hard_gas_limit_per_operation;
        parametric.hard_gas_limit_per_block := hard_gas_limit_per_block;
        parametric.proof_of_work_threshold := proof_of_work_threshold;
        parametric.tokens_per_roll := tokens_per_roll;
        parametric.michelson_maximum_type_size := michelson_maximum_type_size;
        parametric.seed_nonce_revelation_tip := seed_nonce_revelation_tip;
        parametric.origination_size := origination_size;
        parametric.block_security_deposit := block_security_deposit;
        parametric.endorsement_security_deposit := endorsement_security_deposit;
        parametric.block_reward := block_reward;
        parametric.endorsement_reward := endorsement_reward;
        parametric.cost_per_byte := cost_per_byte;
        parametric.hard_storage_limit_per_operation :=
          hard_storage_limit_per_operation;
        parametric.test_chain_duration := test_chain_duration;
        parametric.quorum_min := quorum_min;
        parametric.quorum_max := quorum_max;
        parametric.min_proposal_quorum := min_proposal_quorum;
        parametric.initial_endorsers := initial_endorsers;
        parametric.delay_per_missing_endorsement :=
          delay_per_missing_endorsement |}) None
    (Data_encoding.merge_objs
      (Data_encoding.obj9
        (Data_encoding.req None None &quot;preserved_cycles&quot; Data_encoding.uint8)
        (Data_encoding.req None None &quot;blocks_per_cycle&quot;
          Data_encoding.__int32_value)
        (Data_encoding.req None None &quot;blocks_per_commitment&quot;
          Data_encoding.__int32_value)
        (Data_encoding.req None None &quot;blocks_per_roll_snapshot&quot;
          Data_encoding.__int32_value)
        (Data_encoding.req None None &quot;blocks_per_voting_period&quot;
          Data_encoding.__int32_value)
        (Data_encoding.req None None &quot;time_between_blocks&quot;
          (Data_encoding.__list_value None Period_repr.encoding))
        (Data_encoding.req None None &quot;endorsers_per_block&quot; Data_encoding.uint16)
        (Data_encoding.req None None &quot;hard_gas_limit_per_operation&quot;
          Data_encoding.z)
        (Data_encoding.req None None &quot;hard_gas_limit_per_block&quot; Data_encoding.z))
      (Data_encoding.merge_objs
        (Data_encoding.obj8
          (Data_encoding.req None None &quot;proof_of_work_threshold&quot;
            Data_encoding.__int64_value)
          (Data_encoding.req None None &quot;tokens_per_roll&quot; Tez_repr.encoding)
          (Data_encoding.req None None &quot;michelson_maximum_type_size&quot;
            Data_encoding.uint16)
          (Data_encoding.req None None &quot;seed_nonce_revelation_tip&quot;
            Tez_repr.encoding)
          (Data_encoding.req None None &quot;origination_size&quot; Data_encoding.int31)
          (Data_encoding.req None None &quot;block_security_deposit&quot;
            Tez_repr.encoding)
          (Data_encoding.req None None &quot;endorsement_security_deposit&quot;
            Tez_repr.encoding)
          (Data_encoding.req None None &quot;block_reward&quot; Tez_repr.encoding))
        (Data_encoding.obj9
          (Data_encoding.req None None &quot;endorsement_reward&quot; Tez_repr.encoding)
          (Data_encoding.req None None &quot;cost_per_byte&quot; Tez_repr.encoding)
          (Data_encoding.req None None &quot;hard_storage_limit_per_operation&quot;
            Data_encoding.z)
          (Data_encoding.req None None &quot;test_chain_duration&quot;
            Data_encoding.__int64_value)
          (Data_encoding.req None None &quot;quorum_min&quot; Data_encoding.__int32_value)
          (Data_encoding.req None None &quot;quorum_max&quot; Data_encoding.__int32_value)
          (Data_encoding.req None None &quot;min_proposal_quorum&quot;
            Data_encoding.__int32_value)
          (Data_encoding.req None None &quot;initial_endorsers&quot; Data_encoding.uint16)
          (Data_encoding.req None None &quot;delay_per_missing_endorsement&quot;
            Period_repr.encoding)))).

Module t.
  Record record : Set := Build {
    fixed : fixed;
    parametric : parametric }.
  Definition with_fixed fixed (r : record) :=
    Build fixed r.(parametric).
  Definition with_parametric parametric (r : record) :=
    Build r.(fixed) parametric.
End t.
Definition t := t.record.

Definition encoding : Data_encoding.encoding t :=
  Data_encoding.conv
    (fun function_parameter =&gt;
      let '{| t.fixed := __fixed_value; t.parametric := __parametric_value |} :=
        function_parameter in
      (__fixed_value, __parametric_value))
    (fun function_parameter =&gt;
      let '(__fixed_value, __parametric_value) := function_parameter in
      {| t.fixed := __fixed_value; t.parametric := __parametric_value |}) None
    (Data_encoding.merge_objs fixed_encoding parametric_encoding).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="constants_services.ml">
  <div style="margin: 20px;">
    <h3>Constants_services</h3>
    <ul>
      <li>OCaml size: 60 lines</li>
      <li>Coq size: 61 lines (+1% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#constants_services.ml"><code>constants_services.ml</code></a>&nbsp;<span class="label label-warning">1 warning</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

let custom_root =
  ( RPC_path.(open_root / &quot;context&quot; / &quot;constants&quot;)
    : RPC_context.t RPC_path.context )

module S = struct
  open Data_encoding

  let errors =
    RPC_service.get_service
      ~description:&quot;Schema for all the RPC errors from this protocol version&quot;
      ~query:RPC_query.empty
      ~output:json_schema
      RPC_path.(custom_root / &quot;errors&quot;)

  let all =
    RPC_service.get_service
      ~description:&quot;All constants&quot;
      ~query:RPC_query.empty
      ~output:Alpha_context.Constants.encoding
      custom_root
end

let register () =
  let open Services_registration in
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0_noctxt S.errors (fun () () -&gt;
      return Data_encoding.Json.(schema error_encoding))</abbr> ;
  register0 S.all (fun ctxt () () -&gt;
      let open Constants in
      return {fixed; parametric = parametric ctxt})

let errors ctxt block = RPC_context.make_call0 S.errors ctxt block () ()

let all ctxt block = RPC_context.make_call0 S.all ctxt block () ()
</pre>
  </div>
  <div class="col-md-6">
    <a href="#constants_services.ml"><code>Constants_services.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Services_registration.

Import Alpha_context.

Definition custom_root : RPC_path.context RPC_context.t :=
  RPC_path.op_div (RPC_path.op_div RPC_path.open_root &quot;context&quot;) &quot;constants&quot;.

Module S.
  Import Data_encoding.
  
  Definition errors
    : RPC_service.service RPC_context.t RPC_context.t unit unit
      Data_encoding.json_schema :=
    RPC_service.get_service
      (Some &quot;Schema for all the RPC errors from this protocol version&quot;)
      RPC_query.empty Data_encoding.__json_schema_value
      (RPC_path.op_div custom_root &quot;errors&quot;).
  
  Definition all
    : RPC_service.service RPC_context.t RPC_context.t unit unit
      Alpha_context.Constants.t :=
    RPC_service.get_service (Some &quot;All constants&quot;) RPC_query.empty
      Alpha_context.Constants.encoding custom_root.
End S.

Definition register (function_parameter : unit) : unit :=
  let '_ := function_parameter in
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  Services_registration.register0 S.all
    (fun ctxt =&gt;
      fun function_parameter =&gt;
        let '_ := function_parameter in
        fun function_parameter =&gt;
          let '_ := function_parameter in
          Error_monad.__return
            {|
              Alpha_context.Constants.t.fixed :=
                Alpha_context.Constants.__fixed_value;
              Alpha_context.Constants.t.parametric :=
                Alpha_context.Constants.__parametric_value ctxt |}).

Definition errors {A : Set} (ctxt : RPC_context.simple A) (block : A)
  : Lwt.t (Error_monad.shell_tzresult Data_encoding.json_schema) :=
  RPC_context.make_call0 S.errors ctxt block tt tt.

Definition all {A : Set} (ctxt : RPC_context.simple A) (block : A)
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Constants.t) :=
  RPC_context.make_call0 S.all ctxt block tt tt.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="constants_services.mli">
  <div style="margin: 20px;">
    <h3>Constants_services_mli</h3>
    <ul>
      <li>OCaml size: 36 lines</li>
      <li>Coq size: 24 lines (-34% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#constants_services.mli"><code>constants_services.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

val errors :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Data_encoding.json_schema shell_tzresult Lwt.t

(** Returns all the constants of the protocol *)
val all : 'a #RPC_context.simple -&gt; 'a -&gt; Constants.t shell_tzresult Lwt.t

val register : unit -&gt; unit
</pre>
  </div>
  <div class="col-md-6">
    <a href="#constants_services.mli"><code>Constants_services_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.

Import Alpha_context.

Parameter errors : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt;
  Lwt.t (Error_monad.shell_tzresult Data_encoding.json_schema).

Parameter all : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.Constants.t).

Parameter register : unit -&gt; unit.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="constants_storage.ml">
  <div style="margin: 20px;">
    <h3>Constants_storage</h3>
    <ul>
      <li>OCaml size: 130 lines</li>
      <li>Coq size: 124 lines (-5% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#constants_storage.ml"><code>constants_storage.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

let preserved_cycles c =
  let constants = Raw_context.constants c in
  constants.preserved_cycles

let blocks_per_cycle c =
  let constants = Raw_context.constants c in
  constants.blocks_per_cycle

let blocks_per_commitment c =
  let constants = Raw_context.constants c in
  constants.blocks_per_commitment

let blocks_per_roll_snapshot c =
  let constants = Raw_context.constants c in
  constants.blocks_per_roll_snapshot

let blocks_per_voting_period c =
  let constants = Raw_context.constants c in
  constants.blocks_per_voting_period

let time_between_blocks c =
  let constants = Raw_context.constants c in
  constants.time_between_blocks

let endorsers_per_block c =
  let constants = Raw_context.constants c in
  constants.endorsers_per_block

let initial_endorsers c =
  let constants = Raw_context.constants c in
  constants.initial_endorsers

let delay_per_missing_endorsement c =
  let constants = Raw_context.constants c in
  constants.delay_per_missing_endorsement

let hard_gas_limit_per_operation c =
  let constants = Raw_context.constants c in
  constants.hard_gas_limit_per_operation

let hard_gas_limit_per_block c =
  let constants = Raw_context.constants c in
  constants.hard_gas_limit_per_block

let cost_per_byte c =
  let constants = Raw_context.constants c in
  constants.cost_per_byte

let hard_storage_limit_per_operation c =
  let constants = Raw_context.constants c in
  constants.hard_storage_limit_per_operation

let proof_of_work_threshold c =
  let constants = Raw_context.constants c in
  constants.proof_of_work_threshold

let tokens_per_roll c =
  let constants = Raw_context.constants c in
  constants.tokens_per_roll

let michelson_maximum_type_size c =
  let constants = Raw_context.constants c in
  constants.michelson_maximum_type_size

let seed_nonce_revelation_tip c =
  let constants = Raw_context.constants c in
  constants.seed_nonce_revelation_tip

let origination_size c =
  let constants = Raw_context.constants c in
  constants.origination_size

let block_security_deposit c =
  let constants = Raw_context.constants c in
  constants.block_security_deposit

let endorsement_security_deposit c =
  let constants = Raw_context.constants c in
  constants.endorsement_security_deposit

let block_reward c =
  let constants = Raw_context.constants c in
  constants.block_reward

let endorsement_reward c =
  let constants = Raw_context.constants c in
  constants.endorsement_reward

let test_chain_duration c =
  let constants = Raw_context.constants c in
  constants.test_chain_duration

let quorum_min c =
  let constants = Raw_context.constants c in
  constants.quorum_min

let quorum_max c =
  let constants = Raw_context.constants c in
  constants.quorum_max

let min_proposal_quorum c =
  let constants = Raw_context.constants c in
  constants.min_proposal_quorum

let parametric c = Raw_context.constants c
</pre>
  </div>
  <div class="col-md-6">
    <a href="#constants_storage.ml"><code>Constants_storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Constants_repr.
Require Tezos.Period_repr.
Require Tezos.Raw_context.
Require Tezos.Tez_repr.

Definition preserved_cycles (c : Raw_context.context) : int :=
  let constants := Raw_context.constants c in
  constants.(Constants_repr.parametric.preserved_cycles).

Definition blocks_per_cycle (c : Raw_context.context) : int32 :=
  let constants := Raw_context.constants c in
  constants.(Constants_repr.parametric.blocks_per_cycle).

Definition blocks_per_commitment (c : Raw_context.context) : int32 :=
  let constants := Raw_context.constants c in
  constants.(Constants_repr.parametric.blocks_per_commitment).

Definition blocks_per_roll_snapshot (c : Raw_context.context) : int32 :=
  let constants := Raw_context.constants c in
  constants.(Constants_repr.parametric.blocks_per_roll_snapshot).

Definition blocks_per_voting_period (c : Raw_context.context) : int32 :=
  let constants := Raw_context.constants c in
  constants.(Constants_repr.parametric.blocks_per_voting_period).

Definition time_between_blocks (c : Raw_context.context) : list Period_repr.t :=
  let constants := Raw_context.constants c in
  constants.(Constants_repr.parametric.time_between_blocks).

Definition endorsers_per_block (c : Raw_context.context) : int :=
  let constants := Raw_context.constants c in
  constants.(Constants_repr.parametric.endorsers_per_block).

Definition initial_endorsers (c : Raw_context.context) : int :=
  let constants := Raw_context.constants c in
  constants.(Constants_repr.parametric.initial_endorsers).

Definition delay_per_missing_endorsement (c : Raw_context.context)
  : Period_repr.t :=
  let constants := Raw_context.constants c in
  constants.(Constants_repr.parametric.delay_per_missing_endorsement).

Definition hard_gas_limit_per_operation (c : Raw_context.context) : Z.t :=
  let constants := Raw_context.constants c in
  constants.(Constants_repr.parametric.hard_gas_limit_per_operation).

Definition hard_gas_limit_per_block (c : Raw_context.context) : Z.t :=
  let constants := Raw_context.constants c in
  constants.(Constants_repr.parametric.hard_gas_limit_per_block).

Definition cost_per_byte (c : Raw_context.context) : Tez_repr.t :=
  let constants := Raw_context.constants c in
  constants.(Constants_repr.parametric.cost_per_byte).

Definition hard_storage_limit_per_operation (c : Raw_context.context) : Z.t :=
  let constants := Raw_context.constants c in
  constants.(Constants_repr.parametric.hard_storage_limit_per_operation).

Definition proof_of_work_threshold (c : Raw_context.context) : int64 :=
  let constants := Raw_context.constants c in
  constants.(Constants_repr.parametric.proof_of_work_threshold).

Definition tokens_per_roll (c : Raw_context.context) : Tez_repr.t :=
  let constants := Raw_context.constants c in
  constants.(Constants_repr.parametric.tokens_per_roll).

Definition michelson_maximum_type_size (c : Raw_context.context) : int :=
  let constants := Raw_context.constants c in
  constants.(Constants_repr.parametric.michelson_maximum_type_size).

Definition seed_nonce_revelation_tip (c : Raw_context.context) : Tez_repr.t :=
  let constants := Raw_context.constants c in
  constants.(Constants_repr.parametric.seed_nonce_revelation_tip).

Definition origination_size (c : Raw_context.context) : int :=
  let constants := Raw_context.constants c in
  constants.(Constants_repr.parametric.origination_size).

Definition block_security_deposit (c : Raw_context.context) : Tez_repr.t :=
  let constants := Raw_context.constants c in
  constants.(Constants_repr.parametric.block_security_deposit).

Definition endorsement_security_deposit (c : Raw_context.context)
  : Tez_repr.t :=
  let constants := Raw_context.constants c in
  constants.(Constants_repr.parametric.endorsement_security_deposit).

Definition block_reward (c : Raw_context.context) : Tez_repr.t :=
  let constants := Raw_context.constants c in
  constants.(Constants_repr.parametric.block_reward).

Definition endorsement_reward (c : Raw_context.context) : Tez_repr.t :=
  let constants := Raw_context.constants c in
  constants.(Constants_repr.parametric.endorsement_reward).

Definition test_chain_duration (c : Raw_context.context) : int64 :=
  let constants := Raw_context.constants c in
  constants.(Constants_repr.parametric.test_chain_duration).

Definition quorum_min (c : Raw_context.context) : int32 :=
  let constants := Raw_context.constants c in
  constants.(Constants_repr.parametric.quorum_min).

Definition quorum_max (c : Raw_context.context) : int32 :=
  let constants := Raw_context.constants c in
  constants.(Constants_repr.parametric.quorum_max).

Definition min_proposal_quorum (c : Raw_context.context) : int32 :=
  let constants := Raw_context.constants c in
  constants.(Constants_repr.parametric.min_proposal_quorum).

Definition __parametric_value (c : Raw_context.context)
  : Constants_repr.parametric := Raw_context.constants c.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="contract_hash.ml">
  <div style="margin: 20px;">
    <h3>Contract_hash</h3>
    <ul>
      <li>OCaml size: 44 lines</li>
      <li>Coq size: 102 lines (+131% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#contract_hash.ml"><code>contract_hash.ml</code></a>&nbsp;<span class="label label-warning">1 warning</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(* 20 *)
let contract_hash = &quot;\002\090\121&quot; (* KT1(36) *)

module Blake2BModule =
  Blake2B.Make
    (Base58)
    (struct
      let name = &quot;Contract_hash&quot;

      let title = &quot;A contract ID&quot;

      let b58check_prefix = contract_hash

      let size = Some 20
    end)

include Blake2BModule

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () = Base58.check_encoded_prefix b58check_encoding &quot;KT1&quot; 36</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#contract_hash.ml"><code>Contract_hash.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.

Definition contract_hash : string := &quot;\002Zy&quot;.

Definition Blake2BModule :=
  (Blake2B.Make
    (existT (A := unit) (fun _ =&gt; _) tt
      {|
        Blake2B.SRegister.register_encoding {_} := Base58.register_encoding
      |}))
    (let name := &quot;Contract_hash&quot; in
    let title := &quot;A contract ID&quot; in
    let b58check_prefix := contract_hash in
    let size := Some 20 in
    existT (A := unit) (fun _ =&gt; _) tt
      {|
        Blake2B.PrefixedName.name := name;
        Blake2B.PrefixedName.title := title;
        Blake2B.PrefixedName.size := size;
        Blake2B.PrefixedName.b58check_prefix := b58check_prefix
      |}).

Definition t := (|Blake2BModule|).(S.HASH.t).

Definition name := (|Blake2BModule|).(S.HASH.name).

Definition title := (|Blake2BModule|).(S.HASH.title).

Definition pp := (|Blake2BModule|).(S.HASH.pp).

Definition pp_short := (|Blake2BModule|).(S.HASH.pp_short).

Definition op_eq := (|Blake2BModule|).(S.HASH.op_eq).

Definition op_ltgt := (|Blake2BModule|).(S.HASH.op_ltgt).

Definition op_lt := (|Blake2BModule|).(S.HASH.op_lt).

Definition op_lteq := (|Blake2BModule|).(S.HASH.op_lteq).

Definition op_gteq := (|Blake2BModule|).(S.HASH.op_gteq).

Definition op_gt := (|Blake2BModule|).(S.HASH.op_gt).

Definition compare := (|Blake2BModule|).(S.HASH.compare).

Definition equal := (|Blake2BModule|).(S.HASH.equal).

Definition max := (|Blake2BModule|).(S.HASH.max).

Definition min := (|Blake2BModule|).(S.HASH.min).

Definition hash_bytes := (|Blake2BModule|).(S.HASH.hash_bytes).

Definition hash_string := (|Blake2BModule|).(S.HASH.hash_string).

Definition zero := (|Blake2BModule|).(S.HASH.zero).

Definition size := (|Blake2BModule|).(S.HASH.size).

Definition to_bytes := (|Blake2BModule|).(S.HASH.to_bytes).

Definition of_bytes_opt := (|Blake2BModule|).(S.HASH.of_bytes_opt).

Definition of_bytes_exn := (|Blake2BModule|).(S.HASH.of_bytes_exn).

Definition to_b58check := (|Blake2BModule|).(S.HASH.to_b58check).

Definition to_short_b58check := (|Blake2BModule|).(S.HASH.to_short_b58check).

Definition of_b58check_exn := (|Blake2BModule|).(S.HASH.of_b58check_exn).

Definition of_b58check_opt := (|Blake2BModule|).(S.HASH.of_b58check_opt).

Definition b58check_encoding := (|Blake2BModule|).(S.HASH.b58check_encoding).

Definition encoding := (|Blake2BModule|).(S.HASH.encoding).

Definition rpc_arg := (|Blake2BModule|).(S.HASH.rpc_arg).

Definition to_path := (|Blake2BModule|).(S.HASH.to_path).

Definition of_path := (|Blake2BModule|).(S.HASH.of_path).

Definition of_path_exn := (|Blake2BModule|).(S.HASH.of_path_exn).

Definition prefix_path := (|Blake2BModule|).(S.HASH.prefix_path).

Definition path_length := (|Blake2BModule|).(S.HASH.path_length).

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="contract_repr.ml">
  <div style="margin: 20px;">
    <h3>Contract_repr</h3>
    <ul>
      <li>OCaml size: 232 lines</li>
      <li>Coq size: 282 lines (+21% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#contract_repr.ml"><code>contract_repr.ml</code></a>&nbsp;<span class="label label-warning">14 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t =
  | Implicit of Signature.Public_key_hash.t
  | Originated of Contract_hash.t

module CompareModule = Compare.Make (struct
  type nonrec t = t

  let compare l1 l2 =
    match (l1, l2) with
    | (Implicit pkh1, Implicit pkh2) -&gt;
        Signature.Public_key_hash.compare pkh1 pkh2
    | (Originated h1, Originated h2) -&gt;
        Contract_hash.compare h1 h2
    | (Implicit _, Originated _) -&gt;
        -1
    | (Originated _, Implicit _) -&gt;
        1
end)

include CompareModule

type contract = t

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Invalid_contract_notation of string</abbr> (* `Permanent *)

let to_b58check = function
  | Implicit pbk -&gt;
      Signature.Public_key_hash.to_b58check pbk
  | Originated h -&gt;
      Contract_hash.to_b58check h

let of_b58check s =
  match Base58.decode s with
  | Some <abbr class="mark-warning" title="Patterns of extensible types are not handled">(Ed25519.Public_key_hash.Data h)</abbr> -&gt;
      ok (Implicit (Signature.Ed25519Hash h))
  | Some <abbr class="mark-warning" title="Patterns of extensible types are not handled">(Secp256k1.Public_key_hash.Data h)</abbr> -&gt;
      ok (Implicit (Signature.Secp256k1Hash h))
  | Some <abbr class="mark-warning" title="Patterns of extensible types are not handled">(P256.Public_key_hash.Data h)</abbr> -&gt;
      ok (Implicit (Signature.P256Hash h))
  | Some <abbr class="mark-warning" title="Patterns of extensible types are not handled">(Contract_hash.Data h)</abbr> -&gt;
      ok (Originated h)
  | _ -&gt;
      error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_contract_notation s)</abbr>

let pp ppf = function
  | Implicit pbk -&gt;
      Signature.Public_key_hash.pp ppf pbk
  | Originated h -&gt;
      Contract_hash.pp ppf h

let pp_short ppf = function
  | Implicit pbk -&gt;
      Signature.Public_key_hash.pp_short ppf pbk
  | Originated h -&gt;
      Contract_hash.pp_short ppf h

let encoding =
  let open Data_encoding in
  def
    &quot;contract_id&quot;
    ~title:&quot;A contract handle&quot;
    ~description:
      &quot;A contract notation as given to an RPC or inside scripts. Can be a \
       base58 implicit contract hash or a base58 originated contract hash.&quot;
  @@ splitted
       ~binary:
         (union
            ~tag_size:`Uint8
            [ case
                (Tag 0)
                ~title:&quot;Implicit&quot;
                Signature.Public_key_hash.encoding
                (function Implicit k -&gt; Some k | _ -&gt; None)
                (fun k -&gt; Implicit k);
              case
                (Tag 1)
                (Fixed.add_padding Contract_hash.encoding 1)
                ~title:&quot;Originated&quot;
                (function Originated k -&gt; Some k | _ -&gt; None)
                (fun k -&gt; Originated k) ])
       ~json:
         (conv
            to_b58check
            (fun s -&gt;
              match of_b58check s with
              | Ok s -&gt;
                  s
              | Error _ -&gt;
                  Json.cannot_destruct &quot;Invalid contract notation.&quot;)
            string)

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  let open Data_encoding in
  register_error_kind
    `Permanent
    ~id:&quot;contract.invalid_contract_notation&quot;
    ~title:&quot;Invalid contract notation&quot;
    ~pp:(fun ppf x -&gt; Format.fprintf ppf &quot;Invalid contract notation %S&quot; x)
    ~description:
      &quot;A malformed contract notation was given to an RPC or in a script.&quot;
    (obj1 (req &quot;notation&quot; string))
    (function Invalid_contract_notation loc -&gt; Some loc | _ -&gt; None)
    (fun loc -&gt; Invalid_contract_notation loc)</abbr>

let implicit_contract id = Implicit id

let is_implicit = function Implicit m -&gt; Some m | Originated _ -&gt; None

let is_originated = function Implicit _ -&gt; None | Originated h -&gt; Some h

type origination_nonce = {
  operation_hash : Operation_hash.t;
  origination_index : int32;
}

let origination_nonce_encoding =
  let open Data_encoding in
  conv
    (fun {operation_hash; origination_index} -&gt;
      (operation_hash, origination_index))
    (fun (operation_hash, origination_index) -&gt;
      {operation_hash; origination_index})
  @@ obj2 (req &quot;operation&quot; Operation_hash.encoding) (dft &quot;index&quot; int32 0l)

let originated_contract nonce =
  let data =
    Data_encoding.Binary.to_bytes_exn origination_nonce_encoding nonce
  in
  Originated (Contract_hash.hash_bytes [data])

let originated_contracts
    ~since:{origination_index = first; operation_hash = first_hash}
    ~until:( {origination_index = last; operation_hash = last_hash} as
           origination_nonce ) =
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Operation_hash.equal first_hash last_hash)</abbr> ;
  let rec contracts acc origination_index =
    if Compare.Int32.(origination_index &lt; first) then acc
    else
      let origination_nonce = {origination_nonce with origination_index} in
      let acc = originated_contract origination_nonce :: acc in
      contracts acc (Int32.pred origination_index)
  in
  contracts [] (Int32.pred last)

let initial_origination_nonce operation_hash =
  {operation_hash; origination_index = 0l}

let incr_origination_nonce nonce =
  let origination_index = Int32.succ nonce.origination_index in
  {nonce with origination_index}

let rpc_arg =
  let construct = to_b58check in
  let destruct hash =
    match of_b58check hash with
    | Error _ -&gt;
        Error &quot;Cannot parse contract id&quot;
    | Ok contract -&gt;
        Ok contract
  in
  RPC_arg.make
    ~descr:&quot;A contract identifier encoded in b58check.&quot;
    ~name:&quot;contract_id&quot;
    ~construct
    ~destruct
    ()

module Index : Storage_description.INDEX with type t = contract = struct
  type t = contract

  let path_length = 7

  let to_path c l =
    let raw_key = Data_encoding.Binary.to_bytes_exn encoding c in
    let (`Hex key) = MBytes.to_hex raw_key in
    let (`Hex index_key) = MBytes.to_hex (Raw_hashes.blake2b raw_key) in
    String.sub index_key 0 2 :: String.sub index_key 2 2
    :: String.sub index_key 4 2 :: String.sub index_key 6 2
    :: String.sub index_key 8 2 :: String.sub index_key 10 2 :: key :: l

  let of_path = function
    | []
    | [_]
    | [_; _]
    | [_; _; _]
    | [_; _; _; _]
    | [_; _; _; _; _]
    | [_; _; _; _; _; _]
    | _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ -&gt;
        None
    | [index1; index2; index3; index4; index5; index6; key] -&gt;
        let raw_key = MBytes.of_hex (`Hex key) in
        let (`Hex index_key) = MBytes.to_hex (Raw_hashes.blake2b raw_key) in
        <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.String.(String.sub index_key 0 2 = index1))</abbr> ;
        <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.String.(String.sub index_key 2 2 = index2))</abbr> ;
        <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.String.(String.sub index_key 4 2 = index3))</abbr> ;
        <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.String.(String.sub index_key 6 2 = index4))</abbr> ;
        <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.String.(String.sub index_key 8 2 = index5))</abbr> ;
        <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.String.(String.sub index_key 10 2 = index6))</abbr> ;
        Data_encoding.Binary.of_bytes encoding raw_key

  let rpc_arg = rpc_arg

  let encoding = encoding

  let compare = compare
end
</pre>
  </div>
  <div class="col-md-6">
    <a href="#contract_repr.ml"><code>Contract_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Contract_hash.
Require Tezos.Storage_description.

Inductive t : Set :=
| Implicit : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt; t
| Originated : Contract_hash.t -&gt; t.

Definition CompareModule :=
  Compare.Make
    (let t : Set := t in
    let compare (l1 : t) (l2 : t) : int :=
      match (l1, l2) with
      | (Implicit pkh1, Implicit pkh2) =&gt;
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.compare) pkh1 pkh2
      | (Originated h1, Originated h2) =&gt; Contract_hash.compare h1 h2
      | (Implicit _, Originated _) =&gt; (-1)
      | (Originated _, Implicit _) =&gt; 1
      end in
    existT (A := Set) _ _
      {|
        Compare.COMPARABLE.compare := compare
      |}).

Definition op_eq := (|CompareModule|).(Compare.S.op_eq).

Definition op_ltgt := (|CompareModule|).(Compare.S.op_ltgt).

Definition op_lt := (|CompareModule|).(Compare.S.op_lt).

Definition op_lteq := (|CompareModule|).(Compare.S.op_lteq).

Definition op_gteq := (|CompareModule|).(Compare.S.op_gteq).

Definition op_gt := (|CompareModule|).(Compare.S.op_gt).

Definition compare := (|CompareModule|).(Compare.S.compare).

Definition equal := (|CompareModule|).(Compare.S.equal).

Definition max := (|CompareModule|).(Compare.S.max).

Definition min := (|CompareModule|).(Compare.S.min).

Definition contract : Set := t.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

Definition to_b58check (function_parameter : t) : string :=
  match function_parameter with
  | Implicit pbk =&gt;
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.to_b58check) pbk
  | Originated h =&gt; Contract_hash.to_b58check h
  end.

Definition of_b58check (s : string) : Error_monad.tzresult t :=
  let '_ := Base58.decode s in
  Error_monad.__error_value extensible_type_value.

Definition pp (ppf : Format.formatter) (function_parameter : t) : unit :=
  match function_parameter with
  | Implicit pbk =&gt;
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.pp) ppf pbk
  | Originated h =&gt; Contract_hash.pp ppf h
  end.

Definition pp_short (ppf : Format.formatter) (function_parameter : t) : unit :=
  match function_parameter with
  | Implicit pbk =&gt;
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.pp_short) ppf pbk
  | Originated h =&gt; Contract_hash.pp_short ppf h
  end.

Definition encoding : Data_encoding.encoding t :=
  (Data_encoding.def &quot;contract_id&quot; (Some &quot;A contract handle&quot;)
    (Some
      &quot;A contract notation as given to an RPC or inside scripts. Can be a base58 implicit contract hash or a base58 originated contract hash.&quot;))
    (Data_encoding.splitted
      (Data_encoding.conv to_b58check
        (fun s =&gt;
          match of_b58check s with
          | Pervasives.Ok s =&gt; s
          | Pervasives.Error _ =&gt;
            Data_encoding.Json.cannot_destruct
              (CamlinternalFormatBasics.Format
                (CamlinternalFormatBasics.String_literal
                  &quot;Invalid contract notation.&quot;
                  CamlinternalFormatBasics.End_of_format)
                &quot;Invalid contract notation.&quot;)
          end) None Data_encoding.__string_value)
      (Data_encoding.union (Some Data_encoding.Uint8)
        [
          Data_encoding.__case_value &quot;Implicit&quot; None (Data_encoding.Tag 0)
            (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding)
            (fun function_parameter =&gt;
              match function_parameter with
              | Implicit k =&gt; Some k
              | _ =&gt; None
              end) (fun k =&gt; Implicit k);
          Data_encoding.__case_value &quot;Originated&quot; None (Data_encoding.Tag 1)
            (Data_encoding.Fixed.add_padding Contract_hash.encoding 1)
            (fun function_parameter =&gt;
              match function_parameter with
              | Originated k =&gt; Some k
              | _ =&gt; None
              end) (fun k =&gt; Originated k)
        ])).

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition implicit_contract
  (id : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) : t := Implicit id.

Definition is_implicit (function_parameter : t)
  : option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) :=
  match function_parameter with
  | Implicit m =&gt; Some m
  | Originated _ =&gt; None
  end.

Definition is_originated (function_parameter : t) : option Contract_hash.t :=
  match function_parameter with
  | Implicit _ =&gt; None
  | Originated h =&gt; Some h
  end.

Module origination_nonce.
  Record record : Set := Build {
    operation_hash : (|Operation_hash|).(S.HASH.t);
    origination_index : int32 }.
  Definition with_operation_hash operation_hash (r : record) :=
    Build operation_hash r.(origination_index).
  Definition with_origination_index origination_index (r : record) :=
    Build r.(operation_hash) origination_index.
End origination_nonce.
Definition origination_nonce := origination_nonce.record.

Definition origination_nonce_encoding
  : Data_encoding.encoding origination_nonce :=
  (let arg :=
    Data_encoding.conv
      (fun function_parameter =&gt;
        let '{|
          origination_nonce.operation_hash := operation_hash;
            origination_nonce.origination_index := origination_index
            |} := function_parameter in
        (operation_hash, origination_index))
      (fun function_parameter =&gt;
        let '(operation_hash, origination_index) := function_parameter in
        {| origination_nonce.operation_hash := operation_hash;
          origination_nonce.origination_index := origination_index |}) in
  fun eta =&gt; arg None eta)
    (Data_encoding.obj2
      (Data_encoding.req None None &quot;operation&quot;
        (|Operation_hash|).(S.HASH.encoding))
      (Data_encoding.dft None None &quot;index&quot; Data_encoding.__int32_value
        (* ‚ùå Constant of type int32 is converted to int *)
        0)).

Definition originated_contract (__nonce_value : origination_nonce) : t :=
  let data :=
    Data_encoding.Binary.to_bytes_exn origination_nonce_encoding __nonce_value
    in
  Originated (Contract_hash.hash_bytes None [ data ]).

Definition originated_contracts (function_parameter : origination_nonce)
  : origination_nonce -&gt; list t :=
  let '{|
    origination_nonce.operation_hash := first_hash;
      origination_nonce.origination_index := first
      |} := function_parameter in
  fun function_parameter =&gt;
    let
      '{|
        origination_nonce.operation_hash := last_hash;
          origination_nonce.origination_index := last
          |} as origination_nonce := function_parameter in
    (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
    (* ‚ùå instruction_sequence &quot;;&quot; *)
    let fix contracts
      (acc : list t) (origination_index : (|Compare.Int32|).(Compare.S.t))
      {struct acc} : list t :=
      if (|Compare.Int32|).(Compare.S.op_lt) origination_index first then
        acc
      else
        let origination_nonce :=
          origination_nonce.with_origination_index origination_index
            origination_nonce in
        let acc := cons (originated_contract origination_nonce) acc in
        contracts acc (Int32.pred origination_index) in
    contracts nil (Int32.pred last).

Definition initial_origination_nonce
  (operation_hash : (|Operation_hash|).(S.HASH.t)) : origination_nonce :=
  {| origination_nonce.operation_hash := operation_hash;
    origination_nonce.origination_index :=
      (* ‚ùå Constant of type int32 is converted to int *)
      0 |}.

Definition incr_origination_nonce (__nonce_value : origination_nonce)
  : origination_nonce :=
  let origination_index :=
    Int32.succ __nonce_value.(origination_nonce.origination_index) in
  origination_nonce.with_origination_index origination_index __nonce_value.

Definition rpc_arg : RPC_arg.arg t :=
  let construct := to_b58check in
  let destruct (__hash_value : string) : Pervasives.result t string :=
    match of_b58check __hash_value with
    | Pervasives.Error _ =&gt; Pervasives.Error &quot;Cannot parse contract id&quot;
    | Pervasives.Ok contract =&gt; Pervasives.Ok contract
    end in
  RPC_arg.make (Some &quot;A contract identifier encoded in b58check.&quot;) &quot;contract_id&quot;
    destruct construct tt.

Definition Index :
  {_ : unit &amp; Storage_description.INDEX.signature (t := contract)} :=
  let t : Set := contract in
  let path_length := 7 in
  let to_path (c : t) (l : list string) : list string :=
    let raw_key := Data_encoding.Binary.to_bytes_exn encoding c in
    let 'MBytes.Hex __key_value := MBytes.to_hex raw_key in
    let 'MBytes.Hex index_key := MBytes.to_hex (Raw_hashes.blake2b raw_key) in
    cons (String.sub index_key 0 2)
      (cons (String.sub index_key 2 2)
        (cons (String.sub index_key 4 2)
          (cons (String.sub index_key 6 2)
            (cons (String.sub index_key 8 2)
              (cons (String.sub index_key 10 2) (cons __key_value l)))))) in
  let of_path (function_parameter : list (|Compare.String|).(Compare.S.t))
    : option t :=
    match function_parameter with
    |
      ([] | cons _ [] | cons _ (cons _ []) | cons _ (cons _ (cons _ [])) |
      cons _ (cons _ (cons _ (cons _ []))) |
      cons _ (cons _ (cons _ (cons _ (cons _ [])))) |
      cons _ (cons _ (cons _ (cons _ (cons _ (cons _ []))))) |
      cons _ (cons _ (cons _ (cons _ (cons _ (cons _ (cons _ (cons _ _))))))))
      =&gt; None
    |
      cons index1
        (cons index2
          (cons index3
            (cons index4 (cons index5 (cons index6 (cons __key_value [])))))) =&gt;
      let raw_key := MBytes.of_hex (MBytes.Hex __key_value) in
      let 'MBytes.Hex index_key := MBytes.to_hex (Raw_hashes.blake2b raw_key) in
      (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
      (* ‚ùå instruction_sequence &quot;;&quot; *)
      (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
      (* ‚ùå instruction_sequence &quot;;&quot; *)
      (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
      (* ‚ùå instruction_sequence &quot;;&quot; *)
      (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
      (* ‚ùå instruction_sequence &quot;;&quot; *)
      (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
      (* ‚ùå instruction_sequence &quot;;&quot; *)
      (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
      (* ‚ùå instruction_sequence &quot;;&quot; *)
      Data_encoding.Binary.of_bytes encoding raw_key
    end in
  existT (A := unit) (fun _ =&gt; _) tt
    {|
      Storage_description.INDEX.path_length := path_length;
      Storage_description.INDEX.to_path := to_path;
      Storage_description.INDEX.of_path := of_path;
      Storage_description.INDEX.rpc_arg := rpc_arg;
      Storage_description.INDEX.encoding := encoding;
      Storage_description.INDEX.compare := compare
    |}.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="contract_repr.mli">
  <div style="margin: 20px;">
    <h3>Contract_repr_mli</h3>
    <ul>
      <li>OCaml size: 80 lines</li>
      <li>Coq size: 89 lines (+11% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#contract_repr.mli"><code>contract_repr.mli</code></a>&nbsp;<span class="label label-warning">1 warning</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = private
  | Implicit of Signature.Public_key_hash.t
  | Originated of Contract_hash.t

type contract = t

include Compare.S with type t := contract

(** {2 Implicit contracts} *)

val implicit_contract : Signature.Public_key_hash.t -&gt; contract

val is_implicit : contract -&gt; Signature.Public_key_hash.t option

(** {2 Originated contracts} *)

(** Originated contracts handles are crafted from the hash of the
    operation that triggered their origination (and nothing else).
    As a single operation can trigger several originations, the
    corresponding handles are forged from a deterministic sequence of
    nonces, initialized with the hash of the operation. *)
type origination_nonce

val originated_contract : origination_nonce -&gt; contract

val originated_contracts :
  since:origination_nonce -&gt; until:origination_nonce -&gt; contract list

val initial_origination_nonce : Operation_hash.t -&gt; origination_nonce

val incr_origination_nonce : origination_nonce -&gt; origination_nonce

val is_originated : contract -&gt; Contract_hash.t option

(** {2 Human readable notation} *)

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Invalid_contract_notation of string</abbr> (* `Permanent *)

val to_b58check : contract -&gt; string

val of_b58check : string -&gt; contract tzresult

val pp : Format.formatter -&gt; contract -&gt; unit

val pp_short : Format.formatter -&gt; contract -&gt; unit

(** {2 Serializers} *)

val encoding : contract Data_encoding.t

val origination_nonce_encoding : origination_nonce Data_encoding.t

val rpc_arg : contract RPC_arg.arg

module Index : Storage_description.INDEX with type t = t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#contract_repr.mli"><code>Contract_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Contract_hash.
Require Tezos.Storage_description.

Inductive t : Set :=
| Implicit : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt; t
| Originated : Contract_hash.t -&gt; t.

Definition contract : Set := t.

Parameter Included_S : {_ : unit &amp; Compare.S.signature (t := contract)}.

Definition op_eq : contract -&gt; contract -&gt; bool :=
  (|Included_S|).(Compare.S.op_eq).

Definition op_ltgt : contract -&gt; contract -&gt; bool :=
  (|Included_S|).(Compare.S.op_ltgt).

Definition op_lt : contract -&gt; contract -&gt; bool :=
  (|Included_S|).(Compare.S.op_lt).

Definition op_lteq : contract -&gt; contract -&gt; bool :=
  (|Included_S|).(Compare.S.op_lteq).

Definition op_gteq : contract -&gt; contract -&gt; bool :=
  (|Included_S|).(Compare.S.op_gteq).

Definition op_gt : contract -&gt; contract -&gt; bool :=
  (|Included_S|).(Compare.S.op_gt).

Definition compare : contract -&gt; contract -&gt; int :=
  (|Included_S|).(Compare.S.compare).

Definition equal : contract -&gt; contract -&gt; bool :=
  (|Included_S|).(Compare.S.equal).

Definition max : contract -&gt; contract -&gt; contract :=
  (|Included_S|).(Compare.S.max).

Definition min : contract -&gt; contract -&gt; contract :=
  (|Included_S|).(Compare.S.min).

Parameter implicit_contract :
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt; contract.

Parameter is_implicit :
  contract -&gt; option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t).

Parameter origination_nonce : Set.

Parameter originated_contract : origination_nonce -&gt; contract.

Parameter originated_contracts :
  origination_nonce -&gt; origination_nonce -&gt; list contract.

Parameter initial_origination_nonce :
  (|Operation_hash|).(S.HASH.t) -&gt; origination_nonce.

Parameter incr_origination_nonce : origination_nonce -&gt; origination_nonce.

Parameter is_originated : contract -&gt; option Contract_hash.t.

(* extensible_type_definition `error` *)

Parameter to_b58check : contract -&gt; string.

Parameter of_b58check : string -&gt; Error_monad.tzresult contract.

Parameter pp : Format.formatter -&gt; contract -&gt; unit.

Parameter pp_short : Format.formatter -&gt; contract -&gt; unit.

Parameter encoding : Data_encoding.t contract.

Parameter origination_nonce_encoding : Data_encoding.t origination_nonce.

Parameter rpc_arg : RPC_arg.arg contract.

Parameter Index : {_ : unit &amp; Storage_description.INDEX.signature (t := t)}.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="contract_services.ml">
  <div style="margin: 20px;">
    <h3>Contract_services</h3>
    <ul>
      <li>OCaml size: 429 lines</li>
      <li>Coq size: 430 lines (+0% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#contract_services.ml"><code>contract_services.ml</code></a>&nbsp;<span class="label label-warning">15 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

let custom_root =
  ( RPC_path.(open_root / &quot;context&quot; / &quot;contracts&quot;)
    : RPC_context.t RPC_path.context )

let big_map_root =
  ( RPC_path.(open_root / &quot;context&quot; / &quot;big_maps&quot;)
    : RPC_context.t RPC_path.context )

type info = {
  balance : Tez.t;
  delegate : public_key_hash option;
  counter : counter option;
  script : Script.t option;
}

let info_encoding =
  let open Data_encoding in
  conv
    (fun {balance; delegate; script; counter} -&gt;
      (balance, delegate, script, counter))
    (fun (balance, delegate, script, counter) -&gt;
      {balance; delegate; script; counter})
  @@ obj4
       (req &quot;balance&quot; Tez.encoding)
       (opt &quot;delegate&quot; Signature.Public_key_hash.encoding)
       (opt &quot;script&quot; Script.encoding)
       (opt &quot;counter&quot; n)

module S = struct
  open Data_encoding

  let balance =
    RPC_service.get_service
      ~description:&quot;Access the balance of a contract.&quot;
      ~query:RPC_query.empty
      ~output:Tez.encoding
      RPC_path.(custom_root /: Contract.rpc_arg / &quot;balance&quot;)

  let manager_key =
    RPC_service.get_service
      ~description:&quot;Access the manager of a contract.&quot;
      ~query:RPC_query.empty
      ~output:(option Signature.Public_key.encoding)
      RPC_path.(custom_root /: Contract.rpc_arg / &quot;manager_key&quot;)

  let delegate =
    RPC_service.get_service
      ~description:&quot;Access the delegate of a contract, if any.&quot;
      ~query:RPC_query.empty
      ~output:Signature.Public_key_hash.encoding
      RPC_path.(custom_root /: Contract.rpc_arg / &quot;delegate&quot;)

  let counter =
    RPC_service.get_service
      ~description:&quot;Access the counter of a contract, if any.&quot;
      ~query:RPC_query.empty
      ~output:z
      RPC_path.(custom_root /: Contract.rpc_arg / &quot;counter&quot;)

  let script =
    RPC_service.get_service
      ~description:&quot;Access the code and data of the contract.&quot;
      ~query:RPC_query.empty
      ~output:Script.encoding
      RPC_path.(custom_root /: Contract.rpc_arg / &quot;script&quot;)

  let storage =
    RPC_service.get_service
      ~description:&quot;Access the data of the contract.&quot;
      ~query:RPC_query.empty
      ~output:Script.expr_encoding
      RPC_path.(custom_root /: Contract.rpc_arg / &quot;storage&quot;)

  let entrypoint_type =
    RPC_service.get_service
      ~description:&quot;Return the type of the given entrypoint of the contract&quot;
      ~query:RPC_query.empty
      ~output:Script.expr_encoding
      RPC_path.(
        custom_root /: Contract.rpc_arg / &quot;entrypoints&quot; /: RPC_arg.string)

  let list_entrypoints =
    RPC_service.get_service
      ~description:&quot;Return the list of entrypoints of the contract&quot;
      ~query:RPC_query.empty
      ~output:
        (obj2
           (dft
              &quot;unreachable&quot;
              (Data_encoding.list
                 (obj1
                    (req
                       &quot;path&quot;
                       (Data_encoding.list
                          Michelson_v1_primitives.prim_encoding))))
              [])
           (req &quot;entrypoints&quot; (assoc Script.expr_encoding)))
      RPC_path.(custom_root /: Contract.rpc_arg / &quot;entrypoints&quot;)

  let contract_big_map_get_opt =
    RPC_service.post_service
      ~description:
        &quot;Access the value associated with a key in a big map of the contract \
         (deprecated).&quot;
      ~query:RPC_query.empty
      ~input:
        (obj2
           (req &quot;key&quot; Script.expr_encoding)
           (req &quot;type&quot; Script.expr_encoding))
      ~output:(option Script.expr_encoding)
      RPC_path.(custom_root /: Contract.rpc_arg / &quot;big_map_get&quot;)

  let big_map_get =
    RPC_service.get_service
      ~description:&quot;Access the value associated with a key in a big map.&quot;
      ~query:RPC_query.empty
      ~output:Script.expr_encoding
      RPC_path.(big_map_root /: Big_map.rpc_arg /: Script_expr_hash.rpc_arg)

  let info =
    RPC_service.get_service
      ~description:&quot;Access the complete status of a contract.&quot;
      ~query:RPC_query.empty
      ~output:info_encoding
      RPC_path.(custom_root /: Contract.rpc_arg)

  let list =
    RPC_service.get_service
      ~description:
        &quot;All existing contracts (including non-empty default contracts).&quot;
      ~query:RPC_query.empty
      ~output:(list Contract.encoding)
      custom_root
end

let register () =
  let open Services_registration in
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.list (fun ctxt () () -&gt; Contract.list ctxt &gt;&gt;= return)</abbr> ;
  let register_field s f =
    register1 s (fun ctxt contract () () -&gt;
        Contract.exists ctxt contract
        &gt;&gt;=? function true -&gt; f ctxt contract | false -&gt; raise <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Not_found</abbr>)
  in
  let register_opt_field s f =
    register_field s (fun ctxt a1 -&gt;
        f ctxt a1 &gt;&gt;=? function None -&gt; raise <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Not_found</abbr> | Some v -&gt; return v)
  in
  let do_big_map_get ctxt id key =
    let open Script_ir_translator in
    let ctxt = Gas.set_unlimited ctxt in
    Big_map.exists ctxt id
    &gt;&gt;=? fun (ctxt, types) -&gt;
    match types with
    | None -&gt;
        raise <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Not_found</abbr>
    | Some (_, value_type) -&gt; (
        Lwt.return
          (parse_ty
             ctxt
             ~legacy:true
             ~allow_big_map:false
             ~allow_operation:false
             ~allow_contract:true
             (Micheline.root value_type))
        &gt;&gt;=? fun (Ex_ty value_type, ctxt) -&gt;
        Big_map.get_opt ctxt id key
        &gt;&gt;=? fun (_ctxt, value) -&gt;
        match value with
        | None -&gt;
            raise <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Not_found</abbr>
        | Some value -&gt;
            (parse_data [@coq_implicit &quot;(a := unit)&quot;])
              ctxt
              ~legacy:true
              value_type
              (Micheline.root value)
            &gt;&gt;=? fun (value, ctxt) -&gt;
            unparse_data ctxt Readable value_type value
            &gt;&gt;=? fun (value, _ctxt) -&gt; return (Micheline.strip_locations value)
        )
  in
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register_field S.balance Contract.get_balance</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register1 S.manager_key (fun ctxt contract () () -&gt;
      match Contract.is_implicit contract with
      | None -&gt;
          raise Not_found
      | Some mgr -&gt; (
          Contract.is_manager_key_revealed ctxt mgr
          &gt;&gt;=? function
          | false -&gt;
              return_none
          | true -&gt;
              Contract.get_manager_key ctxt mgr &gt;&gt;=? return_some ))</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register_opt_field S.delegate Delegate.get</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register1 S.counter (fun ctxt contract () () -&gt;
      match Contract.is_implicit contract with
      | None -&gt;
          raise Not_found
      | Some mgr -&gt;
          Contract.get_counter ctxt mgr)</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register_opt_field S.script (fun c v -&gt;
      Contract.get_script c v &gt;&gt;=? fun (_, v) -&gt; return v)</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register_opt_field S.storage (fun ctxt contract -&gt;
      Contract.get_script ctxt contract
      &gt;&gt;=? fun (ctxt, script) -&gt;
      match script with
      | None -&gt;
          return_none
      | Some script -&gt;
          let ctxt = Gas.set_unlimited ctxt in
          let open Script_ir_translator in
          parse_script ctxt ~legacy:true script
          &gt;&gt;=? fun (Ex_script script, ctxt) -&gt;
          unparse_script ctxt Readable script
          &gt;&gt;=? fun (script, ctxt) -&gt;
          Script.force_decode_in_context ctxt script.storage
          &gt;&gt;=? fun (storage, _ctxt) -&gt; return_some storage)</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register2 S.entrypoint_type (fun ctxt v entrypoint () () -&gt;
      Contract.get_script_code ctxt v
      &gt;&gt;=? fun (_, expr) -&gt;
      match expr with
      | None -&gt;
          raise Not_found
      | Some expr -&gt; (
          let ctxt = Gas.set_unlimited ctxt in
          let legacy = true in
          let open Script_ir_translator in
          Script.force_decode_in_context ctxt expr
          &gt;&gt;=? fun (expr, _) -&gt;
          Lwt.return
            ( parse_toplevel ~legacy expr
            &gt;&gt;? fun (arg_type, _, _, root_name) -&gt;
            parse_ty
              ctxt
              ~legacy
              ~allow_big_map:true
              ~allow_operation:false
              ~allow_contract:true
              arg_type
            &gt;&gt;? fun (Ex_ty arg_type, _) -&gt;
            Script_ir_translator.find_entrypoint ~root_name arg_type entrypoint
            )
          &gt;&gt;= function
          | Ok (_f, Ex_ty ty) -&gt;
              unparse_ty ctxt ty
              &gt;&gt;=? fun (ty_node, _) -&gt;
              return (Micheline.strip_locations ty_node)
          | Error _ -&gt;
              raise Not_found ))</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register1 S.list_entrypoints (fun ctxt v () () -&gt;
      Contract.get_script_code ctxt v
      &gt;&gt;=? fun (_, expr) -&gt;
      match expr with
      | None -&gt;
          raise Not_found
      | Some expr -&gt;
          let ctxt = Gas.set_unlimited ctxt in
          let legacy = true in
          let open Script_ir_translator in
          Script.force_decode_in_context ctxt expr
          &gt;&gt;=? fun (expr, _) -&gt;
          Lwt.return
            ( parse_toplevel ~legacy expr
            &gt;&gt;? fun (arg_type, _, _, root_name) -&gt;
            parse_ty
              ctxt
              ~legacy
              ~allow_big_map:true
              ~allow_operation:false
              ~allow_contract:true
              arg_type
            &gt;&gt;? fun (Ex_ty arg_type, _) -&gt;
            Script_ir_translator.list_entrypoints ~root_name arg_type ctxt )
          &gt;&gt;=? fun (unreachable_entrypoint, map) -&gt;
          return
            ( unreachable_entrypoint,
              Entrypoints_map.fold
                (fun entry (_, ty) acc -&gt;
                  (entry, Micheline.strip_locations ty) :: acc)
                map
                [] ))</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register1 S.contract_big_map_get_opt (fun ctxt contract () (key, key_type) -&gt;
      Contract.get_script ctxt contract
      &gt;&gt;=? fun (ctxt, script) -&gt;
      Lwt.return
        (Script_ir_translator.parse_packable_ty
           ctxt
           ~legacy:true
           (Micheline.root key_type))
      &gt;&gt;=? fun (Ex_ty key_type, ctxt) -&gt;
      Script_ir_translator.parse_data
        ctxt
        ~legacy:true
        key_type
        (Micheline.root key)
      &gt;&gt;=? fun (key, ctxt) -&gt;
      Script_ir_translator.hash_data ctxt key_type key
      &gt;&gt;=? fun (key, ctxt) -&gt;
      match script with
      | None -&gt;
          raise Not_found
      | Some script -&gt;
          let ctxt = Gas.set_unlimited ctxt in
          let open Script_ir_translator in
          parse_script ctxt ~legacy:true script
          &gt;&gt;=? fun (Ex_script script, ctxt) -&gt;
          Script_ir_translator.collect_big_maps
            ctxt
            script.storage_type
            script.storage
          &gt;&gt;=? fun (ids, _ctxt) -&gt;
          let ids = Script_ir_translator.list_of_big_map_ids ids in
          let rec find = function
            | [] -&gt;
                return_none
            | (id : Z.t) :: ids -&gt; (
              try do_big_map_get ctxt id key &gt;&gt;=? return_some
              with Not_found -&gt; find ids )
          in
          find ids)</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register2 S.big_map_get (fun ctxt id key () () -&gt; do_big_map_get ctxt id key)</abbr> ;
  register_field S.info (fun ctxt contract -&gt;
      Contract.get_balance ctxt contract
      &gt;&gt;=? fun balance -&gt;
      Delegate.get ctxt contract
      &gt;&gt;=? fun delegate -&gt;
      ( match Contract.is_implicit contract with
      | Some manager -&gt;
          Contract.get_counter ctxt manager
          &gt;&gt;=? fun counter -&gt; return_some counter
      | None -&gt;
          return None )
      &gt;&gt;=? fun counter -&gt;
      Contract.get_script ctxt contract
      &gt;&gt;=? fun (ctxt, script) -&gt;
      ( match script with
      | None -&gt;
          return (None, ctxt)
      | Some script -&gt;
          let ctxt = Gas.set_unlimited ctxt in
          let open Script_ir_translator in
          parse_script ctxt ~legacy:true script
          &gt;&gt;=? fun (Ex_script script, ctxt) -&gt;
          unparse_script ctxt Readable script
          &gt;&gt;=? fun (script, ctxt) -&gt; return (Some script, ctxt) )
      &gt;&gt;=? fun (script, _ctxt) -&gt; return {balance; delegate; script; counter})

let list ctxt block = RPC_context.make_call0 S.list ctxt block () ()

let info ctxt block contract =
  RPC_context.make_call1 S.info ctxt block contract () ()

let balance ctxt block contract =
  RPC_context.make_call1 S.balance ctxt block contract () ()

let manager_key ctxt block mgr =
  RPC_context.make_call1
    S.manager_key
    ctxt
    block
    (Contract.implicit_contract mgr)
    ()
    ()

let delegate ctxt block contract =
  RPC_context.make_call1 S.delegate ctxt block contract () ()

let delegate_opt ctxt block contract =
  RPC_context.make_opt_call1 S.delegate ctxt block contract () ()

let counter ctxt block mgr =
  RPC_context.make_call1
    S.counter
    ctxt
    block
    (Contract.implicit_contract mgr)
    ()
    ()

let script ctxt block contract =
  RPC_context.make_call1 S.script ctxt block contract () ()

let script_opt ctxt block contract =
  RPC_context.make_opt_call1 S.script ctxt block contract () ()

let storage ctxt block contract =
  RPC_context.make_call1 S.storage ctxt block contract () ()

let entrypoint_type ctxt block contract entrypoint =
  RPC_context.make_call2 S.entrypoint_type ctxt block contract entrypoint () ()

let list_entrypoints ctxt block contract =
  RPC_context.make_call1 S.list_entrypoints ctxt block contract () ()

let storage_opt ctxt block contract =
  RPC_context.make_opt_call1 S.storage ctxt block contract () ()

let big_map_get ctxt block id key =
  RPC_context.make_call2 S.big_map_get ctxt block id key () ()

let contract_big_map_get_opt ctxt block contract key =
  RPC_context.make_call1 S.contract_big_map_get_opt ctxt block contract () key
</pre>
  </div>
  <div class="col-md-6">
    <a href="#contract_services.ml"><code>Contract_services.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Michelson_v1_primitives.
Require Tezos.Script_expr_hash.
Require Tezos.Script_ir_translator.
Require Tezos.Script_typed_ir.
Require Tezos.Services_registration.

Import Alpha_context.

Definition custom_root : RPC_path.context RPC_context.t :=
  RPC_path.op_div (RPC_path.op_div RPC_path.open_root &quot;context&quot;) &quot;contracts&quot;.

Definition big_map_root : RPC_path.context RPC_context.t :=
  RPC_path.op_div (RPC_path.op_div RPC_path.open_root &quot;context&quot;) &quot;big_maps&quot;.

Module info.
  Record record : Set := Build {
    balance : Alpha_context.Tez.t;
    delegate : option Alpha_context.public_key_hash;
    counter : option Alpha_context.counter;
    script : option Alpha_context.Script.t }.
  Definition with_balance balance (r : record) :=
    Build balance r.(delegate) r.(counter) r.(script).
  Definition with_delegate delegate (r : record) :=
    Build r.(balance) delegate r.(counter) r.(script).
  Definition with_counter counter (r : record) :=
    Build r.(balance) r.(delegate) counter r.(script).
  Definition with_script script (r : record) :=
    Build r.(balance) r.(delegate) r.(counter) script.
End info.
Definition info := info.record.

Definition info_encoding : Data_encoding.encoding info :=
  (let arg :=
    Data_encoding.conv
      (fun function_parameter =&gt;
        let '{|
          info.balance := balance;
            info.delegate := delegate;
            info.counter := counter;
            info.script := script
            |} := function_parameter in
        (balance, delegate, script, counter))
      (fun function_parameter =&gt;
        let '(balance, delegate, script, counter) := function_parameter in
        {| info.balance := balance; info.delegate := delegate;
          info.counter := counter; info.script := script |}) in
  fun eta =&gt; arg None eta)
    (Data_encoding.obj4
      (Data_encoding.req None None &quot;balance&quot; Alpha_context.Tez.encoding)
      (Data_encoding.opt None None &quot;delegate&quot;
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding))
      (Data_encoding.opt None None &quot;script&quot; Alpha_context.Script.encoding)
      (Data_encoding.opt None None &quot;counter&quot; Data_encoding.n)).

Module S.
  Import Data_encoding.
  
  Definition balance
    : RPC_service.service RPC_context.t
      (RPC_context.t * Alpha_context.Contract.contract) unit unit
      Alpha_context.Tez.t :=
    RPC_service.get_service (Some &quot;Access the balance of a contract.&quot;)
      RPC_query.empty Alpha_context.Tez.encoding
      (RPC_path.op_div
        (RPC_path.op_divcolon custom_root Alpha_context.Contract.rpc_arg)
        &quot;balance&quot;).
  
  Definition manager_key
    : RPC_service.service RPC_context.t
      (RPC_context.t * Alpha_context.Contract.contract) unit unit
      (option (|Signature.Public_key|).(S.SPublic_key.t)) :=
    RPC_service.get_service (Some &quot;Access the manager of a contract.&quot;)
      RPC_query.empty
      (Data_encoding.__option_value
        (|Signature.Public_key|).(S.SPublic_key.encoding))
      (RPC_path.op_div
        (RPC_path.op_divcolon custom_root Alpha_context.Contract.rpc_arg)
        &quot;manager_key&quot;).
  
  Definition delegate
    : RPC_service.service RPC_context.t
      (RPC_context.t * Alpha_context.Contract.contract) unit unit
      (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) :=
    RPC_service.get_service (Some &quot;Access the delegate of a contract, if any.&quot;)
      RPC_query.empty
      (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding)
      (RPC_path.op_div
        (RPC_path.op_divcolon custom_root Alpha_context.Contract.rpc_arg)
        &quot;delegate&quot;).
  
  Definition counter
    : RPC_service.service RPC_context.t
      (RPC_context.t * Alpha_context.Contract.contract) unit unit Z.t :=
    RPC_service.get_service (Some &quot;Access the counter of a contract, if any.&quot;)
      RPC_query.empty Data_encoding.z
      (RPC_path.op_div
        (RPC_path.op_divcolon custom_root Alpha_context.Contract.rpc_arg)
        &quot;counter&quot;).
  
  Definition script
    : RPC_service.service RPC_context.t
      (RPC_context.t * Alpha_context.Contract.contract) unit unit
      Alpha_context.Script.t :=
    RPC_service.get_service (Some &quot;Access the code and data of the contract.&quot;)
      RPC_query.empty Alpha_context.Script.encoding
      (RPC_path.op_div
        (RPC_path.op_divcolon custom_root Alpha_context.Contract.rpc_arg)
        &quot;script&quot;).
  
  Definition storage
    : RPC_service.service RPC_context.t
      (RPC_context.t * Alpha_context.Contract.contract) unit unit
      Alpha_context.Script.expr :=
    RPC_service.get_service (Some &quot;Access the data of the contract.&quot;)
      RPC_query.empty Alpha_context.Script.expr_encoding
      (RPC_path.op_div
        (RPC_path.op_divcolon custom_root Alpha_context.Contract.rpc_arg)
        &quot;storage&quot;).
  
  Definition entrypoint_type
    : RPC_service.service RPC_context.t
      ((RPC_context.t * Alpha_context.Contract.contract) * string) unit unit
      Alpha_context.Script.expr :=
    RPC_service.get_service
      (Some &quot;Return the type of the given entrypoint of the contract&quot;)
      RPC_query.empty Alpha_context.Script.expr_encoding
      (RPC_path.op_divcolon
        (RPC_path.op_div
          (RPC_path.op_divcolon custom_root Alpha_context.Contract.rpc_arg)
          &quot;entrypoints&quot;) RPC_arg.__string_value).
  
  Definition list_entrypoints
    : RPC_service.service RPC_context.t
      (RPC_context.t * Alpha_context.Contract.contract) unit unit
      (list (list Michelson_v1_primitives.prim) *
        list (string * Alpha_context.Script.expr)) :=
    RPC_service.get_service
      (Some &quot;Return the list of entrypoints of the contract&quot;) RPC_query.empty
      (Data_encoding.obj2
        (Data_encoding.dft None None &quot;unreachable&quot;
          (Data_encoding.__list_value None
            (Data_encoding.obj1
              (Data_encoding.req None None &quot;path&quot;
                (Data_encoding.__list_value None
                  Michelson_v1_primitives.prim_encoding)))) nil)
        (Data_encoding.req None None &quot;entrypoints&quot;
          (Data_encoding.assoc Alpha_context.Script.expr_encoding)))
      (RPC_path.op_div
        (RPC_path.op_divcolon custom_root Alpha_context.Contract.rpc_arg)
        &quot;entrypoints&quot;).
  
  Definition contract_big_map_get_opt
    : RPC_service.service RPC_context.t
      (RPC_context.t * Alpha_context.Contract.contract) unit
      (Alpha_context.Script.expr * Alpha_context.Script.expr)
      (option Alpha_context.Script.expr) :=
    RPC_service.post_service
      (Some
        &quot;Access the value associated with a key in a big map of the contract (deprecated).&quot;)
      RPC_query.empty
      (Data_encoding.obj2
        (Data_encoding.req None None &quot;key&quot; Alpha_context.Script.expr_encoding)
        (Data_encoding.req None None &quot;type&quot; Alpha_context.Script.expr_encoding))
      (Data_encoding.__option_value Alpha_context.Script.expr_encoding)
      (RPC_path.op_div
        (RPC_path.op_divcolon custom_root Alpha_context.Contract.rpc_arg)
        &quot;big_map_get&quot;).
  
  Definition big_map_get
    : RPC_service.service RPC_context.t
      ((RPC_context.t * Alpha_context.Big_map.id) * Script_expr_hash.t) unit
      unit Alpha_context.Script.expr :=
    RPC_service.get_service
      (Some &quot;Access the value associated with a key in a big map.&quot;)
      RPC_query.empty Alpha_context.Script.expr_encoding
      (RPC_path.op_divcolon
        (RPC_path.op_divcolon big_map_root Alpha_context.Big_map.rpc_arg)
        Script_expr_hash.rpc_arg).
  
  Definition __info_value
    : RPC_service.service RPC_context.t
      (RPC_context.t * Alpha_context.Contract.contract) unit unit info :=
    RPC_service.get_service (Some &quot;Access the complete status of a contract.&quot;)
      RPC_query.empty info_encoding
      (RPC_path.op_divcolon custom_root Alpha_context.Contract.rpc_arg).
  
  Definition __list_value
    : RPC_service.service RPC_context.t RPC_context.t unit unit
      (list Alpha_context.Contract.t) :=
    RPC_service.get_service
      (Some &quot;All existing contracts (including non-empty default contracts).&quot;)
      RPC_query.empty
      (Data_encoding.__list_value None Alpha_context.Contract.encoding)
      custom_root.
End S.

Definition register (function_parameter : unit) : unit :=
  let '_ := function_parameter in
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  let register_field {A : Set}
    (s :
      RPC_service.t Updater.rpc_context
        (Updater.rpc_context * Alpha_context.Contract.contract) unit unit A)
    (f :
      Alpha_context.t -&gt; Alpha_context.Contract.contract -&gt;
      Lwt.t (Error_monad.tzresult A)) : unit :=
    Services_registration.register1 s
      (fun ctxt =&gt;
        fun contract =&gt;
          fun function_parameter =&gt;
            let '_ := function_parameter in
            fun function_parameter =&gt;
              let '_ := function_parameter in
              let=? function_parameter :=
                Alpha_context.Contract.__exists ctxt contract in
              match function_parameter with
              | true =&gt; f ctxt contract
              | false =&gt; Pervasives.raise extensible_type_value
              end) in
  let register_opt_field {A : Set}
    (s :
      RPC_service.t Updater.rpc_context
        (Updater.rpc_context * Alpha_context.Contract.contract) unit unit A)
    (f :
      Alpha_context.t -&gt; Alpha_context.Contract.contract -&gt;
      Lwt.t (Error_monad.tzresult (option A))) : unit :=
    register_field s
      (fun ctxt =&gt;
        fun a1 =&gt;
          let=? function_parameter := f ctxt a1 in
          match function_parameter with
          | None =&gt; Pervasives.raise extensible_type_value
          | Some v =&gt; Error_monad.__return v
          end) in
  let do_big_map_get
    (ctxt : Alpha_context.context) (id : Alpha_context.Big_map.id)
    (__key_value : Script_expr_hash.t)
    : Lwt.t
      (Error_monad.tzresult (Micheline.canonical Alpha_context.Script.prim)) :=
    let ctxt := Alpha_context.Gas.set_unlimited ctxt in
    let=? '(ctxt, types) := Alpha_context.Big_map.__exists ctxt id in
    match types with
    | None =&gt; Pervasives.raise extensible_type_value
    | Some (_, value_type) =&gt;
      let=? '(Script_ir_translator.Ex_ty value_type, ctxt) :=
        Lwt.__return
          (Script_ir_translator.parse_ty ctxt true false false true
            (Micheline.root value_type)) in
      let=? '(_ctxt, value) := Alpha_context.Big_map.get_opt ctxt id __key_value
        in
      match value with
      | None =&gt; Pervasives.raise extensible_type_value
      | Some value =&gt;
        let=? '(value, ctxt) :=
          (Script_ir_translator.parse_data (a := unit)) None ctxt true
            value_type (Micheline.root value) in
        let=? '(value, _ctxt) :=
          Script_ir_translator.unparse_data ctxt Script_ir_translator.Readable
            value_type value in
        Error_monad.__return (Micheline.strip_locations value)
      end
    end in
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  register_field S.__info_value
    (fun ctxt =&gt;
      fun contract =&gt;
        let=? balance := Alpha_context.Contract.get_balance ctxt contract in
        let=? delegate := Alpha_context.Delegate.get ctxt contract in
        let=? counter :=
          match Alpha_context.Contract.is_implicit contract with
          | Some manager =&gt;
            let=? counter := Alpha_context.Contract.get_counter ctxt manager in
            Error_monad.return_some counter
          | None =&gt; Error_monad.__return None
          end in
        let=? '(ctxt, script) := Alpha_context.Contract.get_script ctxt contract
          in
        let=? '(script, _ctxt) :=
          match script with
          | None =&gt; Error_monad.__return (None, ctxt)
          | Some script =&gt;
            let ctxt := Alpha_context.Gas.set_unlimited ctxt in
            let=? '(Script_ir_translator.Ex_script script, ctxt) :=
              Script_ir_translator.parse_script None ctxt true script in
            let 'existT _ __Ex_script_'b2 [script, ctxt] :=
              existT (A := Set)
                (fun __Ex_script_'b2 =&gt;
                  [Script_typed_ir.script __Ex_script_'b2 **
                    Alpha_context.context]) _ [script, ctxt] in
            let=? '(script, ctxt) :=
              Script_ir_translator.unparse_script ctxt
                Script_ir_translator.Readable script in
            Error_monad.__return ((Some script), ctxt)
          end in
        Error_monad.__return
          {| info.balance := balance; info.delegate := delegate;
            info.counter := counter; info.script := script |}).

Definition __list_value {A : Set} (ctxt : RPC_context.simple A) (block : A)
  : Lwt.t (Error_monad.shell_tzresult (list Alpha_context.Contract.t)) :=
  RPC_context.make_call0 S.__list_value ctxt block tt tt.

Definition __info_value {A : Set}
  (ctxt : RPC_context.simple A) (block : A)
  (contract : Alpha_context.Contract.contract)
  : Lwt.t (Error_monad.shell_tzresult info) :=
  RPC_context.make_call1 S.__info_value ctxt block contract tt tt.

Definition balance {A : Set}
  (ctxt : RPC_context.simple A) (block : A)
  (contract : Alpha_context.Contract.contract)
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Tez.t) :=
  RPC_context.make_call1 S.balance ctxt block contract tt tt.

Definition manager_key {A : Set}
  (ctxt : RPC_context.simple A) (block : A)
  (mgr : Alpha_context.public_key_hash)
  : Lwt.t
    (Error_monad.shell_tzresult
      (option (|Signature.Public_key|).(S.SPublic_key.t))) :=
  RPC_context.make_call1 S.manager_key ctxt block
    (Alpha_context.Contract.implicit_contract mgr) tt tt.

Definition delegate {A : Set}
  (ctxt : RPC_context.simple A) (block : A)
  (contract : Alpha_context.Contract.contract)
  : Lwt.t
    (Error_monad.shell_tzresult
      (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) :=
  RPC_context.make_call1 S.delegate ctxt block contract tt tt.

Definition delegate_opt {A : Set}
  (ctxt : RPC_context.simple A) (block : A)
  (contract : Alpha_context.Contract.contract)
  : Lwt.t
    (Error_monad.shell_tzresult
      (option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))) :=
  RPC_context.make_opt_call1 S.delegate ctxt block contract tt tt.

Definition counter {A : Set}
  (ctxt : RPC_context.simple A) (block : A)
  (mgr : Alpha_context.public_key_hash)
  : Lwt.t (Error_monad.shell_tzresult Z.t) :=
  RPC_context.make_call1 S.counter ctxt block
    (Alpha_context.Contract.implicit_contract mgr) tt tt.

Definition script {A : Set}
  (ctxt : RPC_context.simple A) (block : A)
  (contract : Alpha_context.Contract.contract)
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Script.t) :=
  RPC_context.make_call1 S.script ctxt block contract tt tt.

Definition script_opt {A : Set}
  (ctxt : RPC_context.simple A) (block : A)
  (contract : Alpha_context.Contract.contract)
  : Lwt.t (Error_monad.shell_tzresult (option Alpha_context.Script.t)) :=
  RPC_context.make_opt_call1 S.script ctxt block contract tt tt.

Definition storage {A : Set}
  (ctxt : RPC_context.simple A) (block : A)
  (contract : Alpha_context.Contract.contract)
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Script.expr) :=
  RPC_context.make_call1 S.storage ctxt block contract tt tt.

Definition entrypoint_type {A : Set}
  (ctxt : RPC_context.simple A) (block : A)
  (contract : Alpha_context.Contract.contract) (entrypoint : string)
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Script.expr) :=
  RPC_context.make_call2 S.entrypoint_type ctxt block contract entrypoint tt tt.

Definition list_entrypoints {A : Set}
  (ctxt : RPC_context.simple A) (block : A)
  (contract : Alpha_context.Contract.contract)
  : Lwt.t
    (Error_monad.shell_tzresult
      (list (list Michelson_v1_primitives.prim) *
        list (string * Alpha_context.Script.expr))) :=
  RPC_context.make_call1 S.list_entrypoints ctxt block contract tt tt.

Definition storage_opt {A : Set}
  (ctxt : RPC_context.simple A) (block : A)
  (contract : Alpha_context.Contract.contract)
  : Lwt.t (Error_monad.shell_tzresult (option Alpha_context.Script.expr)) :=
  RPC_context.make_opt_call1 S.storage ctxt block contract tt tt.

Definition big_map_get {A : Set}
  (ctxt : RPC_context.simple A) (block : A) (id : Alpha_context.Big_map.id)
  (__key_value : Script_expr_hash.t)
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Script.expr) :=
  RPC_context.make_call2 S.big_map_get ctxt block id __key_value tt tt.

Definition contract_big_map_get_opt {A : Set}
  (ctxt : RPC_context.simple A) (block : A)
  (contract : Alpha_context.Contract.contract)
  (__key_value : Alpha_context.Script.expr * Alpha_context.Script.expr)
  : Lwt.t (Error_monad.shell_tzresult (option Alpha_context.Script.expr)) :=
  RPC_context.make_call1 S.contract_big_map_get_opt ctxt block contract tt
    __key_value.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="contract_services.mli">
  <div style="margin: 20px;">
    <h3>Contract_services_mli</h3>
    <ul>
      <li>OCaml size: 119 lines</li>
      <li>Coq size: 101 lines (-16% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#contract_services.mli"><code>contract_services.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

val list : 'a #RPC_context.simple -&gt; 'a -&gt; Contract.t list shell_tzresult Lwt.t

type info = {
  balance : Tez.t;
  delegate : public_key_hash option;
  counter : counter option;
  script : Script.t option;
}

val info_encoding : info Data_encoding.t

val info :
  'a #RPC_context.simple -&gt; 'a -&gt; Contract.t -&gt; info shell_tzresult Lwt.t

val balance :
  'a #RPC_context.simple -&gt; 'a -&gt; Contract.t -&gt; Tez.t shell_tzresult Lwt.t

val manager_key :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  public_key_hash -&gt;
  public_key option shell_tzresult Lwt.t

val delegate :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Contract.t -&gt;
  public_key_hash shell_tzresult Lwt.t

val delegate_opt :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Contract.t -&gt;
  public_key_hash option shell_tzresult Lwt.t

val counter :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  public_key_hash -&gt;
  counter shell_tzresult Lwt.t

val script :
  'a #RPC_context.simple -&gt; 'a -&gt; Contract.t -&gt; Script.t shell_tzresult Lwt.t

val script_opt :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Contract.t -&gt;
  Script.t option shell_tzresult Lwt.t

val storage :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Contract.t -&gt;
  Script.expr shell_tzresult Lwt.t

val entrypoint_type :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Contract.t -&gt;
  string -&gt;
  Script.expr shell_tzresult Lwt.t

val list_entrypoints :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Contract.t -&gt;
  (Michelson_v1_primitives.prim list list * (string * Script.expr) list)
  shell_tzresult
  Lwt.t

val storage_opt :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Contract.t -&gt;
  Script.expr option shell_tzresult Lwt.t

val big_map_get :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Z.t -&gt;
  Script_expr_hash.t -&gt;
  Script.expr shell_tzresult Lwt.t

val contract_big_map_get_opt :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Contract.t -&gt;
  Script.expr * Script.expr -&gt;
  Script.expr option shell_tzresult Lwt.t

val register : unit -&gt; unit
</pre>
  </div>
  <div class="col-md-6">
    <a href="#contract_services.mli"><code>Contract_services_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Michelson_v1_primitives.
Require Tezos.Script_expr_hash.

Import Alpha_context.

Parameter __list_value : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt;
  Lwt.t (Error_monad.shell_tzresult (list Alpha_context.Contract.t)).

Module info.
  Record record : Set := Build {
    balance : Alpha_context.Tez.t;
    delegate : option Alpha_context.public_key_hash;
    counter : option Alpha_context.counter;
    script : option Alpha_context.Script.t }.
  Definition with_balance balance (r : record) :=
    Build balance r.(delegate) r.(counter) r.(script).
  Definition with_delegate delegate (r : record) :=
    Build r.(balance) delegate r.(counter) r.(script).
  Definition with_counter counter (r : record) :=
    Build r.(balance) r.(delegate) counter r.(script).
  Definition with_script script (r : record) :=
    Build r.(balance) r.(delegate) r.(counter) script.
End info.
Definition info := info.record.

Parameter info_encoding : Data_encoding.t info.

Parameter __info_value : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt; Alpha_context.Contract.t -&gt;
  Lwt.t (Error_monad.shell_tzresult info).

Parameter balance : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt; Alpha_context.Contract.t -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.Tez.t).

Parameter manager_key : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt; Alpha_context.public_key_hash -&gt;
  Lwt.t (Error_monad.shell_tzresult (option Alpha_context.public_key)).

Parameter delegate : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt; Alpha_context.Contract.t -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.public_key_hash).

Parameter delegate_opt : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt; Alpha_context.Contract.t -&gt;
  Lwt.t (Error_monad.shell_tzresult (option Alpha_context.public_key_hash)).

Parameter counter : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt; Alpha_context.public_key_hash -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.counter).

Parameter script : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt; Alpha_context.Contract.t -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.Script.t).

Parameter script_opt : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt; Alpha_context.Contract.t -&gt;
  Lwt.t (Error_monad.shell_tzresult (option Alpha_context.Script.t)).

Parameter storage : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt; Alpha_context.Contract.t -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.Script.expr).

Parameter entrypoint_type : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt; Alpha_context.Contract.t -&gt; string -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.Script.expr).

Parameter list_entrypoints : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt; Alpha_context.Contract.t -&gt;
  Lwt.t
    (Error_monad.shell_tzresult
      (list (list Michelson_v1_primitives.prim) *
        list (string * Alpha_context.Script.expr))).

Parameter storage_opt : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt; Alpha_context.Contract.t -&gt;
  Lwt.t (Error_monad.shell_tzresult (option Alpha_context.Script.expr)).

Parameter big_map_get : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt; Z.t -&gt; Script_expr_hash.t -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.Script.expr).

Parameter contract_big_map_get_opt : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt; Alpha_context.Contract.t -&gt;
  Alpha_context.Script.expr * Alpha_context.Script.expr -&gt;
  Lwt.t (Error_monad.shell_tzresult (option Alpha_context.Script.expr)).

Parameter register : unit -&gt; unit.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="contract_storage.ml">
  <div style="margin: 20px;">
    <h3>Contract_storage</h3>
    <ul>
      <li>OCaml size: 733 lines</li>
      <li>Coq size: 818 lines (+11% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#contract_storage.ml"><code>contract_storage.ml</code></a>&nbsp;<span class="label label-warning">16 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | Balance_too_low of Contract_repr.contract * Tez_repr.t * Tez_repr.t
  | (* `Temporary *)
      Counter_in_the_past of Contract_repr.contract * Z.t * Z.t
  | (* `Branch *)
      Counter_in_the_future of Contract_repr.contract * Z.t * Z.t
  | (* `Temporary *)
      Unspendable_contract of Contract_repr.contract
  | (* `Permanent *)
      Non_existing_contract of Contract_repr.contract
  | (* `Temporary *)
      Empty_implicit_contract of Signature.Public_key_hash.t
  | (* `Temporary *)
      Empty_transaction of Contract_repr.t (* `Temporary *)
  | Inconsistent_hash of
      Signature.Public_key.t
      * Signature.Public_key_hash.t
      * Signature.Public_key_hash.t
  | (* `Permanent *)
      Inconsistent_public_key of
      Signature.Public_key.t * Signature.Public_key.t
  | (* `Permanent *)
      Failure of string (* `Permanent *)
  | Previously_revealed_key of Contract_repr.t (* `Permanent *)
  | Unrevealed_manager_key of Contract_repr.t</abbr>

(* `Permanent *)

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  register_error_kind
    `Permanent
    ~id:&quot;contract.unspendable_contract&quot;
    ~title:&quot;Unspendable contract&quot;
    ~description:
      &quot;An operation tried to spend tokens from an unspendable contract&quot;
    ~pp:(fun ppf c -&gt;
      Format.fprintf
        ppf
        &quot;The tokens of contract %a can only be spent by its script&quot;
        Contract_repr.pp
        c)
    Data_encoding.(obj1 (req &quot;contract&quot; Contract_repr.encoding))
    (function Unspendable_contract c -&gt; Some c | _ -&gt; None)
    (fun c -&gt; Unspendable_contract c) ;
  register_error_kind
    `Temporary
    ~id:&quot;contract.balance_too_low&quot;
    ~title:&quot;Balance too low&quot;
    ~description:
      &quot;An operation tried to spend more tokens than the contract has&quot;
    ~pp:(fun ppf (c, b, a) -&gt;
      Format.fprintf
        ppf
        &quot;Balance of contract %a too low (%a) to spend %a&quot;
        Contract_repr.pp
        c
        Tez_repr.pp
        b
        Tez_repr.pp
        a)
    Data_encoding.(
      obj3
        (req &quot;contract&quot; Contract_repr.encoding)
        (req &quot;balance&quot; Tez_repr.encoding)
        (req &quot;amount&quot; Tez_repr.encoding))
    (function Balance_too_low (c, b, a) -&gt; Some (c, b, a) | _ -&gt; None)
    (fun (c, b, a) -&gt; Balance_too_low (c, b, a)) ;
  register_error_kind
    `Temporary
    ~id:&quot;contract.counter_in_the_future&quot;
    ~title:&quot;Invalid counter (not yet reached) in a manager operation&quot;
    ~description:&quot;An operation assumed a contract counter in the future&quot;
    ~pp:(fun ppf (contract, exp, found) -&gt;
      Format.fprintf
        ppf
        &quot;Counter %s not yet reached for contract %a (expected %s)&quot;
        (Z.to_string found)
        Contract_repr.pp
        contract
        (Z.to_string exp))
    Data_encoding.(
      obj3
        (req &quot;contract&quot; Contract_repr.encoding)
        (req &quot;expected&quot; z)
        (req &quot;found&quot; z))
    (function Counter_in_the_future (c, x, y) -&gt; Some (c, x, y) | _ -&gt; None)
    (fun (c, x, y) -&gt; Counter_in_the_future (c, x, y)) ;
  register_error_kind
    `Branch
    ~id:&quot;contract.counter_in_the_past&quot;
    ~title:&quot;Invalid counter (already used) in a manager operation&quot;
    ~description:&quot;An operation assumed a contract counter in the past&quot;
    ~pp:(fun ppf (contract, exp, found) -&gt;
      Format.fprintf
        ppf
        &quot;Counter %s already used for contract %a (expected %s)&quot;
        (Z.to_string found)
        Contract_repr.pp
        contract
        (Z.to_string exp))
    Data_encoding.(
      obj3
        (req &quot;contract&quot; Contract_repr.encoding)
        (req &quot;expected&quot; z)
        (req &quot;found&quot; z))
    (function Counter_in_the_past (c, x, y) -&gt; Some (c, x, y) | _ -&gt; None)
    (fun (c, x, y) -&gt; Counter_in_the_past (c, x, y)) ;
  register_error_kind
    `Temporary
    ~id:&quot;contract.non_existing_contract&quot;
    ~title:&quot;Non existing contract&quot;
    ~description:
      &quot;A contract handle is not present in the context (either it never was \
       or it has been destroyed)&quot;
    ~pp:(fun ppf contract -&gt;
      Format.fprintf ppf &quot;Contract %a does not exist&quot; Contract_repr.pp contract)
    Data_encoding.(obj1 (req &quot;contract&quot; Contract_repr.encoding))
    (function Non_existing_contract c -&gt; Some c | _ -&gt; None)
    (fun c -&gt; Non_existing_contract c) ;
  register_error_kind
    `Permanent
    ~id:&quot;contract.manager.inconsistent_hash&quot;
    ~title:&quot;Inconsistent public key hash&quot;
    ~description:
      &quot;A revealed manager public key is inconsistent with the announced hash&quot;
    ~pp:(fun ppf (k, eh, ph) -&gt;
      Format.fprintf
        ppf
        &quot;The hash of the manager public key %s is not %a as announced but %a&quot;
        (Signature.Public_key.to_b58check k)
        Signature.Public_key_hash.pp
        ph
        Signature.Public_key_hash.pp
        eh)
    Data_encoding.(
      obj3
        (req &quot;public_key&quot; Signature.Public_key.encoding)
        (req &quot;expected_hash&quot; Signature.Public_key_hash.encoding)
        (req &quot;provided_hash&quot; Signature.Public_key_hash.encoding))
    (function Inconsistent_hash (k, eh, ph) -&gt; Some (k, eh, ph) | _ -&gt; None)
    (fun (k, eh, ph) -&gt; Inconsistent_hash (k, eh, ph)) ;
  register_error_kind
    `Permanent
    ~id:&quot;contract.manager.inconsistent_public_key&quot;
    ~title:&quot;Inconsistent public key&quot;
    ~description:
      &quot;A provided manager public key is different with the public key stored \
       in the contract&quot;
    ~pp:(fun ppf (eh, ph) -&gt;
      Format.fprintf
        ppf
        &quot;Expected manager public key %s but %s was provided&quot;
        (Signature.Public_key.to_b58check ph)
        (Signature.Public_key.to_b58check eh))
    Data_encoding.(
      obj2
        (req &quot;public_key&quot; Signature.Public_key.encoding)
        (req &quot;expected_public_key&quot; Signature.Public_key.encoding))
    (function Inconsistent_public_key (eh, ph) -&gt; Some (eh, ph) | _ -&gt; None)
    (fun (eh, ph) -&gt; Inconsistent_public_key (eh, ph)) ;
  register_error_kind
    `Permanent
    ~id:&quot;contract.failure&quot;
    ~title:&quot;Contract storage failure&quot;
    ~description:&quot;Unexpected contract storage error&quot;
    ~pp:(fun ppf s -&gt; Format.fprintf ppf &quot;Contract_storage.Failure %S&quot; s)
    Data_encoding.(obj1 (req &quot;message&quot; string))
    (function Failure s -&gt; Some s | _ -&gt; None)
    (fun s -&gt; Failure s) ;
  register_error_kind
    `Branch
    ~id:&quot;contract.unrevealed_key&quot;
    ~title:&quot;Manager operation precedes key revelation&quot;
    ~description:
      &quot;One tried to apply a manager operation without revealing the manager \
       public key&quot;
    ~pp:(fun ppf s -&gt;
      Format.fprintf
        ppf
        &quot;Unrevealed manager key for contract %a.&quot;
        Contract_repr.pp
        s)
    Data_encoding.(obj1 (req &quot;contract&quot; Contract_repr.encoding))
    (function Unrevealed_manager_key s -&gt; Some s | _ -&gt; None)
    (fun s -&gt; Unrevealed_manager_key s) ;
  register_error_kind
    `Branch
    ~id:&quot;contract.previously_revealed_key&quot;
    ~title:&quot;Manager operation already revealed&quot;
    ~description:&quot;One tried to revealed twice a manager public key&quot;
    ~pp:(fun ppf s -&gt;
      Format.fprintf
        ppf
        &quot;Previously revealed manager key for contract %a.&quot;
        Contract_repr.pp
        s)
    Data_encoding.(obj1 (req &quot;contract&quot; Contract_repr.encoding))
    (function Previously_revealed_key s -&gt; Some s | _ -&gt; None)
    (fun s -&gt; Previously_revealed_key s) ;
  register_error_kind
    `Branch
    ~id:&quot;implicit.empty_implicit_contract&quot;
    ~title:&quot;Empty implicit contract&quot;
    ~description:
      &quot;No manager operations are allowed on an empty implicit contract.&quot;
    ~pp:(fun ppf implicit -&gt;
      Format.fprintf
        ppf
        &quot;Empty implicit contract (%a)&quot;
        Signature.Public_key_hash.pp
        implicit)
    Data_encoding.(obj1 (req &quot;implicit&quot; Signature.Public_key_hash.encoding))
    (function Empty_implicit_contract c -&gt; Some c | _ -&gt; None)
    (fun c -&gt; Empty_implicit_contract c) ;
  register_error_kind
    `Branch
    ~id:&quot;contract.empty_transaction&quot;
    ~title:&quot;Empty transaction&quot;
    ~description:&quot;Forbidden to credit 0√™¬ú¬© to a contract without code.&quot;
    ~pp:(fun ppf contract -&gt;
      Format.fprintf
        ppf
        &quot;Transaction of 0√™¬ú¬© towards a contract without code are forbidden \
         (%a).&quot;
        Contract_repr.pp
        contract)
    Data_encoding.(obj1 (req &quot;contract&quot; Contract_repr.encoding))
    (function Empty_transaction c -&gt; Some c | _ -&gt; None)
    (fun c -&gt; Empty_transaction c)</abbr>

let failwith msg = fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Failure msg)</abbr>

type big_map_diff_item =
  | Update of {
      big_map : Z.t;
      diff_key : Script_repr.expr;
      diff_key_hash : Script_expr_hash.t;
      diff_value : Script_repr.expr option;
    }
  | Clear of Z.t
  | Copy of Z.t * Z.t
  | Alloc of {
      big_map : Z.t;
      key_type : Script_repr.expr;
      value_type : Script_repr.expr;
    }

type big_map_diff = big_map_diff_item list

let big_map_diff_item_encoding =
  let open Data_encoding in
  union
    [ case
        (Tag 0)
        ~title:&quot;update&quot;
        (obj5
           (req &quot;action&quot; (constant &quot;update&quot;))
           (req &quot;big_map&quot; z)
           (req &quot;key_hash&quot; Script_expr_hash.encoding)
           (req &quot;key&quot; Script_repr.expr_encoding)
           (opt &quot;value&quot; Script_repr.expr_encoding))
        (function
          | Update {big_map; diff_key_hash; diff_key; diff_value} -&gt;
              Some ((), big_map, diff_key_hash, diff_key, diff_value)
          | _ -&gt;
              None)
        (fun ((), big_map, diff_key_hash, diff_key, diff_value) -&gt;
          Update {big_map; diff_key_hash; diff_key; diff_value});
      case
        (Tag 1)
        ~title:&quot;remove&quot;
        (obj2 (req &quot;action&quot; (constant &quot;remove&quot;)) (req &quot;big_map&quot; z))
        (function Clear big_map -&gt; Some ((), big_map) | _ -&gt; None)
        (fun ((), big_map) -&gt; Clear big_map);
      case
        (Tag 2)
        ~title:&quot;copy&quot;
        (obj3
           (req &quot;action&quot; (constant &quot;copy&quot;))
           (req &quot;source_big_map&quot; z)
           (req &quot;destination_big_map&quot; z))
        (function Copy (src, dst) -&gt; Some ((), src, dst) | _ -&gt; None)
        (fun ((), src, dst) -&gt; Copy (src, dst));
      case
        (Tag 3)
        ~title:&quot;alloc&quot;
        (obj4
           (req &quot;action&quot; (constant &quot;alloc&quot;))
           (req &quot;big_map&quot; z)
           (req &quot;key_type&quot; Script_repr.expr_encoding)
           (req &quot;value_type&quot; Script_repr.expr_encoding))
        (function
          | Alloc {big_map; key_type; value_type} -&gt;
              Some ((), big_map, key_type, value_type)
          | _ -&gt;
              None)
        (fun ((), big_map, key_type, value_type) -&gt;
          Alloc {big_map; key_type; value_type}) ]

let big_map_diff_encoding =
  let open Data_encoding in
  def &quot;contract.big_map_diff&quot; @@ list big_map_diff_item_encoding

let big_map_key_cost = 65

let big_map_cost = 33

let update_script_big_map c = function
  | None -&gt;
      return (c, Z.zero)
  | Some diff -&gt;
      fold_left_s
        (fun (c, total) -&gt; function Clear id -&gt;
              Storage.Big_map.Total_bytes.get c id
              &gt;&gt;=? fun size -&gt;
              Storage.Big_map.remove_rec c id
              &gt;&gt;= fun c -&gt;
              if Compare.Z.(id &lt; Z.zero) then return (c, total)
              else return (c, Z.sub (Z.sub total size) (Z.of_int big_map_cost))
          | Copy (from, to_) -&gt;
              Storage.Big_map.copy c ~from ~to_
              &gt;&gt;=? fun c -&gt;
              if Compare.Z.(to_ &lt; Z.zero) then return (c, total)
              else
                Storage.Big_map.Total_bytes.get c from
                &gt;&gt;=? fun size -&gt;
                return (c, Z.add (Z.add total size) (Z.of_int big_map_cost))
          | Alloc {big_map; key_type; value_type} -&gt;
              Storage.Big_map.Total_bytes.init c big_map Z.zero
              &gt;&gt;=? fun c -&gt;
              (* Annotations are erased to allow sharing on
                 [Copy]. The types from the contract code are used,
                 these ones are only used to make sure they are
                 compatible during transmissions between contracts,
                 and only need to be compatible, annotations
                 nonwhistanding. *)
              let key_type =
                Micheline.strip_locations
                  (Script_repr.strip_annotations (Micheline.root key_type))
              in
              let value_type =
                Micheline.strip_locations
                  (Script_repr.strip_annotations (Micheline.root value_type))
              in
              Storage.Big_map.Key_type.init c big_map key_type
              &gt;&gt;=? fun c -&gt;
              Storage.Big_map.Value_type.init c big_map value_type
              &gt;&gt;=? fun c -&gt;
              if Compare.Z.(big_map &lt; Z.zero) then return (c, total)
              else return (c, Z.add total (Z.of_int big_map_cost))
          | Update {big_map; diff_key_hash; diff_value = None} -&gt;
              Storage.Big_map.Contents.remove (c, big_map) diff_key_hash
              &gt;&gt;=? fun (c, freed, existed) -&gt;
              let freed =
                if existed then freed + big_map_key_cost else freed
              in
              Storage.Big_map.Total_bytes.get c big_map
              &gt;&gt;=? fun size -&gt;
              Storage.Big_map.Total_bytes.set
                c
                big_map
                (Z.sub size (Z.of_int freed))
              &gt;&gt;=? fun c -&gt;
              if Compare.Z.(big_map &lt; Z.zero) then return (c, total)
              else return (c, Z.sub total (Z.of_int freed))
          | Update {big_map; diff_key_hash; diff_value = Some v} -&gt;
              Storage.Big_map.Contents.init_set (c, big_map) diff_key_hash v
              &gt;&gt;=? fun (c, size_diff, existed) -&gt;
              let size_diff =
                if existed then size_diff else size_diff + big_map_key_cost
              in
              Storage.Big_map.Total_bytes.get c big_map
              &gt;&gt;=? fun size -&gt;
              Storage.Big_map.Total_bytes.set
                c
                big_map
                (Z.add size (Z.of_int size_diff))
              &gt;&gt;=? fun c -&gt;
              if Compare.Z.(big_map &lt; Z.zero) then return (c, total)
              else return (c, Z.add total (Z.of_int size_diff)))
        (c, Z.zero)
        diff

let create_base c ?(prepaid_bootstrap_storage = false)
    (* Free space for bootstrap contracts *)
    contract ~balance ~manager ~delegate ?script () =
  ( match Contract_repr.is_implicit contract with
  | None -&gt;
      return c
  | Some _ -&gt;
      Storage.Contract.Global_counter.get c
      &gt;&gt;=? fun counter -&gt; Storage.Contract.Counter.init c contract counter )
  &gt;&gt;=? fun c -&gt;
  Storage.Contract.Balance.init c contract balance
  &gt;&gt;=? fun c -&gt;
  ( match manager with
  | Some manager -&gt;
      Storage.Contract.Manager.init c contract (Manager_repr.Hash manager)
  | None -&gt;
      return c )
  &gt;&gt;=? fun c -&gt;
  ( match delegate with
  | None -&gt;
      return c
  | Some delegate -&gt;
      Delegate_storage.init c contract delegate )
  &gt;&gt;=? fun c -&gt;
  match script with
  | Some ({Script_repr.code; storage}, big_map_diff) -&gt;
      Storage.Contract.Code.init c contract code
      &gt;&gt;=? fun (c, code_size) -&gt;
      Storage.Contract.Storage.init c contract storage
      &gt;&gt;=? fun (c, storage_size) -&gt;
      update_script_big_map c big_map_diff
      &gt;&gt;=? fun (c, big_map_size) -&gt;
      let total_size =
        Z.add (Z.add (Z.of_int code_size) (Z.of_int storage_size)) big_map_size
      in
      <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.Z.(total_size &gt;= Z.zero))</abbr> ;
      let prepaid_bootstrap_storage =
        if prepaid_bootstrap_storage then total_size else Z.zero
      in
      Storage.Contract.Paid_storage_space.init
        c
        contract
        prepaid_bootstrap_storage
      &gt;&gt;=? fun c -&gt;
      Storage.Contract.Used_storage_space.init c contract total_size
  | None -&gt;
      return c

let originate_raw c ?prepaid_bootstrap_storage contract ~balance ~script
    ~delegate =
  create_base
    c
    ?prepaid_bootstrap_storage
    contract
    ~balance
    ~manager:None
    ~delegate
    ~script
    ()

let create_implicit c manager ~balance =
  create_base
    c
    (Contract_repr.implicit_contract manager)
    ~balance
    ~manager:(Some manager)
    ?script:None
    ~delegate:None
    ()

let delete c contract =
  match Contract_repr.is_implicit contract with
  | None -&gt;
      (* For non implicit contract Big_map should be cleared *)
      failwith &quot;Non implicit contracts cannot be removed&quot;
  | Some _ -&gt;
      Delegate_storage.remove c contract
      &gt;&gt;=? fun c -&gt;
      Storage.Contract.Balance.delete c contract
      &gt;&gt;=? fun c -&gt;
      Storage.Contract.Manager.delete c contract
      &gt;&gt;=? fun c -&gt;
      Storage.Contract.Counter.delete c contract
      &gt;&gt;=? fun c -&gt;
      Storage.Contract.Code.remove c contract
      &gt;&gt;=? fun (c, _, _) -&gt;
      Storage.Contract.Storage.remove c contract
      &gt;&gt;=? fun (c, _, _) -&gt;
      Storage.Contract.Paid_storage_space.remove c contract
      &gt;&gt;= fun c -&gt;
      Storage.Contract.Used_storage_space.remove c contract
      &gt;&gt;= fun c -&gt; return c

let allocated c contract =
  Storage.Contract.Balance.get_option c contract
  &gt;&gt;=? function None -&gt; return_false | Some _ -&gt; return_true

let exists c contract =
  match Contract_repr.is_implicit contract with
  | Some _ -&gt;
      return_true
  | None -&gt;
      allocated c contract

let must_exist c contract =
  exists c contract
  &gt;&gt;=? function
  | true -&gt; return_unit | false -&gt; fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Non_existing_contract contract)</abbr>

let must_be_allocated c contract =
  allocated c contract
  &gt;&gt;=? function
  | true -&gt;
      return_unit
  | false -&gt; (
    match Contract_repr.is_implicit contract with
    | Some pkh -&gt;
        fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Empty_implicit_contract pkh)</abbr>
    | None -&gt;
        fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Non_existing_contract contract)</abbr> )

let list c = Storage.Contract.list c

let fresh_contract_from_current_nonce c =
  Lwt.return (Raw_context.increment_origination_nonce c)
  &gt;&gt;=? fun (c, nonce) -&gt; return (c, Contract_repr.originated_contract nonce)

let originated_from_current_nonce ~since:ctxt_since ~until:ctxt_until =
  Lwt.return (Raw_context.origination_nonce ctxt_since)
  &gt;&gt;=? fun since -&gt;
  Lwt.return (Raw_context.origination_nonce ctxt_until)
  &gt;&gt;=? fun until -&gt;
  filter_map_s
    (fun contract -&gt;
      exists ctxt_until contract
      &gt;&gt;=? function true -&gt; return_some contract | false -&gt; return_none)
    (Contract_repr.originated_contracts ~since ~until)

let check_counter_increment c manager counter =
  let contract = Contract_repr.implicit_contract manager in
  Storage.Contract.Counter.get c contract
  &gt;&gt;=? fun contract_counter -&gt;
  let expected = Z.succ contract_counter in
  if Compare.Z.(expected = counter) then return_unit
  else if Compare.Z.(expected &gt; counter) then
    fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Counter_in_the_past (contract, expected, counter))</abbr>
  else fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Counter_in_the_future (contract, expected, counter))</abbr>

let increment_counter c manager =
  let contract = Contract_repr.implicit_contract manager in
  Storage.Contract.Global_counter.get c
  &gt;&gt;=? fun global_counter -&gt;
  Storage.Contract.Global_counter.set c (Z.succ global_counter)
  &gt;&gt;=? fun c -&gt;
  Storage.Contract.Counter.get c contract
  &gt;&gt;=? fun contract_counter -&gt;
  Storage.Contract.Counter.set c contract (Z.succ contract_counter)

let get_script_code c contract = Storage.Contract.Code.get_option c contract

let get_script c contract =
  Storage.Contract.Code.get_option c contract
  &gt;&gt;=? fun (c, code) -&gt;
  Storage.Contract.Storage.get_option c contract
  &gt;&gt;=? fun (c, storage) -&gt;
  match (code, storage) with
  | (None, None) -&gt;
      return (c, None)
  | (Some code, Some storage) -&gt;
      return (c, Some {Script_repr.code; storage})
  | (None, Some _) | (Some _, None) -&gt;
      failwith &quot;get_script&quot;

let get_storage ctxt contract =
  Storage.Contract.Storage.get_option ctxt contract
  &gt;&gt;=? function
  | (ctxt, None) -&gt;
      return (ctxt, None)
  | (ctxt, Some storage) -&gt;
      Lwt.return (Script_repr.force_decode storage)
      &gt;&gt;=? fun (storage, cost) -&gt;
      Lwt.return (Raw_context.consume_gas ctxt cost)
      &gt;&gt;=? fun ctxt -&gt; return (ctxt, Some storage)

let get_counter c manager =
  let contract = Contract_repr.implicit_contract manager in
  Storage.Contract.Counter.get_option c contract
  &gt;&gt;=? function
  | None -&gt; (
    match Contract_repr.is_implicit contract with
    | Some _ -&gt;
        Storage.Contract.Global_counter.get c
    | None -&gt;
        failwith &quot;get_counter&quot; )
  | Some v -&gt;
      return v

let get_manager_key c manager =
  let contract = Contract_repr.implicit_contract manager in
  Storage.Contract.Manager.get_option c contract
  &gt;&gt;=? function
  | None -&gt;
      failwith &quot;get_manager_key&quot;
  | Some (Manager_repr.Hash _) -&gt;
      fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Unrevealed_manager_key contract)</abbr>
  | Some (Manager_repr.Public_key v) -&gt;
      return v

let is_manager_key_revealed c manager =
  let contract = Contract_repr.implicit_contract manager in
  Storage.Contract.Manager.get_option c contract
  &gt;&gt;=? function
  | None -&gt;
      return_false
  | Some (Manager_repr.Hash _) -&gt;
      return_false
  | Some (Manager_repr.Public_key _) -&gt;
      return_true

let reveal_manager_key c manager public_key =
  let contract = Contract_repr.implicit_contract manager in
  Storage.Contract.Manager.get c contract
  &gt;&gt;=? function
  | Public_key _ -&gt;
      fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Previously_revealed_key contract)</abbr>
  | Hash v -&gt;
      let actual_hash = Signature.Public_key.hash public_key in
      if Signature.Public_key_hash.equal actual_hash v then
        let v = Manager_repr.Public_key public_key in
        Storage.Contract.Manager.set c contract v &gt;&gt;=? fun c -&gt; return c
      else fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Inconsistent_hash (public_key, v, actual_hash))</abbr>

let get_balance c contract =
  Storage.Contract.Balance.get_option c contract
  &gt;&gt;=? function
  | None -&gt; (
    match Contract_repr.is_implicit contract with
    | Some _ -&gt;
        return Tez_repr.zero
    | None -&gt;
        failwith &quot;get_balance&quot; )
  | Some v -&gt;
      return v

let update_script_storage c contract storage big_map_diff =
  let storage = Script_repr.lazy_expr storage in
  update_script_big_map c big_map_diff
  &gt;&gt;=? fun (c, big_map_size_diff) -&gt;
  Storage.Contract.Storage.set c contract storage
  &gt;&gt;=? fun (c, size_diff) -&gt;
  Storage.Contract.Used_storage_space.get c contract
  &gt;&gt;=? fun previous_size -&gt;
  let new_size =
    Z.add previous_size (Z.add big_map_size_diff (Z.of_int size_diff))
  in
  Storage.Contract.Used_storage_space.set c contract new_size

let spend c contract amount =
  Storage.Contract.Balance.get c contract
  &gt;&gt;=? fun balance -&gt;
  match Tez_repr.(balance -? amount) with
  | Error _ -&gt;
      fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Balance_too_low (contract, balance, amount))</abbr>
  | Ok new_balance -&gt; (
      Storage.Contract.Balance.set c contract new_balance
      &gt;&gt;=? fun c -&gt;
      Roll_storage.Contract.remove_amount c contract amount
      &gt;&gt;=? fun c -&gt;
      if Tez_repr.(new_balance &gt; Tez_repr.zero) then return c
      else
        match Contract_repr.is_implicit contract with
        | None -&gt;
            return c (* Never delete originated contracts *)
        | Some pkh -&gt; (
            Delegate_storage.get c contract
            &gt;&gt;=? function
            | Some pkh' -&gt;
                (* Don't delete &quot;delegate&quot; contract *)
                <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Signature.Public_key_hash.equal pkh pkh')</abbr> ;
                return c
            | None -&gt;
                (* Delete empty implicit contract *)
                delete c contract ) )

let credit c contract amount =
  ( if Tez_repr.(amount &lt;&gt; Tez_repr.zero) then return c
  else
    Storage.Contract.Code.mem c contract
    &gt;&gt;=? fun (c, target_has_code) -&gt;
    fail_unless target_has_code <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Empty_transaction contract)</abbr>
    &gt;&gt;=? fun () -&gt; return c )
  &gt;&gt;=? fun c -&gt;
  Storage.Contract.Balance.get_option c contract
  &gt;&gt;=? function
  | None -&gt; (
    match Contract_repr.is_implicit contract with
    | None -&gt;
        fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Non_existing_contract contract)</abbr>
    | Some manager -&gt;
        create_implicit c manager ~balance:amount )
  | Some balance -&gt;
      Lwt.return Tez_repr.(amount +? balance)
      &gt;&gt;=? fun balance -&gt;
      Storage.Contract.Balance.set c contract balance
      &gt;&gt;=? fun c -&gt; Roll_storage.Contract.add_amount c contract amount

let init c = Storage.Contract.Global_counter.init c Z.zero

let used_storage_space c contract =
  Storage.Contract.Used_storage_space.get_option c contract
  &gt;&gt;=? function None -&gt; return Z.zero | Some fees -&gt; return fees

let paid_storage_space c contract =
  Storage.Contract.Paid_storage_space.get_option c contract
  &gt;&gt;=? function None -&gt; return Z.zero | Some paid_space -&gt; return paid_space

let set_paid_storage_space_and_return_fees_to_pay c contract new_storage_space
    =
  Storage.Contract.Paid_storage_space.get c contract
  &gt;&gt;=? fun already_paid_space -&gt;
  if Compare.Z.(already_paid_space &gt;= new_storage_space) then return (Z.zero, c)
  else
    let to_pay = Z.sub new_storage_space already_paid_space in
    Storage.Contract.Paid_storage_space.set c contract new_storage_space
    &gt;&gt;=? fun c -&gt; return (to_pay, c)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#contract_storage.ml"><code>Contract_storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Contract_repr.
Require Tezos.Delegate_storage.
Require Tezos.Gas_limit_repr.
Require Tezos.Manager_repr.
Require Tezos.Michelson_v1_primitives.
Require Tezos.Raw_context.
Require Tezos.Roll_storage.
Require Tezos.Script_expr_hash.
Require Tezos.Script_repr.
Require Tezos.Storage_mli. Module Storage := Storage_mli.
Require Tezos.Storage_sigs.
Require Tezos.Tez_repr.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition failwith {A : Set} (msg : string) : Lwt.t (Error_monad.tzresult A) :=
  Error_monad.fail extensible_type_value.

Module ConstructorRecords_big_map_diff_item.
  Module big_map_diff_item.
    Module Update.
      Record record {big_map diff_key diff_key_hash diff_value : Set} : Set := Build {
        big_map : big_map;
        diff_key : diff_key;
        diff_key_hash : diff_key_hash;
        diff_value : diff_value }.
      Arguments record : clear implicits.
      Definition with_big_map
        {t_big_map t_diff_key t_diff_key_hash t_diff_value} big_map
        (r : record t_big_map t_diff_key t_diff_key_hash t_diff_value) :=
        Build t_big_map t_diff_key t_diff_key_hash t_diff_value big_map
          r.(diff_key) r.(diff_key_hash) r.(diff_value).
      Definition with_diff_key
        {t_big_map t_diff_key t_diff_key_hash t_diff_value} diff_key
        (r : record t_big_map t_diff_key t_diff_key_hash t_diff_value) :=
        Build t_big_map t_diff_key t_diff_key_hash t_diff_value r.(big_map)
          diff_key r.(diff_key_hash) r.(diff_value).
      Definition with_diff_key_hash
        {t_big_map t_diff_key t_diff_key_hash t_diff_value} diff_key_hash
        (r : record t_big_map t_diff_key t_diff_key_hash t_diff_value) :=
        Build t_big_map t_diff_key t_diff_key_hash t_diff_value r.(big_map)
          r.(diff_key) diff_key_hash r.(diff_value).
      Definition with_diff_value
        {t_big_map t_diff_key t_diff_key_hash t_diff_value} diff_value
        (r : record t_big_map t_diff_key t_diff_key_hash t_diff_value) :=
        Build t_big_map t_diff_key t_diff_key_hash t_diff_value r.(big_map)
          r.(diff_key) r.(diff_key_hash) diff_value.
    End Update.
    Definition Update_skeleton := Update.record.
    
    Module Alloc.
      Record record {big_map key_type value_type : Set} : Set := Build {
        big_map : big_map;
        key_type : key_type;
        value_type : value_type }.
      Arguments record : clear implicits.
      Definition with_big_map {t_big_map t_key_type t_value_type} big_map
        (r : record t_big_map t_key_type t_value_type) :=
        Build t_big_map t_key_type t_value_type big_map r.(key_type)
          r.(value_type).
      Definition with_key_type {t_big_map t_key_type t_value_type} key_type
        (r : record t_big_map t_key_type t_value_type) :=
        Build t_big_map t_key_type t_value_type r.(big_map) key_type
          r.(value_type).
      Definition with_value_type {t_big_map t_key_type t_value_type} value_type
        (r : record t_big_map t_key_type t_value_type) :=
        Build t_big_map t_key_type t_value_type r.(big_map) r.(key_type)
          value_type.
    End Alloc.
    Definition Alloc_skeleton := Alloc.record.
  End big_map_diff_item.
End ConstructorRecords_big_map_diff_item.
Import ConstructorRecords_big_map_diff_item.

Reserved Notation &quot;'big_map_diff_item.Update&quot;.
Reserved Notation &quot;'big_map_diff_item.Alloc&quot;.

Inductive big_map_diff_item : Set :=
| Update : 'big_map_diff_item.Update -&gt; big_map_diff_item
| Clear : Z.t -&gt; big_map_diff_item
| Copy : Z.t -&gt; Z.t -&gt; big_map_diff_item
| Alloc : 'big_map_diff_item.Alloc -&gt; big_map_diff_item

where &quot;'big_map_diff_item.Update&quot; :=
  (big_map_diff_item.Update_skeleton Z.t Script_repr.expr Script_expr_hash.t
    (option Script_repr.expr))
and &quot;'big_map_diff_item.Alloc&quot; :=
  (big_map_diff_item.Alloc_skeleton Z.t Script_repr.expr Script_repr.expr).

Module big_map_diff_item.
  Include ConstructorRecords_big_map_diff_item.big_map_diff_item.
  Definition Update := 'big_map_diff_item.Update.
  Definition Alloc := 'big_map_diff_item.Alloc.
End big_map_diff_item.

Definition big_map_diff : Set := list big_map_diff_item.

Definition big_map_diff_item_encoding
  : Data_encoding.encoding big_map_diff_item :=
  Data_encoding.union None
    [
      Data_encoding.__case_value &quot;update&quot; None (Data_encoding.Tag 0)
        (Data_encoding.obj5
          (Data_encoding.req None None &quot;action&quot;
            (Data_encoding.constant &quot;update&quot;))
          (Data_encoding.req None None &quot;big_map&quot; Data_encoding.z)
          (Data_encoding.req None None &quot;key_hash&quot; Script_expr_hash.encoding)
          (Data_encoding.req None None &quot;key&quot; Script_repr.expr_encoding)
          (Data_encoding.opt None None &quot;value&quot; Script_repr.expr_encoding))
        (fun function_parameter =&gt;
          match function_parameter with
          |
            Update {|
              big_map_diff_item.Update.big_map := big_map;
                big_map_diff_item.Update.diff_key := diff_key;
                big_map_diff_item.Update.diff_key_hash :=
                  diff_key_hash;
                big_map_diff_item.Update.diff_value := diff_value
                |} =&gt;
            Some (tt, big_map, diff_key_hash, diff_key, diff_value)
          | _ =&gt; None
          end)
        (fun function_parameter =&gt;
          let '(_, big_map, diff_key_hash, diff_key, diff_value) :=
            function_parameter in
          Update
            {| big_map_diff_item.Update.big_map := big_map;
              big_map_diff_item.Update.diff_key := diff_key;
              big_map_diff_item.Update.diff_key_hash := diff_key_hash;
              big_map_diff_item.Update.diff_value := diff_value |});
      Data_encoding.__case_value &quot;remove&quot; None (Data_encoding.Tag 1)
        (Data_encoding.obj2
          (Data_encoding.req None None &quot;action&quot;
            (Data_encoding.constant &quot;remove&quot;))
          (Data_encoding.req None None &quot;big_map&quot; Data_encoding.z))
        (fun function_parameter =&gt;
          match function_parameter with
          | Clear big_map =&gt; Some (tt, big_map)
          | _ =&gt; None
          end)
        (fun function_parameter =&gt;
          let '(_, big_map) := function_parameter in
          Clear big_map);
      Data_encoding.__case_value &quot;copy&quot; None (Data_encoding.Tag 2)
        (Data_encoding.obj3
          (Data_encoding.req None None &quot;action&quot;
            (Data_encoding.constant &quot;copy&quot;))
          (Data_encoding.req None None &quot;source_big_map&quot; Data_encoding.z)
          (Data_encoding.req None None &quot;destination_big_map&quot; Data_encoding.z))
        (fun function_parameter =&gt;
          match function_parameter with
          | Copy src dst =&gt; Some (tt, src, dst)
          | _ =&gt; None
          end)
        (fun function_parameter =&gt;
          let '(_, src, dst) := function_parameter in
          Copy src dst);
      Data_encoding.__case_value &quot;alloc&quot; None (Data_encoding.Tag 3)
        (Data_encoding.obj4
          (Data_encoding.req None None &quot;action&quot;
            (Data_encoding.constant &quot;alloc&quot;))
          (Data_encoding.req None None &quot;big_map&quot; Data_encoding.z)
          (Data_encoding.req None None &quot;key_type&quot; Script_repr.expr_encoding)
          (Data_encoding.req None None &quot;value_type&quot;
            Script_repr.expr_encoding))
        (fun function_parameter =&gt;
          match function_parameter with
          |
            Alloc {|
              big_map_diff_item.Alloc.big_map := big_map;
                big_map_diff_item.Alloc.key_type := key_type;
                big_map_diff_item.Alloc.value_type := value_type
                |} =&gt; Some (tt, big_map, key_type, value_type)
          | _ =&gt; None
          end)
        (fun function_parameter =&gt;
          let '(_, big_map, key_type, value_type) := function_parameter in
          Alloc
            {| big_map_diff_item.Alloc.big_map := big_map;
              big_map_diff_item.Alloc.key_type := key_type;
              big_map_diff_item.Alloc.value_type := value_type |})
    ].

Definition big_map_diff_encoding
  : Data_encoding.encoding (list big_map_diff_item) :=
  (let arg := Data_encoding.def &quot;contract.big_map_diff&quot; in
  fun eta =&gt; arg None None eta)
    (Data_encoding.__list_value None big_map_diff_item_encoding).

Definition big_map_key_cost : int := 65.

Definition big_map_cost : int := 33.

Definition update_script_big_map
  (c :
    (|Storage.Big_map.Total_bytes|).(Storage_sigs.Indexed_data_storage.context))
  (function_parameter : option (list big_map_diff_item))
  : Lwt.t
    (Error_monad.tzresult
      ((|Storage.Big_map.Total_bytes|).(Storage_sigs.Indexed_data_storage.context)
        * Z.t)) :=
  match function_parameter with
  | None =&gt; Error_monad.__return (c, Z.zero)
  | Some diff =&gt;
    Error_monad.fold_left_s
      (fun function_parameter =&gt;
        let '(c, total) := function_parameter in
        fun function_parameter =&gt;
          match function_parameter with
          | Clear id =&gt;
            let=? size :=
              (|Storage.Big_map.Total_bytes|).(Storage_sigs.Indexed_data_storage.get)
                c id in
            let= c := Storage.Big_map.remove_rec c id in
            if (|Compare.Z|).(Compare.S.op_lt) id Z.zero then
              Error_monad.__return (c, total)
            else
              Error_monad.__return
                (c, (Z.sub (Z.sub total size) (Z.of_int big_map_cost)))
          | Copy from to_ =&gt;
            let=? c := Storage.Big_map.copy c from to_ in
            if (|Compare.Z|).(Compare.S.op_lt) to_ Z.zero then
              Error_monad.__return (c, total)
            else
              let=? size :=
                (|Storage.Big_map.Total_bytes|).(Storage_sigs.Indexed_data_storage.get)
                  c from in
              Error_monad.__return
                (c, (Z.add (Z.add total size) (Z.of_int big_map_cost)))
          |
            Alloc {|
              big_map_diff_item.Alloc.big_map := big_map;
                big_map_diff_item.Alloc.key_type := key_type;
                big_map_diff_item.Alloc.value_type := value_type
                |} =&gt;
            let=? c :=
              (|Storage.Big_map.Total_bytes|).(Storage_sigs.Indexed_data_storage.init)
                c big_map Z.zero in
            let key_type :=
              Micheline.strip_locations
                (Script_repr.strip_annotations (Micheline.root key_type)) in
            let value_type :=
              Micheline.strip_locations
                (Script_repr.strip_annotations (Micheline.root value_type)) in
            let=? c :=
              (|Storage.Big_map.Key_type|).(Storage_sigs.Indexed_data_storage.init)
                c big_map key_type in
            let=? c :=
              (|Storage.Big_map.Value_type|).(Storage_sigs.Indexed_data_storage.init)
                c big_map value_type in
            if (|Compare.Z|).(Compare.S.op_lt) big_map Z.zero then
              Error_monad.__return (c, total)
            else
              Error_monad.__return (c, (Z.add total (Z.of_int big_map_cost)))
          |
            Update {|
              big_map_diff_item.Update.big_map := big_map;
                big_map_diff_item.Update.diff_key_hash := diff_key_hash;
                big_map_diff_item.Update.diff_value := None
                |} =&gt;
            let=? '(c, freed, existed) :=
              (|Storage.Big_map.Contents|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.remove)
                (c, big_map) diff_key_hash in
            let freed :=
              if existed then
                Pervasives.op_plus freed big_map_key_cost
              else
                freed in
            let=? size :=
              (|Storage.Big_map.Total_bytes|).(Storage_sigs.Indexed_data_storage.get)
                c big_map in
            let=? c :=
              (|Storage.Big_map.Total_bytes|).(Storage_sigs.Indexed_data_storage.set)
                c big_map (Z.sub size (Z.of_int freed)) in
            if (|Compare.Z|).(Compare.S.op_lt) big_map Z.zero then
              Error_monad.__return (c, total)
            else
              Error_monad.__return (c, (Z.sub total (Z.of_int freed)))
          |
            Update {|
              big_map_diff_item.Update.big_map := big_map;
                big_map_diff_item.Update.diff_key_hash := diff_key_hash;
                big_map_diff_item.Update.diff_value := Some v
                |} =&gt;
            let=? '(c, size_diff, existed) :=
              (|Storage.Big_map.Contents|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.init_set)
                (c, big_map) diff_key_hash v in
            let size_diff :=
              if existed then
                size_diff
              else
                Pervasives.op_plus size_diff big_map_key_cost in
            let=? size :=
              (|Storage.Big_map.Total_bytes|).(Storage_sigs.Indexed_data_storage.get)
                c big_map in
            let=? c :=
              (|Storage.Big_map.Total_bytes|).(Storage_sigs.Indexed_data_storage.set)
                c big_map (Z.add size (Z.of_int size_diff)) in
            if (|Compare.Z|).(Compare.S.op_lt) big_map Z.zero then
              Error_monad.__return (c, total)
            else
              Error_monad.__return (c, (Z.add total (Z.of_int size_diff)))
          end) (c, Z.zero) diff
  end.

Definition create_base (c : Raw_context.t) (op_staroptstar : option bool)
  : Contract_repr.contract -&gt;
  (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.value) -&gt;
  option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  option (Script_repr.t * option (list big_map_diff_item)) -&gt; unit -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let prepaid_bootstrap_storage :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; false
    end in
  fun contract =&gt;
    fun balance =&gt;
      fun manager =&gt;
        fun delegate =&gt;
          fun script =&gt;
            fun function_parameter =&gt;
              let '_ := function_parameter in
              let=? c :=
                match Contract_repr.is_implicit contract with
                | None =&gt; Error_monad.__return c
                | Some _ =&gt;
                  let=? counter := Storage.Contract.Global_counter.get c in
                  (|Storage.Contract.Counter|).(Storage_sigs.Indexed_data_storage.init)
                    c contract counter
                end in
              let=? c :=
                (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.init)
                  c contract balance in
              let=? c :=
                match manager with
                | Some manager =&gt;
                  (|Storage.Contract.Manager|).(Storage_sigs.Indexed_data_storage.init)
                    c contract (Manager_repr.Hash manager)
                | None =&gt; Error_monad.__return c
                end in
              let=? c :=
                match delegate with
                | None =&gt; Error_monad.__return c
                | Some delegate =&gt; Delegate_storage.init c contract delegate
                end in
              match script with
              |
                Some
                  ({|
                    Script_repr.t.code := code;
                      Script_repr.t.storage := storage
                      |}, big_map_diff) =&gt;
                let=? '(c, code_size) :=
                  (|Storage.Contract.Code|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.init)
                    c contract code in
                let=? '(c, storage_size) :=
                  (|Storage.Contract.Storage|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.init)
                    c contract storage in
                let=? '(c, big_map_size) := update_script_big_map c big_map_diff
                  in
                let total_size :=
                  Z.add (Z.add (Z.of_int code_size) (Z.of_int storage_size))
                    big_map_size in
                (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
                (* ‚ùå instruction_sequence &quot;;&quot; *)
                let prepaid_bootstrap_storage :=
                  if prepaid_bootstrap_storage then
                    total_size
                  else
                    Z.zero in
                let=? c :=
                  (|Storage.Contract.Paid_storage_space|).(Storage_sigs.Indexed_data_storage.init)
                    c contract prepaid_bootstrap_storage in
                (|Storage.Contract.Used_storage_space|).(Storage_sigs.Indexed_data_storage.init)
                  c contract total_size
              | None =&gt; Error_monad.__return c
              end.

Definition originate_raw
  (c : Raw_context.t) (prepaid_bootstrap_storage : option bool)
  (contract : Contract_repr.contract)
  (balance :
    (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.value))
  (script : Script_repr.t * option (list big_map_diff_item))
  (delegate : option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  create_base c prepaid_bootstrap_storage contract balance None delegate
    (Some script) tt.

Definition create_implicit
  (c : Raw_context.t)
  (manager : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  (balance :
    (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.value))
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  create_base c None (Contract_repr.implicit_contract manager) balance
    (Some manager) None None tt.

Definition delete (c : Raw_context.t) (contract : Contract_repr.contract)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  match Contract_repr.is_implicit contract with
  | None =&gt; failwith &quot;Non implicit contracts cannot be removed&quot;
  | Some _ =&gt;
    let=? c := Delegate_storage.remove c contract in
    let=? c :=
      (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.delete) c
        contract in
    let=? c :=
      (|Storage.Contract.Manager|).(Storage_sigs.Indexed_data_storage.delete) c
        contract in
    let=? c :=
      (|Storage.Contract.Counter|).(Storage_sigs.Indexed_data_storage.delete) c
        contract in
    let=? '(c, _, _) :=
      (|Storage.Contract.Code|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.remove)
        c contract in
    let=? '(c, _, _) :=
      (|Storage.Contract.Storage|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.remove)
        c contract in
    let= c :=
      (|Storage.Contract.Paid_storage_space|).(Storage_sigs.Indexed_data_storage.remove)
        c contract in
    let= c :=
      (|Storage.Contract.Used_storage_space|).(Storage_sigs.Indexed_data_storage.remove)
        c contract in
    Error_monad.__return c
  end.

Definition allocated
  (c : (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.context))
  (contract :
    (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t (Error_monad.tzresult bool) :=
  let=? function_parameter :=
    (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.get_option)
      c contract in
  match function_parameter with
  | None =&gt; Error_monad.return_false
  | Some _ =&gt; Error_monad.return_true
  end.

Definition __exists
  (c : (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.context))
  (contract : Contract_repr.contract) : Lwt.t (Error_monad.tzresult bool) :=
  match Contract_repr.is_implicit contract with
  | Some _ =&gt; Error_monad.return_true
  | None =&gt; allocated c contract
  end.

Definition must_exist
  (c : (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.context))
  (contract : Contract_repr.contract) : Lwt.t (Error_monad.tzresult unit) :=
  let=? function_parameter := __exists c contract in
  match function_parameter with
  | true =&gt; Error_monad.return_unit
  | false =&gt; Error_monad.fail extensible_type_value
  end.

Definition must_be_allocated
  (c : (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.context))
  (contract :
    (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t (Error_monad.tzresult unit) :=
  let=? function_parameter := allocated c contract in
  match function_parameter with
  | true =&gt; Error_monad.return_unit
  | false =&gt;
    match Contract_repr.is_implicit contract with
    | Some pkh =&gt; Error_monad.fail extensible_type_value
    | None =&gt; Error_monad.fail extensible_type_value
    end
  end.

Definition __list_value (c : Raw_context.t) : Lwt.t (list Contract_repr.t) :=
  Storage.Contract.__list_value c.

Definition fresh_contract_from_current_nonce (c : Raw_context.t)
  : Lwt.t (Error_monad.tzresult (Raw_context.t * Contract_repr.contract)) :=
  let=? '(c, __nonce_value) :=
    Lwt.__return (Raw_context.increment_origination_nonce c) in
  Error_monad.__return (c, (Contract_repr.originated_contract __nonce_value)).

Definition originated_from_current_nonce
  (ctxt_since : Raw_context.t) (ctxt_until : Raw_context.t)
  : Lwt.t (Error_monad.tzresult (list Contract_repr.contract)) :=
  let=? since := Lwt.__return (Raw_context.origination_nonce ctxt_since) in
  let=? until := Lwt.__return (Raw_context.origination_nonce ctxt_until) in
  Error_monad.filter_map_s
    (fun contract =&gt;
      let=? function_parameter := __exists ctxt_until contract in
      match function_parameter with
      | true =&gt; Error_monad.return_some contract
      | false =&gt; Error_monad.return_none
      end) (Contract_repr.originated_contracts since until).

Definition check_counter_increment
  (c : (|Storage.Contract.Counter|).(Storage_sigs.Indexed_data_storage.context))
  (manager : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  (counter : (|Compare.Z|).(Compare.S.t)) : Lwt.t (Error_monad.tzresult unit) :=
  let contract := Contract_repr.implicit_contract manager in
  let=? contract_counter :=
    (|Storage.Contract.Counter|).(Storage_sigs.Indexed_data_storage.get) c
      contract in
  let expected := Z.succ contract_counter in
  if (|Compare.Z|).(Compare.S.op_eq) expected counter then
    Error_monad.return_unit
  else
    if (|Compare.Z|).(Compare.S.op_gt) expected counter then
      Error_monad.fail extensible_type_value
    else
      Error_monad.fail extensible_type_value.

Definition increment_counter
  (c : Raw_context.t)
  (manager : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let contract := Contract_repr.implicit_contract manager in
  let=? global_counter := Storage.Contract.Global_counter.get c in
  let=? c := Storage.Contract.Global_counter.set c (Z.succ global_counter) in
  let=? contract_counter :=
    (|Storage.Contract.Counter|).(Storage_sigs.Indexed_data_storage.get) c
      contract in
  (|Storage.Contract.Counter|).(Storage_sigs.Indexed_data_storage.set) c
    contract (Z.succ contract_counter).

Definition get_script_code
  (c :
    (|Storage.Contract.Code|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context))
  (contract :
    (|Storage.Contract.Code|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
  : Lwt.t
    (Error_monad.tzresult
      (Raw_context.t *
        option
          (|Storage.Contract.Code|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value))) :=
  (|Storage.Contract.Code|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get_option)
    c contract.

Definition get_script
  (c :
    (|Storage.Contract.Code|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context))
  (contract :
    (|Storage.Contract.Code|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
  : Lwt.t (Error_monad.tzresult (Raw_context.t * option Script_repr.t)) :=
  let=? '(c, code) :=
    (|Storage.Contract.Code|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get_option)
      c contract in
  let=? '(c, storage) :=
    (|Storage.Contract.Storage|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get_option)
      c contract in
  match (code, storage) with
  | (None, None) =&gt; Error_monad.__return (c, None)
  | (Some code, Some storage) =&gt;
    Error_monad.__return
      (c,
        (Some {| Script_repr.t.code := code; Script_repr.t.storage := storage |}))
  | ((None, Some _) | (Some _, None)) =&gt; failwith &quot;get_script&quot;
  end.

Definition get_storage
  (ctxt :
    (|Storage.Contract.Storage|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context))
  (contract :
    (|Storage.Contract.Storage|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
  : Lwt.t (Error_monad.tzresult (Raw_context.t * option Script_repr.expr)) :=
  let=? function_parameter :=
    (|Storage.Contract.Storage|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get_option)
      ctxt contract in
  match function_parameter with
  | (ctxt, None) =&gt; Error_monad.__return (ctxt, None)
  | (ctxt, Some storage) =&gt;
    let=? '(storage, cost) := Lwt.__return (Script_repr.force_decode storage) in
    let=? ctxt := Lwt.__return (Raw_context.consume_gas ctxt cost) in
    Error_monad.__return (ctxt, (Some storage))
  end.

Definition get_counter
  (c : (|Storage.Contract.Counter|).(Storage_sigs.Indexed_data_storage.context))
  (manager : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.tzresult Z.t) :=
  let contract := Contract_repr.implicit_contract manager in
  let=? function_parameter :=
    (|Storage.Contract.Counter|).(Storage_sigs.Indexed_data_storage.get_option)
      c contract in
  match function_parameter with
  | None =&gt;
    match Contract_repr.is_implicit contract with
    | Some _ =&gt; Storage.Contract.Global_counter.get c
    | None =&gt; failwith &quot;get_counter&quot;
    end
  | Some v =&gt; Error_monad.__return v
  end.

Definition get_manager_key
  (c : (|Storage.Contract.Manager|).(Storage_sigs.Indexed_data_storage.context))
  (manager : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.tzresult (|Signature.Public_key|).(S.SPublic_key.t)) :=
  let contract := Contract_repr.implicit_contract manager in
  let=? function_parameter :=
    (|Storage.Contract.Manager|).(Storage_sigs.Indexed_data_storage.get_option)
      c contract in
  match function_parameter with
  | None =&gt; failwith &quot;get_manager_key&quot;
  | Some (Manager_repr.Hash _) =&gt; Error_monad.fail extensible_type_value
  | Some (Manager_repr.Public_key v) =&gt; Error_monad.__return v
  end.

Definition is_manager_key_revealed
  (c : (|Storage.Contract.Manager|).(Storage_sigs.Indexed_data_storage.context))
  (manager : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.tzresult bool) :=
  let contract := Contract_repr.implicit_contract manager in
  let=? function_parameter :=
    (|Storage.Contract.Manager|).(Storage_sigs.Indexed_data_storage.get_option)
      c contract in
  match function_parameter with
  | None =&gt; Error_monad.return_false
  | Some (Manager_repr.Hash _) =&gt; Error_monad.return_false
  | Some (Manager_repr.Public_key _) =&gt; Error_monad.return_true
  end.

Definition reveal_manager_key
  (c : (|Storage.Contract.Manager|).(Storage_sigs.Indexed_data_storage.context))
  (manager : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  (public_key : (|Signature.Public_key|).(S.SPublic_key.t))
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let contract := Contract_repr.implicit_contract manager in
  let=? function_parameter :=
    (|Storage.Contract.Manager|).(Storage_sigs.Indexed_data_storage.get) c
      contract in
  match function_parameter with
  | Manager_repr.Public_key _ =&gt; Error_monad.fail extensible_type_value
  | Manager_repr.Hash v =&gt;
    let actual_hash :=
      (|Signature.Public_key|).(S.SPublic_key.__hash_value) public_key in
    if (|Signature.Public_key_hash|).(S.SPublic_key_hash.equal) actual_hash v
      then
      let v := Manager_repr.Public_key public_key in
      let=? c :=
        (|Storage.Contract.Manager|).(Storage_sigs.Indexed_data_storage.set) c
          contract v in
      Error_monad.__return c
    else
      Error_monad.fail extensible_type_value
  end.

Definition get_balance
  (c : (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.context))
  (contract :
    (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t (Error_monad.tzresult Tez_repr.t) :=
  let=? function_parameter :=
    (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.get_option)
      c contract in
  match function_parameter with
  | None =&gt;
    match Contract_repr.is_implicit contract with
    | Some _ =&gt; Error_monad.__return Tez_repr.zero
    | None =&gt; failwith &quot;get_balance&quot;
    end
  | Some v =&gt; Error_monad.__return v
  end.

Definition update_script_storage
  (c :
    (|Storage.Big_map.Total_bytes|).(Storage_sigs.Indexed_data_storage.context))
  (contract :
    (|Storage.Contract.Storage|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
  (storage : Script_repr.expr) (big_map_diff : option (list big_map_diff_item))
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let storage := Script_repr.__lazy_expr_value storage in
  let=? '(c, big_map_size_diff) := update_script_big_map c big_map_diff in
  let=? '(c, size_diff) :=
    (|Storage.Contract.Storage|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set)
      c contract storage in
  let=? previous_size :=
    (|Storage.Contract.Used_storage_space|).(Storage_sigs.Indexed_data_storage.get)
      c contract in
  let new_size :=
    Z.add previous_size (Z.add big_map_size_diff (Z.of_int size_diff)) in
  (|Storage.Contract.Used_storage_space|).(Storage_sigs.Indexed_data_storage.set)
    c contract new_size.

Definition spend
  (c : (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.context))
  (contract :
    (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.key))
  (amount : Tez_repr.t) : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let=? balance :=
    (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.get) c
      contract in
  match Tez_repr.op_minusquestion balance amount with
  | Pervasives.Error _ =&gt; Error_monad.fail extensible_type_value
  | Pervasives.Ok new_balance =&gt;
    let=? c :=
      (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.set) c
        contract new_balance in
    let=? c := Roll_storage.Contract.remove_amount c contract amount in
    if Tez_repr.op_gt new_balance Tez_repr.zero then
      Error_monad.__return c
    else
      match Contract_repr.is_implicit contract with
      | None =&gt; Error_monad.__return c
      | Some pkh =&gt;
        let=? function_parameter := Delegate_storage.get c contract in
        match function_parameter with
        | Some pkh' =&gt;
          (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
          (* ‚ùå instruction_sequence &quot;;&quot; *)
          Error_monad.__return c
        | None =&gt; delete c contract
        end
      end
  end.

Definition credit
  (c :
    (|Storage.Contract.Code|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context))
  (contract :
    (|Storage.Contract.Code|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
  (amount : Tez_repr.t) : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let=? c :=
    if Tez_repr.op_ltgt amount Tez_repr.zero then
      Error_monad.__return c
    else
      let=? '(c, target_has_code) :=
        (|Storage.Contract.Code|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.mem)
          c contract in
      let=? '_ := Error_monad.fail_unless target_has_code extensible_type_value
        in
      Error_monad.__return c in
  let=? function_parameter :=
    (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.get_option)
      c contract in
  match function_parameter with
  | None =&gt;
    match Contract_repr.is_implicit contract with
    | None =&gt; Error_monad.fail extensible_type_value
    | Some manager =&gt; create_implicit c manager amount
    end
  | Some balance =&gt;
    let=? balance := Lwt.__return (Tez_repr.op_plusquestion amount balance) in
    let=? c :=
      (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.set) c
        contract balance in
    Roll_storage.Contract.add_amount c contract amount
  end.

Definition init (c : Raw_context.t)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  Storage.Contract.Global_counter.init c Z.zero.

Definition used_storage_space
  (c :
    (|Storage.Contract.Used_storage_space|).(Storage_sigs.Indexed_data_storage.context))
  (contract :
    (|Storage.Contract.Used_storage_space|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t (Error_monad.tzresult Z.t) :=
  let=? function_parameter :=
    (|Storage.Contract.Used_storage_space|).(Storage_sigs.Indexed_data_storage.get_option)
      c contract in
  match function_parameter with
  | None =&gt; Error_monad.__return Z.zero
  | Some fees =&gt; Error_monad.__return fees
  end.

Definition paid_storage_space
  (c :
    (|Storage.Contract.Paid_storage_space|).(Storage_sigs.Indexed_data_storage.context))
  (contract :
    (|Storage.Contract.Paid_storage_space|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t (Error_monad.tzresult Z.t) :=
  let=? function_parameter :=
    (|Storage.Contract.Paid_storage_space|).(Storage_sigs.Indexed_data_storage.get_option)
      c contract in
  match function_parameter with
  | None =&gt; Error_monad.__return Z.zero
  | Some paid_space =&gt; Error_monad.__return paid_space
  end.

Definition set_paid_storage_space_and_return_fees_to_pay
  (c :
    (|Storage.Contract.Paid_storage_space|).(Storage_sigs.Indexed_data_storage.context))
  (contract :
    (|Storage.Contract.Paid_storage_space|).(Storage_sigs.Indexed_data_storage.key))
  (new_storage_space : (|Compare.Z|).(Compare.S.t))
  : Lwt.t
    (Error_monad.tzresult
      (Z.t *
        (|Storage.Contract.Paid_storage_space|).(Storage_sigs.Indexed_data_storage.context))) :=
  let=? already_paid_space :=
    (|Storage.Contract.Paid_storage_space|).(Storage_sigs.Indexed_data_storage.get)
      c contract in
  if (|Compare.Z|).(Compare.S.op_gteq) already_paid_space new_storage_space then
    Error_monad.__return (Z.zero, c)
  else
    let to_pay := Z.sub new_storage_space already_paid_space in
    let=? c :=
      (|Storage.Contract.Paid_storage_space|).(Storage_sigs.Indexed_data_storage.set)
        c contract new_storage_space in
    Error_monad.__return (to_pay, c).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="contract_storage.mli">
  <div style="margin: 20px;">
    <h3>Contract_storage_mli</h3>
    <ul>
      <li>OCaml size: 169 lines</li>
      <li>Coq size: 191 lines (+13% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#contract_storage.mli"><code>contract_storage.mli</code></a>&nbsp;<span class="label label-warning">1 warning</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

<abbr class="mark-warning" title="Extensible types are not handled.">type error +=
  | Balance_too_low of Contract_repr.contract * Tez_repr.t * Tez_repr.t
  | (* `Temporary *)
      Counter_in_the_past of Contract_repr.contract * Z.t * Z.t
  | (* `Branch *)
      Counter_in_the_future of Contract_repr.contract * Z.t * Z.t
  | (* `Temporary *)
      Unspendable_contract of Contract_repr.contract
  | (* `Permanent *)
      Non_existing_contract of Contract_repr.contract
  | (* `Temporary *)
      Empty_implicit_contract of Signature.Public_key_hash.t
  | (* `Temporary *)
      Empty_transaction of Contract_repr.t (* `Temporary *)
  | Inconsistent_hash of
      Signature.Public_key.t
      * Signature.Public_key_hash.t
      * Signature.Public_key_hash.t
  | (* `Permanent *)
      Inconsistent_public_key of
      Signature.Public_key.t * Signature.Public_key.t
  | (* `Permanent *)
      Failure of string (* `Permanent *)
  | Previously_revealed_key of Contract_repr.t (* `Permanent *)
  | Unrevealed_manager_key of Contract_repr.t</abbr>

(* `Permanent *)

val exists : Raw_context.t -&gt; Contract_repr.t -&gt; bool tzresult Lwt.t

val must_exist : Raw_context.t -&gt; Contract_repr.t -&gt; unit tzresult Lwt.t

val allocated : Raw_context.t -&gt; Contract_repr.t -&gt; bool tzresult Lwt.t

val must_be_allocated : Raw_context.t -&gt; Contract_repr.t -&gt; unit tzresult Lwt.t

val list : Raw_context.t -&gt; Contract_repr.t list Lwt.t

val check_counter_increment :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; Z.t -&gt; unit tzresult Lwt.t

val increment_counter :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; Raw_context.t tzresult Lwt.t

val get_manager_key :
  Raw_context.t -&gt;
  Signature.Public_key_hash.t -&gt;
  Signature.Public_key.t tzresult Lwt.t

val is_manager_key_revealed :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; bool tzresult Lwt.t

val reveal_manager_key :
  Raw_context.t -&gt;
  Signature.Public_key_hash.t -&gt;
  Signature.Public_key.t -&gt;
  Raw_context.t tzresult Lwt.t

val get_balance : Raw_context.t -&gt; Contract_repr.t -&gt; Tez_repr.t tzresult Lwt.t

val get_counter :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; Z.t tzresult Lwt.t

val get_script_code :
  Raw_context.t -&gt;
  Contract_repr.t -&gt;
  (Raw_context.t * Script_repr.lazy_expr option) tzresult Lwt.t

val get_script :
  Raw_context.t -&gt;
  Contract_repr.t -&gt;
  (Raw_context.t * Script_repr.t option) tzresult Lwt.t

val get_storage :
  Raw_context.t -&gt;
  Contract_repr.t -&gt;
  (Raw_context.t * Script_repr.expr option) tzresult Lwt.t

type big_map_diff_item =
  | Update of {
      big_map : Z.t;
      diff_key : Script_repr.expr;
      diff_key_hash : Script_expr_hash.t;
      diff_value : Script_repr.expr option;
    }
  | Clear of Z.t
  | Copy of Z.t * Z.t
  | Alloc of {
      big_map : Z.t;
      key_type : Script_repr.expr;
      value_type : Script_repr.expr;
    }

type big_map_diff = big_map_diff_item list

val big_map_diff_encoding : big_map_diff Data_encoding.t

val update_script_storage :
  Raw_context.t -&gt;
  Contract_repr.t -&gt;
  Script_repr.expr -&gt;
  big_map_diff option -&gt;
  Raw_context.t tzresult Lwt.t

val credit :
  Raw_context.t -&gt;
  Contract_repr.t -&gt;
  Tez_repr.t -&gt;
  Raw_context.t tzresult Lwt.t

val spend :
  Raw_context.t -&gt;
  Contract_repr.t -&gt;
  Tez_repr.t -&gt;
  Raw_context.t tzresult Lwt.t

val originate_raw :
  Raw_context.t -&gt;
  ?prepaid_bootstrap_storage:bool -&gt;
  Contract_repr.t -&gt;
  balance:Tez_repr.t -&gt;
  script:Script_repr.t * big_map_diff option -&gt;
  delegate:Signature.Public_key_hash.t option -&gt;
  Raw_context.t tzresult Lwt.t

val fresh_contract_from_current_nonce :
  Raw_context.t -&gt; (Raw_context.t * Contract_repr.t) tzresult Lwt.t

val originated_from_current_nonce :
  since:Raw_context.t -&gt;
  until:Raw_context.t -&gt;
  Contract_repr.t list tzresult Lwt.t

val init : Raw_context.t -&gt; Raw_context.t tzresult Lwt.t

val used_storage_space : Raw_context.t -&gt; Contract_repr.t -&gt; Z.t tzresult Lwt.t

val paid_storage_space : Raw_context.t -&gt; Contract_repr.t -&gt; Z.t tzresult Lwt.t

val set_paid_storage_space_and_return_fees_to_pay :
  Raw_context.t -&gt;
  Contract_repr.t -&gt;
  Z.t -&gt;
  (Z.t * Raw_context.t) tzresult Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#contract_storage.mli"><code>Contract_storage_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Contract_repr.
Require Tezos.Raw_context.
Require Tezos.Script_expr_hash.
Require Tezos.Script_repr.
Require Tezos.Tez_repr.

(* extensible_type_definition `error` *)

Parameter __exists :
  Raw_context.t -&gt; Contract_repr.t -&gt; Lwt.t (Error_monad.tzresult bool).

Parameter must_exist :
  Raw_context.t -&gt; Contract_repr.t -&gt; Lwt.t (Error_monad.tzresult unit).

Parameter allocated :
  Raw_context.t -&gt; Contract_repr.t -&gt; Lwt.t (Error_monad.tzresult bool).

Parameter must_be_allocated :
  Raw_context.t -&gt; Contract_repr.t -&gt; Lwt.t (Error_monad.tzresult unit).

Parameter __list_value : Raw_context.t -&gt; Lwt.t (list Contract_repr.t).

Parameter check_counter_increment :
  Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Z.t -&gt; Lwt.t (Error_monad.tzresult unit).

Parameter increment_counter :
  Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter get_manager_key :
  Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.tzresult (|Signature.Public_key|).(S.SPublic_key.t)).

Parameter is_manager_key_revealed :
  Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.tzresult bool).

Parameter reveal_manager_key :
  Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  (|Signature.Public_key|).(S.SPublic_key.t) -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter get_balance :
  Raw_context.t -&gt; Contract_repr.t -&gt; Lwt.t (Error_monad.tzresult Tez_repr.t).

Parameter get_counter :
  Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.tzresult Z.t).

Parameter get_script_code :
  Raw_context.t -&gt; Contract_repr.t -&gt;
  Lwt.t (Error_monad.tzresult (Raw_context.t * option Script_repr.lazy_expr)).

Parameter get_script :
  Raw_context.t -&gt; Contract_repr.t -&gt;
  Lwt.t (Error_monad.tzresult (Raw_context.t * option Script_repr.t)).

Parameter get_storage :
  Raw_context.t -&gt; Contract_repr.t -&gt;
  Lwt.t (Error_monad.tzresult (Raw_context.t * option Script_repr.expr)).

Module ConstructorRecords_big_map_diff_item.
  Module big_map_diff_item.
    Module Update.
      Record record {big_map diff_key diff_key_hash diff_value : Set} : Set := Build {
        big_map : big_map;
        diff_key : diff_key;
        diff_key_hash : diff_key_hash;
        diff_value : diff_value }.
      Arguments record : clear implicits.
      Definition with_big_map
        {t_big_map t_diff_key t_diff_key_hash t_diff_value} big_map
        (r : record t_big_map t_diff_key t_diff_key_hash t_diff_value) :=
        Build t_big_map t_diff_key t_diff_key_hash t_diff_value big_map
          r.(diff_key) r.(diff_key_hash) r.(diff_value).
      Definition with_diff_key
        {t_big_map t_diff_key t_diff_key_hash t_diff_value} diff_key
        (r : record t_big_map t_diff_key t_diff_key_hash t_diff_value) :=
        Build t_big_map t_diff_key t_diff_key_hash t_diff_value r.(big_map)
          diff_key r.(diff_key_hash) r.(diff_value).
      Definition with_diff_key_hash
        {t_big_map t_diff_key t_diff_key_hash t_diff_value} diff_key_hash
        (r : record t_big_map t_diff_key t_diff_key_hash t_diff_value) :=
        Build t_big_map t_diff_key t_diff_key_hash t_diff_value r.(big_map)
          r.(diff_key) diff_key_hash r.(diff_value).
      Definition with_diff_value
        {t_big_map t_diff_key t_diff_key_hash t_diff_value} diff_value
        (r : record t_big_map t_diff_key t_diff_key_hash t_diff_value) :=
        Build t_big_map t_diff_key t_diff_key_hash t_diff_value r.(big_map)
          r.(diff_key) r.(diff_key_hash) diff_value.
    End Update.
    Definition Update_skeleton := Update.record.
    
    Module Alloc.
      Record record {big_map key_type value_type : Set} : Set := Build {
        big_map : big_map;
        key_type : key_type;
        value_type : value_type }.
      Arguments record : clear implicits.
      Definition with_big_map {t_big_map t_key_type t_value_type} big_map
        (r : record t_big_map t_key_type t_value_type) :=
        Build t_big_map t_key_type t_value_type big_map r.(key_type)
          r.(value_type).
      Definition with_key_type {t_big_map t_key_type t_value_type} key_type
        (r : record t_big_map t_key_type t_value_type) :=
        Build t_big_map t_key_type t_value_type r.(big_map) key_type
          r.(value_type).
      Definition with_value_type {t_big_map t_key_type t_value_type} value_type
        (r : record t_big_map t_key_type t_value_type) :=
        Build t_big_map t_key_type t_value_type r.(big_map) r.(key_type)
          value_type.
    End Alloc.
    Definition Alloc_skeleton := Alloc.record.
  End big_map_diff_item.
End ConstructorRecords_big_map_diff_item.
Import ConstructorRecords_big_map_diff_item.

Reserved Notation &quot;'big_map_diff_item.Update&quot;.
Reserved Notation &quot;'big_map_diff_item.Alloc&quot;.

Inductive big_map_diff_item : Set :=
| Update : 'big_map_diff_item.Update -&gt; big_map_diff_item
| Clear : Z.t -&gt; big_map_diff_item
| Copy : Z.t -&gt; Z.t -&gt; big_map_diff_item
| Alloc : 'big_map_diff_item.Alloc -&gt; big_map_diff_item

where &quot;'big_map_diff_item.Update&quot; :=
  (big_map_diff_item.Update_skeleton Z.t Script_repr.expr Script_expr_hash.t
    (option Script_repr.expr))
and &quot;'big_map_diff_item.Alloc&quot; :=
  (big_map_diff_item.Alloc_skeleton Z.t Script_repr.expr Script_repr.expr).

Module big_map_diff_item.
  Include ConstructorRecords_big_map_diff_item.big_map_diff_item.
  Definition Update := 'big_map_diff_item.Update.
  Definition Alloc := 'big_map_diff_item.Alloc.
End big_map_diff_item.

Definition big_map_diff : Set := list big_map_diff_item.

Parameter big_map_diff_encoding : Data_encoding.t big_map_diff.

Parameter update_script_storage :
  Raw_context.t -&gt; Contract_repr.t -&gt; Script_repr.expr -&gt; option big_map_diff -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter credit :
  Raw_context.t -&gt; Contract_repr.t -&gt; Tez_repr.t -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter spend :
  Raw_context.t -&gt; Contract_repr.t -&gt; Tez_repr.t -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter originate_raw :
  Raw_context.t -&gt; option bool -&gt; Contract_repr.t -&gt; Tez_repr.t -&gt;
  Script_repr.t * option big_map_diff -&gt;
  option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter fresh_contract_from_current_nonce :
  Raw_context.t -&gt;
  Lwt.t (Error_monad.tzresult (Raw_context.t * Contract_repr.t)).

Parameter originated_from_current_nonce :
  Raw_context.t -&gt; Raw_context.t -&gt;
  Lwt.t (Error_monad.tzresult (list Contract_repr.t)).

Parameter init : Raw_context.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter used_storage_space :
  Raw_context.t -&gt; Contract_repr.t -&gt; Lwt.t (Error_monad.tzresult Z.t).

Parameter paid_storage_space :
  Raw_context.t -&gt; Contract_repr.t -&gt; Lwt.t (Error_monad.tzresult Z.t).

Parameter set_paid_storage_space_and_return_fees_to_pay :
  Raw_context.t -&gt; Contract_repr.t -&gt; Z.t -&gt;
  Lwt.t (Error_monad.tzresult (Z.t * Raw_context.t)).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="cycle_repr.ml">
  <div style="margin: 20px;">
    <h3>Cycle_repr</h3>
    <ul>
      <li>OCaml size: 93 lines</li>
      <li>Coq size: 127 lines (+36% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#cycle_repr.ml"><code>cycle_repr.ml</code></a>&nbsp;<span class="label label-warning">4 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = int32

type cycle = t

let encoding = Data_encoding.int32

let rpc_arg =
  let construct = Int32.to_string in
  let destruct str =
    match Int32.of_string str with
    | exception <abbr class="mark-warning" title="We do not support pattern-matching on exceptions">_</abbr> -&gt;
        Error &quot;Cannot parse cycle&quot;
    | cycle -&gt;
        Ok cycle
  in
  RPC_arg.make
    ~descr:&quot;A cycle integer&quot;
    ~name:&quot;block_cycle&quot;
    ~construct
    ~destruct
    ()

let pp ppf cycle = Format.fprintf ppf &quot;%ld&quot; cycle

include (Compare.Int32 : Compare.S with type t := t)

module Map = Map.Make (Compare.Int32)

let root = 0l

let succ = Int32.succ

let pred = function 0l -&gt; None | i -&gt; Some (Int32.pred i)

let add c i =
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.Int.(i &gt; 0))</abbr> ;
  Int32.add c (Int32.of_int i)

let sub c i =
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.Int.(i &gt; 0))</abbr> ;
  let r = Int32.sub c (Int32.of_int i) in
  if Compare.Int32.(r &lt; 0l) then None else Some r

let to_int32 i = i

let of_int32_exn l =
  if Compare.Int32.(l &gt;= 0l) then l
  else invalid_arg &quot;Level_repr.Cycle.of_int32&quot;

module Index : Storage_description.INDEX with type t = cycle = struct
  type t = cycle

  let path_length = 1

  let to_path c l = Int32.to_string (to_int32 c) :: l

  let of_path = function
    | [s] -&gt; <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(
      try Some (Int32.of_string s) with _ -&gt; None )</abbr>
    | _ -&gt;
        None

  let rpc_arg = rpc_arg

  let encoding = encoding

  let compare = compare
end
</pre>
  </div>
  <div class="col-md-6">
    <a href="#cycle_repr.ml"><code>Cycle_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Storage_description.

Definition t : Set := int32.

Definition cycle : Set := t.

Definition encoding : Data_encoding.encoding int32 :=
  Data_encoding.__int32_value.

Definition rpc_arg : RPC_arg.arg int32 :=
  let construct := Int32.to_string in
  let destruct (str : string) : Pervasives.result int32 string :=
    let 'cycle := Int32.of_string str in
    Pervasives.Ok cycle in
  RPC_arg.make (Some &quot;A cycle integer&quot;) &quot;block_cycle&quot; destruct construct tt.

Definition pp (ppf : Format.formatter) (cycle : int32) : unit :=
  Format.fprintf ppf
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.Int32 CamlinternalFormatBasics.Int_d
        CamlinternalFormatBasics.No_padding
        CamlinternalFormatBasics.No_precision
        CamlinternalFormatBasics.End_of_format) &quot;%ld&quot;) cycle.

Definition op_eq := (|Compare.Int32|).(Compare.S.op_eq).

Definition op_ltgt := (|Compare.Int32|).(Compare.S.op_ltgt).

Definition op_lt := (|Compare.Int32|).(Compare.S.op_lt).

Definition op_lteq := (|Compare.Int32|).(Compare.S.op_lteq).

Definition op_gteq := (|Compare.Int32|).(Compare.S.op_gteq).

Definition op_gt := (|Compare.Int32|).(Compare.S.op_gt).

Definition compare := (|Compare.Int32|).(Compare.S.compare).

Definition equal := (|Compare.Int32|).(Compare.S.equal).

Definition max := (|Compare.Int32|).(Compare.S.max).

Definition min := (|Compare.Int32|).(Compare.S.min).

Definition Map :=
  Map.Make
    (existT (A := Set) _ _
      {|
        Compare.COMPARABLE.compare := (|Compare.Int32|).(Compare.S.compare)
      |}).

Definition root : int32 :=
  (* ‚ùå Constant of type int32 is converted to int *)
  0.

Definition succ : int32 -&gt; int32 := Int32.succ.

Definition pred (function_parameter : int32) : option int32 :=
  match function_parameter with
  |
    (* ‚ùå Constant of type int32 is converted to int *)
    0 =&gt; None
  | i =&gt; Some (Int32.pred i)
  end.

Definition add (c : int32) (i : (|Compare.Int|).(Compare.S.t)) : int32 :=
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  Int32.add c (Int32.of_int i).

Definition sub (c : int32) (i : (|Compare.Int|).(Compare.S.t)) : option int32 :=
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  let __r_value := Int32.sub c (Int32.of_int i) in
  if
    (|Compare.Int32|).(Compare.S.op_lt) __r_value
      (* ‚ùå Constant of type int32 is converted to int *)
      0 then
    None
  else
    Some __r_value.

Definition to_int32 {A : Set} (i : A) : A := i.

Definition of_int32_exn (l : (|Compare.Int32|).(Compare.S.t))
  : (|Compare.Int32|).(Compare.S.t) :=
  if
    (|Compare.Int32|).(Compare.S.op_gteq) l
      (* ‚ùå Constant of type int32 is converted to int *)
      0 then
    l
  else
    Pervasives.invalid_arg &quot;Level_repr.Cycle.of_int32&quot;.

Definition Index : {_ : unit &amp; Storage_description.INDEX.signature (t := cycle)}
  :=
  let t : Set := cycle in
  let path_length := 1 in
  let to_path (c : int32) (l : list string) : list string :=
    cons (Int32.to_string (to_int32 c)) l in
  let of_path (function_parameter : list string) : option int32 :=
    match function_parameter with
    | cons s [] =&gt;
      (* ‚ùå Try-with are not handled *)
      try (Some (Int32.of_string s))
    | _ =&gt; None
    end in
  existT (A := unit) (fun _ =&gt; _) tt
    {|
      Storage_description.INDEX.path_length := path_length;
      Storage_description.INDEX.to_path := to_path;
      Storage_description.INDEX.of_path := of_path;
      Storage_description.INDEX.rpc_arg := rpc_arg;
      Storage_description.INDEX.encoding := encoding;
      Storage_description.INDEX.compare := compare
    |}.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="cycle_repr.mli">
  <div style="margin: 20px;">
    <h3>Cycle_repr_mli</h3>
    <ul>
      <li>OCaml size: 54 lines</li>
      <li>Coq size: 62 lines (+14% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#cycle_repr.mli"><code>cycle_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t

type cycle = t

include Compare.S with type t := t

val encoding : cycle Data_encoding.t

val rpc_arg : cycle RPC_arg.arg

val pp : Format.formatter -&gt; cycle -&gt; unit

val root : cycle

val pred : cycle -&gt; cycle option

val add : cycle -&gt; int -&gt; cycle

val sub : cycle -&gt; int -&gt; cycle option

val succ : cycle -&gt; cycle

val to_int32 : cycle -&gt; int32

val of_int32_exn : int32 -&gt; cycle

module Map : S.MAP with type key = cycle

module Index : Storage_description.INDEX with type t = cycle
</pre>
  </div>
  <div class="col-md-6">
    <a href="#cycle_repr.mli"><code>Cycle_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Storage_description.

Parameter t : Set.

Definition cycle : Set := t.

Parameter Included_S : {_ : unit &amp; Compare.S.signature (t := t)}.

Definition op_eq : t -&gt; t -&gt; bool := (|Included_S|).(Compare.S.op_eq).

Definition op_ltgt : t -&gt; t -&gt; bool := (|Included_S|).(Compare.S.op_ltgt).

Definition op_lt : t -&gt; t -&gt; bool := (|Included_S|).(Compare.S.op_lt).

Definition op_lteq : t -&gt; t -&gt; bool := (|Included_S|).(Compare.S.op_lteq).

Definition op_gteq : t -&gt; t -&gt; bool := (|Included_S|).(Compare.S.op_gteq).

Definition op_gt : t -&gt; t -&gt; bool := (|Included_S|).(Compare.S.op_gt).

Definition compare : t -&gt; t -&gt; int := (|Included_S|).(Compare.S.compare).

Definition equal : t -&gt; t -&gt; bool := (|Included_S|).(Compare.S.equal).

Definition max : t -&gt; t -&gt; t := (|Included_S|).(Compare.S.max).

Definition min : t -&gt; t -&gt; t := (|Included_S|).(Compare.S.min).

Parameter encoding : Data_encoding.t cycle.

Parameter rpc_arg : RPC_arg.arg cycle.

Parameter pp : Format.formatter -&gt; cycle -&gt; unit.

Parameter root : cycle.

Parameter pred : cycle -&gt; option cycle.

Parameter add : cycle -&gt; int -&gt; cycle.

Parameter sub : cycle -&gt; int -&gt; option cycle.

Parameter succ : cycle -&gt; cycle.

Parameter to_int32 : cycle -&gt; int32.

Parameter of_int32_exn : int32 -&gt; cycle.

Parameter Map : {t : Set -&gt; Set &amp; S.MAP.signature (key := cycle) (t := t)}.

Parameter Index : {_ : unit &amp; Storage_description.INDEX.signature (t := cycle)}.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="delegate_services.ml">
  <div style="margin: 20px;">
    <h3>Delegate_services</h3>
    <ul>
      <li>OCaml size: 693 lines</li>
      <li>Coq size: 1022 lines (+47% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#delegate_services.ml"><code>delegate_services.ml</code></a>&nbsp;<span class="label label-warning">14 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

type info = {
  balance : Tez.t;
  frozen_balance : Tez.t;
  frozen_balance_by_cycle : Delegate.frozen_balance Cycle.Map.t;
  staking_balance : Tez.t;
  delegated_contracts : Contract_repr.t list;
  delegated_balance : Tez.t;
  deactivated : bool;
  grace_period : Cycle.t;
}

let info_encoding =
  let open Data_encoding in
  conv
    (fun { balance;
           frozen_balance;
           frozen_balance_by_cycle;
           staking_balance;
           delegated_contracts;
           delegated_balance;
           deactivated;
           grace_period } -&gt;
      ( balance,
        frozen_balance,
        frozen_balance_by_cycle,
        staking_balance,
        delegated_contracts,
        delegated_balance,
        deactivated,
        grace_period ))
    (fun ( balance,
           frozen_balance,
           frozen_balance_by_cycle,
           staking_balance,
           delegated_contracts,
           delegated_balance,
           deactivated,
           grace_period ) -&gt;
      {
        balance;
        frozen_balance;
        frozen_balance_by_cycle;
        staking_balance;
        delegated_contracts;
        delegated_balance;
        deactivated;
        grace_period;
      })
    (obj8
       (req &quot;balance&quot; Tez.encoding)
       (req &quot;frozen_balance&quot; Tez.encoding)
       (req &quot;frozen_balance_by_cycle&quot; Delegate.frozen_balance_by_cycle_encoding)
       (req &quot;staking_balance&quot; Tez.encoding)
       (req &quot;delegated_contracts&quot; (list Contract_repr.encoding))
       (req &quot;delegated_balance&quot; Tez.encoding)
       (req &quot;deactivated&quot; bool)
       (req &quot;grace_period&quot; Cycle.encoding))

module S = struct
  let raw_path = RPC_path.(open_root / &quot;context&quot; / &quot;delegates&quot;)

  open Data_encoding

  type list_query = {active : bool; inactive : bool}

  let list_query : list_query RPC_query.t =
    let open RPC_query in
    query (fun active inactive -&gt; {active; inactive})
    |+ flag &quot;active&quot; (fun t -&gt; t.active)
    |+ flag &quot;inactive&quot; (fun t -&gt; t.inactive)
    |&gt; seal

  let list_delegate =
    RPC_service.get_service
      ~description:&quot;Lists all registered delegates.&quot;
      ~query:list_query
      ~output:(list Signature.Public_key_hash.encoding)
      raw_path

  let path = RPC_path.(raw_path /: Signature.Public_key_hash.rpc_arg)

  let info =
    RPC_service.get_service
      ~description:&quot;Everything about a delegate.&quot;
      ~query:RPC_query.empty
      ~output:info_encoding
      path

  let balance =
    RPC_service.get_service
      ~description:
        &quot;Returns the full balance of a given delegate, including the frozen \
         balances.&quot;
      ~query:RPC_query.empty
      ~output:Tez.encoding
      RPC_path.(path / &quot;balance&quot;)

  let frozen_balance =
    RPC_service.get_service
      ~description:
        &quot;Returns the total frozen balances of a given delegate, this includes \
         the frozen deposits, rewards and fees.&quot;
      ~query:RPC_query.empty
      ~output:Tez.encoding
      RPC_path.(path / &quot;frozen_balance&quot;)

  let frozen_balance_by_cycle =
    RPC_service.get_service
      ~description:
        &quot;Returns the frozen balances of a given delegate, indexed by the \
         cycle by which it will be unfrozen&quot;
      ~query:RPC_query.empty
      ~output:Delegate.frozen_balance_by_cycle_encoding
      RPC_path.(path / &quot;frozen_balance_by_cycle&quot;)

  let staking_balance =
    RPC_service.get_service
      ~description:
        &quot;Returns the total amount of tokens delegated to a given delegate. \
         This includes the balances of all the contracts that delegate to it, \
         but also the balance of the delegate itself and its frozen fees and \
         deposits. The rewards do not count in the delegated balance until \
         they are unfrozen.&quot;
      ~query:RPC_query.empty
      ~output:Tez.encoding
      RPC_path.(path / &quot;staking_balance&quot;)

  let delegated_contracts =
    RPC_service.get_service
      ~description:
        &quot;Returns the list of contracts that delegate to a given delegate.&quot;
      ~query:RPC_query.empty
      ~output:(list Contract_repr.encoding)
      RPC_path.(path / &quot;delegated_contracts&quot;)

  let delegated_balance =
    RPC_service.get_service
      ~description:
        &quot;Returns the balances of all the contracts that delegate to a given \
         delegate. This excludes the delegate's own balance and its frozen \
         balances.&quot;
      ~query:RPC_query.empty
      ~output:Tez.encoding
      RPC_path.(path / &quot;delegated_balance&quot;)

  let deactivated =
    RPC_service.get_service
      ~description:
        &quot;Tells whether the delegate is currently tagged as deactivated or not.&quot;
      ~query:RPC_query.empty
      ~output:bool
      RPC_path.(path / &quot;deactivated&quot;)

  let grace_period =
    RPC_service.get_service
      ~description:
        &quot;Returns the cycle by the end of which the delegate might be \
         deactivated if she fails to execute any delegate action. A \
         deactivated delegate might be reactivated (without loosing any \
         rolls) by simply re-registering as a delegate. For deactivated \
         delegates, this value contains the cycle by which they were \
         deactivated.&quot;
      ~query:RPC_query.empty
      ~output:Cycle.encoding
      RPC_path.(path / &quot;grace_period&quot;)
end

let begin_register () =
  let open Services_registration in
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.list_delegate (fun ctxt q () -&gt;
      Delegate.list ctxt
      &gt;&gt;= fun delegates -&gt;
      if q.active &amp;&amp; q.inactive then return delegates
      else if q.active then
        filter_map_s
          (fun pkh -&gt;
            Delegate.deactivated ctxt pkh
            &gt;&gt;=? function true -&gt; return_none | false -&gt; return_some pkh)
          delegates
      else if q.inactive then
        filter_map_s
          (fun pkh -&gt;
            Delegate.deactivated ctxt pkh
            &gt;&gt;=? function false -&gt; return_none | true -&gt; return_some pkh)
          delegates
      else return_nil)</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register1 S.info (fun ctxt pkh () () -&gt;
      Delegate.full_balance ctxt pkh
      &gt;&gt;=? fun balance -&gt;
      Delegate.frozen_balance ctxt pkh
      &gt;&gt;=? fun frozen_balance -&gt;
      Delegate.frozen_balance_by_cycle ctxt pkh
      &gt;&gt;= fun frozen_balance_by_cycle -&gt;
      Delegate.staking_balance ctxt pkh
      &gt;&gt;=? fun staking_balance -&gt;
      Delegate.delegated_contracts ctxt pkh
      &gt;&gt;= fun delegated_contracts -&gt;
      Delegate.delegated_balance ctxt pkh
      &gt;&gt;=? fun delegated_balance -&gt;
      Delegate.deactivated ctxt pkh
      &gt;&gt;=? fun deactivated -&gt;
      Delegate.grace_period ctxt pkh
      &gt;&gt;=? fun grace_period -&gt;
      return
        {
          balance;
          frozen_balance;
          frozen_balance_by_cycle;
          staking_balance;
          delegated_contracts;
          delegated_balance;
          deactivated;
          grace_period;
        })</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register1 S.balance (fun ctxt pkh () () -&gt; Delegate.full_balance ctxt pkh)</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register1 S.frozen_balance (fun ctxt pkh () () -&gt;
      Delegate.frozen_balance ctxt pkh)</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register1 S.frozen_balance_by_cycle (fun ctxt pkh () () -&gt;
      Delegate.frozen_balance_by_cycle ctxt pkh &gt;&gt;= return)</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register1 S.staking_balance (fun ctxt pkh () () -&gt;
      Delegate.staking_balance ctxt pkh)</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register1 S.delegated_contracts (fun ctxt pkh () () -&gt;
      Delegate.delegated_contracts ctxt pkh &gt;&gt;= return)</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register1 S.delegated_balance (fun ctxt pkh () () -&gt;
      Delegate.delegated_balance ctxt pkh)</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register1 S.deactivated (fun ctxt pkh () () -&gt; Delegate.deactivated ctxt pkh)</abbr> ;
  register1 S.grace_period (fun ctxt pkh () () -&gt;
      Delegate.grace_period ctxt pkh)

let list ctxt block ?(active = true) ?(inactive = false) () =
  RPC_context.make_call0 S.list_delegate ctxt block {active; inactive} ()

let info ctxt block pkh = RPC_context.make_call1 S.info ctxt block pkh () ()

let balance ctxt block pkh =
  RPC_context.make_call1 S.balance ctxt block pkh () ()

let frozen_balance ctxt block pkh =
  RPC_context.make_call1 S.frozen_balance ctxt block pkh () ()

let frozen_balance_by_cycle ctxt block pkh =
  RPC_context.make_call1 S.frozen_balance_by_cycle ctxt block pkh () ()

let staking_balance ctxt block pkh =
  RPC_context.make_call1 S.staking_balance ctxt block pkh () ()

let delegated_contracts ctxt block pkh =
  RPC_context.make_call1 S.delegated_contracts ctxt block pkh () ()

let delegated_balance ctxt block pkh =
  RPC_context.make_call1 S.delegated_balance ctxt block pkh () ()

let deactivated ctxt block pkh =
  RPC_context.make_call1 S.deactivated ctxt block pkh () ()

let grace_period ctxt block pkh =
  RPC_context.make_call1 S.grace_period ctxt block pkh () ()

let requested_levels ~default ctxt cycles levels =
  match (levels, cycles) with
  | ([], []) -&gt;
      return [default]
  | (levels, cycles) -&gt;
      (* explicitly fail when requested levels or cycle are in the past...
         or too far in the future... *)
      let levels =
        List.sort_uniq
          Level.compare
          (List.concat
             ( List.map (Level.from_raw ctxt) levels
             :: List.map (Level.levels_in_cycle ctxt) cycles ))
      in
      map_s
        (fun level -&gt;
          let current_level = Level.current ctxt in
          if Level.(level &lt;= current_level) then return (level, None)
          else
            Baking.earlier_predecessor_timestamp ctxt level
            &gt;&gt;=? fun timestamp -&gt; return (level, Some timestamp))
        levels

module Baking_rights = struct
  type t = {
    level : Raw_level.t;
    delegate : Signature.Public_key_hash.t;
    priority : int;
    timestamp : Timestamp.t option;
  }

  let encoding =
    let open Data_encoding in
    conv
      (fun {level; delegate; priority; timestamp} -&gt;
        (level, delegate, priority, timestamp))
      (fun (level, delegate, priority, timestamp) -&gt;
        {level; delegate; priority; timestamp})
      (obj4
         (req &quot;level&quot; Raw_level.encoding)
         (req &quot;delegate&quot; Signature.Public_key_hash.encoding)
         (req &quot;priority&quot; uint16)
         (opt &quot;estimated_time&quot; Timestamp.encoding))

  module S = struct
    let custom_root = RPC_path.(open_root / &quot;helpers&quot; / &quot;baking_rights&quot;)

    type baking_rights_query = {
      levels : Raw_level.t list;
      cycles : Cycle.t list;
      delegates : Signature.Public_key_hash.t list;
      max_priority : int option;
      all : bool;
    }

    let baking_rights_query =
      let open RPC_query in
      query (fun levels cycles delegates max_priority all -&gt;
          {levels; cycles; delegates; max_priority; all})
      |+ multi_field &quot;level&quot; Raw_level.rpc_arg (fun t -&gt; t.levels)
      |+ multi_field &quot;cycle&quot; Cycle.rpc_arg (fun t -&gt; t.cycles)
      |+ multi_field &quot;delegate&quot; Signature.Public_key_hash.rpc_arg (fun t -&gt;
             t.delegates)
      |+ opt_field &quot;max_priority&quot; RPC_arg.int (fun t -&gt; t.max_priority)
      |+ flag &quot;all&quot; (fun t -&gt; t.all)
      |&gt; seal

    let baking_rights =
      RPC_service.get_service
        ~description:
          &quot;Retrieves the list of delegates allowed to bake a block.\n\
           By default, it gives the best baking priorities for bakers that \
           have at least one opportunity below the 64th priority for the next \
           block.\n\
           Parameters `level` and `cycle` can be used to specify the (valid) \
           level(s) in the past or future at which the baking rights have to \
           be returned. Parameter `delegate` can be used to restrict the \
           results to the given delegates. If parameter `all` is set, all the \
           baking opportunities for each baker at each level are returned, \
           instead of just the first one.\n\
           Returns the list of baking slots. Also returns the minimal \
           timestamps that correspond to these slots. The timestamps are \
           omitted for levels in the past, and are only estimates for levels \
           later that the next block, based on the hypothesis that all \
           predecessor blocks were baked at the first priority.&quot;
        ~query:baking_rights_query
        ~output:(Data_encoding.list encoding)
        custom_root
  end

  let baking_priorities ctxt max_prio (level, pred_timestamp) =
    Baking.baking_priorities ctxt level
    &gt;&gt;=? fun contract_list -&gt;
    let rec loop l acc priority =
      if Compare.Int.(priority &gt;= max_prio) then return (List.rev acc)
      else
        let (Misc.LCons (pk, next)) = l in
        let delegate = Signature.Public_key.hash pk in
        ( match pred_timestamp with
        | None -&gt;
            return_none
        | Some pred_timestamp -&gt;
            Baking.minimal_time ctxt priority pred_timestamp
            &gt;&gt;=? fun t -&gt; return_some t )
        &gt;&gt;=? fun timestamp -&gt;
        let acc =
          {level = level.level; delegate; priority; timestamp} :: acc
        in
        next () &gt;&gt;=? fun l -&gt; loop l acc (priority + 1)
    in
    loop contract_list [] 0

  let remove_duplicated_delegates rights =
    List.rev @@ fst
    @@ List.fold_left
         (fun (acc, previous) r -&gt;
           if Signature.Public_key_hash.Set.mem r.delegate previous then
             (acc, previous)
           else
             (r :: acc, Signature.Public_key_hash.Set.add r.delegate previous))
         ([], Signature.Public_key_hash.Set.empty)
         rights

  let register () =
    let open Services_registration in
    register0 S.baking_rights (fun ctxt q () -&gt;
        requested_levels
          ~default:
            ( Level.succ ctxt (Level.current ctxt),
              Some (Timestamp.current ctxt) )
          ctxt
          q.cycles
          q.levels
        &gt;&gt;=? fun levels -&gt;
        let max_priority =
          match q.max_priority with None -&gt; 64 | Some max -&gt; max
        in
        map_s (baking_priorities ctxt max_priority) levels
        &gt;&gt;=? fun rights -&gt;
        let rights =
          if q.all then rights else List.map remove_duplicated_delegates rights
        in
        let rights = List.concat rights in
        match q.delegates with
        | [] -&gt;
            return rights
        | _ :: _ as delegates -&gt;
            let is_requested p =
              List.exists
                (Signature.Public_key_hash.equal p.delegate)
                delegates
            in
            return (List.filter is_requested rights))

  let get ctxt ?(levels = []) ?(cycles = []) ?(delegates = []) ?(all = false)
      ?max_priority block =
    RPC_context.make_call0
      S.baking_rights
      ctxt
      block
      {levels; cycles; delegates; max_priority; all}
      ()
end

module Endorsing_rights = struct
  type t = {
    level : Raw_level.t;
    delegate : Signature.Public_key_hash.t;
    slots : int list;
    estimated_time : Time.t option;
  }

  let encoding =
    let open Data_encoding in
    conv
      (fun {level; delegate; slots; estimated_time} -&gt;
        (level, delegate, slots, estimated_time))
      (fun (level, delegate, slots, estimated_time) -&gt;
        {level; delegate; slots; estimated_time})
      (obj4
         (req &quot;level&quot; Raw_level.encoding)
         (req &quot;delegate&quot; Signature.Public_key_hash.encoding)
         (req &quot;slots&quot; (list uint16))
         (opt &quot;estimated_time&quot; Timestamp.encoding))

  module S = struct
    let custom_root = RPC_path.(open_root / &quot;helpers&quot; / &quot;endorsing_rights&quot;)

    type endorsing_rights_query = {
      levels : Raw_level.t list;
      cycles : Cycle.t list;
      delegates : Signature.Public_key_hash.t list;
    }

    let endorsing_rights_query =
      let open RPC_query in
      query (fun levels cycles delegates -&gt; {levels; cycles; delegates})
      |+ multi_field &quot;level&quot; Raw_level.rpc_arg (fun t -&gt; t.levels)
      |+ multi_field &quot;cycle&quot; Cycle.rpc_arg (fun t -&gt; t.cycles)
      |+ multi_field &quot;delegate&quot; Signature.Public_key_hash.rpc_arg (fun t -&gt;
             t.delegates)
      |&gt; seal

    let endorsing_rights =
      RPC_service.get_service
        ~description:
          &quot;Retrieves the delegates allowed to endorse a block.\n\
           By default, it gives the endorsement slots for delegates that have \
           at least one in the next block.\n\
           Parameters `level` and `cycle` can be used to specify the (valid) \
           level(s) in the past or future at which the endorsement rights \
           have to be returned. Parameter `delegate` can be used to restrict \
           the results to the given delegates.\n\
           Returns the list of endorsement slots. Also returns the minimal \
           timestamps that correspond to these slots. The timestamps are \
           omitted for levels in the past, and are only estimates for levels \
           later that the next block, based on the hypothesis that all \
           predecessor blocks were baked at the first priority.&quot;
        ~query:endorsing_rights_query
        ~output:(Data_encoding.list encoding)
        custom_root
  end

  let endorsement_slots ctxt (level, estimated_time) =
    Baking.endorsement_rights ctxt level
    &gt;&gt;=? fun rights -&gt;
    return
      (Signature.Public_key_hash.Map.fold
         (fun delegate (_, slots, _) acc -&gt;
           {level = level.level; delegate; slots; estimated_time} :: acc)
         rights
         [])

  let register () =
    let open Services_registration in
    register0 S.endorsing_rights (fun ctxt q () -&gt;
        requested_levels
          ~default:(Level.current ctxt, Some (Timestamp.current ctxt))
          ctxt
          q.cycles
          q.levels
        &gt;&gt;=? fun levels -&gt;
        map_s (endorsement_slots ctxt) levels
        &gt;&gt;=? fun rights -&gt;
        let rights = List.concat rights in
        match q.delegates with
        | [] -&gt;
            return rights
        | _ :: _ as delegates -&gt;
            let is_requested p =
              List.exists
                (Signature.Public_key_hash.equal p.delegate)
                delegates
            in
            return (List.filter is_requested rights))

  let get ctxt ?(levels = []) ?(cycles = []) ?(delegates = []) block =
    RPC_context.make_call0
      S.endorsing_rights
      ctxt
      block
      {levels; cycles; delegates}
      ()
end

module Endorsing_power = struct
  let endorsing_power ctxt (operation, chain_id) =
    let (Operation_data data) = operation.protocol_data in
    match data.contents with
    | Single (Endorsement _) -&gt;
        Baking.check_endorsement_rights
          ctxt
          chain_id
          {shell = operation.shell; protocol_data = data}
        &gt;&gt;=? fun (_, slots, _) -&gt; return (List.length slots)
    | _ -&gt;
        failwith &quot;Operation is not an endorsement&quot;

  module S = struct
    let endorsing_power =
      let open Data_encoding in
      RPC_service.post_service
        ~description:
          &quot;Get the endorsing power of an endorsement, that is, the number of \
           slots that the endorser has&quot;
        ~query:RPC_query.empty
        ~input:
          (obj2
             (req &quot;endorsement_operation&quot; Operation.encoding)
             (req &quot;chain_id&quot; Chain_id.encoding))
        ~output:int31
        RPC_path.(open_root / &quot;endorsing_power&quot;)
  end

  let register () =
    let open Services_registration in
    register0 S.endorsing_power (fun ctxt () (op, chain_id) -&gt;
        endorsing_power ctxt (op, chain_id))

  let get ctxt block op chain_id =
    RPC_context.make_call0 S.endorsing_power ctxt block () (op, chain_id)
end

module Required_endorsements = struct
  let required_endorsements ctxt block_delay =
    return (Baking.minimum_allowed_endorsements ctxt ~block_delay)

  module S = struct
    type t = {block_delay : Period.t}

    let required_endorsements_query =
      let open RPC_query in
      query (fun block_delay -&gt; {block_delay})
      |+ field &quot;block_delay&quot; Period.rpc_arg Period.zero (fun t -&gt;
             t.block_delay)
      |&gt; seal

    let required_endorsements =
      let open Data_encoding in
      RPC_service.get_service
        ~description:
          &quot;Minimum number of endorsements for a block to be valid, given a \
           delay of the block's timestamp with respect to the minimum time to \
           bake at the block's priority&quot;
        ~query:required_endorsements_query
        ~output:int31
        RPC_path.(open_root / &quot;required_endorsements&quot;)
  end

  let register () =
    let open Services_registration in
    register0 S.required_endorsements (fun ctxt {block_delay} () -&gt;
        required_endorsements ctxt block_delay)

  let get ctxt block block_delay =
    RPC_context.make_call0 S.required_endorsements ctxt block {block_delay} ()
end

module Minimal_valid_time = struct
  let minimal_valid_time ctxt ~priority ~endorsing_power =
    Baking.minimal_valid_time ctxt ~priority ~endorsing_power

  module S = struct
    type t = {priority : int; endorsing_power : int}

    let minimal_valid_time_query =
      let open RPC_query in
      query (fun priority endorsing_power -&gt; {priority; endorsing_power})
      |+ field &quot;priority&quot; RPC_arg.int 0 (fun t -&gt; t.priority)
      |+ field &quot;endorsing_power&quot; RPC_arg.int 0 (fun t -&gt; t.endorsing_power)
      |&gt; seal

    let minimal_valid_time =
      RPC_service.get_service
        ~description:
          &quot;Minimal valid time for a block given a priority and an endorsing \
           power.&quot;
        ~query:minimal_valid_time_query
        ~output:Time.encoding
        RPC_path.(open_root / &quot;minimal_valid_time&quot;)
  end

  let register () =
    let open Services_registration in
    register0 S.minimal_valid_time (fun ctxt {priority; endorsing_power} () -&gt;
        minimal_valid_time ctxt ~priority ~endorsing_power)

  let get ctxt block priority endorsing_power =
    RPC_context.make_call0
      S.minimal_valid_time
      ctxt
      block
      {priority; endorsing_power}
      ()
end

let register () =
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">begin_register ()</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Baking_rights.register ()</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Endorsing_rights.register ()</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Endorsing_power.register ()</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Required_endorsements.register ()</abbr> ;
  Minimal_valid_time.register ()

let endorsement_rights ctxt level =
  Endorsing_rights.endorsement_slots ctxt (level, None)
  &gt;&gt;=? fun l -&gt;
  return (List.map (fun {Endorsing_rights.delegate; _} -&gt; delegate) l)

let baking_rights ctxt max_priority =
  let max = match max_priority with None -&gt; 64 | Some m -&gt; m in
  let level = Level.current ctxt in
  Baking_rights.baking_priorities ctxt max (level, None)
  &gt;&gt;=? fun l -&gt;
  return
    ( level.level,
      List.map
        (fun {Baking_rights.delegate; timestamp; _} -&gt; (delegate, timestamp))
        l )

let endorsing_power ctxt operation =
  Endorsing_power.endorsing_power ctxt operation

let required_endorsements ctxt delay =
  Required_endorsements.required_endorsements ctxt delay

let minimal_valid_time ctxt priority endorsing_power =
  Minimal_valid_time.minimal_valid_time ctxt priority endorsing_power
</pre>
  </div>
  <div class="col-md-6">
    <a href="#delegate_services.ml"><code>Delegate_services.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Baking.
Require Tezos.Contract_repr.
Require Tezos.Misc.
Require Tezos.Services_registration.

Import Alpha_context.

Module info.
  Record record : Set := Build {
    balance : Alpha_context.Tez.t;
    frozen_balance : Alpha_context.Tez.t;
    frozen_balance_by_cycle :
      (|Alpha_context.Cycle.Map|).(S.MAP.t)
        Alpha_context.Delegate.frozen_balance;
    staking_balance : Alpha_context.Tez.t;
    delegated_contracts : list Contract_repr.t;
    delegated_balance : Alpha_context.Tez.t;
    deactivated : bool;
    grace_period : Alpha_context.Cycle.t }.
  Definition with_balance balance (r : record) :=
    Build balance r.(frozen_balance) r.(frozen_balance_by_cycle)
      r.(staking_balance) r.(delegated_contracts) r.(delegated_balance)
      r.(deactivated) r.(grace_period).
  Definition with_frozen_balance frozen_balance (r : record) :=
    Build r.(balance) frozen_balance r.(frozen_balance_by_cycle)
      r.(staking_balance) r.(delegated_contracts) r.(delegated_balance)
      r.(deactivated) r.(grace_period).
  Definition with_frozen_balance_by_cycle frozen_balance_by_cycle
    (r : record) :=
    Build r.(balance) r.(frozen_balance) frozen_balance_by_cycle
      r.(staking_balance) r.(delegated_contracts) r.(delegated_balance)
      r.(deactivated) r.(grace_period).
  Definition with_staking_balance staking_balance (r : record) :=
    Build r.(balance) r.(frozen_balance) r.(frozen_balance_by_cycle)
      staking_balance r.(delegated_contracts) r.(delegated_balance)
      r.(deactivated) r.(grace_period).
  Definition with_delegated_contracts delegated_contracts (r : record) :=
    Build r.(balance) r.(frozen_balance) r.(frozen_balance_by_cycle)
      r.(staking_balance) delegated_contracts r.(delegated_balance)
      r.(deactivated) r.(grace_period).
  Definition with_delegated_balance delegated_balance (r : record) :=
    Build r.(balance) r.(frozen_balance) r.(frozen_balance_by_cycle)
      r.(staking_balance) r.(delegated_contracts) delegated_balance
      r.(deactivated) r.(grace_period).
  Definition with_deactivated deactivated (r : record) :=
    Build r.(balance) r.(frozen_balance) r.(frozen_balance_by_cycle)
      r.(staking_balance) r.(delegated_contracts) r.(delegated_balance)
      deactivated r.(grace_period).
  Definition with_grace_period grace_period (r : record) :=
    Build r.(balance) r.(frozen_balance) r.(frozen_balance_by_cycle)
      r.(staking_balance) r.(delegated_contracts) r.(delegated_balance)
      r.(deactivated) grace_period.
End info.
Definition info := info.record.

Definition info_encoding : Data_encoding.encoding info :=
  Data_encoding.conv
    (fun function_parameter =&gt;
      let '{|
        info.balance := balance;
          info.frozen_balance := __frozen_balance_value;
          info.frozen_balance_by_cycle := frozen_balance_by_cycle;
          info.staking_balance := staking_balance;
          info.delegated_contracts := delegated_contracts;
          info.delegated_balance := delegated_balance;
          info.deactivated := deactivated;
          info.grace_period := grace_period
          |} := function_parameter in
      (balance, __frozen_balance_value, frozen_balance_by_cycle,
        staking_balance, delegated_contracts, delegated_balance, deactivated,
        grace_period))
    (fun function_parameter =&gt;
      let
        '(balance, __frozen_balance_value, frozen_balance_by_cycle,
          staking_balance, delegated_contracts, delegated_balance, deactivated,
          grace_period) := function_parameter in
      {| info.balance := balance; info.frozen_balance := __frozen_balance_value;
        info.frozen_balance_by_cycle := frozen_balance_by_cycle;
        info.staking_balance := staking_balance;
        info.delegated_contracts := delegated_contracts;
        info.delegated_balance := delegated_balance;
        info.deactivated := deactivated; info.grace_period := grace_period |})
    None
    (Data_encoding.obj8
      (Data_encoding.req None None &quot;balance&quot; Alpha_context.Tez.encoding)
      (Data_encoding.req None None &quot;frozen_balance&quot; Alpha_context.Tez.encoding)
      (Data_encoding.req None None &quot;frozen_balance_by_cycle&quot;
        Alpha_context.Delegate.frozen_balance_by_cycle_encoding)
      (Data_encoding.req None None &quot;staking_balance&quot; Alpha_context.Tez.encoding)
      (Data_encoding.req None None &quot;delegated_contracts&quot;
        (Data_encoding.__list_value None Contract_repr.encoding))
      (Data_encoding.req None None &quot;delegated_balance&quot;
        Alpha_context.Tez.encoding)
      (Data_encoding.req None None &quot;deactivated&quot; Data_encoding.__bool_value)
      (Data_encoding.req None None &quot;grace_period&quot; Alpha_context.Cycle.encoding)).

Module S.
  Definition raw_path : RPC_path.path Updater.rpc_context Updater.rpc_context :=
    RPC_path.op_div (RPC_path.op_div RPC_path.open_root &quot;context&quot;) &quot;delegates&quot;.
  
  Import Data_encoding.
  
  Module list_query.
    Record record : Set := Build {
      active : bool;
      inactive : bool }.
    Definition with_active active (r : record) :=
      Build active r.(inactive).
    Definition with_inactive inactive (r : record) :=
      Build r.(active) inactive.
  End list_query.
  Definition list_query := list_query.record.
  
  Definition __list_query_value : RPC_query.t list_query :=
    RPC_query.seal
      (RPC_query.op_pipeplus
        (RPC_query.op_pipeplus
          (RPC_query.__query_value
            (fun active =&gt;
              fun inactive =&gt;
                {| list_query.active := active; list_query.inactive := inactive
                  |}))
          (RPC_query.flag None &quot;active&quot;
            (fun __t_value =&gt; __t_value.(list_query.active))))
        (RPC_query.flag None &quot;inactive&quot;
          (fun __t_value =&gt; __t_value.(list_query.inactive)))).
  
  Definition list_delegate
    : RPC_service.service Updater.rpc_context Updater.rpc_context list_query
      unit (list (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) :=
    RPC_service.get_service (Some &quot;Lists all registered delegates.&quot;)
      __list_query_value
      (Data_encoding.__list_value None
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding)) raw_path.
  
  Definition path
    : RPC_path.path Updater.rpc_context
      (Updater.rpc_context *
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) :=
    RPC_path.op_divcolon raw_path
      (|Signature.Public_key_hash|).(S.SPublic_key_hash.rpc_arg).
  
  Definition __info_value
    : RPC_service.service Updater.rpc_context
      (Updater.rpc_context *
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) unit unit info :=
    RPC_service.get_service (Some &quot;Everything about a delegate.&quot;)
      RPC_query.empty info_encoding path.
  
  Definition balance
    : RPC_service.service Updater.rpc_context
      (Updater.rpc_context *
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) unit unit
      Alpha_context.Tez.t :=
    RPC_service.get_service
      (Some
        &quot;Returns the full balance of a given delegate, including the frozen balances.&quot;)
      RPC_query.empty Alpha_context.Tez.encoding
      (RPC_path.op_div path &quot;balance&quot;).
  
  Definition __frozen_balance_value
    : RPC_service.service Updater.rpc_context
      (Updater.rpc_context *
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) unit unit
      Alpha_context.Tez.t :=
    RPC_service.get_service
      (Some
        &quot;Returns the total frozen balances of a given delegate, this includes the frozen deposits, rewards and fees.&quot;)
      RPC_query.empty Alpha_context.Tez.encoding
      (RPC_path.op_div path &quot;frozen_balance&quot;).
  
  Definition frozen_balance_by_cycle
    : RPC_service.service Updater.rpc_context
      (Updater.rpc_context *
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) unit unit
      ((|Alpha_context.Cycle.Map|).(S.MAP.t)
        Alpha_context.Delegate.frozen_balance) :=
    RPC_service.get_service
      (Some
        &quot;Returns the frozen balances of a given delegate, indexed by the cycle by which it will be unfrozen&quot;)
      RPC_query.empty Alpha_context.Delegate.frozen_balance_by_cycle_encoding
      (RPC_path.op_div path &quot;frozen_balance_by_cycle&quot;).
  
  Definition staking_balance
    : RPC_service.service Updater.rpc_context
      (Updater.rpc_context *
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) unit unit
      Alpha_context.Tez.t :=
    RPC_service.get_service
      (Some
        &quot;Returns the total amount of tokens delegated to a given delegate. This includes the balances of all the contracts that delegate to it, but also the balance of the delegate itself and its frozen fees and deposits. The rewards do not count in the delegated balance until they are unfrozen.&quot;)
      RPC_query.empty Alpha_context.Tez.encoding
      (RPC_path.op_div path &quot;staking_balance&quot;).
  
  Definition delegated_contracts
    : RPC_service.service Updater.rpc_context
      (Updater.rpc_context *
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) unit unit
      (list Contract_repr.contract) :=
    RPC_service.get_service
      (Some &quot;Returns the list of contracts that delegate to a given delegate.&quot;)
      RPC_query.empty (Data_encoding.__list_value None Contract_repr.encoding)
      (RPC_path.op_div path &quot;delegated_contracts&quot;).
  
  Definition delegated_balance
    : RPC_service.service Updater.rpc_context
      (Updater.rpc_context *
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) unit unit
      Alpha_context.Tez.t :=
    RPC_service.get_service
      (Some
        &quot;Returns the balances of all the contracts that delegate to a given delegate. This excludes the delegate's own balance and its frozen balances.&quot;)
      RPC_query.empty Alpha_context.Tez.encoding
      (RPC_path.op_div path &quot;delegated_balance&quot;).
  
  Definition deactivated
    : RPC_service.service Updater.rpc_context
      (Updater.rpc_context *
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) unit unit bool :=
    RPC_service.get_service
      (Some
        &quot;Tells whether the delegate is currently tagged as deactivated or not.&quot;)
      RPC_query.empty Data_encoding.__bool_value
      (RPC_path.op_div path &quot;deactivated&quot;).
  
  Definition grace_period
    : RPC_service.service Updater.rpc_context
      (Updater.rpc_context *
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) unit unit
      Alpha_context.Cycle.t :=
    RPC_service.get_service
      (Some
        &quot;Returns the cycle by the end of which the delegate might be deactivated if she fails to execute any delegate action. A deactivated delegate might be reactivated (without loosing any rolls) by simply re-registering as a delegate. For deactivated delegates, this value contains the cycle by which they were deactivated.&quot;)
      RPC_query.empty Alpha_context.Cycle.encoding
      (RPC_path.op_div path &quot;grace_period&quot;).
End S.

Definition begin_register (function_parameter : unit) : unit :=
  let '_ := function_parameter in
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  Services_registration.register1 S.grace_period
    (fun ctxt =&gt;
      fun pkh =&gt;
        fun function_parameter =&gt;
          let '_ := function_parameter in
          fun function_parameter =&gt;
            let '_ := function_parameter in
            Alpha_context.Delegate.grace_period ctxt pkh).

Definition __list_value {A : Set}
  (ctxt : RPC_context.simple A) (block : A) (op_staroptstar : option bool)
  : option bool -&gt; unit -&gt;
  Lwt.t
    (Error_monad.shell_tzresult
      (list (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))) :=
  let active :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; true
    end in
  fun op_staroptstar =&gt;
    let inactive :=
      match op_staroptstar with
      | Some op_starsthstar =&gt; op_starsthstar
      | None =&gt; false
      end in
    fun function_parameter =&gt;
      let '_ := function_parameter in
      RPC_context.make_call0 S.list_delegate ctxt block
        {| S.list_query.active := active; S.list_query.inactive := inactive |}
        tt.

Definition __info_value {A : Set}
  (ctxt : RPC_context.simple A) (block : A)
  (pkh : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.shell_tzresult info) :=
  RPC_context.make_call1 S.__info_value ctxt block pkh tt tt.

Definition balance {A : Set}
  (ctxt : RPC_context.simple A) (block : A)
  (pkh : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Tez.t) :=
  RPC_context.make_call1 S.balance ctxt block pkh tt tt.

Definition __frozen_balance_value {A : Set}
  (ctxt : RPC_context.simple A) (block : A)
  (pkh : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Tez.t) :=
  RPC_context.make_call1 S.__frozen_balance_value ctxt block pkh tt tt.

Definition frozen_balance_by_cycle {A : Set}
  (ctxt : RPC_context.simple A) (block : A)
  (pkh : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t
    (Error_monad.shell_tzresult
      ((|Alpha_context.Cycle.Map|).(S.MAP.t)
        Alpha_context.Delegate.frozen_balance)) :=
  RPC_context.make_call1 S.frozen_balance_by_cycle ctxt block pkh tt tt.

Definition staking_balance {A : Set}
  (ctxt : RPC_context.simple A) (block : A)
  (pkh : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Tez.t) :=
  RPC_context.make_call1 S.staking_balance ctxt block pkh tt tt.

Definition delegated_contracts {A : Set}
  (ctxt : RPC_context.simple A) (block : A)
  (pkh : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.shell_tzresult (list Contract_repr.contract)) :=
  RPC_context.make_call1 S.delegated_contracts ctxt block pkh tt tt.

Definition delegated_balance {A : Set}
  (ctxt : RPC_context.simple A) (block : A)
  (pkh : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Tez.t) :=
  RPC_context.make_call1 S.delegated_balance ctxt block pkh tt tt.

Definition deactivated {A : Set}
  (ctxt : RPC_context.simple A) (block : A)
  (pkh : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.shell_tzresult bool) :=
  RPC_context.make_call1 S.deactivated ctxt block pkh tt tt.

Definition grace_period {A : Set}
  (ctxt : RPC_context.simple A) (block : A)
  (pkh : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Cycle.t) :=
  RPC_context.make_call1 S.grace_period ctxt block pkh tt tt.

Definition requested_levels
  (default : Alpha_context.Level.t * option Alpha_context.Timestamp.t)
  (ctxt : Alpha_context.context) (cycles : list Alpha_context.Cycle.t)
  (levels : list Alpha_context.Raw_level.t)
  : Lwt.t
    (Error_monad.tzresult
      (list (Alpha_context.Level.t * option Alpha_context.Timestamp.t))) :=
  match (levels, cycles) with
  | ([], []) =&gt; Error_monad.__return [ default ]
  | (levels, cycles) =&gt;
    let levels :=
      List.sort_uniq Alpha_context.Level.compare
        (List.concat
          (cons
            (List.map
              (let arg := Alpha_context.Level.from_raw ctxt in
              fun eta =&gt; arg None eta) levels)
            (List.map (Alpha_context.Level.levels_in_cycle ctxt) cycles))) in
    Error_monad.map_s
      (fun level =&gt;
        let current_level := Alpha_context.Level.current ctxt in
        if Alpha_context.Level.op_lteq level current_level then
          Error_monad.__return (level, None)
        else
          let=? timestamp := Baking.earlier_predecessor_timestamp ctxt level in
          Error_monad.__return (level, (Some timestamp))) levels
  end.

Module Baking_rights.
  Module t.
    Record record : Set := Build {
      level : Alpha_context.Raw_level.t;
      delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t);
      priority : int;
      timestamp : option Alpha_context.Timestamp.t }.
    Definition with_level level (r : record) :=
      Build level r.(delegate) r.(priority) r.(timestamp).
    Definition with_delegate delegate (r : record) :=
      Build r.(level) delegate r.(priority) r.(timestamp).
    Definition with_priority priority (r : record) :=
      Build r.(level) r.(delegate) priority r.(timestamp).
    Definition with_timestamp timestamp (r : record) :=
      Build r.(level) r.(delegate) r.(priority) timestamp.
  End t.
  Definition t := t.record.
  
  Definition encoding : Data_encoding.encoding t :=
    Data_encoding.conv
      (fun function_parameter =&gt;
        let '{|
          t.level := level;
            t.delegate := delegate;
            t.priority := priority;
            t.timestamp := timestamp
            |} := function_parameter in
        (level, delegate, priority, timestamp))
      (fun function_parameter =&gt;
        let '(level, delegate, priority, timestamp) := function_parameter in
        {| t.level := level; t.delegate := delegate; t.priority := priority;
          t.timestamp := timestamp |}) None
      (Data_encoding.obj4
        (Data_encoding.req None None &quot;level&quot; Alpha_context.Raw_level.encoding)
        (Data_encoding.req None None &quot;delegate&quot;
          (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding))
        (Data_encoding.req None None &quot;priority&quot; Data_encoding.uint16)
        (Data_encoding.opt None None &quot;estimated_time&quot;
          Alpha_context.Timestamp.encoding)).
  
  Module S.
    Definition custom_root
      : RPC_path.path Updater.rpc_context Updater.rpc_context :=
      RPC_path.op_div (RPC_path.op_div RPC_path.open_root &quot;helpers&quot;)
        &quot;baking_rights&quot;.
    
    Module baking_rights_query.
      Record record : Set := Build {
        levels : list Alpha_context.Raw_level.t;
        cycles : list Alpha_context.Cycle.t;
        delegates : list (|Signature.Public_key_hash|).(S.SPublic_key_hash.t);
        max_priority : option int;
        all : bool }.
      Definition with_levels levels (r : record) :=
        Build levels r.(cycles) r.(delegates) r.(max_priority) r.(all).
      Definition with_cycles cycles (r : record) :=
        Build r.(levels) cycles r.(delegates) r.(max_priority) r.(all).
      Definition with_delegates delegates (r : record) :=
        Build r.(levels) r.(cycles) delegates r.(max_priority) r.(all).
      Definition with_max_priority max_priority (r : record) :=
        Build r.(levels) r.(cycles) r.(delegates) max_priority r.(all).
      Definition with_all all (r : record) :=
        Build r.(levels) r.(cycles) r.(delegates) r.(max_priority) all.
    End baking_rights_query.
    Definition baking_rights_query := baking_rights_query.record.
    
    Definition __baking_rights_query_value : RPC_query.t baking_rights_query :=
      RPC_query.seal
        (RPC_query.op_pipeplus
          (RPC_query.op_pipeplus
            (RPC_query.op_pipeplus
              (RPC_query.op_pipeplus
                (RPC_query.op_pipeplus
                  (RPC_query.__query_value
                    (fun levels =&gt;
                      fun cycles =&gt;
                        fun delegates =&gt;
                          fun max_priority =&gt;
                            fun all =&gt;
                              {| baking_rights_query.levels := levels;
                                baking_rights_query.cycles := cycles;
                                baking_rights_query.delegates := delegates;
                                baking_rights_query.max_priority := max_priority;
                                baking_rights_query.all := all |}))
                  (RPC_query.multi_field None &quot;level&quot;
                    Alpha_context.Raw_level.rpc_arg
                    (fun __t_value =&gt; __t_value.(baking_rights_query.levels))))
                (RPC_query.multi_field None &quot;cycle&quot; Alpha_context.Cycle.rpc_arg
                  (fun __t_value =&gt; __t_value.(baking_rights_query.cycles))))
              (RPC_query.multi_field None &quot;delegate&quot;
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.rpc_arg)
                (fun __t_value =&gt; __t_value.(baking_rights_query.delegates))))
            (RPC_query.opt_field None &quot;max_priority&quot; RPC_arg.__int_value
              (fun __t_value =&gt; __t_value.(baking_rights_query.max_priority))))
          (RPC_query.flag None &quot;all&quot;
            (fun __t_value =&gt; __t_value.(baking_rights_query.all)))).
    
    Definition baking_rights
      : RPC_service.service Updater.rpc_context Updater.rpc_context
        baking_rights_query unit (list t) :=
      RPC_service.get_service
        (Some
          &quot;Retrieves the list of delegates allowed to bake a block.\nBy default, it gives the best baking priorities for bakers that have at least one opportunity below the 64th priority for the next block.\nParameters `level` and `cycle` can be used to specify the (valid) level(s) in the past or future at which the baking rights have to be returned. Parameter `delegate` can be used to restrict the results to the given delegates. If parameter `all` is set, all the baking opportunities for each baker at each level are returned, instead of just the first one.\nReturns the list of baking slots. Also returns the minimal timestamps that correspond to these slots. The timestamps are omitted for levels in the past, and are only estimates for levels later that the next block, based on the hypothesis that all predecessor blocks were baked at the first priority.&quot;)
        __baking_rights_query_value (Data_encoding.__list_value None encoding)
        custom_root.
  End S.
  
  Definition baking_priorities
    (ctxt : Alpha_context.context) (max_prio : (|Compare.Int|).(Compare.S.t))
    (function_parameter : Alpha_context.Level.t * option Time.t)
    : Lwt.t (Error_monad.tzresult (list t)) :=
    let '(level, pred_timestamp) := function_parameter in
    let=? contract_list := Baking.baking_priorities ctxt level in
    let fix loop
      (l : Misc.lazy_list_t (|Signature.Public_key|).(S.SPublic_key.t))
      (acc : list t) (priority : (|Compare.Int|).(Compare.S.t))
      : Lwt.t (Error_monad.tzresult (list t)) :=
      if (|Compare.Int|).(Compare.S.op_gteq) priority max_prio then
        Error_monad.__return (List.rev acc)
      else
        let 'Misc.LCons pk next := l in
        let delegate := (|Signature.Public_key|).(S.SPublic_key.__hash_value) pk
          in
        let=? timestamp :=
          match pred_timestamp with
          | None =&gt; Error_monad.return_none
          | Some pred_timestamp =&gt;
            let=? __t_value := Baking.minimal_time ctxt priority pred_timestamp
              in
            Error_monad.return_some __t_value
          end in
        let acc :=
          cons
            {| t.level := level.(Alpha_context.Level.t.level);
              t.delegate := delegate; t.priority := priority;
              t.timestamp := timestamp |} acc in
        let=? l := next tt in
        loop l acc (Pervasives.op_plus priority 1) in
    loop contract_list nil 0.
  
  Definition remove_duplicated_delegates (rights : list t) : list t :=
    List.rev
      (Pervasives.fst
        (List.fold_left
          (fun function_parameter =&gt;
            let '(acc, previous) := function_parameter in
            fun __r_value =&gt;
              if
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.__Set).(S.INDEXES_Set.mem)
                  __r_value.(t.delegate) previous then
                (acc, previous)
              else
                ((cons __r_value acc),
                  ((|Signature.Public_key_hash|).(S.SPublic_key_hash.__Set).(S.INDEXES_Set.add)
                    __r_value.(t.delegate) previous)))
          (nil,
            (|Signature.Public_key_hash|).(S.SPublic_key_hash.__Set).(S.INDEXES_Set.empty))
          rights)).
  
  Definition register (function_parameter : unit) : unit :=
    let '_ := function_parameter in
    Services_registration.register0 S.baking_rights
      (fun ctxt =&gt;
        fun q =&gt;
          fun function_parameter =&gt;
            let '_ := function_parameter in
            let=? levels :=
              requested_levels
                ((Alpha_context.Level.succ ctxt
                  (Alpha_context.Level.current ctxt)),
                  (Some (Alpha_context.Timestamp.current ctxt))) ctxt
                q.(S.baking_rights_query.cycles)
                q.(S.baking_rights_query.levels) in
            let max_priority :=
              match q.(S.baking_rights_query.max_priority) with
              | None =&gt; 64
              | Some max =&gt; max
              end in
            let=? rights :=
              Error_monad.map_s (baking_priorities ctxt max_priority) levels in
            let rights :=
              if q.(S.baking_rights_query.all) then
                rights
              else
                List.map remove_duplicated_delegates rights in
            let rights := List.concat rights in
            match q.(S.baking_rights_query.delegates) with
            | [] =&gt; Error_monad.__return rights
            | (cons _ _) as delegates =&gt;
              let is_requested (__p_value : t) : bool :=
                List.__exists
                  ((|Signature.Public_key_hash|).(S.SPublic_key_hash.equal)
                    __p_value.(t.delegate)) delegates in
              Error_monad.__return (List.filter is_requested rights)
            end).
  
  Definition get {A : Set}
    (ctxt : RPC_context.simple A)
    (op_staroptstar : option (list Alpha_context.Raw_level.t))
    : option (list Alpha_context.Cycle.t) -&gt;
    option (list (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) -&gt;
    option bool -&gt; option int -&gt; A -&gt;
    Lwt.t (Error_monad.shell_tzresult (list t)) :=
    let levels :=
      match op_staroptstar with
      | Some op_starsthstar =&gt; op_starsthstar
      | None =&gt; nil
      end in
    fun op_staroptstar =&gt;
      let cycles :=
        match op_staroptstar with
        | Some op_starsthstar =&gt; op_starsthstar
        | None =&gt; nil
        end in
      fun op_staroptstar =&gt;
        let delegates :=
          match op_staroptstar with
          | Some op_starsthstar =&gt; op_starsthstar
          | None =&gt; nil
          end in
        fun op_staroptstar =&gt;
          let all :=
            match op_staroptstar with
            | Some op_starsthstar =&gt; op_starsthstar
            | None =&gt; false
            end in
          fun max_priority =&gt;
            fun block =&gt;
              RPC_context.make_call0 S.baking_rights ctxt block
                {| S.baking_rights_query.levels := levels;
                  S.baking_rights_query.cycles := cycles;
                  S.baking_rights_query.delegates := delegates;
                  S.baking_rights_query.max_priority := max_priority;
                  S.baking_rights_query.all := all |} tt.
End Baking_rights.

Module Endorsing_rights.
  Module t.
    Record record : Set := Build {
      level : Alpha_context.Raw_level.t;
      delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t);
      slots : list int;
      estimated_time : option Time.t }.
    Definition with_level level (r : record) :=
      Build level r.(delegate) r.(slots) r.(estimated_time).
    Definition with_delegate delegate (r : record) :=
      Build r.(level) delegate r.(slots) r.(estimated_time).
    Definition with_slots slots (r : record) :=
      Build r.(level) r.(delegate) slots r.(estimated_time).
    Definition with_estimated_time estimated_time (r : record) :=
      Build r.(level) r.(delegate) r.(slots) estimated_time.
  End t.
  Definition t := t.record.
  
  Definition encoding : Data_encoding.encoding t :=
    Data_encoding.conv
      (fun function_parameter =&gt;
        let '{|
          t.level := level;
            t.delegate := delegate;
            t.slots := slots;
            t.estimated_time := estimated_time
            |} := function_parameter in
        (level, delegate, slots, estimated_time))
      (fun function_parameter =&gt;
        let '(level, delegate, slots, estimated_time) := function_parameter in
        {| t.level := level; t.delegate := delegate; t.slots := slots;
          t.estimated_time := estimated_time |}) None
      (Data_encoding.obj4
        (Data_encoding.req None None &quot;level&quot; Alpha_context.Raw_level.encoding)
        (Data_encoding.req None None &quot;delegate&quot;
          (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding))
        (Data_encoding.req None None &quot;slots&quot;
          (Data_encoding.__list_value None Data_encoding.uint16))
        (Data_encoding.opt None None &quot;estimated_time&quot;
          Alpha_context.Timestamp.encoding)).
  
  Module S.
    Definition custom_root
      : RPC_path.path Updater.rpc_context Updater.rpc_context :=
      RPC_path.op_div (RPC_path.op_div RPC_path.open_root &quot;helpers&quot;)
        &quot;endorsing_rights&quot;.
    
    Module endorsing_rights_query.
      Record record : Set := Build {
        levels : list Alpha_context.Raw_level.t;
        cycles : list Alpha_context.Cycle.t;
        delegates : list (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) }.
      Definition with_levels levels (r : record) :=
        Build levels r.(cycles) r.(delegates).
      Definition with_cycles cycles (r : record) :=
        Build r.(levels) cycles r.(delegates).
      Definition with_delegates delegates (r : record) :=
        Build r.(levels) r.(cycles) delegates.
    End endorsing_rights_query.
    Definition endorsing_rights_query := endorsing_rights_query.record.
    
    Definition __endorsing_rights_query_value
      : RPC_query.t endorsing_rights_query :=
      RPC_query.seal
        (RPC_query.op_pipeplus
          (RPC_query.op_pipeplus
            (RPC_query.op_pipeplus
              (RPC_query.__query_value
                (fun levels =&gt;
                  fun cycles =&gt;
                    fun delegates =&gt;
                      {| endorsing_rights_query.levels := levels;
                        endorsing_rights_query.cycles := cycles;
                        endorsing_rights_query.delegates := delegates |}))
              (RPC_query.multi_field None &quot;level&quot;
                Alpha_context.Raw_level.rpc_arg
                (fun __t_value =&gt; __t_value.(endorsing_rights_query.levels))))
            (RPC_query.multi_field None &quot;cycle&quot; Alpha_context.Cycle.rpc_arg
              (fun __t_value =&gt; __t_value.(endorsing_rights_query.cycles))))
          (RPC_query.multi_field None &quot;delegate&quot;
            (|Signature.Public_key_hash|).(S.SPublic_key_hash.rpc_arg)
            (fun __t_value =&gt; __t_value.(endorsing_rights_query.delegates)))).
    
    Definition endorsing_rights
      : RPC_service.service Updater.rpc_context Updater.rpc_context
        endorsing_rights_query unit (list t) :=
      RPC_service.get_service
        (Some
          &quot;Retrieves the delegates allowed to endorse a block.\nBy default, it gives the endorsement slots for delegates that have at least one in the next block.\nParameters `level` and `cycle` can be used to specify the (valid) level(s) in the past or future at which the endorsement rights have to be returned. Parameter `delegate` can be used to restrict the results to the given delegates.\nReturns the list of endorsement slots. Also returns the minimal timestamps that correspond to these slots. The timestamps are omitted for levels in the past, and are only estimates for levels later that the next block, based on the hypothesis that all predecessor blocks were baked at the first priority.&quot;)
        __endorsing_rights_query_value
        (Data_encoding.__list_value None encoding) custom_root.
  End S.
  
  Definition endorsement_slots
    (ctxt : Alpha_context.context)
    (function_parameter : Alpha_context.Level.t * option Time.t)
    : Lwt.t (Error_monad.tzresult (list t)) :=
    let '(level, estimated_time) := function_parameter in
    let=? rights := Baking.endorsement_rights ctxt level in
    Error_monad.__return
      ((|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.fold)
        (fun delegate =&gt;
          fun function_parameter =&gt;
            let '(_, slots, _) := function_parameter in
            fun acc =&gt;
              cons
                {| t.level := level.(Alpha_context.Level.t.level);
                  t.delegate := delegate; t.slots := slots;
                  t.estimated_time := estimated_time |} acc) rights nil).
  
  Definition register (function_parameter : unit) : unit :=
    let '_ := function_parameter in
    Services_registration.register0 S.endorsing_rights
      (fun ctxt =&gt;
        fun q =&gt;
          fun function_parameter =&gt;
            let '_ := function_parameter in
            let=? levels :=
              requested_levels
                ((Alpha_context.Level.current ctxt),
                  (Some (Alpha_context.Timestamp.current ctxt))) ctxt
                q.(S.endorsing_rights_query.cycles)
                q.(S.endorsing_rights_query.levels) in
            let=? rights := Error_monad.map_s (endorsement_slots ctxt) levels in
            let rights := List.concat rights in
            match q.(S.endorsing_rights_query.delegates) with
            | [] =&gt; Error_monad.__return rights
            | (cons _ _) as delegates =&gt;
              let is_requested (__p_value : t) : bool :=
                List.__exists
                  ((|Signature.Public_key_hash|).(S.SPublic_key_hash.equal)
                    __p_value.(t.delegate)) delegates in
              Error_monad.__return (List.filter is_requested rights)
            end).
  
  Definition get {A : Set}
    (ctxt : RPC_context.simple A)
    (op_staroptstar : option (list Alpha_context.Raw_level.t))
    : option (list Alpha_context.Cycle.t) -&gt;
    option (list (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) -&gt; A -&gt;
    Lwt.t (Error_monad.shell_tzresult (list t)) :=
    let levels :=
      match op_staroptstar with
      | Some op_starsthstar =&gt; op_starsthstar
      | None =&gt; nil
      end in
    fun op_staroptstar =&gt;
      let cycles :=
        match op_staroptstar with
        | Some op_starsthstar =&gt; op_starsthstar
        | None =&gt; nil
        end in
      fun op_staroptstar =&gt;
        let delegates :=
          match op_staroptstar with
          | Some op_starsthstar =&gt; op_starsthstar
          | None =&gt; nil
          end in
        fun block =&gt;
          RPC_context.make_call0 S.endorsing_rights ctxt block
            {| S.endorsing_rights_query.levels := levels;
              S.endorsing_rights_query.cycles := cycles;
              S.endorsing_rights_query.delegates := delegates |} tt.
End Endorsing_rights.

Module Endorsing_power.
  Definition endorsing_power
    (ctxt : Alpha_context.context)
    (function_parameter :
      Alpha_context.packed_operation * (|Chain_id|).(S.HASH.t))
    : Lwt.t (Error_monad.tzresult int) :=
    let '(operation, chain_id) := function_parameter in
    let 'Alpha_context.Operation_data data :=
      operation.(Alpha_context.packed_operation.protocol_data) in
    match data.(Alpha_context.protocol_data.contents) with
    | Alpha_context.Single (Alpha_context.Endorsement _) =&gt;
      let=? '(_, slots, _) :=
        Baking.check_endorsement_rights ctxt chain_id
          {|
            Alpha_context.operation.shell :=
              operation.(Alpha_context.packed_operation.shell);
            Alpha_context.operation.protocol_data := data |} in
      Error_monad.__return (List.length slots)
    | _ =&gt; Pervasives.failwith &quot;Operation is not an endorsement&quot;
    end.
  
  Module S.
    Definition endorsing_power
      : RPC_service.service Updater.rpc_context Updater.rpc_context unit
        (Alpha_context.Operation.packed * (|Chain_id|).(S.HASH.t)) int :=
      RPC_service.post_service
        (Some
          &quot;Get the endorsing power of an endorsement, that is, the number of slots that the endorser has&quot;)
        RPC_query.empty
        (Data_encoding.obj2
          (Data_encoding.req None None &quot;endorsement_operation&quot;
            Alpha_context.Operation.encoding)
          (Data_encoding.req None None &quot;chain_id&quot; (|Chain_id|).(S.HASH.encoding)))
        Data_encoding.int31
        (RPC_path.op_div RPC_path.open_root &quot;endorsing_power&quot;).
  End S.
  
  Definition register (function_parameter : unit) : unit :=
    let '_ := function_parameter in
    Services_registration.register0 S.endorsing_power
      (fun ctxt =&gt;
        fun function_parameter =&gt;
          let '_ := function_parameter in
          fun function_parameter =&gt;
            let '(op, chain_id) := function_parameter in
            endorsing_power ctxt (op, chain_id)).
  
  Definition get {A : Set}
    (ctxt : RPC_context.simple A) (block : A)
    (op : Alpha_context.Operation.packed) (chain_id : (|Chain_id|).(S.HASH.t))
    : Lwt.t (Error_monad.shell_tzresult int) :=
    RPC_context.make_call0 S.endorsing_power ctxt block tt (op, chain_id).
End Endorsing_power.

Module Required_endorsements.
  Definition required_endorsements
    (ctxt : Alpha_context.context) (block_delay : Alpha_context.Period.t)
    : Lwt.t (Error_monad.tzresult int) :=
    Error_monad.__return (Baking.minimum_allowed_endorsements ctxt block_delay).
  
  Module S.
    Module t.
      Record record : Set := Build {
        block_delay : Alpha_context.Period.t }.
      Definition with_block_delay block_delay (r : record) :=
        Build block_delay.
    End t.
    Definition t := t.record.
    
    Definition required_endorsements_query : RPC_query.t t :=
      RPC_query.seal
        (RPC_query.op_pipeplus
          (RPC_query.__query_value
            (fun block_delay =&gt; {| t.block_delay := block_delay |}))
          (RPC_query.__field_value None &quot;block_delay&quot;
            Alpha_context.Period.rpc_arg Alpha_context.Period.zero
            (fun __t_value =&gt; __t_value.(t.block_delay)))).
    
    Definition required_endorsements
      : RPC_service.service Updater.rpc_context Updater.rpc_context t unit int :=
      RPC_service.get_service
        (Some
          &quot;Minimum number of endorsements for a block to be valid, given a delay of the block's timestamp with respect to the minimum time to bake at the block's priority&quot;)
        required_endorsements_query Data_encoding.int31
        (RPC_path.op_div RPC_path.open_root &quot;required_endorsements&quot;).
  End S.
  
  Definition register (function_parameter : unit) : unit :=
    let '_ := function_parameter in
    Services_registration.register0 S.required_endorsements
      (fun ctxt =&gt;
        fun function_parameter =&gt;
          let '{| S.t.block_delay := block_delay |} := function_parameter in
          fun function_parameter =&gt;
            let '_ := function_parameter in
            required_endorsements ctxt block_delay).
  
  Definition get {A : Set}
    (ctxt : RPC_context.simple A) (block : A)
    (block_delay : Alpha_context.Period.t)
    : Lwt.t (Error_monad.shell_tzresult int) :=
    RPC_context.make_call0 S.required_endorsements ctxt block
      {| S.t.block_delay := block_delay |} tt.
End Required_endorsements.

Module Minimal_valid_time.
  Definition minimal_valid_time
    (ctxt : Alpha_context.context) (priority : int) (endorsing_power : int)
    : Lwt.t (Error_monad.tzresult Time.t) :=
    Baking.minimal_valid_time ctxt priority endorsing_power.
  
  Module S.
    Module t.
      Record record : Set := Build {
        priority : int;
        endorsing_power : int }.
      Definition with_priority priority (r : record) :=
        Build priority r.(endorsing_power).
      Definition with_endorsing_power endorsing_power (r : record) :=
        Build r.(priority) endorsing_power.
    End t.
    Definition t := t.record.
    
    Definition minimal_valid_time_query : RPC_query.t t :=
      RPC_query.seal
        (RPC_query.op_pipeplus
          (RPC_query.op_pipeplus
            (RPC_query.__query_value
              (fun priority =&gt;
                fun endorsing_power =&gt;
                  {| t.priority := priority;
                    t.endorsing_power := endorsing_power |}))
            (RPC_query.__field_value None &quot;priority&quot; RPC_arg.__int_value 0
              (fun __t_value =&gt; __t_value.(t.priority))))
          (RPC_query.__field_value None &quot;endorsing_power&quot; RPC_arg.__int_value 0
            (fun __t_value =&gt; __t_value.(t.endorsing_power)))).
    
    Definition minimal_valid_time
      : RPC_service.service Updater.rpc_context Updater.rpc_context t unit
        Time.t :=
      RPC_service.get_service
        (Some
          &quot;Minimal valid time for a block given a priority and an endorsing power.&quot;)
        minimal_valid_time_query Time.encoding
        (RPC_path.op_div RPC_path.open_root &quot;minimal_valid_time&quot;).
  End S.
  
  Definition register (function_parameter : unit) : unit :=
    let '_ := function_parameter in
    Services_registration.register0 S.minimal_valid_time
      (fun ctxt =&gt;
        fun function_parameter =&gt;
          let '{|
            S.t.priority := priority;
              S.t.endorsing_power := endorsing_power
              |} := function_parameter in
          fun function_parameter =&gt;
            let '_ := function_parameter in
            minimal_valid_time ctxt priority endorsing_power).
  
  Definition get {A : Set}
    (ctxt : RPC_context.simple A) (block : A) (priority : int)
    (endorsing_power : int) : Lwt.t (Error_monad.shell_tzresult Time.t) :=
    RPC_context.make_call0 S.minimal_valid_time ctxt block
      {| S.t.priority := priority; S.t.endorsing_power := endorsing_power |} tt.
End Minimal_valid_time.

Definition register (function_parameter : unit) : unit :=
  let '_ := function_parameter in
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  Minimal_valid_time.register tt.

Definition endorsement_rights
  (ctxt : Alpha_context.context) (level : Alpha_context.Level.t)
  : Lwt.t
    (Error_monad.tzresult
      (list (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))) :=
  let=? l := Endorsing_rights.endorsement_slots ctxt (level, None) in
  Error_monad.__return
    (List.map
      (fun function_parameter =&gt;
        let '{| Endorsing_rights.t.delegate := delegate |} := function_parameter
          in
        delegate) l).

Definition baking_rights
  (ctxt : Alpha_context.context)
  (max_priority : option (|Compare.Int|).(Compare.S.t))
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.Raw_level.t *
        list
          ((|Signature.Public_key_hash|).(S.SPublic_key_hash.t) *
            option Alpha_context.Timestamp.t))) :=
  let max :=
    match max_priority with
    | None =&gt; 64
    | Some m =&gt; m
    end in
  let level := Alpha_context.Level.current ctxt in
  let=? l := Baking_rights.baking_priorities ctxt max (level, None) in
  Error_monad.__return
    (level.(Alpha_context.Level.t.level),
      (List.map
        (fun function_parameter =&gt;
          let '{|
            Baking_rights.t.delegate := delegate;
              Baking_rights.t.timestamp := timestamp
              |} := function_parameter in
          (delegate, timestamp)) l)).

Definition endorsing_power
  (ctxt : Alpha_context.context)
  (operation : Alpha_context.packed_operation * (|Chain_id|).(S.HASH.t))
  : Lwt.t (Error_monad.tzresult int) :=
  Endorsing_power.endorsing_power ctxt operation.

Definition required_endorsements
  (ctxt : Alpha_context.context) (delay : Alpha_context.Period.t)
  : Lwt.t (Error_monad.tzresult int) :=
  Required_endorsements.required_endorsements ctxt delay.

Definition minimal_valid_time
  (ctxt : Alpha_context.context) (priority : int) (endorsing_power : int)
  : Lwt.t (Error_monad.tzresult Time.t) :=
  Minimal_valid_time.minimal_valid_time ctxt priority endorsing_power.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="delegate_services.mli">
  <div style="margin: 20px;">
    <h3>Delegate_services_mli</h3>
    <ul>
      <li>OCaml size: 211 lines</li>
      <li>Coq size: 210 lines (-1% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#delegate_services.mli"><code>delegate_services.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

val list :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  ?active:bool -&gt;
  ?inactive:bool -&gt;
  unit -&gt;
  Signature.Public_key_hash.t list shell_tzresult Lwt.t

type info = {
  balance : Tez.t;
  frozen_balance : Tez.t;
  frozen_balance_by_cycle : Delegate.frozen_balance Cycle.Map.t;
  staking_balance : Tez.t;
  delegated_contracts : Contract_repr.t list;
  delegated_balance : Tez.t;
  deactivated : bool;
  grace_period : Cycle.t;
}

val info_encoding : info Data_encoding.t

val info :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Signature.Public_key_hash.t -&gt;
  info shell_tzresult Lwt.t

val balance :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Signature.Public_key_hash.t -&gt;
  Tez.t shell_tzresult Lwt.t

val frozen_balance :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Signature.Public_key_hash.t -&gt;
  Tez.t shell_tzresult Lwt.t

val frozen_balance_by_cycle :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Signature.Public_key_hash.t -&gt;
  Delegate.frozen_balance Cycle.Map.t shell_tzresult Lwt.t

val staking_balance :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Signature.Public_key_hash.t -&gt;
  Tez.t shell_tzresult Lwt.t

val delegated_contracts :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Signature.Public_key_hash.t -&gt;
  Contract_repr.t list shell_tzresult Lwt.t

val delegated_balance :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Signature.Public_key_hash.t -&gt;
  Tez.t shell_tzresult Lwt.t

val deactivated :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Signature.Public_key_hash.t -&gt;
  bool shell_tzresult Lwt.t

val grace_period :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Signature.Public_key_hash.t -&gt;
  Cycle.t shell_tzresult Lwt.t

module Baking_rights : sig
  type t = {
    level : Raw_level.t;
    delegate : Signature.Public_key_hash.t;
    priority : int;
    timestamp : Timestamp.t option;
  }

  (** Retrieves the list of delegates allowed to bake a block.

      By default, it gives the best baking priorities for bakers
      that have at least one opportunity below the 64th priority for
      the next block.

      Parameters [levels] and [cycles] can be used to specify the
      (valid) level(s) in the past or future at which the baking rights
      have to be returned. Parameter [delegates] can be used to
      restrict the results to the given delegates. If parameter [all]
      is [true], all the baking opportunities for each baker at each level
      are returned, instead of just the first one.

      Returns the list of baking slots. Also returns the minimal
      timestamps that correspond to these slots. The timestamps are
      omitted for levels in the past, and are only estimates for levels
      later that the next block, based on the hypothesis that all
      predecessor blocks were baked at the first priority. *)
  val get :
    'a #RPC_context.simple -&gt;
    ?levels:Raw_level.t list -&gt;
    ?cycles:Cycle.t list -&gt;
    ?delegates:Signature.public_key_hash list -&gt;
    ?all:bool -&gt;
    ?max_priority:int -&gt;
    'a -&gt;
    t list shell_tzresult Lwt.t
end

module Endorsing_rights : sig
  type t = {
    level : Raw_level.t;
    delegate : Signature.Public_key_hash.t;
    slots : int list;
    estimated_time : Timestamp.t option;
  }

  (** Retrieves the delegates allowed to endorse a block.

      By default, it gives the endorsement slots for bakers that have
      at least one in the next block.

      Parameters [levels] and [cycles] can be used to specify the
      (valid) level(s) in the past or future at which the endorsement
      rights have to be returned. Parameter [delegates] can be used to
      restrict the results to the given delegates.  Returns the list of
      endorsement slots. Also returns the minimal timestamps that
      correspond to these slots.

      Timestamps are omitted for levels in the past, and are only
      estimates for levels later that the next block, based on the
      hypothesis that all predecessor blocks were baked at the first
      priority. *)
  val get :
    'a #RPC_context.simple -&gt;
    ?levels:Raw_level.t list -&gt;
    ?cycles:Cycle.t list -&gt;
    ?delegates:Signature.public_key_hash list -&gt;
    'a -&gt;
    t list shell_tzresult Lwt.t
end

module Endorsing_power : sig
  val get :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    Alpha_context.packed_operation -&gt;
    Chain_id.t -&gt;
    int shell_tzresult Lwt.t
end

module Required_endorsements : sig
  val get :
    'a #RPC_context.simple -&gt; 'a -&gt; Period.t -&gt; int shell_tzresult Lwt.t
end

module Minimal_valid_time : sig
  val get :
    'a #RPC_context.simple -&gt; 'a -&gt; int -&gt; int -&gt; Time.t shell_tzresult Lwt.t
end

(* temporary export for deprecated unit test *)
val endorsement_rights :
  Alpha_context.t -&gt; Level.t -&gt; public_key_hash list tzresult Lwt.t

val baking_rights :
  Alpha_context.t -&gt;
  int option -&gt;
  (Raw_level.t * (public_key_hash * Time.t option) list) tzresult Lwt.t

val endorsing_power :
  Alpha_context.t -&gt;
  Alpha_context.packed_operation * Chain_id.t -&gt;
  int tzresult Lwt.t

val required_endorsements :
  Alpha_context.t -&gt; Alpha_context.Period.t -&gt; int tzresult Lwt.t

val minimal_valid_time : Alpha_context.t -&gt; int -&gt; int -&gt; Time.t tzresult Lwt.t

val register : unit -&gt; unit
</pre>
  </div>
  <div class="col-md-6">
    <a href="#delegate_services.mli"><code>Delegate_services_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Contract_repr.

Import Alpha_context.

Parameter __list_value : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt; option bool -&gt; option bool -&gt; unit -&gt;
  Lwt.t
    (Error_monad.shell_tzresult
      (list (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))).

Module info.
  Record record : Set := Build {
    balance : Alpha_context.Tez.t;
    frozen_balance : Alpha_context.Tez.t;
    frozen_balance_by_cycle :
      (|Alpha_context.Cycle.Map|).(S.MAP.t)
        Alpha_context.Delegate.frozen_balance;
    staking_balance : Alpha_context.Tez.t;
    delegated_contracts : list Contract_repr.t;
    delegated_balance : Alpha_context.Tez.t;
    deactivated : bool;
    grace_period : Alpha_context.Cycle.t }.
  Definition with_balance balance (r : record) :=
    Build balance r.(frozen_balance) r.(frozen_balance_by_cycle)
      r.(staking_balance) r.(delegated_contracts) r.(delegated_balance)
      r.(deactivated) r.(grace_period).
  Definition with_frozen_balance frozen_balance (r : record) :=
    Build r.(balance) frozen_balance r.(frozen_balance_by_cycle)
      r.(staking_balance) r.(delegated_contracts) r.(delegated_balance)
      r.(deactivated) r.(grace_period).
  Definition with_frozen_balance_by_cycle frozen_balance_by_cycle
    (r : record) :=
    Build r.(balance) r.(frozen_balance) frozen_balance_by_cycle
      r.(staking_balance) r.(delegated_contracts) r.(delegated_balance)
      r.(deactivated) r.(grace_period).
  Definition with_staking_balance staking_balance (r : record) :=
    Build r.(balance) r.(frozen_balance) r.(frozen_balance_by_cycle)
      staking_balance r.(delegated_contracts) r.(delegated_balance)
      r.(deactivated) r.(grace_period).
  Definition with_delegated_contracts delegated_contracts (r : record) :=
    Build r.(balance) r.(frozen_balance) r.(frozen_balance_by_cycle)
      r.(staking_balance) delegated_contracts r.(delegated_balance)
      r.(deactivated) r.(grace_period).
  Definition with_delegated_balance delegated_balance (r : record) :=
    Build r.(balance) r.(frozen_balance) r.(frozen_balance_by_cycle)
      r.(staking_balance) r.(delegated_contracts) delegated_balance
      r.(deactivated) r.(grace_period).
  Definition with_deactivated deactivated (r : record) :=
    Build r.(balance) r.(frozen_balance) r.(frozen_balance_by_cycle)
      r.(staking_balance) r.(delegated_contracts) r.(delegated_balance)
      deactivated r.(grace_period).
  Definition with_grace_period grace_period (r : record) :=
    Build r.(balance) r.(frozen_balance) r.(frozen_balance_by_cycle)
      r.(staking_balance) r.(delegated_contracts) r.(delegated_balance)
      r.(deactivated) grace_period.
End info.
Definition info := info.record.

Parameter info_encoding : Data_encoding.t info.

Parameter __info_value : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt;
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.shell_tzresult info).

Parameter balance : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt;
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.Tez.t).

Parameter __frozen_balance_value : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt;
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.Tez.t).

Parameter frozen_balance_by_cycle : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt;
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t
    (Error_monad.shell_tzresult
      ((|Alpha_context.Cycle.Map|).(S.MAP.t)
        Alpha_context.Delegate.frozen_balance)).

Parameter staking_balance : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt;
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.Tez.t).

Parameter delegated_contracts : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt;
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.shell_tzresult (list Contract_repr.t)).

Parameter delegated_balance : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt;
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.Tez.t).

Parameter deactivated : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt;
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.shell_tzresult bool).

Parameter grace_period : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt;
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.Cycle.t).

Module Baking_rights.
  Module t.
    Record record : Set := Build {
      level : Alpha_context.Raw_level.t;
      delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t);
      priority : int;
      timestamp : option Alpha_context.Timestamp.t }.
    Definition with_level level (r : record) :=
      Build level r.(delegate) r.(priority) r.(timestamp).
    Definition with_delegate delegate (r : record) :=
      Build r.(level) delegate r.(priority) r.(timestamp).
    Definition with_priority priority (r : record) :=
      Build r.(level) r.(delegate) priority r.(timestamp).
    Definition with_timestamp timestamp (r : record) :=
      Build r.(level) r.(delegate) r.(priority) timestamp.
  End t.
  Definition t := t.record.
  
  Parameter get : forall {a : Set},
    RPC_context.simple a -&gt; option (list Alpha_context.Raw_level.t) -&gt;
    option (list Alpha_context.Cycle.t) -&gt;
    option (list Signature.public_key_hash) -&gt; option bool -&gt; option int -&gt; a -&gt;
    Lwt.t (Error_monad.shell_tzresult (list t)).
End Baking_rights.

Module Endorsing_rights.
  Module t.
    Record record : Set := Build {
      level : Alpha_context.Raw_level.t;
      delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t);
      slots : list int;
      estimated_time : option Alpha_context.Timestamp.t }.
    Definition with_level level (r : record) :=
      Build level r.(delegate) r.(slots) r.(estimated_time).
    Definition with_delegate delegate (r : record) :=
      Build r.(level) delegate r.(slots) r.(estimated_time).
    Definition with_slots slots (r : record) :=
      Build r.(level) r.(delegate) slots r.(estimated_time).
    Definition with_estimated_time estimated_time (r : record) :=
      Build r.(level) r.(delegate) r.(slots) estimated_time.
  End t.
  Definition t := t.record.
  
  Parameter get : forall {a : Set},
    RPC_context.simple a -&gt; option (list Alpha_context.Raw_level.t) -&gt;
    option (list Alpha_context.Cycle.t) -&gt;
    option (list Signature.public_key_hash) -&gt; a -&gt;
    Lwt.t (Error_monad.shell_tzresult (list t)).
End Endorsing_rights.

Module Endorsing_power.
  Parameter get : forall {a : Set},
    RPC_context.simple a -&gt; a -&gt; Alpha_context.packed_operation -&gt;
    (|Chain_id|).(S.HASH.t) -&gt; Lwt.t (Error_monad.shell_tzresult int).
End Endorsing_power.

Module Required_endorsements.
  Parameter get : forall {a : Set},
    RPC_context.simple a -&gt; a -&gt; Alpha_context.Period.t -&gt;
    Lwt.t (Error_monad.shell_tzresult int).
End Required_endorsements.

Module Minimal_valid_time.
  Parameter get : forall {a : Set},
    RPC_context.simple a -&gt; a -&gt; int -&gt; int -&gt;
    Lwt.t (Error_monad.shell_tzresult Time.t).
End Minimal_valid_time.

Parameter endorsement_rights :
  Alpha_context.t -&gt; Alpha_context.Level.t -&gt;
  Lwt.t (Error_monad.tzresult (list Alpha_context.public_key_hash)).

Parameter baking_rights :
  Alpha_context.t -&gt; option int -&gt;
  Lwt.t
    (Error_monad.tzresult
      (Alpha_context.Raw_level.t *
        list (Alpha_context.public_key_hash * option Time.t))).

Parameter endorsing_power :
  Alpha_context.t -&gt; Alpha_context.packed_operation * (|Chain_id|).(S.HASH.t) -&gt;
  Lwt.t (Error_monad.tzresult int).

Parameter required_endorsements :
  Alpha_context.t -&gt; Alpha_context.Period.t -&gt; Lwt.t (Error_monad.tzresult int).

Parameter minimal_valid_time :
  Alpha_context.t -&gt; int -&gt; int -&gt; Lwt.t (Error_monad.tzresult Time.t).

Parameter register : unit -&gt; unit.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="delegate_storage.ml">
  <div style="margin: 20px;">
    <h3>Delegate_storage</h3>
    <ul>
      <li>OCaml size: 713 lines</li>
      <li>Coq size: 897 lines (+25% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#delegate_storage.ml"><code>delegate_storage.ml</code></a>&nbsp;<span class="label label-warning">11 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type balance =
  | Contract of Contract_repr.t
  | Rewards of Signature.Public_key_hash.t * Cycle_repr.t
  | Fees of Signature.Public_key_hash.t * Cycle_repr.t
  | Deposits of Signature.Public_key_hash.t * Cycle_repr.t

let balance_encoding =
  let open Data_encoding in
  def &quot;operation_metadata.alpha.balance&quot;
  @@ union
       [ case
           (Tag 0)
           ~title:&quot;Contract&quot;
           (obj2
              (req &quot;kind&quot; (constant &quot;contract&quot;))
              (req &quot;contract&quot; Contract_repr.encoding))
           (function Contract c -&gt; Some ((), c) | _ -&gt; None)
           (fun ((), c) -&gt; Contract c);
         case
           (Tag 1)
           ~title:&quot;Rewards&quot;
           (obj4
              (req &quot;kind&quot; (constant &quot;freezer&quot;))
              (req &quot;category&quot; (constant &quot;rewards&quot;))
              (req &quot;delegate&quot; Signature.Public_key_hash.encoding)
              (req &quot;cycle&quot; Cycle_repr.encoding))
           (function Rewards (d, l) -&gt; Some ((), (), d, l) | _ -&gt; None)
           (fun ((), (), d, l) -&gt; Rewards (d, l));
         case
           (Tag 2)
           ~title:&quot;Fees&quot;
           (obj4
              (req &quot;kind&quot; (constant &quot;freezer&quot;))
              (req &quot;category&quot; (constant &quot;fees&quot;))
              (req &quot;delegate&quot; Signature.Public_key_hash.encoding)
              (req &quot;cycle&quot; Cycle_repr.encoding))
           (function Fees (d, l) -&gt; Some ((), (), d, l) | _ -&gt; None)
           (fun ((), (), d, l) -&gt; Fees (d, l));
         case
           (Tag 3)
           ~title:&quot;Deposits&quot;
           (obj4
              (req &quot;kind&quot; (constant &quot;freezer&quot;))
              (req &quot;category&quot; (constant &quot;deposits&quot;))
              (req &quot;delegate&quot; Signature.Public_key_hash.encoding)
              (req &quot;cycle&quot; Cycle_repr.encoding))
           (function Deposits (d, l) -&gt; Some ((), (), d, l) | _ -&gt; None)
           (fun ((), (), d, l) -&gt; Deposits (d, l)) ]

type balance_update = Debited of Tez_repr.t | Credited of Tez_repr.t

let balance_update_encoding =
  let open Data_encoding in
  def &quot;operation_metadata.alpha.balance_update&quot;
  @@ obj1
       (req
          &quot;change&quot;
          (conv
             (function
               | Credited v -&gt;
                   Tez_repr.to_mutez v
               | Debited v -&gt;
                   Int64.neg (Tez_repr.to_mutez v))
             ( Json.wrap_error
             @@ fun v -&gt;
             if Compare.Int64.(v &lt; 0L) then
               match Tez_repr.of_mutez (Int64.neg v) with
               | Some v -&gt;
                   Debited v
               | None -&gt;
                   failwith &quot;Qty.of_mutez&quot;
             else
               match Tez_repr.of_mutez v with
               | Some v -&gt;
                   Credited v
               | None -&gt;
                   failwith &quot;Qty.of_mutez&quot; )
             int64))

type balance_updates = (balance * balance_update) list

let balance_updates_encoding =
  let open Data_encoding in
  def &quot;operation_metadata.alpha.balance_updates&quot;
  @@ list (merge_objs balance_encoding balance_update_encoding)

let cleanup_balance_updates balance_updates =
  List.filter
    (fun (_, (Credited update | Debited update)) -&gt;
      not (Tez_repr.equal update Tez_repr.zero))
    balance_updates

type frozen_balance = {
  deposit : Tez_repr.t;
  fees : Tez_repr.t;
  rewards : Tez_repr.t;
}

let frozen_balance_encoding =
  let open Data_encoding in
  conv
    (fun {deposit; fees; rewards} -&gt; (deposit, fees, rewards))
    (fun (deposit, fees, rewards) -&gt; {deposit; fees; rewards})
    (obj3
       (req &quot;deposit&quot; Tez_repr.encoding)
       (req &quot;fees&quot; Tez_repr.encoding)
       (req &quot;rewards&quot; Tez_repr.encoding))

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | No_deletion of Signature.Public_key_hash.t (* `Permanent *)
  | Active_delegate (* `Temporary *)
  | Current_delegate (* `Temporary *)
  | Empty_delegate_account of Signature.Public_key_hash.t (* `Temporary *)
  | Balance_too_low_for_deposit of {
      delegate : Signature.Public_key_hash.t;
      deposit : Tez_repr.t;
      balance : Tez_repr.t;
    }</abbr>

(* `Temporary *)

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  register_error_kind
    `Permanent
    ~id:&quot;delegate.no_deletion&quot;
    ~title:&quot;Forbidden delegate deletion&quot;
    ~description:&quot;Tried to unregister a delegate&quot;
    ~pp:(fun ppf delegate -&gt;
      Format.fprintf
        ppf
        &quot;Delegate deletion is forbidden (%a)&quot;
        Signature.Public_key_hash.pp
        delegate)
    Data_encoding.(obj1 (req &quot;delegate&quot; Signature.Public_key_hash.encoding))
    (function No_deletion c -&gt; Some c | _ -&gt; None)
    (fun c -&gt; No_deletion c) ;
  register_error_kind
    `Temporary
    ~id:&quot;delegate.already_active&quot;
    ~title:&quot;Delegate already active&quot;
    ~description:&quot;Useless delegate reactivation&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf ppf &quot;The delegate is still active, no need to refresh it&quot;)
    Data_encoding.empty
    (function Active_delegate -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Active_delegate) ;
  register_error_kind
    `Temporary
    ~id:&quot;delegate.unchanged&quot;
    ~title:&quot;Unchanged delegated&quot;
    ~description:&quot;Contract already delegated to the given delegate&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf
        ppf
        &quot;The contract is already delegated to the same delegate&quot;)
    Data_encoding.empty
    (function Current_delegate -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Current_delegate) ;
  register_error_kind
    `Permanent
    ~id:&quot;delegate.empty_delegate_account&quot;
    ~title:&quot;Empty delegate account&quot;
    ~description:
      &quot;Cannot register a delegate when its implicit account is empty&quot;
    ~pp:(fun ppf delegate -&gt;
      Format.fprintf
        ppf
        &quot;Delegate registration is forbidden when the delegate\n\
        \           implicit account is empty (%a)&quot;
        Signature.Public_key_hash.pp
        delegate)
    Data_encoding.(obj1 (req &quot;delegate&quot; Signature.Public_key_hash.encoding))
    (function Empty_delegate_account c -&gt; Some c | _ -&gt; None)
    (fun c -&gt; Empty_delegate_account c) ;
  register_error_kind
    `Temporary
    ~id:&quot;delegate.balance_too_low_for_deposit&quot;
    ~title:&quot;Balance too low for deposit&quot;
    ~description:&quot;Cannot freeze deposit when the balance is too low&quot;
    ~pp:(fun ppf (delegate, balance, deposit) -&gt;
      Format.fprintf
        ppf
        &quot;Delegate %a has a too low balance (%a) to deposit %a&quot;
        Signature.Public_key_hash.pp
        delegate
        Tez_repr.pp
        balance
        Tez_repr.pp
        deposit)
    Data_encoding.(
      obj3
        (req &quot;delegate&quot; Signature.Public_key_hash.encoding)
        (req &quot;balance&quot; Tez_repr.encoding)
        (req &quot;deposit&quot; Tez_repr.encoding))
    (function
      | Balance_too_low_for_deposit {delegate; balance; deposit} -&gt;
          Some (delegate, balance, deposit)
      | _ -&gt;
          None)
    (fun (delegate, balance, deposit) -&gt;
      Balance_too_low_for_deposit {delegate; balance; deposit})</abbr>

let link c contract delegate =
  Storage.Contract.Balance.get c contract
  &gt;&gt;=? fun balance -&gt;
  Roll_storage.Delegate.add_amount c delegate balance
  &gt;&gt;=? fun c -&gt;
  Storage.Contract.Delegated.add
    (c, Contract_repr.implicit_contract delegate)
    contract
  &gt;&gt;= fun c -&gt; return c

let unlink c contract =
  Storage.Contract.Balance.get c contract
  &gt;&gt;=? fun balance -&gt;
  Storage.Contract.Delegate.get_option c contract
  &gt;&gt;=? function
  | None -&gt;
      return c
  | Some delegate -&gt;
      (* Removes the balance of the contract from the delegate *)
      Roll_storage.Delegate.remove_amount c delegate balance
      &gt;&gt;=? fun c -&gt;
      Storage.Contract.Delegated.del
        (c, Contract_repr.implicit_contract delegate)
        contract
      &gt;&gt;= fun c -&gt; return c

let known c delegate =
  Storage.Contract.Manager.get_option
    c
    (Contract_repr.implicit_contract delegate)
  &gt;&gt;=? function
  | None | Some (Manager_repr.Hash _) -&gt;
      return_false
  | Some (Manager_repr.Public_key _) -&gt;
      return_true

(* A delegate is registered if its &quot;implicit account&quot; delegates to itself. *)
let registered c delegate =
  Storage.Contract.Delegate.get_option
    c
    (Contract_repr.implicit_contract delegate)
  &gt;&gt;=? function
  | Some current_delegate -&gt;
      return @@ Signature.Public_key_hash.equal delegate current_delegate
  | None -&gt;
      return_false

let init ctxt contract delegate =
  known ctxt delegate
  &gt;&gt;=? fun known_delegate -&gt;
  fail_unless known_delegate <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Roll_storage.Unregistered_delegate delegate)</abbr>
  &gt;&gt;=? fun () -&gt;
  registered ctxt delegate
  &gt;&gt;=? fun is_registered -&gt;
  fail_unless is_registered <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Roll_storage.Unregistered_delegate delegate)</abbr>
  &gt;&gt;=? fun () -&gt;
  Storage.Contract.Delegate.init ctxt contract delegate
  &gt;&gt;=? fun ctxt -&gt; link ctxt contract delegate

let get = Roll_storage.get_contract_delegate

let set c contract delegate =
  match delegate with
  | None -&gt; (
      let delete () =
        unlink c contract
        &gt;&gt;=? fun c -&gt;
        Storage.Contract.Delegate.remove c contract &gt;&gt;= fun c -&gt; return c
      in
      match Contract_repr.is_implicit contract with
      | Some pkh -&gt;
          (* check if contract is a registered delegate *)
          registered c pkh
          &gt;&gt;=? fun is_registered -&gt;
          if is_registered then fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(No_deletion pkh)</abbr> else delete ()
      | None -&gt;
          delete () )
  | Some delegate -&gt;
      known c delegate
      &gt;&gt;=? fun known_delegate -&gt;
      registered c delegate
      &gt;&gt;=? fun registered_delegate -&gt;
      let self_delegation =
        match Contract_repr.is_implicit contract with
        | Some pkh -&gt;
            Signature.Public_key_hash.equal pkh delegate
        | None -&gt;
            false
      in
      if (not known_delegate) || not (registered_delegate || self_delegation)
      then fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Roll_storage.Unregistered_delegate delegate)</abbr>
      else
        Storage.Contract.Delegate.get_option c contract
        &gt;&gt;=? (function
               | Some current_delegate
                 when Signature.Public_key_hash.equal delegate current_delegate
                 -&gt;
                   if self_delegation then
                     Roll_storage.Delegate.is_inactive c delegate
                     &gt;&gt;=? function
                     | true -&gt; return_unit | false -&gt; fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Active_delegate</abbr>
                   else fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Current_delegate</abbr>
               | None | Some _ -&gt;
                   return_unit)
        &gt;&gt;=? fun () -&gt;
        (* check if contract is a registered delegate *)
        ( match Contract_repr.is_implicit contract with
        | Some pkh -&gt;
            registered c pkh
            &gt;&gt;=? fun is_registered -&gt;
            (* allow self-delegation to re-activate *)
            if (not self_delegation) &amp;&amp; is_registered then
              fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(No_deletion pkh)</abbr>
            else return_unit
        | None -&gt;
            return_unit )
        &gt;&gt;=? fun () -&gt;
        Storage.Contract.Balance.mem c contract
        &gt;&gt;= fun exists -&gt;
        fail_when
          (self_delegation &amp;&amp; not exists)
          <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Empty_delegate_account delegate)</abbr>
        &gt;&gt;=? fun () -&gt;
        unlink c contract
        &gt;&gt;=? fun c -&gt;
        Storage.Contract.Delegate.init_set c contract delegate
        &gt;&gt;= fun c -&gt;
        link c contract delegate
        &gt;&gt;=? fun c -&gt;
        ( if self_delegation then
          Storage.Delegates.add c delegate
          &gt;&gt;= fun c -&gt;
          Roll_storage.Delegate.set_active c delegate &gt;&gt;=? fun c -&gt; return c
        else return c )
        &gt;&gt;=? fun c -&gt; return c

let remove ctxt contract = unlink ctxt contract

let delegated_contracts ctxt delegate =
  let contract = Contract_repr.implicit_contract delegate in
  Storage.Contract.Delegated.elements (ctxt, contract)

let get_frozen_deposit ctxt contract cycle =
  Storage.Contract.Frozen_deposits.get_option (ctxt, contract) cycle
  &gt;&gt;=? function None -&gt; return Tez_repr.zero | Some frozen -&gt; return frozen

let credit_frozen_deposit ctxt delegate cycle amount =
  let contract = Contract_repr.implicit_contract delegate in
  get_frozen_deposit ctxt contract cycle
  &gt;&gt;=? fun old_amount -&gt;
  Lwt.return Tez_repr.(old_amount +? amount)
  &gt;&gt;=? fun new_amount -&gt;
  Storage.Contract.Frozen_deposits.init_set (ctxt, contract) cycle new_amount
  &gt;&gt;= fun ctxt -&gt;
  Storage.Delegates_with_frozen_balance.add (ctxt, cycle) delegate
  &gt;&gt;= fun ctxt -&gt; return ctxt

let freeze_deposit ctxt delegate amount =
  let {Level_repr.cycle; _} = Level_storage.current ctxt in
  Roll_storage.Delegate.set_active ctxt delegate
  &gt;&gt;=? fun ctxt -&gt;
  let contract = Contract_repr.implicit_contract delegate in
  Storage.Contract.Balance.get ctxt contract
  &gt;&gt;=? fun balance -&gt;
  Lwt.return
    (record_trace
       <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Balance_too_low_for_deposit {delegate; deposit = amount; balance})</abbr>
       Tez_repr.(balance -? amount))
  &gt;&gt;=? fun new_balance -&gt;
  Storage.Contract.Balance.set ctxt contract new_balance
  &gt;&gt;=? fun ctxt -&gt; credit_frozen_deposit ctxt delegate cycle amount

let get_frozen_fees ctxt contract cycle =
  Storage.Contract.Frozen_fees.get_option (ctxt, contract) cycle
  &gt;&gt;=? function None -&gt; return Tez_repr.zero | Some frozen -&gt; return frozen

let credit_frozen_fees ctxt delegate cycle amount =
  let contract = Contract_repr.implicit_contract delegate in
  get_frozen_fees ctxt contract cycle
  &gt;&gt;=? fun old_amount -&gt;
  Lwt.return Tez_repr.(old_amount +? amount)
  &gt;&gt;=? fun new_amount -&gt;
  Storage.Contract.Frozen_fees.init_set (ctxt, contract) cycle new_amount
  &gt;&gt;= fun ctxt -&gt;
  Storage.Delegates_with_frozen_balance.add (ctxt, cycle) delegate
  &gt;&gt;= fun ctxt -&gt; return ctxt

let freeze_fees ctxt delegate amount =
  let {Level_repr.cycle; _} = Level_storage.current ctxt in
  Roll_storage.Delegate.add_amount ctxt delegate amount
  &gt;&gt;=? fun ctxt -&gt; credit_frozen_fees ctxt delegate cycle amount

let burn_fees ctxt delegate cycle amount =
  let contract = Contract_repr.implicit_contract delegate in
  get_frozen_fees ctxt contract cycle
  &gt;&gt;=? fun old_amount -&gt;
  ( match Tez_repr.(old_amount -? amount) with
  | Ok new_amount -&gt;
      Roll_storage.Delegate.remove_amount ctxt delegate amount
      &gt;&gt;=? fun ctxt -&gt; return (new_amount, ctxt)
  | Error _ -&gt;
      Roll_storage.Delegate.remove_amount ctxt delegate old_amount
      &gt;&gt;=? fun ctxt -&gt; return (Tez_repr.zero, ctxt) )
  &gt;&gt;=? fun (new_amount, ctxt) -&gt;
  Storage.Contract.Frozen_fees.init_set (ctxt, contract) cycle new_amount
  &gt;&gt;= fun ctxt -&gt; return ctxt

let get_frozen_rewards ctxt contract cycle =
  Storage.Contract.Frozen_rewards.get_option (ctxt, contract) cycle
  &gt;&gt;=? function None -&gt; return Tez_repr.zero | Some frozen -&gt; return frozen

let credit_frozen_rewards ctxt delegate cycle amount =
  let contract = Contract_repr.implicit_contract delegate in
  get_frozen_rewards ctxt contract cycle
  &gt;&gt;=? fun old_amount -&gt;
  Lwt.return Tez_repr.(old_amount +? amount)
  &gt;&gt;=? fun new_amount -&gt;
  Storage.Contract.Frozen_rewards.init_set (ctxt, contract) cycle new_amount
  &gt;&gt;= fun ctxt -&gt;
  Storage.Delegates_with_frozen_balance.add (ctxt, cycle) delegate
  &gt;&gt;= fun ctxt -&gt; return ctxt

let freeze_rewards ctxt delegate amount =
  let {Level_repr.cycle; _} = Level_storage.current ctxt in
  credit_frozen_rewards ctxt delegate cycle amount

let burn_rewards ctxt delegate cycle amount =
  let contract = Contract_repr.implicit_contract delegate in
  get_frozen_rewards ctxt contract cycle
  &gt;&gt;=? fun old_amount -&gt;
  let new_amount =
    match Tez_repr.(old_amount -? amount) with
    | Error _ -&gt;
        Tez_repr.zero
    | Ok new_amount -&gt;
        new_amount
  in
  Storage.Contract.Frozen_rewards.init_set (ctxt, contract) cycle new_amount
  &gt;&gt;= fun ctxt -&gt; return ctxt

let unfreeze ctxt delegate cycle =
  let contract = Contract_repr.implicit_contract delegate in
  get_frozen_deposit ctxt contract cycle
  &gt;&gt;=? fun deposit -&gt;
  get_frozen_fees ctxt contract cycle
  &gt;&gt;=? fun fees -&gt;
  get_frozen_rewards ctxt contract cycle
  &gt;&gt;=? fun rewards -&gt;
  Storage.Contract.Balance.get ctxt contract
  &gt;&gt;=? fun balance -&gt;
  Lwt.return Tez_repr.(deposit +? fees)
  &gt;&gt;=? fun unfrozen_amount -&gt;
  Lwt.return Tez_repr.(unfrozen_amount +? rewards)
  &gt;&gt;=? fun unfrozen_amount -&gt;
  Lwt.return Tez_repr.(balance +? unfrozen_amount)
  &gt;&gt;=? fun balance -&gt;
  Storage.Contract.Balance.set ctxt contract balance
  &gt;&gt;=? fun ctxt -&gt;
  Roll_storage.Delegate.add_amount ctxt delegate rewards
  &gt;&gt;=? fun ctxt -&gt;
  Storage.Contract.Frozen_deposits.remove (ctxt, contract) cycle
  &gt;&gt;= fun ctxt -&gt;
  Storage.Contract.Frozen_fees.remove (ctxt, contract) cycle
  &gt;&gt;= fun ctxt -&gt;
  Storage.Contract.Frozen_rewards.remove (ctxt, contract) cycle
  &gt;&gt;= fun ctxt -&gt;
  return
    ( ctxt,
      cleanup_balance_updates
        [ (Deposits (delegate, cycle), Debited deposit);
          (Fees (delegate, cycle), Debited fees);
          (Rewards (delegate, cycle), Debited rewards);
          ( Contract (Contract_repr.implicit_contract delegate),
            Credited unfrozen_amount ) ] )

let cycle_end ctxt last_cycle unrevealed =
  let preserved = Constants_storage.preserved_cycles ctxt in
  ( match Cycle_repr.pred last_cycle with
  | None -&gt;
      return (ctxt, [])
  | Some revealed_cycle -&gt;
      List.fold_left
        (fun acc (u : Nonce_storage.unrevealed) -&gt;
          acc
          &gt;&gt;=? fun (ctxt, balance_updates) -&gt;
          burn_fees ctxt u.delegate revealed_cycle u.fees
          &gt;&gt;=? fun ctxt -&gt;
          burn_rewards ctxt u.delegate revealed_cycle u.rewards
          &gt;&gt;=? fun ctxt -&gt;
          let bus =
            [ (Fees (u.delegate, revealed_cycle), Debited u.fees);
              (Rewards (u.delegate, revealed_cycle), Debited u.rewards) ]
          in
          return (ctxt, bus @ balance_updates))
        (return (ctxt, []))
        unrevealed )
  &gt;&gt;=? fun (ctxt, balance_updates) -&gt;
  match Cycle_repr.sub last_cycle preserved with
  | None -&gt;
      return (ctxt, balance_updates, [])
  | Some unfrozen_cycle -&gt;
      Storage.Delegates_with_frozen_balance.fold
        (ctxt, unfrozen_cycle)
        ~init:(Ok (ctxt, balance_updates))
        ~f:(fun delegate acc -&gt;
          Lwt.return acc
          &gt;&gt;=? fun (ctxt, bus) -&gt;
          unfreeze ctxt delegate unfrozen_cycle
          &gt;&gt;=? fun (ctxt, balance_updates) -&gt;
          return (ctxt, balance_updates @ bus))
      &gt;&gt;=? fun (ctxt, balance_updates) -&gt;
      Storage.Delegates_with_frozen_balance.clear (ctxt, unfrozen_cycle)
      &gt;&gt;= fun ctxt -&gt;
      Storage.Active_delegates_with_rolls.fold
        ctxt
        ~init:(Ok (ctxt, []))
        ~f:(fun delegate acc -&gt;
          Lwt.return acc
          &gt;&gt;=? fun (ctxt, deactivated) -&gt;
          Storage.Contract.Delegate_desactivation.get
            ctxt
            (Contract_repr.implicit_contract delegate)
          &gt;&gt;=? fun cycle -&gt;
          if Cycle_repr.(cycle &lt;= last_cycle) then
            Roll_storage.Delegate.set_inactive ctxt delegate
            &gt;&gt;=? fun ctxt -&gt; return (ctxt, delegate :: deactivated)
          else return (ctxt, deactivated))
      &gt;&gt;=? fun (ctxt, deactivated) -&gt;
      return (ctxt, balance_updates, deactivated)

let punish ctxt delegate cycle =
  let contract = Contract_repr.implicit_contract delegate in
  get_frozen_deposit ctxt contract cycle
  &gt;&gt;=? fun deposit -&gt;
  get_frozen_fees ctxt contract cycle
  &gt;&gt;=? fun fees -&gt;
  get_frozen_rewards ctxt contract cycle
  &gt;&gt;=? fun rewards -&gt;
  Roll_storage.Delegate.remove_amount ctxt delegate deposit
  &gt;&gt;=? fun ctxt -&gt;
  Roll_storage.Delegate.remove_amount ctxt delegate fees
  &gt;&gt;=? fun ctxt -&gt;
  (* Rewards are not accounted in the delegate's rolls yet... *)
  Storage.Contract.Frozen_deposits.remove (ctxt, contract) cycle
  &gt;&gt;= fun ctxt -&gt;
  Storage.Contract.Frozen_fees.remove (ctxt, contract) cycle
  &gt;&gt;= fun ctxt -&gt;
  Storage.Contract.Frozen_rewards.remove (ctxt, contract) cycle
  &gt;&gt;= fun ctxt -&gt; return (ctxt, {deposit; fees; rewards})

let has_frozen_balance ctxt delegate cycle =
  let contract = Contract_repr.implicit_contract delegate in
  get_frozen_deposit ctxt contract cycle
  &gt;&gt;=? fun deposit -&gt;
  if Tez_repr.(deposit &lt;&gt; zero) then return_true
  else
    get_frozen_fees ctxt contract cycle
    &gt;&gt;=? fun fees -&gt;
    if Tez_repr.(fees &lt;&gt; zero) then return_true
    else
      get_frozen_rewards ctxt contract cycle
      &gt;&gt;=? fun rewards -&gt; return Tez_repr.(rewards &lt;&gt; zero)

let frozen_balance_by_cycle_encoding =
  let open Data_encoding in
  conv
    Cycle_repr.Map.bindings
    (List.fold_left
       (fun m (c, b) -&gt; Cycle_repr.Map.add c b m)
       Cycle_repr.Map.empty)
    (list
       (merge_objs
          (obj1 (req &quot;cycle&quot; Cycle_repr.encoding))
          frozen_balance_encoding))

let empty_frozen_balance =
  {deposit = Tez_repr.zero; fees = Tez_repr.zero; rewards = Tez_repr.zero}

let frozen_balance_by_cycle ctxt delegate =
  let contract = Contract_repr.implicit_contract delegate in
  let map = Cycle_repr.Map.empty in
  Storage.Contract.Frozen_deposits.fold
    (ctxt, contract)
    ~init:map
    ~f:(fun cycle amount map -&gt;
      Lwt.return
        (Cycle_repr.Map.add
           cycle
           {empty_frozen_balance with deposit = amount}
           map))
  &gt;&gt;= fun map -&gt;
  Storage.Contract.Frozen_fees.fold
    (ctxt, contract)
    ~init:map
    ~f:(fun cycle amount map -&gt;
      let balance =
        match Cycle_repr.Map.find_opt cycle map with
        | None -&gt;
            empty_frozen_balance
        | Some balance -&gt;
            balance
      in
      Lwt.return (Cycle_repr.Map.add cycle {balance with fees = amount} map))
  &gt;&gt;= fun map -&gt;
  Storage.Contract.Frozen_rewards.fold
    (ctxt, contract)
    ~init:map
    ~f:(fun cycle amount map -&gt;
      let balance =
        match Cycle_repr.Map.find_opt cycle map with
        | None -&gt;
            empty_frozen_balance
        | Some balance -&gt;
            balance
      in
      Lwt.return (Cycle_repr.Map.add cycle {balance with rewards = amount} map))
  &gt;&gt;= fun map -&gt; Lwt.return map

let frozen_balance ctxt delegate =
  let contract = Contract_repr.implicit_contract delegate in
  let balance = Ok Tez_repr.zero in
  Storage.Contract.Frozen_deposits.fold
    (ctxt, contract)
    ~init:balance
    ~f:(fun _cycle amount acc -&gt;
      Lwt.return acc &gt;&gt;=? fun acc -&gt; Lwt.return Tez_repr.(acc +? amount))
  &gt;&gt;= fun balance -&gt;
  Storage.Contract.Frozen_fees.fold
    (ctxt, contract)
    ~init:balance
    ~f:(fun _cycle amount acc -&gt;
      Lwt.return acc &gt;&gt;=? fun acc -&gt; Lwt.return Tez_repr.(acc +? amount))
  &gt;&gt;= fun balance -&gt;
  Storage.Contract.Frozen_rewards.fold
    (ctxt, contract)
    ~init:balance
    ~f:(fun _cycle amount acc -&gt;
      Lwt.return acc &gt;&gt;=? fun acc -&gt; Lwt.return Tez_repr.(acc +? amount))
  &gt;&gt;= fun balance -&gt; Lwt.return balance

let full_balance ctxt delegate =
  let contract = Contract_repr.implicit_contract delegate in
  frozen_balance ctxt delegate
  &gt;&gt;=? fun frozen_balance -&gt;
  Storage.Contract.Balance.get ctxt contract
  &gt;&gt;=? fun balance -&gt; Lwt.return Tez_repr.(frozen_balance +? balance)

let deactivated = Roll_storage.Delegate.is_inactive

let grace_period ctxt delegate =
  let contract = Contract_repr.implicit_contract delegate in
  Storage.Contract.Delegate_desactivation.get ctxt contract

let staking_balance ctxt delegate =
  let token_per_rolls = Constants_storage.tokens_per_roll ctxt in
  Roll_storage.get_rolls ctxt delegate
  &gt;&gt;=? fun rolls -&gt;
  Roll_storage.get_change ctxt delegate
  &gt;&gt;=? fun change -&gt;
  let rolls = Int64.of_int (List.length rolls) in
  Lwt.return Tez_repr.(token_per_rolls *? rolls)
  &gt;&gt;=? fun balance -&gt; Lwt.return Tez_repr.(balance +? change)

let delegated_balance ctxt delegate =
  let contract = Contract_repr.implicit_contract delegate in
  staking_balance ctxt delegate
  &gt;&gt;=? fun staking_balance -&gt;
  Storage.Contract.Balance.get ctxt contract
  &gt;&gt;= fun self_staking_balance -&gt;
  Storage.Contract.Frozen_deposits.fold
    (ctxt, contract)
    ~init:self_staking_balance
    ~f:(fun _cycle amount acc -&gt;
      Lwt.return acc &gt;&gt;=? fun acc -&gt; Lwt.return Tez_repr.(acc +? amount))
  &gt;&gt;= fun self_staking_balance -&gt;
  Storage.Contract.Frozen_fees.fold
    (ctxt, contract)
    ~init:self_staking_balance
    ~f:(fun _cycle amount acc -&gt;
      Lwt.return acc &gt;&gt;=? fun acc -&gt; Lwt.return Tez_repr.(acc +? amount))
  &gt;&gt;=? fun self_staking_balance -&gt;
  Lwt.return Tez_repr.(staking_balance -? self_staking_balance)

let fold = Storage.Delegates.fold

let list = Storage.Delegates.elements
</pre>
  </div>
  <div class="col-md-6">
    <a href="#delegate_storage.ml"><code>Delegate_storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Constants_storage.
Require Tezos.Contract_repr.
Require Tezos.Cycle_repr.
Require Tezos.Level_repr.
Require Tezos.Level_storage.
Require Tezos.Manager_repr.
Require Tezos.Nonce_storage.
Require Tezos.Raw_context.
Require Tezos.Roll_storage.
Require Tezos.Storage_mli. Module Storage := Storage_mli.
Require Tezos.Storage_sigs.
Require Tezos.Tez_repr.

Inductive balance : Set :=
| Contract : Contract_repr.t -&gt; balance
| Rewards :
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt; Cycle_repr.t -&gt;
  balance
| Fees :
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt; Cycle_repr.t -&gt;
  balance
| Deposits :
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt; Cycle_repr.t -&gt;
  balance.

Definition balance_encoding : Data_encoding.encoding balance :=
  (let arg := Data_encoding.def &quot;operation_metadata.alpha.balance&quot; in
  fun eta =&gt; arg None None eta)
    (Data_encoding.union None
      [
        Data_encoding.__case_value &quot;Contract&quot; None (Data_encoding.Tag 0)
          (Data_encoding.obj2
            (Data_encoding.req None None &quot;kind&quot;
              (Data_encoding.constant &quot;contract&quot;))
            (Data_encoding.req None None &quot;contract&quot;
              Contract_repr.encoding))
          (fun function_parameter =&gt;
            match function_parameter with
            | Contract c =&gt; Some (tt, c)
            | _ =&gt; None
            end)
          (fun function_parameter =&gt;
            let '(_, c) := function_parameter in
            Contract c);
        Data_encoding.__case_value &quot;Rewards&quot; None (Data_encoding.Tag 1)
          (Data_encoding.obj4
            (Data_encoding.req None None &quot;kind&quot;
              (Data_encoding.constant &quot;freezer&quot;))
            (Data_encoding.req None None &quot;category&quot;
              (Data_encoding.constant &quot;rewards&quot;))
            (Data_encoding.req None None &quot;delegate&quot;
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding))
            (Data_encoding.req None None &quot;cycle&quot; Cycle_repr.encoding))
          (fun function_parameter =&gt;
            match function_parameter with
            | Rewards d l =&gt; Some (tt, tt, d, l)
            | _ =&gt; None
            end)
          (fun function_parameter =&gt;
            let '(_, _, d, l) := function_parameter in
            Rewards d l);
        Data_encoding.__case_value &quot;Fees&quot; None (Data_encoding.Tag 2)
          (Data_encoding.obj4
            (Data_encoding.req None None &quot;kind&quot;
              (Data_encoding.constant &quot;freezer&quot;))
            (Data_encoding.req None None &quot;category&quot;
              (Data_encoding.constant &quot;fees&quot;))
            (Data_encoding.req None None &quot;delegate&quot;
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding))
            (Data_encoding.req None None &quot;cycle&quot; Cycle_repr.encoding))
          (fun function_parameter =&gt;
            match function_parameter with
            | Fees d l =&gt; Some (tt, tt, d, l)
            | _ =&gt; None
            end)
          (fun function_parameter =&gt;
            let '(_, _, d, l) := function_parameter in
            Fees d l);
        Data_encoding.__case_value &quot;Deposits&quot; None (Data_encoding.Tag 3)
          (Data_encoding.obj4
            (Data_encoding.req None None &quot;kind&quot;
              (Data_encoding.constant &quot;freezer&quot;))
            (Data_encoding.req None None &quot;category&quot;
              (Data_encoding.constant &quot;deposits&quot;))
            (Data_encoding.req None None &quot;delegate&quot;
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding))
            (Data_encoding.req None None &quot;cycle&quot; Cycle_repr.encoding))
          (fun function_parameter =&gt;
            match function_parameter with
            | Deposits d l =&gt; Some (tt, tt, d, l)
            | _ =&gt; None
            end)
          (fun function_parameter =&gt;
            let '(_, _, d, l) := function_parameter in
            Deposits d l)
      ]).

Inductive balance_update : Set :=
| Debited : Tez_repr.t -&gt; balance_update
| Credited : Tez_repr.t -&gt; balance_update.

Definition balance_update_encoding : Data_encoding.encoding balance_update :=
  (let arg := Data_encoding.def &quot;operation_metadata.alpha.balance_update&quot; in
  fun eta =&gt; arg None None eta)
    (Data_encoding.obj1
      (Data_encoding.req None None &quot;change&quot;
        (Data_encoding.conv
          (fun function_parameter =&gt;
            match function_parameter with
            | Credited v =&gt; Tez_repr.to_mutez v
            | Debited v =&gt; Int64.neg (Tez_repr.to_mutez v)
            end)
          (Data_encoding.Json.wrap_error
            (fun v =&gt;
              if
                (|Compare.Int64|).(Compare.S.op_lt) v
                  (* ‚ùå Constant of type int64 is converted to int *)
                  0 then
                match Tez_repr.of_mutez (Int64.neg v) with
                | Some v =&gt; Debited v
                | None =&gt; Pervasives.failwith &quot;Qty.of_mutez&quot;
                end
              else
                match Tez_repr.of_mutez v with
                | Some v =&gt; Credited v
                | None =&gt; Pervasives.failwith &quot;Qty.of_mutez&quot;
                end)) None Data_encoding.__int64_value))).

Definition balance_updates : Set := list (balance * balance_update).

Definition balance_updates_encoding
  : Data_encoding.encoding (list (balance * balance_update)) :=
  (let arg := Data_encoding.def &quot;operation_metadata.alpha.balance_updates&quot; in
  fun eta =&gt; arg None None eta)
    (Data_encoding.__list_value None
      (Data_encoding.merge_objs balance_encoding balance_update_encoding)).

Definition cleanup_balance_updates {A : Set}
  (balance_updates : list (A * balance_update)) : list (A * balance_update) :=
  List.filter
    (fun function_parameter =&gt;
      match function_parameter with
      | (_, (Credited update | Debited update)) =&gt;
        Pervasives.not (Tez_repr.equal update Tez_repr.zero)
      end) balance_updates.

Module frozen_balance.
  Record record : Set := Build {
    deposit : Tez_repr.t;
    fees : Tez_repr.t;
    rewards : Tez_repr.t }.
  Definition with_deposit deposit (r : record) :=
    Build deposit r.(fees) r.(rewards).
  Definition with_fees fees (r : record) :=
    Build r.(deposit) fees r.(rewards).
  Definition with_rewards rewards (r : record) :=
    Build r.(deposit) r.(fees) rewards.
End frozen_balance.
Definition frozen_balance := frozen_balance.record.

Definition frozen_balance_encoding : Data_encoding.encoding frozen_balance :=
  Data_encoding.conv
    (fun function_parameter =&gt;
      let '{|
        frozen_balance.deposit := deposit;
          frozen_balance.fees := fees;
          frozen_balance.rewards := rewards
          |} := function_parameter in
      (deposit, fees, rewards))
    (fun function_parameter =&gt;
      let '(deposit, fees, rewards) := function_parameter in
      {| frozen_balance.deposit := deposit; frozen_balance.fees := fees;
        frozen_balance.rewards := rewards |}) None
    (Data_encoding.obj3
      (Data_encoding.req None None &quot;deposit&quot; Tez_repr.encoding)
      (Data_encoding.req None None &quot;fees&quot; Tez_repr.encoding)
      (Data_encoding.req None None &quot;rewards&quot; Tez_repr.encoding)).

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition link
  (c : (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.context))
  (contract :
    (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.key))
  (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let=? balance :=
    (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.get) c
      contract in
  let=? c := Roll_storage.Delegate.add_amount c delegate balance in
  let= c :=
    (|Storage.Contract.Delegated|).(Storage_sigs.Data_set_storage.add)
      (c, (Contract_repr.implicit_contract delegate)) contract in
  Error_monad.__return c.

Definition unlink
  (c : (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.context))
  (contract :
    (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t
    (Error_monad.tzresult
      (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.context)) :=
  let=? balance :=
    (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.get) c
      contract in
  let=? function_parameter :=
    (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.get_option)
      c contract in
  match function_parameter with
  | None =&gt; Error_monad.__return c
  | Some delegate =&gt;
    let=? c := Roll_storage.Delegate.remove_amount c delegate balance in
    let= c :=
      (|Storage.Contract.Delegated|).(Storage_sigs.Data_set_storage.del)
        (c, (Contract_repr.implicit_contract delegate)) contract in
    Error_monad.__return c
  end.

Definition known
  (c : (|Storage.Contract.Manager|).(Storage_sigs.Indexed_data_storage.context))
  (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.tzresult bool) :=
  let=? function_parameter :=
    (|Storage.Contract.Manager|).(Storage_sigs.Indexed_data_storage.get_option)
      c (Contract_repr.implicit_contract delegate) in
  match function_parameter with
  | (None | Some (Manager_repr.Hash _)) =&gt; Error_monad.return_false
  | Some (Manager_repr.Public_key _) =&gt; Error_monad.return_true
  end.

Definition registered
  (c : (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.context))
  (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.tzresult bool) :=
  let=? function_parameter :=
    (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.get_option)
      c (Contract_repr.implicit_contract delegate) in
  match function_parameter with
  | Some current_delegate =&gt;
    Error_monad.__return
      ((|Signature.Public_key_hash|).(S.SPublic_key_hash.equal) delegate
        current_delegate)
  | None =&gt; Error_monad.return_false
  end.

Definition init
  (ctxt :
    (|Storage.Contract.Manager|).(Storage_sigs.Indexed_data_storage.context))
  (contract :
    (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.key))
  (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let=? known_delegate := known ctxt delegate in
  let=? '_ := Error_monad.fail_unless known_delegate extensible_type_value in
  let=? is_registered := registered ctxt delegate in
  let=? '_ := Error_monad.fail_unless is_registered extensible_type_value in
  let=? ctxt :=
    (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.init) ctxt
      contract delegate in
  link ctxt contract delegate.

Definition get
  : Raw_context.t -&gt; Contract_repr.t -&gt;
  Lwt.t
    (Error_monad.tzresult
      (option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))) :=
  Roll_storage.get_contract_delegate.

Definition set
  (c : (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.context))
  (contract :
    (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.key))
  (delegate : option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  match delegate with
  | None =&gt;
    let delete (function_parameter : unit)
      : Lwt.t (Error_monad.tzresult Raw_context.t) :=
      let '_ := function_parameter in
      let=? c := unlink c contract in
      let= c :=
        (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.remove)
          c contract in
      Error_monad.__return c in
    match Contract_repr.is_implicit contract with
    | Some pkh =&gt;
      let=? is_registered := registered c pkh in
      if is_registered then
        Error_monad.fail extensible_type_value
      else
        delete tt
    | None =&gt; delete tt
    end
  | Some delegate =&gt;
    let=? known_delegate := known c delegate in
    let=? registered_delegate := registered c delegate in
    let self_delegation :=
      match Contract_repr.is_implicit contract with
      | Some pkh =&gt;
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.equal) pkh delegate
      | None =&gt; false
      end in
    if
      Pervasives.op_pipepipe (Pervasives.not known_delegate)
        (Pervasives.not
          (Pervasives.op_pipepipe registered_delegate self_delegation)) then
      Error_monad.fail extensible_type_value
    else
      let=? '_ :=
        let=? function_parameter :=
          (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.get_option)
            c contract in
        match
          (function_parameter,
            match function_parameter with
            | Some current_delegate =&gt;
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.equal) delegate
                current_delegate
            | _ =&gt; false
            end) with
        | (Some current_delegate, true) =&gt;
          if self_delegation then
            let=? function_parameter :=
              Roll_storage.Delegate.is_inactive c delegate in
            match function_parameter with
            | true =&gt; Error_monad.return_unit
            | false =&gt; Error_monad.fail extensible_type_value
            end
          else
            Error_monad.fail extensible_type_value
        | ((None | Some _), _) =&gt; Error_monad.return_unit
        end in
      let=? '_ :=
        match Contract_repr.is_implicit contract with
        | Some pkh =&gt;
          let=? is_registered := registered c pkh in
          if Pervasives.op_andand (Pervasives.not self_delegation) is_registered
            then
            Error_monad.fail extensible_type_value
          else
            Error_monad.return_unit
        | None =&gt; Error_monad.return_unit
        end in
      let= __exists :=
        (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.mem) c
          contract in
      let=? '_ :=
        Error_monad.fail_when
          (Pervasives.op_andand self_delegation (Pervasives.not __exists))
          extensible_type_value in
      let=? c := unlink c contract in
      let= c :=
        (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.init_set)
          c contract delegate in
      let=? c := link c contract delegate in
      let=? c :=
        if self_delegation then
          let= c :=
            (|Storage.Delegates|).(Storage_sigs.Data_set_storage.add) c delegate
            in
          let=? c := Roll_storage.Delegate.set_active c delegate in
          Error_monad.__return c
        else
          Error_monad.__return c in
      Error_monad.__return c
  end.

Definition remove
  (ctxt :
    (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.context))
  (contract :
    (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t
    (Error_monad.tzresult
      (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.context)) :=
  unlink ctxt contract.

Definition delegated_contracts
  (ctxt : Raw_context.t)
  (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t
    (list (|Storage.Contract.Delegated|).(Storage_sigs.Data_set_storage.elt)) :=
  let contract := Contract_repr.implicit_contract delegate in
  (|Storage.Contract.Delegated|).(Storage_sigs.Data_set_storage.elements)
    (ctxt, contract).

Definition get_frozen_deposit
  (ctxt : Raw_context.t) (contract : Contract_repr.t)
  (cycle :
    (|Storage.Contract.Frozen_deposits|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t (Error_monad.tzresult Tez_repr.t) :=
  let=? function_parameter :=
    (|Storage.Contract.Frozen_deposits|).(Storage_sigs.Indexed_data_storage.get_option)
      (ctxt, contract) cycle in
  match function_parameter with
  | None =&gt; Error_monad.__return Tez_repr.zero
  | Some frozen =&gt; Error_monad.__return frozen
  end.

Definition credit_frozen_deposit
  (ctxt : Raw_context.t)
  (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  (cycle :
    (|Storage.Contract.Frozen_deposits|).(Storage_sigs.Indexed_data_storage.key))
  (amount : Tez_repr.t) : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let contract := Contract_repr.implicit_contract delegate in
  let=? old_amount := get_frozen_deposit ctxt contract cycle in
  let=? new_amount := Lwt.__return (Tez_repr.op_plusquestion old_amount amount)
    in
  let= ctxt :=
    (|Storage.Contract.Frozen_deposits|).(Storage_sigs.Indexed_data_storage.init_set)
      (ctxt, contract) cycle new_amount in
  let= ctxt :=
    (|Storage.Delegates_with_frozen_balance|).(Storage_sigs.Data_set_storage.add)
      (ctxt, cycle) delegate in
  Error_monad.__return ctxt.

Definition freeze_deposit
  (ctxt : Raw_context.t)
  (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  (amount : Tez_repr.t) : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let '{| Level_repr.t.cycle := cycle |} := Level_storage.current ctxt in
  let=? ctxt := Roll_storage.Delegate.set_active ctxt delegate in
  let contract := Contract_repr.implicit_contract delegate in
  let=? balance :=
    (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.get) ctxt
      contract in
  let=? new_balance :=
    Lwt.__return
      (Error_monad.record_trace extensible_type_value
        (Tez_repr.op_minusquestion balance amount)) in
  let=? ctxt :=
    (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.set) ctxt
      contract new_balance in
  credit_frozen_deposit ctxt delegate cycle amount.

Definition get_frozen_fees
  (ctxt : Raw_context.t) (contract : Contract_repr.t)
  (cycle :
    (|Storage.Contract.Frozen_fees|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t (Error_monad.tzresult Tez_repr.t) :=
  let=? function_parameter :=
    (|Storage.Contract.Frozen_fees|).(Storage_sigs.Indexed_data_storage.get_option)
      (ctxt, contract) cycle in
  match function_parameter with
  | None =&gt; Error_monad.__return Tez_repr.zero
  | Some frozen =&gt; Error_monad.__return frozen
  end.

Definition credit_frozen_fees
  (ctxt : Raw_context.t)
  (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  (cycle :
    (|Storage.Contract.Frozen_fees|).(Storage_sigs.Indexed_data_storage.key))
  (amount : Tez_repr.t) : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let contract := Contract_repr.implicit_contract delegate in
  let=? old_amount := get_frozen_fees ctxt contract cycle in
  let=? new_amount := Lwt.__return (Tez_repr.op_plusquestion old_amount amount)
    in
  let= ctxt :=
    (|Storage.Contract.Frozen_fees|).(Storage_sigs.Indexed_data_storage.init_set)
      (ctxt, contract) cycle new_amount in
  let= ctxt :=
    (|Storage.Delegates_with_frozen_balance|).(Storage_sigs.Data_set_storage.add)
      (ctxt, cycle) delegate in
  Error_monad.__return ctxt.

Definition freeze_fees
  (ctxt : Raw_context.t)
  (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  (amount : Tez_repr.t) : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let '{| Level_repr.t.cycle := cycle |} := Level_storage.current ctxt in
  let=? ctxt := Roll_storage.Delegate.add_amount ctxt delegate amount in
  credit_frozen_fees ctxt delegate cycle amount.

Definition burn_fees
  (ctxt : Raw_context.t)
  (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  (cycle :
    (|Storage.Contract.Frozen_fees|).(Storage_sigs.Indexed_data_storage.key))
  (amount : Tez_repr.t) : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let contract := Contract_repr.implicit_contract delegate in
  let=? old_amount := get_frozen_fees ctxt contract cycle in
  let=? '(new_amount, ctxt) :=
    match Tez_repr.op_minusquestion old_amount amount with
    | Pervasives.Ok new_amount =&gt;
      let=? ctxt := Roll_storage.Delegate.remove_amount ctxt delegate amount in
      Error_monad.__return (new_amount, ctxt)
    | Pervasives.Error _ =&gt;
      let=? ctxt := Roll_storage.Delegate.remove_amount ctxt delegate old_amount
        in
      Error_monad.__return (Tez_repr.zero, ctxt)
    end in
  let= ctxt :=
    (|Storage.Contract.Frozen_fees|).(Storage_sigs.Indexed_data_storage.init_set)
      (ctxt, contract) cycle new_amount in
  Error_monad.__return ctxt.

Definition get_frozen_rewards
  (ctxt : Raw_context.t) (contract : Contract_repr.t)
  (cycle :
    (|Storage.Contract.Frozen_rewards|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t (Error_monad.tzresult Tez_repr.t) :=
  let=? function_parameter :=
    (|Storage.Contract.Frozen_rewards|).(Storage_sigs.Indexed_data_storage.get_option)
      (ctxt, contract) cycle in
  match function_parameter with
  | None =&gt; Error_monad.__return Tez_repr.zero
  | Some frozen =&gt; Error_monad.__return frozen
  end.

Definition credit_frozen_rewards
  (ctxt : Raw_context.t)
  (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  (cycle :
    (|Storage.Contract.Frozen_rewards|).(Storage_sigs.Indexed_data_storage.key))
  (amount : Tez_repr.t) : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let contract := Contract_repr.implicit_contract delegate in
  let=? old_amount := get_frozen_rewards ctxt contract cycle in
  let=? new_amount := Lwt.__return (Tez_repr.op_plusquestion old_amount amount)
    in
  let= ctxt :=
    (|Storage.Contract.Frozen_rewards|).(Storage_sigs.Indexed_data_storage.init_set)
      (ctxt, contract) cycle new_amount in
  let= ctxt :=
    (|Storage.Delegates_with_frozen_balance|).(Storage_sigs.Data_set_storage.add)
      (ctxt, cycle) delegate in
  Error_monad.__return ctxt.

Definition freeze_rewards
  (ctxt : Raw_context.t)
  (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  (amount : Tez_repr.t) : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let '{| Level_repr.t.cycle := cycle |} := Level_storage.current ctxt in
  credit_frozen_rewards ctxt delegate cycle amount.

Definition burn_rewards
  (ctxt : Raw_context.t)
  (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  (cycle :
    (|Storage.Contract.Frozen_rewards|).(Storage_sigs.Indexed_data_storage.key))
  (amount : Tez_repr.t) : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let contract := Contract_repr.implicit_contract delegate in
  let=? old_amount := get_frozen_rewards ctxt contract cycle in
  let new_amount :=
    match Tez_repr.op_minusquestion old_amount amount with
    | Pervasives.Error _ =&gt; Tez_repr.zero
    | Pervasives.Ok new_amount =&gt; new_amount
    end in
  let= ctxt :=
    (|Storage.Contract.Frozen_rewards|).(Storage_sigs.Indexed_data_storage.init_set)
      (ctxt, contract) cycle new_amount in
  Error_monad.__return ctxt.

Definition unfreeze
  (ctxt : Raw_context.t)
  (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  (cycle :
    (|Storage.Contract.Frozen_deposits|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t
    (Error_monad.tzresult (Raw_context.t * list (balance * balance_update))) :=
  let contract := Contract_repr.implicit_contract delegate in
  let=? deposit := get_frozen_deposit ctxt contract cycle in
  let=? fees := get_frozen_fees ctxt contract cycle in
  let=? rewards := get_frozen_rewards ctxt contract cycle in
  let=? balance :=
    (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.get) ctxt
      contract in
  let=? unfrozen_amount := Lwt.__return (Tez_repr.op_plusquestion deposit fees)
    in
  let=? unfrozen_amount :=
    Lwt.__return (Tez_repr.op_plusquestion unfrozen_amount rewards) in
  let=? balance :=
    Lwt.__return (Tez_repr.op_plusquestion balance unfrozen_amount) in
  let=? ctxt :=
    (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.set) ctxt
      contract balance in
  let=? ctxt := Roll_storage.Delegate.add_amount ctxt delegate rewards in
  let= ctxt :=
    (|Storage.Contract.Frozen_deposits|).(Storage_sigs.Indexed_data_storage.remove)
      (ctxt, contract) cycle in
  let= ctxt :=
    (|Storage.Contract.Frozen_fees|).(Storage_sigs.Indexed_data_storage.remove)
      (ctxt, contract) cycle in
  let= ctxt :=
    (|Storage.Contract.Frozen_rewards|).(Storage_sigs.Indexed_data_storage.remove)
      (ctxt, contract) cycle in
  Error_monad.__return
    (ctxt,
      (cleanup_balance_updates
        [
          ((Deposits delegate cycle), (Debited deposit));
          ((Fees delegate cycle), (Debited fees));
          ((Rewards delegate cycle), (Debited rewards));
          ((Contract (Contract_repr.implicit_contract delegate)),
            (Credited unfrozen_amount))
        ])).

Definition cycle_end
  (ctxt : Raw_context.context) (last_cycle : Cycle_repr.cycle)
  (unrevealed : list Nonce_storage.unrevealed)
  : Lwt.t
    (Error_monad.tzresult
      (Raw_context.context * list (balance * balance_update) *
        list
          (|Storage.Active_delegates_with_rolls|).(Storage_sigs.Data_set_storage.elt))) :=
  let preserved := Constants_storage.preserved_cycles ctxt in
  let=? '(ctxt, balance_updates) :=
    match Cycle_repr.pred last_cycle with
    | None =&gt; Error_monad.__return (ctxt, nil)
    | Some revealed_cycle =&gt;
      List.fold_left
        (fun acc =&gt;
          fun u =&gt;
            let=? '(ctxt, balance_updates) := acc in
            let=? ctxt :=
              burn_fees ctxt u.(Storage.unrevealed_nonce.delegate)
                revealed_cycle u.(Storage.unrevealed_nonce.fees) in
            let=? ctxt :=
              burn_rewards ctxt u.(Storage.unrevealed_nonce.delegate)
                revealed_cycle u.(Storage.unrevealed_nonce.rewards) in
            let bus :=
              [
                ((Fees u.(Storage.unrevealed_nonce.delegate) revealed_cycle),
                  (Debited u.(Storage.unrevealed_nonce.fees)));
                ((Rewards u.(Storage.unrevealed_nonce.delegate) revealed_cycle),
                  (Debited u.(Storage.unrevealed_nonce.rewards)))
              ] in
            Error_monad.__return (ctxt, (Pervasives.op_at bus balance_updates)))
        (Error_monad.__return (ctxt, nil)) unrevealed
    end in
  match Cycle_repr.sub last_cycle preserved with
  | None =&gt; Error_monad.__return (ctxt, balance_updates, nil)
  | Some unfrozen_cycle =&gt;
    let=? '(ctxt, balance_updates) :=
      (|Storage.Delegates_with_frozen_balance|).(Storage_sigs.Data_set_storage.fold)
        (ctxt, unfrozen_cycle) (Pervasives.Ok (ctxt, balance_updates))
        (fun delegate =&gt;
          fun acc =&gt;
            let=? '(ctxt, bus) := Lwt.__return acc in
            let=? '(ctxt, balance_updates) :=
              unfreeze ctxt delegate unfrozen_cycle in
            Error_monad.__return (ctxt, (Pervasives.op_at balance_updates bus)))
      in
    let= ctxt :=
      (|Storage.Delegates_with_frozen_balance|).(Storage_sigs.Data_set_storage.clear)
        (ctxt, unfrozen_cycle) in
    let=? '(ctxt, deactivated) :=
      (|Storage.Active_delegates_with_rolls|).(Storage_sigs.Data_set_storage.fold)
        ctxt (Pervasives.Ok (ctxt, nil))
        (fun delegate =&gt;
          fun acc =&gt;
            let=? '(ctxt, deactivated) := Lwt.__return acc in
            let=? cycle :=
              (|Storage.Contract.Delegate_desactivation|).(Storage_sigs.Indexed_data_storage.get)
                ctxt (Contract_repr.implicit_contract delegate) in
            if Cycle_repr.op_lteq cycle last_cycle then
              let=? ctxt := Roll_storage.Delegate.set_inactive ctxt delegate in
              Error_monad.__return (ctxt, (cons delegate deactivated))
            else
              Error_monad.__return (ctxt, deactivated)) in
    Error_monad.__return (ctxt, balance_updates, deactivated)
  end.

Definition punish
  (ctxt : Raw_context.t)
  (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  (cycle :
    (|Storage.Contract.Frozen_deposits|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t (Error_monad.tzresult (Raw_context.t * frozen_balance)) :=
  let contract := Contract_repr.implicit_contract delegate in
  let=? deposit := get_frozen_deposit ctxt contract cycle in
  let=? fees := get_frozen_fees ctxt contract cycle in
  let=? rewards := get_frozen_rewards ctxt contract cycle in
  let=? ctxt := Roll_storage.Delegate.remove_amount ctxt delegate deposit in
  let=? ctxt := Roll_storage.Delegate.remove_amount ctxt delegate fees in
  let= ctxt :=
    (|Storage.Contract.Frozen_deposits|).(Storage_sigs.Indexed_data_storage.remove)
      (ctxt, contract) cycle in
  let= ctxt :=
    (|Storage.Contract.Frozen_fees|).(Storage_sigs.Indexed_data_storage.remove)
      (ctxt, contract) cycle in
  let= ctxt :=
    (|Storage.Contract.Frozen_rewards|).(Storage_sigs.Indexed_data_storage.remove)
      (ctxt, contract) cycle in
  Error_monad.__return
    (ctxt,
      {| frozen_balance.deposit := deposit; frozen_balance.fees := fees;
        frozen_balance.rewards := rewards |}).

Definition has_frozen_balance
  (ctxt : Raw_context.t)
  (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  (cycle :
    (|Storage.Contract.Frozen_deposits|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t (Error_monad.tzresult bool) :=
  let contract := Contract_repr.implicit_contract delegate in
  let=? deposit := get_frozen_deposit ctxt contract cycle in
  if Tez_repr.op_ltgt deposit Tez_repr.zero then
    Error_monad.return_true
  else
    let=? fees := get_frozen_fees ctxt contract cycle in
    if Tez_repr.op_ltgt fees Tez_repr.zero then
      Error_monad.return_true
    else
      let=? rewards := get_frozen_rewards ctxt contract cycle in
      Error_monad.__return (Tez_repr.op_ltgt rewards Tez_repr.zero).

Definition frozen_balance_by_cycle_encoding
  : Data_encoding.encoding ((|Cycle_repr.Map|).(S.MAP.t) frozen_balance) :=
  Data_encoding.conv (|Cycle_repr.Map|).(S.MAP.bindings)
    (List.fold_left
      (fun m =&gt;
        fun function_parameter =&gt;
          let '(c, __b_value) := function_parameter in
          (|Cycle_repr.Map|).(S.MAP.add) c __b_value m)
      (|Cycle_repr.Map|).(S.MAP.empty)) None
    (Data_encoding.__list_value None
      (Data_encoding.merge_objs
        (Data_encoding.obj1
          (Data_encoding.req None None &quot;cycle&quot; Cycle_repr.encoding))
        frozen_balance_encoding)).

Definition empty_frozen_balance : frozen_balance :=
  {| frozen_balance.deposit := Tez_repr.zero;
    frozen_balance.fees := Tez_repr.zero;
    frozen_balance.rewards := Tez_repr.zero |}.

Definition frozen_balance_by_cycle
  (ctxt : Raw_context.t)
  (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t ((|Cycle_repr.Map|).(S.MAP.t) frozen_balance) :=
  let contract := Contract_repr.implicit_contract delegate in
  let map {A : Set} : (|Cycle_repr.Map|).(S.MAP.t) A :=
    (|Cycle_repr.Map|).(S.MAP.empty) in
  let= map :=
    (|Storage.Contract.Frozen_deposits|).(Storage_sigs.Indexed_data_storage.fold)
      (ctxt, contract) map
      (fun cycle =&gt;
        fun amount =&gt;
          fun map =&gt;
            Lwt.__return
              ((|Cycle_repr.Map|).(S.MAP.add) cycle
                (frozen_balance.with_deposit amount empty_frozen_balance) map))
    in
  let= map :=
    (|Storage.Contract.Frozen_fees|).(Storage_sigs.Indexed_data_storage.fold)
      (ctxt, contract) map
      (fun cycle =&gt;
        fun amount =&gt;
          fun map =&gt;
            let balance :=
              match (|Cycle_repr.Map|).(S.MAP.find_opt) cycle map with
              | None =&gt; empty_frozen_balance
              | Some balance =&gt; balance
              end in
            Lwt.__return
              ((|Cycle_repr.Map|).(S.MAP.add) cycle
                (frozen_balance.with_fees amount balance) map)) in
  let= map :=
    (|Storage.Contract.Frozen_rewards|).(Storage_sigs.Indexed_data_storage.fold)
      (ctxt, contract) map
      (fun cycle =&gt;
        fun amount =&gt;
          fun map =&gt;
            let balance :=
              match (|Cycle_repr.Map|).(S.MAP.find_opt) cycle map with
              | None =&gt; empty_frozen_balance
              | Some balance =&gt; balance
              end in
            Lwt.__return
              ((|Cycle_repr.Map|).(S.MAP.add) cycle
                (frozen_balance.with_rewards amount balance) map)) in
  Lwt.__return map.

Definition __frozen_balance_value
  (ctxt : Raw_context.t)
  (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Pervasives.result Tez_repr.t (list Error_monad.__error)) :=
  let contract := Contract_repr.implicit_contract delegate in
  let balance {A : Set} : Pervasives.result Tez_repr.t A :=
    Pervasives.Ok Tez_repr.zero in
  let= balance :=
    (|Storage.Contract.Frozen_deposits|).(Storage_sigs.Indexed_data_storage.fold)
      (ctxt, contract) balance
      (fun _cycle =&gt;
        fun amount =&gt;
          fun acc =&gt;
            let=? acc := Lwt.__return acc in
            Lwt.__return (Tez_repr.op_plusquestion acc amount)) in
  let= balance :=
    (|Storage.Contract.Frozen_fees|).(Storage_sigs.Indexed_data_storage.fold)
      (ctxt, contract) balance
      (fun _cycle =&gt;
        fun amount =&gt;
          fun acc =&gt;
            let=? acc := Lwt.__return acc in
            Lwt.__return (Tez_repr.op_plusquestion acc amount)) in
  let= balance :=
    (|Storage.Contract.Frozen_rewards|).(Storage_sigs.Indexed_data_storage.fold)
      (ctxt, contract) balance
      (fun _cycle =&gt;
        fun amount =&gt;
          fun acc =&gt;
            let=? acc := Lwt.__return acc in
            Lwt.__return (Tez_repr.op_plusquestion acc amount)) in
  Lwt.__return balance.

Definition full_balance
  (ctxt : Raw_context.t)
  (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.tzresult Tez_repr.t) :=
  let contract := Contract_repr.implicit_contract delegate in
  let=? __frozen_balance_value := __frozen_balance_value ctxt delegate in
  let=? balance :=
    (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.get) ctxt
      contract in
  Lwt.__return (Tez_repr.op_plusquestion __frozen_balance_value balance).

Definition deactivated
  : Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.tzresult bool) := Roll_storage.Delegate.is_inactive.

Definition grace_period
  (ctxt :
    (|Storage.Contract.Delegate_desactivation|).(Storage_sigs.Indexed_data_storage.context))
  (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t
    (Error_monad.tzresult
      (|Storage.Contract.Delegate_desactivation|).(Storage_sigs.Indexed_data_storage.value)) :=
  let contract := Contract_repr.implicit_contract delegate in
  (|Storage.Contract.Delegate_desactivation|).(Storage_sigs.Indexed_data_storage.get)
    ctxt contract.

Definition staking_balance
  (ctxt : Raw_context.context)
  (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.tzresult Tez_repr.t) :=
  let token_per_rolls := Constants_storage.tokens_per_roll ctxt in
  let=? rolls := Roll_storage.get_rolls ctxt delegate in
  let=? change := Roll_storage.get_change ctxt delegate in
  let rolls := Int64.of_int (List.length rolls) in
  let=? balance := Lwt.__return (Tez_repr.op_starquestion token_per_rolls rolls)
    in
  Lwt.__return (Tez_repr.op_plusquestion balance change).

Definition delegated_balance
  (ctxt : Raw_context.context)
  (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.tzresult Tez_repr.t) :=
  let contract := Contract_repr.implicit_contract delegate in
  let=? staking_balance := staking_balance ctxt delegate in
  let= self_staking_balance :=
    (|Storage.Contract.Balance|).(Storage_sigs.Indexed_data_storage.get) ctxt
      contract in
  let= self_staking_balance :=
    (|Storage.Contract.Frozen_deposits|).(Storage_sigs.Indexed_data_storage.fold)
      (ctxt, contract) self_staking_balance
      (fun _cycle =&gt;
        fun amount =&gt;
          fun acc =&gt;
            let=? acc := Lwt.__return acc in
            Lwt.__return (Tez_repr.op_plusquestion acc amount)) in
  let=? self_staking_balance :=
    (|Storage.Contract.Frozen_fees|).(Storage_sigs.Indexed_data_storage.fold)
      (ctxt, contract) self_staking_balance
      (fun _cycle =&gt;
        fun amount =&gt;
          fun acc =&gt;
            let=? acc := Lwt.__return acc in
            Lwt.__return (Tez_repr.op_plusquestion acc amount)) in
  Lwt.__return (Tez_repr.op_minusquestion staking_balance self_staking_balance).

Definition fold {A : Set}
  : (|Storage.Delegates|).(Storage_sigs.Data_set_storage.context) -&gt; A -&gt;
  ((|Storage.Delegates|).(Storage_sigs.Data_set_storage.elt) -&gt; A -&gt; Lwt.t A) -&gt;
  Lwt.t A := (|Storage.Delegates|).(Storage_sigs.Data_set_storage.fold).

Definition __list_value
  : (|Storage.Delegates|).(Storage_sigs.Data_set_storage.context) -&gt;
  Lwt.t (list (|Storage.Delegates|).(Storage_sigs.Data_set_storage.elt)) :=
  (|Storage.Delegates|).(Storage_sigs.Data_set_storage.elements).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="delegate_storage.mli">
  <div style="margin: 20px;">
    <h3>Delegate_storage_mli</h3>
    <ul>
      <li>OCaml size: 191 lines</li>
      <li>Coq size: 150 lines (-22% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#delegate_storage.mli"><code>delegate_storage.mli</code></a>&nbsp;<span class="label label-warning">1 warning</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Places where tezzies can be found in the ledger's state. *)
type balance =
  | Contract of Contract_repr.t
  | Rewards of Signature.Public_key_hash.t * Cycle_repr.t
  | Fees of Signature.Public_key_hash.t * Cycle_repr.t
  | Deposits of Signature.Public_key_hash.t * Cycle_repr.t

(** A credit or debit of tezzies to a balance. *)
type balance_update = Debited of Tez_repr.t | Credited of Tez_repr.t

(** A list of balance updates. Duplicates may happen. *)
type balance_updates = (balance * balance_update) list

val balance_updates_encoding : balance_updates Data_encoding.t

(** Remove zero-valued balances from a list of updates. *)
val cleanup_balance_updates : balance_updates -&gt; balance_updates

type frozen_balance = {
  deposit : Tez_repr.t;
  fees : Tez_repr.t;
  rewards : Tez_repr.t;
}

(** Allow to register a delegate when creating an account. *)
val init :
  Raw_context.t -&gt;
  Contract_repr.t -&gt;
  Signature.Public_key_hash.t -&gt;
  Raw_context.t tzresult Lwt.t

(** Cleanup delegation when deleting a contract. *)
val remove : Raw_context.t -&gt; Contract_repr.t -&gt; Raw_context.t tzresult Lwt.t

(** Reading the current delegate of a contract. *)
val get :
  Raw_context.t -&gt;
  Contract_repr.t -&gt;
  Signature.Public_key_hash.t option tzresult Lwt.t

val registered :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; bool tzresult Lwt.t

(** Updating the delegate of a contract.

    When calling this function on an &quot;implicit contract&quot; and setting
    the delegate to the contract manager registers it as a delegate. One
    cannot unregister a delegate for now. The associate contract is now
    'undeletable'. *)
val set :
  Raw_context.t -&gt;
  Contract_repr.t -&gt;
  Signature.Public_key_hash.t option -&gt;
  Raw_context.t tzresult Lwt.t

<abbr class="mark-warning" title="Extensible types are not handled.">type error +=
  | No_deletion of Signature.Public_key_hash.t (* `Permanent *)
  | Active_delegate (* `Temporary *)
  | Current_delegate (* `Temporary *)
  | Empty_delegate_account of Signature.Public_key_hash.t (* `Temporary *)
  | Balance_too_low_for_deposit of {
      delegate : Signature.Public_key_hash.t;
      deposit : Tez_repr.t;
      balance : Tez_repr.t;
    }</abbr>

(* `Temporary *)

(** Iterate on all registered delegates. *)
val fold :
  Raw_context.t -&gt;
  init:'a -&gt;
  f:(Signature.Public_key_hash.t -&gt; 'a -&gt; 'a Lwt.t) -&gt;
  'a Lwt.t

(** List all registered delegates. *)
val list : Raw_context.t -&gt; Signature.Public_key_hash.t list Lwt.t

(** Various functions to 'freeze' tokens.  A frozen 'deposit' keeps its
    associated rolls. When frozen, 'fees' may trigger new rolls
    allocation. Rewards won't trigger new rolls allocation until
    unfrozen. *)
val freeze_deposit :
  Raw_context.t -&gt;
  Signature.Public_key_hash.t -&gt;
  Tez_repr.t -&gt;
  Raw_context.t tzresult Lwt.t

val freeze_fees :
  Raw_context.t -&gt;
  Signature.Public_key_hash.t -&gt;
  Tez_repr.t -&gt;
  Raw_context.t tzresult Lwt.t

val freeze_rewards :
  Raw_context.t -&gt;
  Signature.Public_key_hash.t -&gt;
  Tez_repr.t -&gt;
  Raw_context.t tzresult Lwt.t

(** Trigger the context maintenance at the end of cycle 'n', i.e.:
    unfreeze deposit/fees/rewards from 'n - preserved_cycle' ; punish the
    provided unrevealed seeds (tipically seed from cycle 'n - 1').
    Returns a list of account with the amount that was unfrozen for each
    and the list of deactivated delegates. *)
val cycle_end :
  Raw_context.t -&gt;
  Cycle_repr.t -&gt;
  Nonce_storage.unrevealed list -&gt;
  (Raw_context.t * balance_updates * Signature.Public_key_hash.t list) tzresult
  Lwt.t

(** Burn all then frozen deposit/fees/rewards for a delegate at a given
    cycle. Returns the burned amounts. *)
val punish :
  Raw_context.t -&gt;
  Signature.Public_key_hash.t -&gt;
  Cycle_repr.t -&gt;
  (Raw_context.t * frozen_balance) tzresult Lwt.t

(** Has the given key some frozen tokens in its implicit contract? *)
val has_frozen_balance :
  Raw_context.t -&gt;
  Signature.Public_key_hash.t -&gt;
  Cycle_repr.t -&gt;
  bool tzresult Lwt.t

(** Returns the amount of frozen deposit, fees and rewards associated
    to a given delegate. *)
val frozen_balance :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; Tez_repr.t tzresult Lwt.t

val frozen_balance_encoding : frozen_balance Data_encoding.t

val frozen_balance_by_cycle_encoding :
  frozen_balance Cycle_repr.Map.t Data_encoding.t

(** Returns the amount of frozen deposit, fees and rewards associated
    to a given delegate, indexed by the cycle by which at the end the
    balance will be unfrozen. *)
val frozen_balance_by_cycle :
  Raw_context.t -&gt;
  Signature.Public_key_hash.t -&gt;
  frozen_balance Cycle_repr.Map.t Lwt.t

(** Returns the full 'balance' of the implicit contract associated to
    a given key, i.e. the sum of the spendable balance and of the
    frozen balance. *)
val full_balance :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; Tez_repr.t tzresult Lwt.t

val staking_balance :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; Tez_repr.t tzresult Lwt.t

(** Returns the list of contracts (implicit or originated) that delegated towards a given delegate *)
val delegated_contracts :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; Contract_repr.t list Lwt.t

val delegated_balance :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; Tez_repr.t tzresult Lwt.t

val deactivated :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; bool tzresult Lwt.t

val grace_period :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; Cycle_repr.t tzresult Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#delegate_storage.mli"><code>Delegate_storage_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Contract_repr.
Require Tezos.Cycle_repr.
Require Tezos.Nonce_storage.
Require Tezos.Raw_context.
Require Tezos.Tez_repr.

Inductive balance : Set :=
| Contract : Contract_repr.t -&gt; balance
| Rewards :
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt; Cycle_repr.t -&gt;
  balance
| Fees :
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt; Cycle_repr.t -&gt;
  balance
| Deposits :
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt; Cycle_repr.t -&gt;
  balance.

Inductive balance_update : Set :=
| Debited : Tez_repr.t -&gt; balance_update
| Credited : Tez_repr.t -&gt; balance_update.

Definition balance_updates : Set := list (balance * balance_update).

Parameter balance_updates_encoding : Data_encoding.t balance_updates.

Parameter cleanup_balance_updates : balance_updates -&gt; balance_updates.

Module frozen_balance.
  Record record : Set := Build {
    deposit : Tez_repr.t;
    fees : Tez_repr.t;
    rewards : Tez_repr.t }.
  Definition with_deposit deposit (r : record) :=
    Build deposit r.(fees) r.(rewards).
  Definition with_fees fees (r : record) :=
    Build r.(deposit) fees r.(rewards).
  Definition with_rewards rewards (r : record) :=
    Build r.(deposit) r.(fees) rewards.
End frozen_balance.
Definition frozen_balance := frozen_balance.record.

Parameter init :
  Raw_context.t -&gt; Contract_repr.t -&gt;
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter remove :
  Raw_context.t -&gt; Contract_repr.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter get :
  Raw_context.t -&gt; Contract_repr.t -&gt;
  Lwt.t
    (Error_monad.tzresult
      (option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))).

Parameter registered :
  Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.tzresult bool).

Parameter set :
  Raw_context.t -&gt; Contract_repr.t -&gt;
  option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

(* extensible_type_definition `error` *)

Parameter fold : forall {a : Set},
  Raw_context.t -&gt; a -&gt;
  ((|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt; a -&gt; Lwt.t a) -&gt;
  Lwt.t a.

Parameter __list_value :
  Raw_context.t -&gt;
  Lwt.t (list (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)).

Parameter freeze_deposit :
  Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Tez_repr.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter freeze_fees :
  Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Tez_repr.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter freeze_rewards :
  Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Tez_repr.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter cycle_end :
  Raw_context.t -&gt; Cycle_repr.t -&gt; list Nonce_storage.unrevealed -&gt;
  Lwt.t
    (Error_monad.tzresult
      (Raw_context.t * balance_updates *
        list (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))).

Parameter punish :
  Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Cycle_repr.t -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * frozen_balance)).

Parameter has_frozen_balance :
  Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Cycle_repr.t -&gt; Lwt.t (Error_monad.tzresult bool).

Parameter __frozen_balance_value :
  Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.tzresult Tez_repr.t).

Parameter frozen_balance_encoding : Data_encoding.t frozen_balance.

Parameter frozen_balance_by_cycle_encoding :
  Data_encoding.t ((|Cycle_repr.Map|).(S.MAP.t) frozen_balance).

Parameter frozen_balance_by_cycle :
  Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t ((|Cycle_repr.Map|).(S.MAP.t) frozen_balance).

Parameter full_balance :
  Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.tzresult Tez_repr.t).

Parameter staking_balance :
  Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.tzresult Tez_repr.t).

Parameter delegated_contracts :
  Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (list Contract_repr.t).

Parameter delegated_balance :
  Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.tzresult Tez_repr.t).

Parameter deactivated :
  Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.tzresult bool).

Parameter grace_period :
  Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.tzresult Cycle_repr.t).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="fees_storage.ml">
  <div style="margin: 20px;">
    <h3>Fees_storage</h3>
    <ul>
      <li>OCaml size: 121 lines</li>
      <li>Coq size: 96 lines (-21% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#fees_storage.ml"><code>fees_storage.ml</code></a>&nbsp;<span class="label label-warning">7 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Cannot_pay_storage_fee</abbr> (* `Temporary *)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Operation_quota_exceeded</abbr> (* `Temporary *)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Storage_limit_too_high</abbr> (* `Permanent *)

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  let open Data_encoding in
  register_error_kind
    `Temporary
    ~id:&quot;contract.cannot_pay_storage_fee&quot;
    ~title:&quot;Cannot pay storage fee&quot;
    ~description:&quot;The storage fee is higher than the contract balance&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Cannot pay storage storage fee&quot;)
    Data_encoding.empty
    (function Cannot_pay_storage_fee -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Cannot_pay_storage_fee) ;
  register_error_kind
    `Temporary
    ~id:&quot;storage_exhausted.operation&quot;
    ~title:&quot;Storage quota exceeded for the operation&quot;
    ~description:
      &quot;A script or one of its callee wrote more bytes than the operation said \
       it would&quot;
    Data_encoding.empty
    (function Operation_quota_exceeded -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Operation_quota_exceeded) ;
  register_error_kind
    `Permanent
    ~id:&quot;storage_limit_too_high&quot;
    ~title:&quot;Storage limit out of protocol hard bounds&quot;
    ~description:&quot;A transaction tried to exceed the hard limit on storage&quot;
    empty
    (function Storage_limit_too_high -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Storage_limit_too_high)</abbr>

let origination_burn c =
  let origination_size = Constants_storage.origination_size c in
  let cost_per_byte = Constants_storage.cost_per_byte c in
  (* the origination burn, measured in bytes *)
  Lwt.return Tez_repr.(cost_per_byte *? Int64.of_int origination_size)
  &gt;&gt;=? fun to_be_paid -&gt;
  return (Raw_context.update_allocated_contracts_count c, to_be_paid)

let record_paid_storage_space c contract =
  Contract_storage.used_storage_space c contract
  &gt;&gt;=? fun size -&gt;
  Contract_storage.set_paid_storage_space_and_return_fees_to_pay
    c
    contract
    size
  &gt;&gt;=? fun (to_be_paid, c) -&gt;
  let c = Raw_context.update_storage_space_to_pay c to_be_paid in
  let cost_per_byte = Constants_storage.cost_per_byte c in
  Lwt.return Tez_repr.(cost_per_byte *? Z.to_int64 to_be_paid)
  &gt;&gt;=? fun to_burn -&gt; return (c, size, to_be_paid, to_burn)

let burn_storage_fees c ~storage_limit ~payer =
  let origination_size = Constants_storage.origination_size c in
  let (c, storage_space_to_pay, allocated_contracts) =
    Raw_context.clear_storage_space_to_pay c
  in
  let storage_space_for_allocated_contracts =
    Z.mul (Z.of_int allocated_contracts) (Z.of_int origination_size)
  in
  let consumed =
    Z.add storage_space_to_pay storage_space_for_allocated_contracts
  in
  let remaining = Z.sub storage_limit consumed in
  if Compare.Z.(remaining &lt; Z.zero) then fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Operation_quota_exceeded</abbr>
  else
    let cost_per_byte = Constants_storage.cost_per_byte c in
    Lwt.return Tez_repr.(cost_per_byte *? Z.to_int64 consumed)
    &gt;&gt;=? fun to_burn -&gt;
    (* Burning the fees... *)
    if Tez_repr.(to_burn = Tez_repr.zero) then
      (* If the payer was was deleted by transfering all its balance, and no space was used,
         burning zero would fail *)
      return c
    else
      trace
        <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Cannot_pay_storage_fee</abbr>
        ( Contract_storage.must_exist c payer
        &gt;&gt;=? fun () -&gt; Contract_storage.spend c payer to_burn )
      &gt;&gt;=? fun c -&gt; return c

let check_storage_limit c ~storage_limit =
  if
    Compare.Z.(
      storage_limit
      &gt; (Raw_context.constants c).hard_storage_limit_per_operation)
    || Compare.Z.(storage_limit &lt; Z.zero)
  then error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Storage_limit_too_high</abbr>
  else ok ()

let start_counting_storage_fees c = Raw_context.init_storage_space_to_pay c
</pre>
  </div>
  <div class="col-md-6">
    <a href="#fees_storage.ml"><code>Fees_storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Constants_repr.
Require Tezos.Constants_storage.
Require Tezos.Contract_repr.
Require Tezos.Contract_storage.
Require Tezos.Raw_context.
Require Tezos.Tez_repr.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition origination_burn (c : Raw_context.context)
  : Lwt.t (Error_monad.tzresult (Raw_context.t * Tez_repr.t)) :=
  let origination_size := Constants_storage.origination_size c in
  let cost_per_byte := Constants_storage.cost_per_byte c in
  let=? to_be_paid :=
    Lwt.__return
      (Tez_repr.op_starquestion cost_per_byte (Int64.of_int origination_size))
    in
  Error_monad.__return
    ((Raw_context.update_allocated_contracts_count c), to_be_paid).

Definition record_paid_storage_space
  (c : Raw_context.t) (contract : Contract_repr.t)
  : Lwt.t (Error_monad.tzresult (Raw_context.t * Z.t * Z.t * Tez_repr.t)) :=
  let=? size := Contract_storage.used_storage_space c contract in
  let=? '(to_be_paid, c) :=
    Contract_storage.set_paid_storage_space_and_return_fees_to_pay c contract
      size in
  let c := Raw_context.update_storage_space_to_pay c to_be_paid in
  let cost_per_byte := Constants_storage.cost_per_byte c in
  let=? to_burn :=
    Lwt.__return
      (Tez_repr.op_starquestion cost_per_byte (Z.to_int64 to_be_paid)) in
  Error_monad.__return (c, size, to_be_paid, to_burn).

Definition burn_storage_fees
  (c : Raw_context.context) (storage_limit : Z.t) (payer : Contract_repr.t)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let origination_size := Constants_storage.origination_size c in
  let '(c, storage_space_to_pay, allocated_contracts) :=
    Raw_context.clear_storage_space_to_pay c in
  let storage_space_for_allocated_contracts :=
    Z.mul (Z.of_int allocated_contracts) (Z.of_int origination_size) in
  let consumed :=
    Z.add storage_space_to_pay storage_space_for_allocated_contracts in
  let remaining := Z.sub storage_limit consumed in
  if (|Compare.Z|).(Compare.S.op_lt) remaining Z.zero then
    Error_monad.fail extensible_type_value
  else
    let cost_per_byte := Constants_storage.cost_per_byte c in
    let=? to_burn :=
      Lwt.__return
        (Tez_repr.op_starquestion cost_per_byte (Z.to_int64 consumed)) in
    if Tez_repr.op_eq to_burn Tez_repr.zero then
      Error_monad.__return c
    else
      let=? c :=
        Error_monad.trace extensible_type_value
          (let=? '_ := Contract_storage.must_exist c payer in
          Contract_storage.spend c payer to_burn) in
      Error_monad.__return c.

Definition check_storage_limit
  (c : Raw_context.context) (storage_limit : (|Compare.Z|).(Compare.S.t))
  : Error_monad.tzresult unit :=
  if
    Pervasives.op_pipepipe
      ((|Compare.Z|).(Compare.S.op_gt) storage_limit
        (Raw_context.constants c).(Constants_repr.parametric.hard_storage_limit_per_operation))
      ((|Compare.Z|).(Compare.S.op_lt) storage_limit Z.zero) then
    Error_monad.__error_value extensible_type_value
  else
    Error_monad.ok tt.

Definition start_counting_storage_fees (c : Raw_context.t) : Raw_context.t :=
  Raw_context.init_storage_space_to_pay c.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="fees_storage.mli">
  <div style="margin: 20px;">
    <h3>Fees_storage_mli</h3>
    <ul>
      <li>OCaml size: 50 lines</li>
      <li>Coq size: 36 lines (-28% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#fees_storage.mli"><code>fees_storage.mli</code></a>&nbsp;<span class="label label-warning">3 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Cannot_pay_storage_fee</abbr> (* `Temporary *)

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Operation_quota_exceeded</abbr> (* `Temporary *)

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Storage_limit_too_high</abbr> (* `Permanent *)

(** Does not burn, only adds the burn to storage space to be paid *)
val origination_burn :
  Raw_context.t -&gt; (Raw_context.t * Tez_repr.t) tzresult Lwt.t

(** The returned Tez quantity is for logging purpose only *)
val record_paid_storage_space :
  Raw_context.t -&gt;
  Contract_repr.t -&gt;
  (Raw_context.t * Z.t * Z.t * Tez_repr.t) tzresult Lwt.t

val check_storage_limit : Raw_context.t -&gt; storage_limit:Z.t -&gt; unit tzresult

val start_counting_storage_fees : Raw_context.t -&gt; Raw_context.t

val burn_storage_fees :
  Raw_context.t -&gt;
  storage_limit:Z.t -&gt;
  payer:Contract_repr.t -&gt;
  Raw_context.t tzresult Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#fees_storage.mli"><code>Fees_storage_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Contract_repr.
Require Tezos.Raw_context.
Require Tezos.Tez_repr.

(* extensible_type_definition `error` *)

(* extensible_type_definition `error` *)

(* extensible_type_definition `error` *)

Parameter origination_burn :
  Raw_context.t -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * Tez_repr.t)).

Parameter record_paid_storage_space :
  Raw_context.t -&gt; Contract_repr.t -&gt;
  Lwt.t (Error_monad.tzresult (Raw_context.t * Z.t * Z.t * Tez_repr.t)).

Parameter check_storage_limit :
  Raw_context.t -&gt; Z.t -&gt; Error_monad.tzresult unit.

Parameter start_counting_storage_fees : Raw_context.t -&gt; Raw_context.t.

Parameter burn_storage_fees :
  Raw_context.t -&gt; Z.t -&gt; Contract_repr.t -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="fitness_repr.ml">
  <div style="margin: 20px;">
    <h3>Fitness_repr</h3>
    <ul>
      <li>OCaml size: 62 lines</li>
      <li>Coq size: 61 lines (-2% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#fitness_repr.ml"><code>fitness_repr.ml</code></a>&nbsp;<span class="label label-warning">5 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Invalid_fitness</abbr> (* `Permanent *)

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  register_error_kind
    `Permanent
    ~id:&quot;invalid_fitness&quot;
    ~title:&quot;Invalid fitness&quot;
    ~description:&quot;Fitness representation should be exactly 8 bytes long.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Invalid fitness&quot;)
    Data_encoding.empty
    (function Invalid_fitness -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Invalid_fitness)</abbr>

let int64_to_bytes i =
  let b = MBytes.create 8 in
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">MBytes.set_int64 b 0 i</abbr> ; b

let int64_of_bytes b =
  if Compare.Int.(MBytes.length b &lt;&gt; 8) then error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_fitness</abbr>
  else ok (MBytes.get_int64 b 0)

let from_int64 fitness =
  [MBytes.of_string Constants_repr.version_number; int64_to_bytes fitness]

let to_int64 = function
  | [version; fitness]
    when Compare.String.(
           MBytes.to_string version = Constants_repr.version_number) -&gt;
      int64_of_bytes fitness
  | [version; _fitness (* ignored since higher version takes priority *)]
    when Compare.String.(
           MBytes.to_string version = Constants_repr.version_number_004) -&gt;
      ok 0L
  | [] -&gt;
      ok 0L
  | _ -&gt;
      error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_fitness</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#fitness_repr.ml"><code>Fitness_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Constants_repr.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition int64_to_bytes (i : int64) : MBytes.t :=
  let __b_value := MBytes.create 8 in
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  __b_value.

Definition int64_of_bytes (__b_value : MBytes.t) : Error_monad.tzresult int64 :=
  if (|Compare.Int|).(Compare.S.op_ltgt) (MBytes.length __b_value) 8 then
    Error_monad.__error_value extensible_type_value
  else
    Error_monad.ok (MBytes.get_int64 __b_value 0).

Definition from_int64 (fitness : int64) : list MBytes.t :=
  [ MBytes.of_string Constants_repr.version_number; int64_to_bytes fitness ].

Definition to_int64 (function_parameter : list MBytes.t)
  : Error_monad.tzresult int64 :=
  match
    (function_parameter,
      match function_parameter with
      | cons version (cons fitness []) =&gt;
        (|Compare.String|).(Compare.S.op_eq) (MBytes.to_string version)
          Constants_repr.version_number
      | _ =&gt; false
      end,
      match function_parameter with
      | cons version (cons _fitness []) =&gt;
        (|Compare.String|).(Compare.S.op_eq) (MBytes.to_string version)
          Constants_repr.version_number_004
      | _ =&gt; false
      end) with
  | (cons version (cons fitness []), true, _) =&gt; int64_of_bytes fitness
  | (cons version (cons _fitness []), _, true) =&gt;
    Error_monad.ok
      (* ‚ùå Constant of type int64 is converted to int *)
      0
  | ([], _, _) =&gt;
    Error_monad.ok
      (* ‚ùå Constant of type int64 is converted to int *)
      0
  | (_, _, _) =&gt; Error_monad.__error_value extensible_type_value
  end.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="fitness_storage.ml">
  <div style="margin: 20px;">
    <h3>Fitness_storage</h3>
    <ul>
      <li>OCaml size: 30 lines</li>
      <li>Coq size: 26 lines (-14% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#fitness_storage.ml"><code>fitness_storage.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

let current = Raw_context.current_fitness

let increase ?(gap = 1) ctxt =
  let fitness = current ctxt in
  Raw_context.set_current_fitness ctxt (Int64.add (Int64.of_int gap) fitness)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#fitness_storage.ml"><code>Fitness_storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Raw_context.

Definition current : Raw_context.context -&gt; Int64.t :=
  Raw_context.current_fitness.

Definition increase (op_staroptstar : option int)
  : Raw_context.context -&gt; Raw_context.t :=
  let gap :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; 1
    end in
  fun ctxt =&gt;
    let fitness := current ctxt in
    Raw_context.set_current_fitness ctxt (Int64.add (Int64.of_int gap) fitness).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="gas_limit_repr.ml">
  <div style="margin: 20px;">
    <h3>Gas_limit_repr</h3>
    <ul>
      <li>OCaml size: 260 lines</li>
      <li>Coq size: 310 lines (+19% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#gas_limit_repr.ml"><code>gas_limit_repr.ml</code></a>&nbsp;<span class="label label-warning">5 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = Unaccounted | Limited of {remaining : Z.t}

type internal_gas = Z.t

type cost = {
  allocations : Z.t;
  steps : Z.t;
  reads : Z.t;
  writes : Z.t;
  bytes_read : Z.t;
  bytes_written : Z.t;
}

let encoding =
  let open Data_encoding in
  union
    [ case
        (Tag 0)
        ~title:&quot;Limited&quot;
        z
        (function Limited {remaining} -&gt; Some remaining | _ -&gt; None)
        (fun remaining -&gt; Limited {remaining});
      case
        (Tag 1)
        ~title:&quot;Unaccounted&quot;
        (constant &quot;unaccounted&quot;)
        (function Unaccounted -&gt; Some () | _ -&gt; None)
        (fun () -&gt; Unaccounted) ]

let pp ppf = function
  | Unaccounted -&gt;
      Format.fprintf ppf &quot;unaccounted&quot;
  | Limited {remaining} -&gt;
      Format.fprintf ppf &quot;%s units remaining&quot; (Z.to_string remaining)

let cost_encoding =
  let open Data_encoding in
  conv
    (fun {allocations; steps; reads; writes; bytes_read; bytes_written} -&gt;
      (allocations, steps, reads, writes, bytes_read, bytes_written))
    (fun (allocations, steps, reads, writes, bytes_read, bytes_written) -&gt;
      {allocations; steps; reads; writes; bytes_read; bytes_written})
    (obj6
       (req &quot;allocations&quot; z)
       (req &quot;steps&quot; z)
       (req &quot;reads&quot; z)
       (req &quot;writes&quot; z)
       (req &quot;bytes_read&quot; z)
       (req &quot;bytes_written&quot; z))

let pp_cost ppf {allocations; steps; reads; writes; bytes_read; bytes_written}
    =
  Format.fprintf
    ppf
    &quot;(steps: %s, allocs: %s, reads: %s (%s bytes), writes: %s (%s bytes))&quot;
    (Z.to_string steps)
    (Z.to_string allocations)
    (Z.to_string reads)
    (Z.to_string bytes_read)
    (Z.to_string writes)
    (Z.to_string bytes_written)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Block_quota_exceeded</abbr> (* `Temporary *)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Operation_quota_exceeded</abbr> (* `Temporary *)

let allocation_weight = Z.of_int 2

let step_weight = Z.of_int 1

let read_base_weight = Z.of_int 100

let write_base_weight = Z.of_int 160

let byte_read_weight = Z.of_int 10

let byte_written_weight = Z.of_int 15

let rescaling_bits = 7

let rescaling_mask = Z.sub (Z.shift_left Z.one rescaling_bits) Z.one

let scale (z : Z.t) = Z.shift_left z rescaling_bits

let rescale (z : Z.t) = Z.shift_right z rescaling_bits

let cost_to_internal_gas (cost : cost) : internal_gas =
  Z.add
    (Z.add
       (Z.mul cost.allocations allocation_weight)
       (Z.mul cost.steps step_weight))
    (Z.add
       (Z.add
          (Z.mul cost.reads read_base_weight)
          (Z.mul cost.writes write_base_weight))
       (Z.add
          (Z.mul cost.bytes_read byte_read_weight)
          (Z.mul cost.bytes_written byte_written_weight)))

let internal_gas_to_gas internal_gas : Z.t * internal_gas =
  let gas = rescale internal_gas in
  let rest = Z.logand internal_gas rescaling_mask in
  (gas, rest)

let consume_raw block_gas operation_gas internal_gas cost =
  match operation_gas with
  | Unaccounted -&gt;
      ok (block_gas, Unaccounted, internal_gas)
  | Limited {remaining} -&gt;
      let cost_internal_gas = cost_to_internal_gas cost in
      let total_internal_gas = Z.add cost_internal_gas internal_gas in
      let (gas, rest) = internal_gas_to_gas total_internal_gas in
      if Compare.Z.(gas &gt; Z.zero) then
        let remaining = Z.sub remaining gas in
        let block_remaining = Z.sub block_gas gas in
        if Compare.Z.(remaining &lt; Z.zero) then error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Operation_quota_exceeded</abbr>
        else if Compare.Z.(block_remaining &lt; Z.zero) then
          error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Block_quota_exceeded</abbr>
        else ok (block_remaining, Limited {remaining}, rest)
      else ok (block_gas, operation_gas, total_internal_gas)

let check_enough_raw block_gas operation_gas internal_gas cost =
  consume_raw block_gas operation_gas internal_gas cost
  &gt;|? fun (_block_remainig, _remaining, _internal_gas) -&gt; ()

let internal_gas_zero : internal_gas = Z.zero

let alloc_cost n =
  {
    allocations = scale (Z.of_int (n + 1));
    steps = Z.zero;
    reads = Z.zero;
    writes = Z.zero;
    bytes_read = Z.zero;
    bytes_written = Z.zero;
  }

let alloc_bytes_cost n = alloc_cost ((n + 7) / 8)

let alloc_bits_cost n = alloc_cost ((n + 63) / 64)

let atomic_step_cost n =
  {
    allocations = Z.zero;
    steps = Z.of_int (2 * n);
    reads = Z.zero;
    writes = Z.zero;
    bytes_read = Z.zero;
    bytes_written = Z.zero;
  }

let step_cost n =
  {
    allocations = Z.zero;
    steps = scale (Z.of_int n);
    reads = Z.zero;
    writes = Z.zero;
    bytes_read = Z.zero;
    bytes_written = Z.zero;
  }

let free =
  {
    allocations = Z.zero;
    steps = Z.zero;
    reads = Z.zero;
    writes = Z.zero;
    bytes_read = Z.zero;
    bytes_written = Z.zero;
  }

let read_bytes_cost n =
  {
    allocations = Z.zero;
    steps = Z.zero;
    reads = scale Z.one;
    writes = Z.zero;
    bytes_read = scale n;
    bytes_written = Z.zero;
  }

let write_bytes_cost n =
  {
    allocations = Z.zero;
    steps = Z.zero;
    reads = Z.zero;
    writes = Z.one;
    bytes_read = Z.zero;
    bytes_written = scale n;
  }

let ( +@ ) x y =
  {
    allocations = Z.add x.allocations y.allocations;
    steps = Z.add x.steps y.steps;
    reads = Z.add x.reads y.reads;
    writes = Z.add x.writes y.writes;
    bytes_read = Z.add x.bytes_read y.bytes_read;
    bytes_written = Z.add x.bytes_written y.bytes_written;
  }

let ( *@ ) x y =
  {
    allocations = Z.mul (Z.of_int x) y.allocations;
    steps = Z.mul (Z.of_int x) y.steps;
    reads = Z.mul (Z.of_int x) y.reads;
    writes = Z.mul (Z.of_int x) y.writes;
    bytes_read = Z.mul (Z.of_int x) y.bytes_read;
    bytes_written = Z.mul (Z.of_int x) y.bytes_written;
  }

let alloc_mbytes_cost n = alloc_cost 12 +@ alloc_bytes_cost n

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  let open Data_encoding in
  register_error_kind
    `Temporary
    ~id:&quot;gas_exhausted.operation&quot;
    ~title:&quot;Gas quota exceeded for the operation&quot;
    ~description:
      &quot;A script or one of its callee took more time than the operation said \
       it would&quot;
    empty
    (function Operation_quota_exceeded -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Operation_quota_exceeded) ;
  register_error_kind
    `Temporary
    ~id:&quot;gas_exhausted.block&quot;
    ~title:&quot;Gas quota exceeded for the block&quot;
    ~description:
      &quot;The sum of gas consumed by all the operations in the block exceeds the \
       hard gas limit per block&quot;
    empty
    (function Block_quota_exceeded -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Block_quota_exceeded)</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#gas_limit_repr.ml"><code>Gas_limit_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.

Module ConstructorRecords_t.
  Module t.
    Module Limited.
      Record record {remaining : Set} : Set := Build {
        remaining : remaining }.
      Arguments record : clear implicits.
      Definition with_remaining {t_remaining} remaining
        (r : record t_remaining) :=
        Build t_remaining remaining.
    End Limited.
    Definition Limited_skeleton := Limited.record.
  End t.
End ConstructorRecords_t.
Import ConstructorRecords_t.

Reserved Notation &quot;'t.Limited&quot;.

Inductive t : Set :=
| Unaccounted : t
| Limited : 't.Limited -&gt; t

where &quot;'t.Limited&quot; := (t.Limited_skeleton Z.t).

Module t.
  Include ConstructorRecords_t.t.
  Definition Limited := 't.Limited.
End t.

Definition internal_gas : Set := Z.t.

Module cost.
  Record record : Set := Build {
    allocations : Z.t;
    steps : Z.t;
    reads : Z.t;
    writes : Z.t;
    bytes_read : Z.t;
    bytes_written : Z.t }.
  Definition with_allocations allocations (r : record) :=
    Build allocations r.(steps) r.(reads) r.(writes) r.(bytes_read)
      r.(bytes_written).
  Definition with_steps steps (r : record) :=
    Build r.(allocations) steps r.(reads) r.(writes) r.(bytes_read)
      r.(bytes_written).
  Definition with_reads reads (r : record) :=
    Build r.(allocations) r.(steps) reads r.(writes) r.(bytes_read)
      r.(bytes_written).
  Definition with_writes writes (r : record) :=
    Build r.(allocations) r.(steps) r.(reads) writes r.(bytes_read)
      r.(bytes_written).
  Definition with_bytes_read bytes_read (r : record) :=
    Build r.(allocations) r.(steps) r.(reads) r.(writes) bytes_read
      r.(bytes_written).
  Definition with_bytes_written bytes_written (r : record) :=
    Build r.(allocations) r.(steps) r.(reads) r.(writes) r.(bytes_read)
      bytes_written.
End cost.
Definition cost := cost.record.

Definition encoding : Data_encoding.encoding t :=
  Data_encoding.union None
    [
      Data_encoding.__case_value &quot;Limited&quot; None (Data_encoding.Tag 0)
        Data_encoding.z
        (fun function_parameter =&gt;
          match function_parameter with
          | Limited {| t.Limited.remaining := remaining |} =&gt; Some remaining
          | _ =&gt; None
          end)
        (fun remaining =&gt; Limited {| t.Limited.remaining := remaining |});
      Data_encoding.__case_value &quot;Unaccounted&quot; None (Data_encoding.Tag 1)
        (Data_encoding.constant &quot;unaccounted&quot;)
        (fun function_parameter =&gt;
          match function_parameter with
          | Unaccounted =&gt; Some tt
          | _ =&gt; None
          end)
        (fun function_parameter =&gt;
          let '_ := function_parameter in
          Unaccounted)
    ].

Definition pp (ppf : Format.formatter) (function_parameter : t) : unit :=
  match function_parameter with
  | Unaccounted =&gt;
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;unaccounted&quot;
          CamlinternalFormatBasics.End_of_format) &quot;unaccounted&quot;)
  | Limited {| t.Limited.remaining := remaining |} =&gt;
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
          (CamlinternalFormatBasics.String_literal &quot; units remaining&quot;
            CamlinternalFormatBasics.End_of_format)) &quot;%s units remaining&quot;)
      (Z.to_string remaining)
  end.

Definition cost_encoding : Data_encoding.encoding cost :=
  Data_encoding.conv
    (fun function_parameter =&gt;
      let '{|
        cost.allocations := allocations;
          cost.steps := steps;
          cost.reads := reads;
          cost.writes := writes;
          cost.bytes_read := bytes_read;
          cost.bytes_written := bytes_written
          |} := function_parameter in
      (allocations, steps, reads, writes, bytes_read, bytes_written))
    (fun function_parameter =&gt;
      let '(allocations, steps, reads, writes, bytes_read, bytes_written) :=
        function_parameter in
      {| cost.allocations := allocations; cost.steps := steps;
        cost.reads := reads; cost.writes := writes;
        cost.bytes_read := bytes_read; cost.bytes_written := bytes_written |})
    None
    (Data_encoding.obj6
      (Data_encoding.req None None &quot;allocations&quot; Data_encoding.z)
      (Data_encoding.req None None &quot;steps&quot; Data_encoding.z)
      (Data_encoding.req None None &quot;reads&quot; Data_encoding.z)
      (Data_encoding.req None None &quot;writes&quot; Data_encoding.z)
      (Data_encoding.req None None &quot;bytes_read&quot; Data_encoding.z)
      (Data_encoding.req None None &quot;bytes_written&quot; Data_encoding.z)).

Definition pp_cost (ppf : Format.formatter) (function_parameter : cost)
  : unit :=
  let '{|
    cost.allocations := allocations;
      cost.steps := steps;
      cost.reads := reads;
      cost.writes := writes;
      cost.bytes_read := bytes_read;
      cost.bytes_written := bytes_written
      |} := function_parameter in
  Format.fprintf ppf
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.String_literal &quot;(steps: &quot;
        (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
          (CamlinternalFormatBasics.String_literal &quot;, allocs: &quot;
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.String_literal &quot;, reads: &quot;
                (CamlinternalFormatBasics.String
                  CamlinternalFormatBasics.No_padding
                  (CamlinternalFormatBasics.String_literal &quot; (&quot;
                    (CamlinternalFormatBasics.String
                      CamlinternalFormatBasics.No_padding
                      (CamlinternalFormatBasics.String_literal
                        &quot; bytes), writes: &quot;
                        (CamlinternalFormatBasics.String
                          CamlinternalFormatBasics.No_padding
                          (CamlinternalFormatBasics.String_literal &quot; (&quot;
                            (CamlinternalFormatBasics.String
                              CamlinternalFormatBasics.No_padding
                              (CamlinternalFormatBasics.String_literal
                                &quot; bytes))&quot;
                                CamlinternalFormatBasics.End_of_format)))))))))))))
      &quot;(steps: %s, allocs: %s, reads: %s (%s bytes), writes: %s (%s bytes))&quot;)
    (Z.to_string steps) (Z.to_string allocations) (Z.to_string reads)
    (Z.to_string bytes_read) (Z.to_string writes) (Z.to_string bytes_written).

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

Definition allocation_weight : Z.t := Z.of_int 2.

Definition step_weight : Z.t := Z.of_int 1.

Definition read_base_weight : Z.t := Z.of_int 100.

Definition write_base_weight : Z.t := Z.of_int 160.

Definition byte_read_weight : Z.t := Z.of_int 10.

Definition byte_written_weight : Z.t := Z.of_int 15.

Definition rescaling_bits : int := 7.

Definition rescaling_mask : Z.t :=
  Z.sub (Z.shift_left Z.one rescaling_bits) Z.one.

Definition scale (z : Z.t) : Z.t := Z.shift_left z rescaling_bits.

Definition rescale (z : Z.t) : Z.t := Z.shift_right z rescaling_bits.

Definition cost_to_internal_gas (cost : cost) : internal_gas :=
  Z.add
    (Z.add (Z.mul cost.(cost.allocations) allocation_weight)
      (Z.mul cost.(cost.steps) step_weight))
    (Z.add
      (Z.add (Z.mul cost.(cost.reads) read_base_weight)
        (Z.mul cost.(cost.writes) write_base_weight))
      (Z.add (Z.mul cost.(cost.bytes_read) byte_read_weight)
        (Z.mul cost.(cost.bytes_written) byte_written_weight))).

Definition internal_gas_to_gas (__internal_gas_value : Z.t)
  : Z.t * internal_gas :=
  let gas := rescale __internal_gas_value in
  let rest := Z.logand __internal_gas_value rescaling_mask in
  (gas, rest).

Definition consume_raw
  (block_gas : Z.t) (operation_gas : t) (__internal_gas_value : Z.t)
  (cost : cost) : Error_monad.tzresult (Z.t * t * Z.t) :=
  match operation_gas with
  | Unaccounted =&gt; Error_monad.ok (block_gas, Unaccounted, __internal_gas_value)
  | Limited {| t.Limited.remaining := remaining |} =&gt;
    let cost_internal_gas := cost_to_internal_gas cost in
    let total_internal_gas := Z.add cost_internal_gas __internal_gas_value in
    let '(gas, rest) := internal_gas_to_gas total_internal_gas in
    if (|Compare.Z|).(Compare.S.op_gt) gas Z.zero then
      let remaining := Z.sub remaining gas in
      let block_remaining := Z.sub block_gas gas in
      if (|Compare.Z|).(Compare.S.op_lt) remaining Z.zero then
        Error_monad.__error_value extensible_type_value
      else
        if (|Compare.Z|).(Compare.S.op_lt) block_remaining Z.zero then
          Error_monad.__error_value extensible_type_value
        else
          Error_monad.ok
            (block_remaining, (Limited {| t.Limited.remaining := remaining |}),
              rest)
    else
      Error_monad.ok (block_gas, operation_gas, total_internal_gas)
  end.

Definition check_enough_raw
  (block_gas : Z.t) (operation_gas : t) (__internal_gas_value : Z.t)
  (cost : cost) : Error_monad.tzresult unit :=
  Error_monad.op_gtpipequestion
    (consume_raw block_gas operation_gas __internal_gas_value cost)
    (fun function_parameter =&gt;
      let '(_block_remainig, _remaining, _internal_gas) := function_parameter in
      tt).

Definition internal_gas_zero : internal_gas := Z.zero.

Definition alloc_cost (n : int) : cost :=
  {| cost.allocations := scale (Z.of_int (Pervasives.op_plus n 1));
    cost.steps := Z.zero; cost.reads := Z.zero; cost.writes := Z.zero;
    cost.bytes_read := Z.zero; cost.bytes_written := Z.zero |}.

Definition alloc_bytes_cost (n : int) : cost :=
  alloc_cost (Pervasives.op_div (Pervasives.op_plus n 7) 8).

Definition alloc_bits_cost (n : int) : cost :=
  alloc_cost (Pervasives.op_div (Pervasives.op_plus n 63) 64).

Definition atomic_step_cost (n : int) : cost :=
  {| cost.allocations := Z.zero;
    cost.steps := Z.of_int (Pervasives.op_star 2 n); cost.reads := Z.zero;
    cost.writes := Z.zero; cost.bytes_read := Z.zero;
    cost.bytes_written := Z.zero |}.

Definition step_cost (n : int) : cost :=
  {| cost.allocations := Z.zero; cost.steps := scale (Z.of_int n);
    cost.reads := Z.zero; cost.writes := Z.zero; cost.bytes_read := Z.zero;
    cost.bytes_written := Z.zero |}.

Definition free : cost :=
  {| cost.allocations := Z.zero; cost.steps := Z.zero; cost.reads := Z.zero;
    cost.writes := Z.zero; cost.bytes_read := Z.zero;
    cost.bytes_written := Z.zero |}.

Definition read_bytes_cost (n : Z.t) : cost :=
  {| cost.allocations := Z.zero; cost.steps := Z.zero;
    cost.reads := scale Z.one; cost.writes := Z.zero;
    cost.bytes_read := scale n; cost.bytes_written := Z.zero |}.

Definition write_bytes_cost (n : Z.t) : cost :=
  {| cost.allocations := Z.zero; cost.steps := Z.zero; cost.reads := Z.zero;
    cost.writes := Z.one; cost.bytes_read := Z.zero;
    cost.bytes_written := scale n |}.

Definition op_plusat (x : cost) (y : cost) : cost :=
  {| cost.allocations := Z.add x.(cost.allocations) y.(cost.allocations);
    cost.steps := Z.add x.(cost.steps) y.(cost.steps);
    cost.reads := Z.add x.(cost.reads) y.(cost.reads);
    cost.writes := Z.add x.(cost.writes) y.(cost.writes);
    cost.bytes_read := Z.add x.(cost.bytes_read) y.(cost.bytes_read);
    cost.bytes_written := Z.add x.(cost.bytes_written) y.(cost.bytes_written) |}.

Definition op_starat (x : int) (y : cost) : cost :=
  {| cost.allocations := Z.mul (Z.of_int x) y.(cost.allocations);
    cost.steps := Z.mul (Z.of_int x) y.(cost.steps);
    cost.reads := Z.mul (Z.of_int x) y.(cost.reads);
    cost.writes := Z.mul (Z.of_int x) y.(cost.writes);
    cost.bytes_read := Z.mul (Z.of_int x) y.(cost.bytes_read);
    cost.bytes_written := Z.mul (Z.of_int x) y.(cost.bytes_written) |}.

Definition alloc_mbytes_cost (n : int) : cost :=
  op_plusat (alloc_cost 12) (alloc_bytes_cost n).

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="gas_limit_repr.mli">
  <div style="margin: 20px;">
    <h3>Gas_limit_repr_mli</h3>
    <ul>
      <li>OCaml size: 71 lines</li>
      <li>Coq size: 86 lines (+21% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#gas_limit_repr.mli"><code>gas_limit_repr.mli</code></a>&nbsp;<span class="label label-warning">2 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = Unaccounted | Limited of {remaining : Z.t}

type internal_gas

val encoding : t Data_encoding.encoding

val pp : Format.formatter -&gt; t -&gt; unit

type cost

val cost_encoding : cost Data_encoding.encoding

val pp_cost : Format.formatter -&gt; cost -&gt; unit

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Block_quota_exceeded</abbr> (* `Temporary *)

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Operation_quota_exceeded</abbr> (* `Temporary *)

val consume_raw :
  Z.t -&gt; t -&gt; internal_gas -&gt; cost -&gt; (Z.t * t * internal_gas) tzresult

val check_enough_raw : Z.t -&gt; t -&gt; internal_gas -&gt; cost -&gt; unit tzresult

val internal_gas_zero : internal_gas

val free : cost

val atomic_step_cost : int -&gt; cost

val step_cost : int -&gt; cost

val alloc_cost : int -&gt; cost

val alloc_bytes_cost : int -&gt; cost

val alloc_mbytes_cost : int -&gt; cost

val alloc_bits_cost : int -&gt; cost

val read_bytes_cost : Z.t -&gt; cost

val write_bytes_cost : Z.t -&gt; cost

val ( *@ ) : int -&gt; cost -&gt; cost

val ( +@ ) : cost -&gt; cost -&gt; cost
</pre>
  </div>
  <div class="col-md-6">
    <a href="#gas_limit_repr.mli"><code>Gas_limit_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.

Module ConstructorRecords_t.
  Module t.
    Module Limited.
      Record record {remaining : Set} : Set := Build {
        remaining : remaining }.
      Arguments record : clear implicits.
      Definition with_remaining {t_remaining} remaining
        (r : record t_remaining) :=
        Build t_remaining remaining.
    End Limited.
    Definition Limited_skeleton := Limited.record.
  End t.
End ConstructorRecords_t.
Import ConstructorRecords_t.

Reserved Notation &quot;'t.Limited&quot;.

Inductive t : Set :=
| Unaccounted : t
| Limited : 't.Limited -&gt; t

where &quot;'t.Limited&quot; := (t.Limited_skeleton Z.t).

Module t.
  Include ConstructorRecords_t.t.
  Definition Limited := 't.Limited.
End t.

Parameter internal_gas : Set.

Parameter encoding : Data_encoding.encoding t.

Parameter pp : Format.formatter -&gt; t -&gt; unit.

Parameter cost : Set.

Parameter cost_encoding : Data_encoding.encoding cost.

Parameter pp_cost : Format.formatter -&gt; cost -&gt; unit.

(* extensible_type_definition `error` *)

(* extensible_type_definition `error` *)

Parameter consume_raw :
  Z.t -&gt; t -&gt; internal_gas -&gt; cost -&gt;
  Error_monad.tzresult (Z.t * t * internal_gas).

Parameter check_enough_raw :
  Z.t -&gt; t -&gt; internal_gas -&gt; cost -&gt; Error_monad.tzresult unit.

Parameter internal_gas_zero : internal_gas.

Parameter free : cost.

Parameter atomic_step_cost : int -&gt; cost.

Parameter step_cost : int -&gt; cost.

Parameter alloc_cost : int -&gt; cost.

Parameter alloc_bytes_cost : int -&gt; cost.

Parameter alloc_mbytes_cost : int -&gt; cost.

Parameter alloc_bits_cost : int -&gt; cost.

Parameter read_bytes_cost : Z.t -&gt; cost.

Parameter write_bytes_cost : Z.t -&gt; cost.

Parameter op_starat : int -&gt; cost -&gt; cost.

Parameter op_plusat : cost -&gt; cost -&gt; cost.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="helpers_services.ml">
  <div style="margin: 20px;">
    <h3>Helpers_services</h3>
    <ul>
      <li>OCaml size: 890 lines</li>
      <li>Coq size: 859 lines (-4% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#helpers_services.ml"><code>helpers_services.ml</code></a>&nbsp;<span class="label label-warning">18 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Cannot_parse_operation</abbr> (* `Branch *)

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  register_error_kind
    `Branch
    ~id:&quot;operation.cannot_parse&quot;
    ~title:&quot;Cannot parse operation&quot;
    ~description:&quot;The operation is ill-formed or for another protocol version&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;The operation cannot be parsed&quot;)
    Data_encoding.unit
    (function Cannot_parse_operation -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Cannot_parse_operation)</abbr>

let parse_operation (op : Operation.raw) =
  match
    Data_encoding.Binary.of_bytes Operation.protocol_data_encoding op.proto
  with
  | Some protocol_data -&gt;
      ok {shell = op.shell; protocol_data}
  | None -&gt;
      error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Cannot_parse_operation</abbr>

let path = RPC_path.(open_root / &quot;helpers&quot;)

module Scripts = struct
  module S = struct
    open Data_encoding

    let path = RPC_path.(path / &quot;scripts&quot;)

    let run_code_input_encoding =
      obj9
        (req &quot;script&quot; Script.expr_encoding)
        (req &quot;storage&quot; Script.expr_encoding)
        (req &quot;input&quot; Script.expr_encoding)
        (req &quot;amount&quot; Tez.encoding)
        (req &quot;chain_id&quot; Chain_id.encoding)
        (opt &quot;source&quot; Contract.encoding)
        (opt &quot;payer&quot; Contract.encoding)
        (opt &quot;gas&quot; z)
        (dft &quot;entrypoint&quot; string &quot;default&quot;)

    let trace_encoding =
      def &quot;scripted.trace&quot; @@ list
      @@ obj3
           (req &quot;location&quot; Script.location_encoding)
           (req &quot;gas&quot; Gas.encoding)
           (req
              &quot;stack&quot;
              (list
                 (obj2 (req &quot;item&quot; Script.expr_encoding) (opt &quot;annot&quot; string))))

    let run_code =
      RPC_service.post_service
        ~description:&quot;Run a piece of code in the current context&quot;
        ~query:RPC_query.empty
        ~input:run_code_input_encoding
        ~output:
          (obj3
             (req &quot;storage&quot; Script.expr_encoding)
             (req &quot;operations&quot; (list Operation.internal_operation_encoding))
             (opt &quot;big_map_diff&quot; Contract.big_map_diff_encoding))
        RPC_path.(path / &quot;run_code&quot;)

    let trace_code =
      RPC_service.post_service
        ~description:
          &quot;Run a piece of code in the current context, keeping a trace&quot;
        ~query:RPC_query.empty
        ~input:run_code_input_encoding
        ~output:
          (obj4
             (req &quot;storage&quot; Script.expr_encoding)
             (req &quot;operations&quot; (list Operation.internal_operation_encoding))
             (req &quot;trace&quot; trace_encoding)
             (opt &quot;big_map_diff&quot; Contract.big_map_diff_encoding))
        RPC_path.(path / &quot;trace_code&quot;)

    let typecheck_code =
      RPC_service.post_service
        ~description:&quot;Typecheck a piece of code in the current context&quot;
        ~query:RPC_query.empty
        ~input:(obj2 (req &quot;program&quot; Script.expr_encoding) (opt &quot;gas&quot; z))
        ~output:
          (obj2
             (req &quot;type_map&quot; Script_tc_errors_registration.type_map_enc)
             (req &quot;gas&quot; Gas.encoding))
        RPC_path.(path / &quot;typecheck_code&quot;)

    let typecheck_data =
      RPC_service.post_service
        ~description:
          &quot;Check that some data expression is well formed and of a given type \
           in the current context&quot;
        ~query:RPC_query.empty
        ~input:
          (obj3
             (req &quot;data&quot; Script.expr_encoding)
             (req &quot;type&quot; Script.expr_encoding)
             (opt &quot;gas&quot; z))
        ~output:(obj1 (req &quot;gas&quot; Gas.encoding))
        RPC_path.(path / &quot;typecheck_data&quot;)

    let pack_data =
      RPC_service.post_service
        ~description:
          &quot;Computes the serialized version of some data expression using the \
           same algorithm as script instruction PACK&quot;
        ~input:
          (obj3
             (req &quot;data&quot; Script.expr_encoding)
             (req &quot;type&quot; Script.expr_encoding)
             (opt &quot;gas&quot; z))
        ~output:(obj2 (req &quot;packed&quot; bytes) (req &quot;gas&quot; Gas.encoding))
        ~query:RPC_query.empty
        RPC_path.(path / &quot;pack_data&quot;)

    let run_operation =
      RPC_service.post_service
        ~description:&quot;Run an operation without signature checks&quot;
        ~query:RPC_query.empty
        ~input:
          (obj2
             (req &quot;operation&quot; Operation.encoding)
             (req &quot;chain_id&quot; Chain_id.encoding))
        ~output:Apply_results.operation_data_and_metadata_encoding
        RPC_path.(path / &quot;run_operation&quot;)

    let entrypoint_type =
      RPC_service.post_service
        ~description:&quot;Return the type of the given entrypoint&quot;
        ~query:RPC_query.empty
        ~input:
          (obj2
             (req &quot;script&quot; Script.expr_encoding)
             (dft &quot;entrypoint&quot; string &quot;default&quot;))
        ~output:(obj1 (req &quot;entrypoint_type&quot; Script.expr_encoding))
        RPC_path.(path / &quot;entrypoint&quot;)

    let list_entrypoints =
      RPC_service.post_service
        ~description:&quot;Return the list of entrypoints of the given script&quot;
        ~query:RPC_query.empty
        ~input:(obj1 (req &quot;script&quot; Script.expr_encoding))
        ~output:
          (obj2
             (dft
                &quot;unreachable&quot;
                (Data_encoding.list
                   (obj1
                      (req
                         &quot;path&quot;
                         (Data_encoding.list
                            Michelson_v1_primitives.prim_encoding))))
                [])
             (req &quot;entrypoints&quot; (assoc Script.expr_encoding)))
        RPC_path.(path / &quot;entrypoints&quot;)
  end

  let register () =
    let open Services_registration in
    let originate_dummy_contract ctxt script =
      let ctxt = Contract.init_origination_nonce ctxt Operation_hash.zero in
      Contract.fresh_contract_from_current_nonce ctxt
      &gt;&gt;=? fun (ctxt, dummy_contract) -&gt;
      let balance =
        match Tez.of_mutez 4_000_000_000_000L with
        | Some balance -&gt;
            balance
        | None -&gt;
            <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
      in
      Contract.originate
        ctxt
        dummy_contract
        ~balance
        ~delegate:None
        ~script:(script, None)
      &gt;&gt;=? fun ctxt -&gt; return (ctxt, dummy_contract)
    in
    <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0
      S.run_code
      (fun ctxt
           ()
           ( code,
             storage,
             parameter,
             amount,
             chain_id,
             source,
             payer,
             gas,
             entrypoint )
           -&gt;
        let storage = Script.lazy_expr storage in
        let code = Script.lazy_expr code in
        originate_dummy_contract ctxt {storage; code}
        &gt;&gt;=? fun (ctxt, dummy_contract) -&gt;
        let (source, payer) =
          match (source, payer) with
          | (Some source, Some payer) -&gt;
              (source, payer)
          | (Some source, None) -&gt;
              (source, source)
          | (None, Some payer) -&gt;
              (payer, payer)
          | (None, None) -&gt;
              (dummy_contract, dummy_contract)
        in
        let gas =
          match gas with
          | Some gas -&gt;
              gas
          | None -&gt;
              Constants.hard_gas_limit_per_operation ctxt
        in
        let ctxt = Gas.set_limit ctxt gas in
        let step_constants =
          let open Script_interpreter in
          {source; payer; self = dummy_contract; amount; chain_id}
        in
        Script_interpreter.execute_wrapper
          ctxt
          Readable
          step_constants
          ~script:{storage; code}
          ~entrypoint
          ~parameter
        &gt;&gt;=? fun {Script_interpreter.storage; operations; big_map_diff; _} -&gt;
        return (storage, operations, big_map_diff))</abbr> ;
    <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0
      S.trace_code
      (fun ctxt
           ()
           ( code,
             storage,
             parameter,
             amount,
             chain_id,
             source,
             payer,
             gas,
             entrypoint )
           -&gt;
        let storage = Script.lazy_expr storage in
        let code = Script.lazy_expr code in
        originate_dummy_contract ctxt {storage; code}
        &gt;&gt;=? fun (ctxt, dummy_contract) -&gt;
        let (source, payer) =
          match (source, payer) with
          | (Some source, Some payer) -&gt;
              (source, payer)
          | (Some source, None) -&gt;
              (source, source)
          | (None, Some payer) -&gt;
              (payer, payer)
          | (None, None) -&gt;
              (dummy_contract, dummy_contract)
        in
        let gas =
          match gas with
          | Some gas -&gt;
              gas
          | None -&gt;
              Constants.hard_gas_limit_per_operation ctxt
        in
        let ctxt = Gas.set_limit ctxt gas in
        let step_constants =
          let open Script_interpreter in
          {source; payer; self = dummy_contract; amount; chain_id}
        in
        Script_interpreter.trace
          ctxt
          Readable
          step_constants
          ~script:{storage; code}
          ~entrypoint
          ~parameter
        &gt;&gt;=? fun ( {Script_interpreter.storage; operations; big_map_diff; _},
                   trace ) -&gt;
        return (storage, operations, trace, big_map_diff))</abbr> ;
    <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.typecheck_code (fun ctxt () (expr, maybe_gas) -&gt;
        let ctxt =
          match maybe_gas with
          | None -&gt;
              Gas.set_unlimited ctxt
          | Some gas -&gt;
              Gas.set_limit ctxt gas
        in
        Script_ir_translator.typecheck_code ctxt expr
        &gt;&gt;=? fun (res, ctxt) -&gt; return (res, Gas.level ctxt))</abbr> ;
    <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.typecheck_data (fun ctxt () (data, ty, maybe_gas) -&gt;
        let ctxt =
          match maybe_gas with
          | None -&gt;
              Gas.set_unlimited ctxt
          | Some gas -&gt;
              Gas.set_limit ctxt gas
        in
        Script_ir_translator.typecheck_data ctxt (data, ty)
        &gt;&gt;=? fun ctxt -&gt; return (Gas.level ctxt))</abbr> ;
    <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.pack_data (fun ctxt () (expr, typ, maybe_gas) -&gt;
        let open Script_ir_translator in
        let ctxt =
          match maybe_gas with
          | None -&gt;
              Gas.set_unlimited ctxt
          | Some gas -&gt;
              Gas.set_limit ctxt gas
        in
        Lwt.return (parse_packable_ty ctxt ~legacy:true (Micheline.root typ))
        &gt;&gt;=? fun (Ex_ty typ, ctxt) -&gt;
        parse_data ctxt ~legacy:true typ (Micheline.root expr)
        &gt;&gt;=? fun (data, ctxt) -&gt;
        Script_ir_translator.pack_data ctxt typ data
        &gt;&gt;=? fun (bytes, ctxt) -&gt; return (bytes, Gas.level ctxt))</abbr> ;
    <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0
      S.run_operation
      (fun ctxt
           ()
           ({shell; protocol_data = Operation_data protocol_data}, chain_id)
           -&gt;
        (* this code is a duplicate of Apply without signature check *)
        let partial_precheck_manager_contents (type kind) ctxt
            (op : kind Kind.manager contents) : context tzresult Lwt.t =
          let (Manager_operation
                {source; fee; counter; operation; gas_limit; storage_limit}) =
            op
          in
          Lwt.return (Gas.check_limit ctxt gas_limit)
          &gt;&gt;=? fun () -&gt;
          let ctxt = Gas.set_limit ctxt gas_limit in
          Lwt.return (Fees.check_storage_limit ctxt storage_limit)
          &gt;&gt;=? fun () -&gt;
          Contract.must_be_allocated ctxt (Contract.implicit_contract source)
          &gt;&gt;=? fun () -&gt;
          Contract.check_counter_increment ctxt source counter
          &gt;&gt;=? fun () -&gt;
          ( match operation with
          | Reveal pk -&gt;
              Contract.reveal_manager_key ctxt source pk
          | Transaction {parameters; _} -&gt;
              (* Here the data comes already deserialized, so we need to fake the deserialization to mimic apply *)
              let arg_bytes =
                Data_encoding.Binary.to_bytes_exn
                  Script.lazy_expr_encoding
                  parameters
              in
              let arg =
                match
                  Data_encoding.Binary.of_bytes
                    Script.lazy_expr_encoding
                    arg_bytes
                with
                | Some arg -&gt;
                    arg
                | None -&gt;
                    assert false
              in
              (* Fail quickly if not enough gas for minimal deserialization cost *)
              Lwt.return
              @@ record_trace Apply.Gas_quota_exceeded_init_deserialize
              @@ Gas.check_enough ctxt (Script.minimal_deserialize_cost arg)
              &gt;&gt;=? fun () -&gt;
              (* Fail if not enough gas for complete deserialization cost *)
              trace Apply.Gas_quota_exceeded_init_deserialize
              @@ Script.force_decode_in_context ctxt arg
              &gt;&gt;|? fun (_arg, ctxt) -&gt; ctxt
          | Origination {script; _} -&gt;
              (* Here the data comes already deserialized, so we need to fake the deserialization to mimic apply *)
              let script_bytes =
                Data_encoding.Binary.to_bytes_exn Script.encoding script
              in
              let script =
                match
                  Data_encoding.Binary.of_bytes Script.encoding script_bytes
                with
                | Some script -&gt;
                    script
                | None -&gt;
                    assert false
              in
              (* Fail quickly if not enough gas for minimal deserialization cost *)
              Lwt.return
              @@ record_trace Apply.Gas_quota_exceeded_init_deserialize
              @@ ( Gas.consume
                     ctxt
                     (Script.minimal_deserialize_cost script.code)
                 &gt;&gt;? fun ctxt -&gt;
                 Gas.check_enough
                   ctxt
                   (Script.minimal_deserialize_cost script.storage) )
              &gt;&gt;=? fun () -&gt;
              (* Fail if not enough gas for complete deserialization cost *)
              trace Apply.Gas_quota_exceeded_init_deserialize
              @@ Script.force_decode_in_context ctxt script.code
              &gt;&gt;=? fun (_code, ctxt) -&gt;
              trace Apply.Gas_quota_exceeded_init_deserialize
              @@ Script.force_decode_in_context ctxt script.storage
              &gt;&gt;|? fun (_storage, ctxt) -&gt; ctxt
          | _ -&gt;
              return ctxt )
          &gt;&gt;=? fun ctxt -&gt;
          Contract.get_manager_key ctxt source
          &gt;&gt;=? fun _public_key -&gt;
          (* signature check unplugged from here *)
          Contract.increment_counter ctxt source
          &gt;&gt;=? fun ctxt -&gt;
          Contract.spend ctxt (Contract.implicit_contract source) fee
          &gt;&gt;=? fun ctxt -&gt; return ctxt
        in
        let rec partial_precheck_manager_contents_list :
            type kind.
            Alpha_context.t -&gt;
            kind Kind.manager contents_list -&gt;
            context tzresult Lwt.t =
         fun ctxt contents_list -&gt;
          match contents_list with
          | Single (Manager_operation _ as op) -&gt;
              partial_precheck_manager_contents ctxt op
          | Cons ((Manager_operation _ as op), rest) -&gt;
              partial_precheck_manager_contents ctxt op
              &gt;&gt;=? fun ctxt -&gt; partial_precheck_manager_contents_list ctxt rest
        in
        let return contents =
          return
            ( Operation_data protocol_data,
              Apply_results.Operation_metadata {contents} )
        in
        let operation : _ operation = {shell; protocol_data} in
        let hash = Operation.hash {shell; protocol_data} in
        let ctxt = Contract.init_origination_nonce ctxt hash in
        let baker = Signature.Public_key_hash.zero in
        match protocol_data.contents with
        | Single (Manager_operation _) as op -&gt;
            partial_precheck_manager_contents_list ctxt op
            &gt;&gt;=? fun ctxt -&gt;
            Apply.apply_manager_contents_list ctxt Optimized baker chain_id op
            &gt;&gt;= fun (_ctxt, result) -&gt; return result
        | Cons (Manager_operation _, _) as op -&gt;
            partial_precheck_manager_contents_list ctxt op
            &gt;&gt;=? fun ctxt -&gt;
            Apply.apply_manager_contents_list ctxt Optimized baker chain_id op
            &gt;&gt;= fun (_ctxt, result) -&gt; return result
        | _ -&gt;
            Apply.apply_contents_list
              ctxt
              chain_id
              Optimized
              shell.branch
              baker
              operation
              operation.protocol_data.contents
            &gt;&gt;=? fun (_ctxt, result) -&gt; return result)</abbr> ;
    <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.entrypoint_type (fun ctxt () (expr, entrypoint) -&gt;
        let ctxt = Gas.set_unlimited ctxt in
        let legacy = false in
        let open Script_ir_translator in
        Lwt.return
          ( parse_toplevel ~legacy expr
          &gt;&gt;? fun (arg_type, _, _, root_name) -&gt;
          parse_ty
            ctxt
            ~legacy
            ~allow_big_map:true
            ~allow_operation:false
            ~allow_contract:true
            arg_type
          &gt;&gt;? fun (Ex_ty arg_type, _) -&gt;
          Script_ir_translator.find_entrypoint ~root_name arg_type entrypoint
          )
        &gt;&gt;=? fun (_f, Ex_ty ty) -&gt;
        unparse_ty ctxt ty
        &gt;&gt;=? fun (ty_node, _) -&gt; return (Micheline.strip_locations ty_node))</abbr> ;
    register0 S.list_entrypoints (fun ctxt () expr -&gt;
        let ctxt = Gas.set_unlimited ctxt in
        let legacy = false in
        let open Script_ir_translator in
        Lwt.return
          ( parse_toplevel ~legacy expr
          &gt;&gt;? fun (arg_type, _, _, root_name) -&gt;
          parse_ty
            ctxt
            ~legacy
            ~allow_big_map:true
            ~allow_operation:false
            ~allow_contract:true
            arg_type
          &gt;&gt;? fun (Ex_ty arg_type, _) -&gt;
          Script_ir_translator.list_entrypoints ~root_name arg_type ctxt )
        &gt;&gt;=? fun (unreachable_entrypoint, map) -&gt;
        return
          ( unreachable_entrypoint,
            Entrypoints_map.fold
              (fun entry (_, ty) acc -&gt;
                (entry, Micheline.strip_locations ty) :: acc)
              map
              [] ))

  let run_code ctxt block code
      (storage, input, amount, chain_id, source, payer, gas, entrypoint) =
    RPC_context.make_call0
      S.run_code
      ctxt
      block
      ()
      (code, storage, input, amount, chain_id, source, payer, gas, entrypoint)

  let trace_code ctxt block code
      (storage, input, amount, chain_id, source, payer, gas, entrypoint) =
    RPC_context.make_call0
      S.trace_code
      ctxt
      block
      ()
      (code, storage, input, amount, chain_id, source, payer, gas, entrypoint)

  let typecheck_code ctxt block =
    RPC_context.make_call0 S.typecheck_code ctxt block ()

  let typecheck_data ctxt block =
    RPC_context.make_call0 S.typecheck_data ctxt block ()

  let pack_data ctxt block = RPC_context.make_call0 S.pack_data ctxt block ()

  let run_operation ctxt block =
    RPC_context.make_call0 S.run_operation ctxt block ()

  let entrypoint_type ctxt block =
    RPC_context.make_call0 S.entrypoint_type ctxt block ()

  let list_entrypoints ctxt block =
    RPC_context.make_call0 S.list_entrypoints ctxt block ()
end

module Forge = struct
  module S = struct
    open Data_encoding

    let path = RPC_path.(path / &quot;forge&quot;)

    let operations =
      RPC_service.post_service
        ~description:&quot;Forge an operation&quot;
        ~query:RPC_query.empty
        ~input:Operation.unsigned_encoding
        ~output:bytes
        RPC_path.(path / &quot;operations&quot;)

    let empty_proof_of_work_nonce =
      MBytes.of_string
        (String.make Constants_repr.proof_of_work_nonce_size '\000')

    let protocol_data =
      RPC_service.post_service
        ~description:&quot;Forge the protocol-specific part of a block header&quot;
        ~query:RPC_query.empty
        ~input:
          (obj3
             (req &quot;priority&quot; uint16)
             (opt &quot;nonce_hash&quot; Nonce_hash.encoding)
             (dft
                &quot;proof_of_work_nonce&quot;
                (Fixed.bytes Alpha_context.Constants.proof_of_work_nonce_size)
                empty_proof_of_work_nonce))
        ~output:(obj1 (req &quot;protocol_data&quot; bytes))
        RPC_path.(path / &quot;protocol_data&quot;)
  end

  let register () =
    let open Services_registration in
    <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0_noctxt S.operations (fun () (shell, proto) -&gt;
        return
          (Data_encoding.Binary.to_bytes_exn
             Operation.unsigned_encoding
             (shell, proto)))</abbr> ;
    register0_noctxt
      S.protocol_data
      (fun () (priority, seed_nonce_hash, proof_of_work_nonce) -&gt;
        return
          (Data_encoding.Binary.to_bytes_exn
             Block_header.contents_encoding
             {priority; seed_nonce_hash; proof_of_work_nonce}))

  module Manager = struct
    let operations ctxt block ~branch ~source ?sourcePubKey ~counter ~fee
        ~gas_limit ~storage_limit operations =
      Contract_services.manager_key ctxt block source
      &gt;&gt;= function
      | Error error -&gt;
          Lwt.return (Error error)
      | Ok revealed -&gt;
          let ops =
            List.map
              (fun (Manager operation) -&gt;
                Contents
                  (Manager_operation
                     {
                       source;
                       counter;
                       operation;
                       fee;
                       gas_limit;
                       storage_limit;
                     }))
              operations
          in
          let ops =
            match (sourcePubKey, revealed) with
            | (None, _) | (_, Some _) -&gt;
                ops
            | (Some pk, None) -&gt;
                let operation = Reveal pk in
                Contents
                  (Manager_operation
                     {
                       source;
                       counter;
                       operation;
                       fee;
                       gas_limit;
                       storage_limit;
                     })
                :: ops
          in
          RPC_context.make_call0
            S.operations
            ctxt
            block
            ()
            ({branch}, Operation.of_list ops)

    let reveal ctxt block ~branch ~source ~sourcePubKey ~counter ~fee () =
      operations
        ctxt
        block
        ~branch
        ~source
        ~sourcePubKey
        ~counter
        ~fee
        ~gas_limit:Z.zero
        ~storage_limit:Z.zero
        []

    let transaction ctxt block ~branch ~source ?sourcePubKey ~counter ~amount
        ~destination ?(entrypoint = &quot;default&quot;) ?parameters ~gas_limit
        ~storage_limit ~fee () =
      let parameters =
        Option.unopt_map
          ~f:Script.lazy_expr
          ~default:Script.unit_parameter
          parameters
      in
      operations
        ctxt
        block
        ~branch
        ~source
        ?sourcePubKey
        ~counter
        ~fee
        ~gas_limit
        ~storage_limit
        [Manager (Transaction {amount; parameters; destination; entrypoint})]

    let origination ctxt block ~branch ~source ?sourcePubKey ~counter ~balance
        ?delegatePubKey ~script ~gas_limit ~storage_limit ~fee () =
      operations
        ctxt
        block
        ~branch
        ~source
        ?sourcePubKey
        ~counter
        ~fee
        ~gas_limit
        ~storage_limit
        [ Manager
            (Origination
               {
                 delegate = delegatePubKey;
                 script;
                 credit = balance;
                 preorigination = None;
               }) ]

    let delegation ctxt block ~branch ~source ?sourcePubKey ~counter ~fee
        delegate =
      operations
        ctxt
        block
        ~branch
        ~source
        ?sourcePubKey
        ~counter
        ~fee
        ~gas_limit:Z.zero
        ~storage_limit:Z.zero
        [Manager (Delegation delegate)]
  end

  let operation ctxt block ~branch operation =
    RPC_context.make_call0
      S.operations
      ctxt
      block
      ()
      ({branch}, Contents_list (Single operation))

  let endorsement ctxt b ~branch ~level () =
    operation ctxt b ~branch (Endorsement {level})

  let proposals ctxt b ~branch ~source ~period ~proposals () =
    operation ctxt b ~branch (Proposals {source; period; proposals})

  let ballot ctxt b ~branch ~source ~period ~proposal ~ballot () =
    operation ctxt b ~branch (Ballot {source; period; proposal; ballot})

  let seed_nonce_revelation ctxt block ~branch ~level ~nonce () =
    operation ctxt block ~branch (Seed_nonce_revelation {level; nonce})

  let double_baking_evidence ctxt block ~branch ~bh1 ~bh2 () =
    operation ctxt block ~branch (Double_baking_evidence {bh1; bh2})

  let double_endorsement_evidence ctxt block ~branch ~op1 ~op2 () =
    operation ctxt block ~branch (Double_endorsement_evidence {op1; op2})

  let empty_proof_of_work_nonce =
    MBytes.of_string
      (String.make Constants_repr.proof_of_work_nonce_size '\000')

  let protocol_data ctxt block ~priority ?seed_nonce_hash
      ?(proof_of_work_nonce = empty_proof_of_work_nonce) () =
    RPC_context.make_call0
      S.protocol_data
      ctxt
      block
      ()
      (priority, seed_nonce_hash, proof_of_work_nonce)
end

module Parse = struct
  module S = struct
    open Data_encoding

    let path = RPC_path.(path / &quot;parse&quot;)

    let operations =
      RPC_service.post_service
        ~description:&quot;Parse operations&quot;
        ~query:RPC_query.empty
        ~input:
          (obj2
             (req &quot;operations&quot; (list (dynamic_size Operation.raw_encoding)))
             (opt &quot;check_signature&quot; bool))
        ~output:(list (dynamic_size Operation.encoding))
        RPC_path.(path / &quot;operations&quot;)

    let block =
      RPC_service.post_service
        ~description:&quot;Parse a block&quot;
        ~query:RPC_query.empty
        ~input:Block_header.raw_encoding
        ~output:Block_header.protocol_data_encoding
        RPC_path.(path / &quot;block&quot;)
  end

  let parse_protocol_data protocol_data =
    match
      Data_encoding.Binary.of_bytes
        Block_header.protocol_data_encoding
        protocol_data
    with
    | None -&gt;
        failwith &quot;Cant_parse_protocol_data&quot;
    | Some protocol_data -&gt;
        return protocol_data

  let register () =
    let open Services_registration in
    <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.operations (fun _ctxt () (operations, check) -&gt;
        map_s
          (fun raw -&gt;
            Lwt.return (parse_operation raw)
            &gt;&gt;=? fun op -&gt;
            ( match check with
            | Some true -&gt;
                return_unit (* FIXME *)
            (* I.check_signature ctxt *)
            (* op.protocol_data.signature op.shell op.protocol_data.contents *)
            | Some false | None -&gt;
                return_unit )
            &gt;&gt;|? fun () -&gt; op)
          operations)</abbr> ;
    register0_noctxt S.block (fun () (raw_block : Block_header.raw) -&gt;
        parse_protocol_data (raw_block : Block_header.raw).protocol_data)

  let operations ctxt block ?check operations =
    RPC_context.make_call0 S.operations ctxt block () (operations, check)

  let block ctxt block shell protocol_data =
    RPC_context.make_call0
      S.block
      ctxt
      block
      ()
      ({shell; protocol_data} : Block_header.raw)
end

module S = struct
  open Data_encoding

  type level_query = {offset : int32}

  let level_query : level_query RPC_query.t =
    let open RPC_query in
    query (fun offset -&gt; {offset})
    |+ field &quot;offset&quot; RPC_arg.int32 0l (fun t -&gt; t.offset)
    |&gt; seal

  let current_level =
    RPC_service.get_service
      ~description:
        &quot;Returns the level of the interrogated block, or the one of a block \
         located `offset` blocks after in the chain (or before when \
         negative). For instance, the next block if `offset` is 1.&quot;
      ~query:level_query
      ~output:Level.encoding
      RPC_path.(path / &quot;current_level&quot;)

  let levels_in_current_cycle =
    RPC_service.get_service
      ~description:&quot;Levels of a cycle&quot;
      ~query:level_query
      ~output:
        (obj2 (req &quot;first&quot; Raw_level.encoding) (req &quot;last&quot; Raw_level.encoding))
      RPC_path.(path / &quot;levels_in_current_cycle&quot;)
end

let register () =
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Scripts.register ()</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Forge.register ()</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Parse.register ()</abbr> ;
  let open Services_registration in
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.current_level (fun ctxt q () -&gt;
      let level = Level.current ctxt in
      return (Level.from_raw ctxt ~offset:q.offset level.level))</abbr> ;
  register0 S.levels_in_current_cycle (fun ctxt q () -&gt;
      let levels = Level.levels_in_current_cycle ctxt ~offset:q.offset () in
      match levels with
      | [] -&gt;
          raise <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Not_found</abbr>
      | _ -&gt;
          let first = List.hd (List.rev levels) in
          let last = List.hd levels in
          return (first.level, last.level))

let current_level ctxt ?(offset = 0l) block =
  RPC_context.make_call0 S.current_level ctxt block {offset} ()

let levels_in_current_cycle ctxt ?(offset = 0l) block =
  RPC_context.make_call0 S.levels_in_current_cycle ctxt block {offset} ()
</pre>
  </div>
  <div class="col-md-6">
    <a href="#helpers_services.ml"><code>Helpers_services.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Apply_results.
Require Tezos.Constants_repr.
Require Tezos.Contract_services.
Require Tezos.Michelson_v1_primitives.
Require Tezos.Nonce_hash.
Require Tezos.Script_ir_translator.
Require Tezos.Script_tc_errors_registration.
Require Tezos.Script_typed_ir.
Require Tezos.Services_registration.

Import Alpha_context.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition parse_operation (op : Alpha_context.Operation.raw)
  : Error_monad.tzresult Alpha_context.packed_operation :=
  match
    Data_encoding.Binary.of_bytes Alpha_context.Operation.protocol_data_encoding
      op.(Operation.t.proto) with
  | Some protocol_data =&gt;
    Error_monad.ok
      {| Alpha_context.packed_operation.shell := op.(Operation.t.shell);
        Alpha_context.packed_operation.protocol_data := protocol_data |}
  | None =&gt; Error_monad.__error_value extensible_type_value
  end.

Definition path : RPC_path.path Updater.rpc_context Updater.rpc_context :=
  RPC_path.op_div RPC_path.open_root &quot;helpers&quot;.

Module Scripts.
  Module S.
    Import Data_encoding.
    
    Definition path : RPC_path.path Updater.rpc_context Updater.rpc_context :=
      RPC_path.op_div path &quot;scripts&quot;.
    
    Definition run_code_input_encoding
      : Data_encoding.encoding
        (Alpha_context.Script.expr * Alpha_context.Script.expr *
          Alpha_context.Script.expr * Alpha_context.Tez.t *
          (|Chain_id|).(S.HASH.t) * option Alpha_context.Contract.t *
          option Alpha_context.Contract.t * option Z.t * string) :=
      Data_encoding.obj9
        (Data_encoding.req None None &quot;script&quot; Alpha_context.Script.expr_encoding)
        (Data_encoding.req None None &quot;storage&quot;
          Alpha_context.Script.expr_encoding)
        (Data_encoding.req None None &quot;input&quot; Alpha_context.Script.expr_encoding)
        (Data_encoding.req None None &quot;amount&quot; Alpha_context.Tez.encoding)
        (Data_encoding.req None None &quot;chain_id&quot; (|Chain_id|).(S.HASH.encoding))
        (Data_encoding.opt None None &quot;source&quot; Alpha_context.Contract.encoding)
        (Data_encoding.opt None None &quot;payer&quot; Alpha_context.Contract.encoding)
        (Data_encoding.opt None None &quot;gas&quot; Data_encoding.z)
        (Data_encoding.dft None None &quot;entrypoint&quot; Data_encoding.__string_value
          &quot;default&quot;).
    
    Definition trace_encoding
      : Data_encoding.encoding
        (list
          (Alpha_context.Script.location * Alpha_context.Gas.t *
            list (Alpha_context.Script.expr * option string))) :=
      (let arg := Data_encoding.def &quot;scripted.trace&quot; in
      fun eta =&gt; arg None None eta)
        ((let arg := Data_encoding.__list_value in
        fun eta =&gt; arg None eta)
          (Data_encoding.obj3
            (Data_encoding.req None None &quot;location&quot;
              Alpha_context.Script.location_encoding)
            (Data_encoding.req None None &quot;gas&quot; Alpha_context.Gas.encoding)
            (Data_encoding.req None None &quot;stack&quot;
              (Data_encoding.__list_value None
                (Data_encoding.obj2
                  (Data_encoding.req None None &quot;item&quot;
                    Alpha_context.Script.expr_encoding)
                  (Data_encoding.opt None None &quot;annot&quot;
                    Data_encoding.__string_value)))))).
    
    Definition run_code
      : RPC_service.service Updater.rpc_context Updater.rpc_context unit
        (Alpha_context.Script.expr * Alpha_context.Script.expr *
          Alpha_context.Script.expr * Alpha_context.Tez.t *
          (|Chain_id|).(S.HASH.t) * option Alpha_context.Contract.t *
          option Alpha_context.Contract.t * option Z.t * string)
        (Alpha_context.Script.expr *
          list Alpha_context.packed_internal_operation *
          option Alpha_context.Contract.big_map_diff) :=
      RPC_service.post_service
        (Some &quot;Run a piece of code in the current context&quot;) RPC_query.empty
        run_code_input_encoding
        (Data_encoding.obj3
          (Data_encoding.req None None &quot;storage&quot;
            Alpha_context.Script.expr_encoding)
          (Data_encoding.req None None &quot;operations&quot;
            (Data_encoding.__list_value None
              Alpha_context.Operation.internal_operation_encoding))
          (Data_encoding.opt None None &quot;big_map_diff&quot;
            Alpha_context.Contract.big_map_diff_encoding))
        (RPC_path.op_div path &quot;run_code&quot;).
    
    Definition trace_code
      : RPC_service.service Updater.rpc_context Updater.rpc_context unit
        (Alpha_context.Script.expr * Alpha_context.Script.expr *
          Alpha_context.Script.expr * Alpha_context.Tez.t *
          (|Chain_id|).(S.HASH.t) * option Alpha_context.Contract.t *
          option Alpha_context.Contract.t * option Z.t * string)
        (Alpha_context.Script.expr *
          list Alpha_context.packed_internal_operation *
          list
            (Alpha_context.Script.location * Alpha_context.Gas.t *
              list (Alpha_context.Script.expr * option string)) *
          option Alpha_context.Contract.big_map_diff) :=
      RPC_service.post_service
        (Some &quot;Run a piece of code in the current context, keeping a trace&quot;)
        RPC_query.empty run_code_input_encoding
        (Data_encoding.obj4
          (Data_encoding.req None None &quot;storage&quot;
            Alpha_context.Script.expr_encoding)
          (Data_encoding.req None None &quot;operations&quot;
            (Data_encoding.__list_value None
              Alpha_context.Operation.internal_operation_encoding))
          (Data_encoding.req None None &quot;trace&quot; trace_encoding)
          (Data_encoding.opt None None &quot;big_map_diff&quot;
            Alpha_context.Contract.big_map_diff_encoding))
        (RPC_path.op_div path &quot;trace_code&quot;).
    
    Definition typecheck_code
      : RPC_service.service Updater.rpc_context Updater.rpc_context unit
        (Alpha_context.Script.expr * option Z.t)
        (list
          (Alpha_context.Script.location *
            (list (Alpha_context.Script.expr * list string) *
              list (Alpha_context.Script.expr * list string))) *
          Alpha_context.Gas.t) :=
      RPC_service.post_service
        (Some &quot;Typecheck a piece of code in the current context&quot;)
        RPC_query.empty
        (Data_encoding.obj2
          (Data_encoding.req None None &quot;program&quot;
            Alpha_context.Script.expr_encoding)
          (Data_encoding.opt None None &quot;gas&quot; Data_encoding.z))
        (Data_encoding.obj2
          (Data_encoding.req None None &quot;type_map&quot;
            Script_tc_errors_registration.type_map_enc)
          (Data_encoding.req None None &quot;gas&quot; Alpha_context.Gas.encoding))
        (RPC_path.op_div path &quot;typecheck_code&quot;).
    
    Definition typecheck_data
      : RPC_service.service Updater.rpc_context Updater.rpc_context unit
        (Alpha_context.Script.expr * Alpha_context.Script.expr * option Z.t)
        Alpha_context.Gas.t :=
      RPC_service.post_service
        (Some
          &quot;Check that some data expression is well formed and of a given type in the current context&quot;)
        RPC_query.empty
        (Data_encoding.obj3
          (Data_encoding.req None None &quot;data&quot; Alpha_context.Script.expr_encoding)
          (Data_encoding.req None None &quot;type&quot; Alpha_context.Script.expr_encoding)
          (Data_encoding.opt None None &quot;gas&quot; Data_encoding.z))
        (Data_encoding.obj1
          (Data_encoding.req None None &quot;gas&quot; Alpha_context.Gas.encoding))
        (RPC_path.op_div path &quot;typecheck_data&quot;).
    
    Definition pack_data
      : RPC_service.service Updater.rpc_context Updater.rpc_context unit
        (Alpha_context.Script.expr * Alpha_context.Script.expr * option Z.t)
        (MBytes.t * Alpha_context.Gas.t) :=
      RPC_service.post_service
        (Some
          &quot;Computes the serialized version of some data expression using the same algorithm as script instruction PACK&quot;)
        RPC_query.empty
        (Data_encoding.obj3
          (Data_encoding.req None None &quot;data&quot; Alpha_context.Script.expr_encoding)
          (Data_encoding.req None None &quot;type&quot; Alpha_context.Script.expr_encoding)
          (Data_encoding.opt None None &quot;gas&quot; Data_encoding.z))
        (Data_encoding.obj2
          (Data_encoding.req None None &quot;packed&quot; Data_encoding.__bytes_value)
          (Data_encoding.req None None &quot;gas&quot; Alpha_context.Gas.encoding))
        (RPC_path.op_div path &quot;pack_data&quot;).
    
    Definition run_operation
      : RPC_service.service Updater.rpc_context Updater.rpc_context unit
        (Alpha_context.Operation.packed * (|Chain_id|).(S.HASH.t))
        (Alpha_context.Operation.packed_protocol_data *
          Apply_results.packed_operation_metadata) :=
      RPC_service.post_service
        (Some &quot;Run an operation without signature checks&quot;) RPC_query.empty
        (Data_encoding.obj2
          (Data_encoding.req None None &quot;operation&quot;
            Alpha_context.Operation.encoding)
          (Data_encoding.req None None &quot;chain_id&quot; (|Chain_id|).(S.HASH.encoding)))
        Apply_results.operation_data_and_metadata_encoding
        (RPC_path.op_div path &quot;run_operation&quot;).
    
    Definition entrypoint_type
      : RPC_service.service Updater.rpc_context Updater.rpc_context unit
        (Alpha_context.Script.expr * string) Alpha_context.Script.expr :=
      RPC_service.post_service (Some &quot;Return the type of the given entrypoint&quot;)
        RPC_query.empty
        (Data_encoding.obj2
          (Data_encoding.req None None &quot;script&quot;
            Alpha_context.Script.expr_encoding)
          (Data_encoding.dft None None &quot;entrypoint&quot; Data_encoding.__string_value
            &quot;default&quot;))
        (Data_encoding.obj1
          (Data_encoding.req None None &quot;entrypoint_type&quot;
            Alpha_context.Script.expr_encoding))
        (RPC_path.op_div path &quot;entrypoint&quot;).
    
    Definition list_entrypoints
      : RPC_service.service Updater.rpc_context Updater.rpc_context unit
        Alpha_context.Script.expr
        (list (list Michelson_v1_primitives.prim) *
          list (string * Alpha_context.Script.expr)) :=
      RPC_service.post_service
        (Some &quot;Return the list of entrypoints of the given script&quot;)
        RPC_query.empty
        (Data_encoding.obj1
          (Data_encoding.req None None &quot;script&quot;
            Alpha_context.Script.expr_encoding))
        (Data_encoding.obj2
          (Data_encoding.dft None None &quot;unreachable&quot;
            (Data_encoding.__list_value None
              (Data_encoding.obj1
                (Data_encoding.req None None &quot;path&quot;
                  (Data_encoding.__list_value None
                    Michelson_v1_primitives.prim_encoding)))) nil)
          (Data_encoding.req None None &quot;entrypoints&quot;
            (Data_encoding.assoc Alpha_context.Script.expr_encoding)))
        (RPC_path.op_div path &quot;entrypoints&quot;).
  End S.
  
  Definition register (function_parameter : unit) : unit :=
    let '_ := function_parameter in
    let originate_dummy_contract
      (ctxt : Alpha_context.context) (script : Alpha_context.Script.t)
      : Lwt.t
        (Error_monad.tzresult (Alpha_context.context * Alpha_context.Contract.t)) :=
      let ctxt :=
        Alpha_context.Contract.init_origination_nonce ctxt
          (|Operation_hash|).(S.HASH.zero) in
      let=? '(ctxt, dummy_contract) :=
        Alpha_context.Contract.fresh_contract_from_current_nonce ctxt in
      let balance :=
        match
          Alpha_context.Tez.of_mutez
            (* ‚ùå Constant of type int64 is converted to int *)
            4000000000000 with
        | Some balance =&gt; balance
        | None =&gt;
          (* ‚ùå Assert instruction is not handled. *)
          assert Alpha_context.Tez.tez false
        end in
      let=? ctxt :=
        Alpha_context.Contract.originate ctxt dummy_contract balance
          (script, None) None in
      Error_monad.__return (ctxt, dummy_contract) in
    (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
    (* ‚ùå instruction_sequence &quot;;&quot; *)
    (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
    (* ‚ùå instruction_sequence &quot;;&quot; *)
    (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
    (* ‚ùå instruction_sequence &quot;;&quot; *)
    (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
    (* ‚ùå instruction_sequence &quot;;&quot; *)
    (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
    (* ‚ùå instruction_sequence &quot;;&quot; *)
    (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
    (* ‚ùå instruction_sequence &quot;;&quot; *)
    (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
    (* ‚ùå instruction_sequence &quot;;&quot; *)
    Services_registration.register0 S.list_entrypoints
      (fun ctxt =&gt;
        fun function_parameter =&gt;
          let '_ := function_parameter in
          fun expr =&gt;
            let ctxt := Alpha_context.Gas.set_unlimited ctxt in
            let legacy := false in
            let=? '(unreachable_entrypoint, map) :=
              Lwt.__return
                (let? '(arg_type, _, _, root_name) :=
                  Script_ir_translator.parse_toplevel legacy expr in
                let? '(Script_ir_translator.Ex_ty arg_type, _) :=
                  Script_ir_translator.parse_ty ctxt legacy true false true
                    arg_type in
                Script_ir_translator.list_entrypoints arg_type ctxt root_name)
              in
            Error_monad.__return
              (unreachable_entrypoint,
                ((|Script_ir_translator.Entrypoints_map|).(S.MAP.fold)
                  (fun entry =&gt;
                    fun function_parameter =&gt;
                      let '(_, ty) := function_parameter in
                      fun acc =&gt;
                        cons (entry, (Micheline.strip_locations ty)) acc) map
                  nil))).
  
  Definition run_code {A : Set}
    (ctxt : RPC_context.simple A) (block : A) (code : Alpha_context.Script.expr)
    (function_parameter :
      Alpha_context.Script.expr * Alpha_context.Script.expr *
        Alpha_context.Tez.t * (|Chain_id|).(S.HASH.t) *
        option Alpha_context.Contract.t * option Alpha_context.Contract.t *
        option Z.t * string)
    : Lwt.t
      (Error_monad.shell_tzresult
        (Alpha_context.Script.expr *
          list Alpha_context.packed_internal_operation *
          option Alpha_context.Contract.big_map_diff)) :=
    let '(storage, input, amount, chain_id, source, payer, gas, entrypoint) :=
      function_parameter in
    RPC_context.make_call0 S.run_code ctxt block tt
      (code, storage, input, amount, chain_id, source, payer, gas, entrypoint).
  
  Definition trace_code {A : Set}
    (ctxt : RPC_context.simple A) (block : A) (code : Alpha_context.Script.expr)
    (function_parameter :
      Alpha_context.Script.expr * Alpha_context.Script.expr *
        Alpha_context.Tez.t * (|Chain_id|).(S.HASH.t) *
        option Alpha_context.Contract.t * option Alpha_context.Contract.t *
        option Z.t * string)
    : Lwt.t
      (Error_monad.shell_tzresult
        (Alpha_context.Script.expr *
          list Alpha_context.packed_internal_operation *
          list
            (Alpha_context.Script.location * Alpha_context.Gas.t *
              list (Alpha_context.Script.expr * option string)) *
          option Alpha_context.Contract.big_map_diff)) :=
    let '(storage, input, amount, chain_id, source, payer, gas, entrypoint) :=
      function_parameter in
    RPC_context.make_call0 S.trace_code ctxt block tt
      (code, storage, input, amount, chain_id, source, payer, gas, entrypoint).
  
  Definition typecheck_code {A : Set} (ctxt : RPC_context.simple A) (block : A)
    : Alpha_context.Script.expr * option Z.t -&gt;
    Lwt.t
      (Error_monad.shell_tzresult
        (list
          (Alpha_context.Script.location *
            (list (Alpha_context.Script.expr * list string) *
              list (Alpha_context.Script.expr * list string))) *
          Alpha_context.Gas.t)) :=
    RPC_context.make_call0 S.typecheck_code ctxt block tt.
  
  Definition typecheck_data {A : Set} (ctxt : RPC_context.simple A) (block : A)
    : Alpha_context.Script.expr * Alpha_context.Script.expr * option Z.t -&gt;
    Lwt.t (Error_monad.shell_tzresult Alpha_context.Gas.t) :=
    RPC_context.make_call0 S.typecheck_data ctxt block tt.
  
  Definition pack_data {A : Set} (ctxt : RPC_context.simple A) (block : A)
    : Alpha_context.Script.expr * Alpha_context.Script.expr * option Z.t -&gt;
    Lwt.t (Error_monad.shell_tzresult (MBytes.t * Alpha_context.Gas.t)) :=
    RPC_context.make_call0 S.pack_data ctxt block tt.
  
  Definition run_operation {A : Set} (ctxt : RPC_context.simple A) (block : A)
    : Alpha_context.Operation.packed * (|Chain_id|).(S.HASH.t) -&gt;
    Lwt.t
      (Error_monad.shell_tzresult
        (Alpha_context.Operation.packed_protocol_data *
          Apply_results.packed_operation_metadata)) :=
    RPC_context.make_call0 S.run_operation ctxt block tt.
  
  Definition entrypoint_type {A : Set} (ctxt : RPC_context.simple A) (block : A)
    : Alpha_context.Script.expr * string -&gt;
    Lwt.t (Error_monad.shell_tzresult Alpha_context.Script.expr) :=
    RPC_context.make_call0 S.entrypoint_type ctxt block tt.
  
  Definition list_entrypoints {A : Set}
    (ctxt : RPC_context.simple A) (block : A)
    : Alpha_context.Script.expr -&gt;
    Lwt.t
      (Error_monad.shell_tzresult
        (list (list Michelson_v1_primitives.prim) *
          list (string * Alpha_context.Script.expr))) :=
    RPC_context.make_call0 S.list_entrypoints ctxt block tt.
End Scripts.

Module Forge.
  Module S.
    Import Data_encoding.
    
    Definition path : RPC_path.path Updater.rpc_context Updater.rpc_context :=
      RPC_path.op_div path &quot;forge&quot;.
    
    Definition operations
      : RPC_service.service Updater.rpc_context Updater.rpc_context unit
        (Operation.shell_header * Alpha_context.packed_contents_list) MBytes.t :=
      RPC_service.post_service (Some &quot;Forge an operation&quot;) RPC_query.empty
        Alpha_context.Operation.unsigned_encoding Data_encoding.__bytes_value
        (RPC_path.op_div path &quot;operations&quot;).
    
    Definition empty_proof_of_work_nonce : MBytes.t :=
      MBytes.of_string
        (String.make Constants_repr.proof_of_work_nonce_size &quot;000&quot; % char).
    
    Definition protocol_data
      : RPC_service.service Updater.rpc_context Updater.rpc_context unit
        (int * option Nonce_hash.t * MBytes.t) MBytes.t :=
      RPC_service.post_service
        (Some &quot;Forge the protocol-specific part of a block header&quot;)
        RPC_query.empty
        (Data_encoding.obj3
          (Data_encoding.req None None &quot;priority&quot; Data_encoding.uint16)
          (Data_encoding.opt None None &quot;nonce_hash&quot; Nonce_hash.encoding)
          (Data_encoding.dft None None &quot;proof_of_work_nonce&quot;
            (Data_encoding.Fixed.__bytes_value
              Alpha_context.Constants.proof_of_work_nonce_size)
            empty_proof_of_work_nonce))
        (Data_encoding.obj1
          (Data_encoding.req None None &quot;protocol_data&quot;
            Data_encoding.__bytes_value)) (RPC_path.op_div path &quot;protocol_data&quot;).
  End S.
  
  Definition register (function_parameter : unit) : unit :=
    let '_ := function_parameter in
    (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
    (* ‚ùå instruction_sequence &quot;;&quot; *)
    Services_registration.register0_noctxt S.protocol_data
      (fun function_parameter =&gt;
        let '_ := function_parameter in
        fun function_parameter =&gt;
          let '(priority, seed_nonce_hash, proof_of_work_nonce) :=
            function_parameter in
          Error_monad.__return
            (Data_encoding.Binary.to_bytes_exn
              Alpha_context.Block_header.contents_encoding
              {| Alpha_context.Block_header.contents.priority := priority;
                Alpha_context.Block_header.contents.seed_nonce_hash :=
                  seed_nonce_hash;
                Alpha_context.Block_header.contents.proof_of_work_nonce :=
                  proof_of_work_nonce |})).
  
  Module Manager.
    Definition operations {A : Set}
      (ctxt : RPC_context.simple A) (block : A)
      (branch : (|Block_hash|).(S.HASH.t))
      (source : Alpha_context.public_key_hash)
      (sourcePubKey : option (|Signature.Public_key|).(S.SPublic_key.t))
      (counter : Alpha_context.counter) (fee : Alpha_context.Tez.tez)
      (gas_limit : Z.t) (storage_limit : Z.t)
      (operations : list Alpha_context.packed_manager_operation)
      : Lwt.t (Pervasives.result MBytes.t (list Error_monad.shell_error)) :=
      let= function_parameter := Contract_services.manager_key ctxt block source
        in
      match function_parameter with
      | Pervasives.Error __error_value =&gt;
        Lwt.__return (Pervasives.Error __error_value)
      | Pervasives.Ok revealed =&gt;
        let ops :=
          List.map
            (fun function_parameter =&gt;
              let 'Alpha_context.Manager operation := function_parameter in
              Alpha_context.Contents
                (Alpha_context.Manager_operation
                  {| Alpha_context.contents.Manager_operation.source := source;
                    Alpha_context.contents.Manager_operation.fee := fee;
                    Alpha_context.contents.Manager_operation.counter := counter;
                    Alpha_context.contents.Manager_operation.operation :=
                      operation;
                    Alpha_context.contents.Manager_operation.gas_limit :=
                      gas_limit;
                    Alpha_context.contents.Manager_operation.storage_limit :=
                      storage_limit |})) operations in
        let ops :=
          match (sourcePubKey, revealed) with
          | ((None, _) | (_, Some _)) =&gt; ops
          | (Some pk, None) =&gt;
            let operation := Alpha_context.Reveal pk in
            cons
              (Alpha_context.Contents
                (Alpha_context.Manager_operation
                  {| Alpha_context.contents.Manager_operation.source := source;
                    Alpha_context.contents.Manager_operation.fee := fee;
                    Alpha_context.contents.Manager_operation.counter := counter;
                    Alpha_context.contents.Manager_operation.operation :=
                      operation;
                    Alpha_context.contents.Manager_operation.gas_limit :=
                      gas_limit;
                    Alpha_context.contents.Manager_operation.storage_limit :=
                      storage_limit |})) ops
          end in
        RPC_context.make_call0 S.operations ctxt block tt
          ({| Operation.shell_header.branch := branch |},
            (Alpha_context.Operation.of_list ops))
      end.
    
    Definition reveal {A : Set}
      (ctxt : RPC_context.simple A) (block : A)
      (branch : (|Block_hash|).(S.HASH.t))
      (source : Alpha_context.public_key_hash)
      (sourcePubKey : (|Signature.Public_key|).(S.SPublic_key.t))
      (counter : Alpha_context.counter) (fee : Alpha_context.Tez.tez)
      (function_parameter : unit)
      : Lwt.t (Pervasives.result MBytes.t (list Error_monad.shell_error)) :=
      let '_ := function_parameter in
      operations ctxt block branch source (Some sourcePubKey) counter fee Z.zero
        Z.zero nil.
    
    Definition transaction {A : Set}
      (ctxt : RPC_context.simple A) (block : A)
      (branch : (|Block_hash|).(S.HASH.t))
      (source : Alpha_context.public_key_hash)
      (sourcePubKey : option (|Signature.Public_key|).(S.SPublic_key.t))
      (counter : Alpha_context.counter) (amount : Alpha_context.Tez.tez)
      (destination : Alpha_context.Contract.contract)
      (op_staroptstar : option string)
      : option Alpha_context.Script.expr -&gt; Z.t -&gt; Z.t -&gt;
      Alpha_context.Tez.tez -&gt; unit -&gt;
      Lwt.t (Pervasives.result MBytes.t (list Error_monad.shell_error)) :=
      let entrypoint :=
        match op_staroptstar with
        | Some op_starsthstar =&gt; op_starsthstar
        | None =&gt; &quot;default&quot;
        end in
      fun parameters =&gt;
        fun gas_limit =&gt;
          fun storage_limit =&gt;
            fun fee =&gt;
              fun function_parameter =&gt;
                let '_ := function_parameter in
                let parameters :=
                  Option.unopt_map Alpha_context.Script.__lazy_expr_value
                    Alpha_context.Script.unit_parameter parameters in
                operations ctxt block branch source sourcePubKey counter fee
                  gas_limit storage_limit
                  [
                    Alpha_context.Manager
                      (Alpha_context.Transaction
                        {|
                          Alpha_context.manager_operation.Transaction.amount :=
                            amount;
                          Alpha_context.manager_operation.Transaction.parameters :=
                            parameters;
                          Alpha_context.manager_operation.Transaction.entrypoint :=
                            entrypoint;
                          Alpha_context.manager_operation.Transaction.destination :=
                            destination
                          |})
                  ].
    
    Definition origination {A : Set}
      (ctxt : RPC_context.simple A) (block : A)
      (branch : (|Block_hash|).(S.HASH.t))
      (source : Alpha_context.public_key_hash)
      (sourcePubKey : option (|Signature.Public_key|).(S.SPublic_key.t))
      (counter : Alpha_context.counter) (balance : Alpha_context.Tez.tez)
      (delegatePubKey :
        option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
      (script : Alpha_context.Script.t) (gas_limit : Z.t) (storage_limit : Z.t)
      (fee : Alpha_context.Tez.tez) (function_parameter : unit)
      : Lwt.t (Pervasives.result MBytes.t (list Error_monad.shell_error)) :=
      let '_ := function_parameter in
      operations ctxt block branch source sourcePubKey counter fee gas_limit
        storage_limit
        [
          Alpha_context.Manager
            (Alpha_context.Origination
              {|
                Alpha_context.manager_operation.Origination.delegate :=
                  delegatePubKey;
                Alpha_context.manager_operation.Origination.script :=
                  script;
                Alpha_context.manager_operation.Origination.credit :=
                  balance;
                Alpha_context.manager_operation.Origination.preorigination :=
                  None |})
        ].
    
    Definition delegation {A : Set}
      (ctxt : RPC_context.simple A) (block : A)
      (branch : (|Block_hash|).(S.HASH.t))
      (source : Alpha_context.public_key_hash)
      (sourcePubKey : option (|Signature.Public_key|).(S.SPublic_key.t))
      (counter : Alpha_context.counter) (fee : Alpha_context.Tez.tez)
      (delegate : option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
      : Lwt.t (Pervasives.result MBytes.t (list Error_monad.shell_error)) :=
      operations ctxt block branch source sourcePubKey counter fee Z.zero Z.zero
        [ Alpha_context.Manager (Alpha_context.Delegation delegate) ].
  End Manager.
  
  Definition operation {A : Set}
    (ctxt : RPC_context.simple A) (block : A)
    (branch : (|Block_hash|).(S.HASH.t)) (operation : Alpha_context.contents)
    : Lwt.t (Error_monad.shell_tzresult MBytes.t) :=
    RPC_context.make_call0 S.operations ctxt block tt
      ({| Operation.shell_header.branch := branch |},
        (Alpha_context.Contents_list (Alpha_context.Single operation))).
  
  Definition endorsement {A : Set}
    (ctxt : RPC_context.simple A) (__b_value : A)
    (branch : (|Block_hash|).(S.HASH.t)) (level : Alpha_context.Raw_level.t)
    (function_parameter : unit) : Lwt.t (Error_monad.shell_tzresult MBytes.t) :=
    let '_ := function_parameter in
    operation ctxt __b_value branch
      (Alpha_context.Endorsement
        {| Alpha_context.contents.Endorsement.level := level |}).
  
  Definition proposals {A : Set}
    (ctxt : RPC_context.simple A) (__b_value : A)
    (branch : (|Block_hash|).(S.HASH.t))
    (source : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
    (period : Alpha_context.Voting_period.t)
    (proposals : list (|Protocol_hash|).(S.HASH.t)) (function_parameter : unit)
    : Lwt.t (Error_monad.shell_tzresult MBytes.t) :=
    let '_ := function_parameter in
    operation ctxt __b_value branch
      (Alpha_context.Proposals
        {| Alpha_context.contents.Proposals.source := source;
          Alpha_context.contents.Proposals.period := period;
          Alpha_context.contents.Proposals.proposals := proposals |}).
  
  Definition ballot {A : Set}
    (ctxt : RPC_context.simple A) (__b_value : A)
    (branch : (|Block_hash|).(S.HASH.t))
    (source : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
    (period : Alpha_context.Voting_period.t)
    (proposal : (|Protocol_hash|).(S.HASH.t))
    (ballot : Alpha_context.Vote.ballot) (function_parameter : unit)
    : Lwt.t (Error_monad.shell_tzresult MBytes.t) :=
    let '_ := function_parameter in
    operation ctxt __b_value branch
      (Alpha_context.Ballot
        {| Alpha_context.contents.Ballot.source := source;
          Alpha_context.contents.Ballot.period := period;
          Alpha_context.contents.Ballot.proposal := proposal;
          Alpha_context.contents.Ballot.ballot := ballot |}).
  
  Definition seed_nonce_revelation {A : Set}
    (ctxt : RPC_context.simple A) (block : A)
    (branch : (|Block_hash|).(S.HASH.t)) (level : Alpha_context.Raw_level.t)
    (__nonce_value : Alpha_context.Nonce.t) (function_parameter : unit)
    : Lwt.t (Error_monad.shell_tzresult MBytes.t) :=
    let '_ := function_parameter in
    operation ctxt block branch
      (Alpha_context.Seed_nonce_revelation
        {| Alpha_context.contents.Seed_nonce_revelation.level := level;
          Alpha_context.contents.Seed_nonce_revelation.nonce := __nonce_value |}).
  
  Definition double_baking_evidence {A : Set}
    (ctxt : RPC_context.simple A) (block : A)
    (branch : (|Block_hash|).(S.HASH.t))
    (bh1 : Alpha_context.Block_header.block_header)
    (bh2 : Alpha_context.Block_header.block_header) (function_parameter : unit)
    : Lwt.t (Error_monad.shell_tzresult MBytes.t) :=
    let '_ := function_parameter in
    operation ctxt block branch
      (Alpha_context.Double_baking_evidence
        {| Alpha_context.contents.Double_baking_evidence.bh1 := bh1;
          Alpha_context.contents.Double_baking_evidence.bh2 := bh2 |}).
  
  Definition double_endorsement_evidence {A : Set}
    (ctxt : RPC_context.simple A) (block : A)
    (branch : (|Block_hash|).(S.HASH.t)) (op1 : Alpha_context.operation)
    (op2 : Alpha_context.operation) (function_parameter : unit)
    : Lwt.t (Error_monad.shell_tzresult MBytes.t) :=
    let '_ := function_parameter in
    operation ctxt block branch
      (Alpha_context.Double_endorsement_evidence
        {| Alpha_context.contents.Double_endorsement_evidence.op1 := op1;
          Alpha_context.contents.Double_endorsement_evidence.op2 := op2 |}).
  
  Definition empty_proof_of_work_nonce : MBytes.t :=
    MBytes.of_string
      (String.make Constants_repr.proof_of_work_nonce_size &quot;000&quot; % char).
  
  Definition protocol_data {A : Set}
    (ctxt : RPC_context.simple A) (block : A) (priority : int)
    (seed_nonce_hash : option Nonce_hash.t) (op_staroptstar : option MBytes.t)
    : unit -&gt; Lwt.t (Error_monad.shell_tzresult MBytes.t) :=
    let proof_of_work_nonce :=
      match op_staroptstar with
      | Some op_starsthstar =&gt; op_starsthstar
      | None =&gt; empty_proof_of_work_nonce
      end in
    fun function_parameter =&gt;
      let '_ := function_parameter in
      RPC_context.make_call0 S.protocol_data ctxt block tt
        (priority, seed_nonce_hash, proof_of_work_nonce).
End Forge.

Module Parse.
  Module S.
    Import Data_encoding.
    
    Definition path : RPC_path.path Updater.rpc_context Updater.rpc_context :=
      RPC_path.op_div path &quot;parse&quot;.
    
    Definition operations
      : RPC_service.service Updater.rpc_context Updater.rpc_context unit
        (list Alpha_context.Operation.raw * option bool)
        (list Alpha_context.Operation.packed) :=
      RPC_service.post_service (Some &quot;Parse operations&quot;) RPC_query.empty
        (Data_encoding.obj2
          (Data_encoding.req None None &quot;operations&quot;
            (Data_encoding.__list_value None
              (Data_encoding.dynamic_size None
                Alpha_context.Operation.raw_encoding)))
          (Data_encoding.opt None None &quot;check_signature&quot;
            Data_encoding.__bool_value))
        (Data_encoding.__list_value None
          (Data_encoding.dynamic_size None Alpha_context.Operation.encoding))
        (RPC_path.op_div path &quot;operations&quot;).
    
    Definition block
      : RPC_service.service Updater.rpc_context Updater.rpc_context unit
        Alpha_context.Block_header.raw Alpha_context.Block_header.protocol_data :=
      RPC_service.post_service (Some &quot;Parse a block&quot;) RPC_query.empty
        Alpha_context.Block_header.raw_encoding
        Alpha_context.Block_header.protocol_data_encoding
        (RPC_path.op_div path &quot;block&quot;).
  End S.
  
  Definition parse_protocol_data (protocol_data : MBytes.t)
    : Lwt.t (Error_monad.tzresult Alpha_context.Block_header.protocol_data) :=
    match
      Data_encoding.Binary.of_bytes
        Alpha_context.Block_header.protocol_data_encoding protocol_data with
    | None =&gt; Pervasives.failwith &quot;Cant_parse_protocol_data&quot;
    | Some protocol_data =&gt; Error_monad.__return protocol_data
    end.
  
  Definition register (function_parameter : unit) : unit :=
    let '_ := function_parameter in
    (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
    (* ‚ùå instruction_sequence &quot;;&quot; *)
    Services_registration.register0_noctxt S.block
      (fun function_parameter =&gt;
        let '_ := function_parameter in
        fun raw_block =&gt;
          parse_protocol_data raw_block.(Block_header.t.protocol_data)).
  
  Definition operations {A : Set}
    (ctxt : RPC_context.simple A) (block : A) (check : option bool)
    (operations : list Alpha_context.Operation.raw)
    : Lwt.t (Error_monad.shell_tzresult (list Alpha_context.Operation.packed)) :=
    RPC_context.make_call0 S.operations ctxt block tt (operations, check).
  
  Definition block {A : Set}
    (ctxt : RPC_context.simple A) (block : A)
    (shell : Block_header.shell_header) (protocol_data : MBytes.t)
    : Lwt.t
      (Error_monad.shell_tzresult Alpha_context.Block_header.protocol_data) :=
    RPC_context.make_call0 S.block ctxt block tt
      {| Block_header.t.shell := shell;
        Block_header.t.protocol_data := protocol_data |}.
End Parse.

Module S.
  Import Data_encoding.
  
  Module level_query.
    Record record : Set := Build {
      offset : int32 }.
    Definition with_offset offset (r : record) :=
      Build offset.
  End level_query.
  Definition level_query := level_query.record.
  
  Definition __level_query_value : RPC_query.t level_query :=
    RPC_query.seal
      (RPC_query.op_pipeplus
        (RPC_query.__query_value
          (fun offset =&gt; {| level_query.offset := offset |}))
        (RPC_query.__field_value None &quot;offset&quot; RPC_arg.__int32_value
          (* ‚ùå Constant of type int32 is converted to int *)
          0 (fun __t_value =&gt; __t_value.(level_query.offset)))).
  
  Definition current_level
    : RPC_service.service Updater.rpc_context Updater.rpc_context level_query
      unit Alpha_context.Level.t :=
    RPC_service.get_service
      (Some
        &quot;Returns the level of the interrogated block, or the one of a block located `offset` blocks after in the chain (or before when negative). For instance, the next block if `offset` is 1.&quot;)
      __level_query_value Alpha_context.Level.encoding
      (RPC_path.op_div path &quot;current_level&quot;).
  
  Definition levels_in_current_cycle
    : RPC_service.service Updater.rpc_context Updater.rpc_context level_query
      unit (Alpha_context.Raw_level.t * Alpha_context.Raw_level.t) :=
    RPC_service.get_service (Some &quot;Levels of a cycle&quot;) __level_query_value
      (Data_encoding.obj2
        (Data_encoding.req None None &quot;first&quot; Alpha_context.Raw_level.encoding)
        (Data_encoding.req None None &quot;last&quot; Alpha_context.Raw_level.encoding))
      (RPC_path.op_div path &quot;levels_in_current_cycle&quot;).
End S.

Definition register (function_parameter : unit) : unit :=
  let '_ := function_parameter in
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  Services_registration.register0 S.levels_in_current_cycle
    (fun ctxt =&gt;
      fun q =&gt;
        fun function_parameter =&gt;
          let '_ := function_parameter in
          let levels :=
            Alpha_context.Level.levels_in_current_cycle ctxt
              (Some q.(S.level_query.offset)) tt in
          match levels with
          | [] =&gt; Pervasives.raise extensible_type_value
          | _ =&gt;
            let first := List.hd (List.rev levels) in
            let last := List.hd levels in
            Error_monad.__return
              (first.(Alpha_context.Level.t.level),
                last.(Alpha_context.Level.t.level))
          end).

Definition current_level {A : Set}
  (ctxt : RPC_context.simple A) (op_staroptstar : option int32)
  : A -&gt; Lwt.t (Error_monad.shell_tzresult Alpha_context.Level.t) :=
  let offset :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt;
      (* ‚ùå Constant of type int32 is converted to int *)
      0
    end in
  fun block =&gt;
    RPC_context.make_call0 S.current_level ctxt block
      {| S.level_query.offset := offset |} tt.

Definition levels_in_current_cycle {A : Set}
  (ctxt : RPC_context.simple A) (op_staroptstar : option int32)
  : A -&gt;
  Lwt.t
    (Error_monad.shell_tzresult
      (Alpha_context.Raw_level.t * Alpha_context.Raw_level.t)) :=
  let offset :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt;
      (* ‚ùå Constant of type int32 is converted to int *)
      0
    end in
  fun block =&gt;
    RPC_context.make_call0 S.levels_in_current_cycle ctxt block
      {| S.level_query.offset := offset |} tt.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="helpers_services.mli">
  <div style="margin: 20px;">
    <h3>Helpers_services_mli</h3>
    <ul>
      <li>OCaml size: 271 lines</li>
      <li>Coq size: 182 lines (-33% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#helpers_services.mli"><code>helpers_services.mli</code></a>&nbsp;<span class="label label-warning">1 warning</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Cannot_parse_operation</abbr> (* `Branch *)

val current_level :
  'a #RPC_context.simple -&gt; ?offset:int32 -&gt; 'a -&gt; Level.t shell_tzresult Lwt.t

val levels_in_current_cycle :
  'a #RPC_context.simple -&gt;
  ?offset:int32 -&gt;
  'a -&gt;
  (Raw_level.t * Raw_level.t) shell_tzresult Lwt.t

module Scripts : sig
  val run_code :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    Script.expr -&gt;
    Script.expr
    * Script.expr
    * Tez.t
    * Chain_id.t
    * Contract.t option
    * Contract.t option
    * Z.t option
    * string -&gt;
    ( Script.expr
    * packed_internal_operation list
    * Contract.big_map_diff option )
    shell_tzresult
    Lwt.t

  val trace_code :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    Script.expr -&gt;
    Script.expr
    * Script.expr
    * Tez.t
    * Chain_id.t
    * Contract.t option
    * Contract.t option
    * Z.t option
    * string -&gt;
    ( Script.expr
    * packed_internal_operation list
    * Script_interpreter.execution_trace
    * Contract.big_map_diff option )
    shell_tzresult
    Lwt.t

  val typecheck_code :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    Script.expr * Z.t option -&gt;
    (Script_tc_errors.type_map * Gas.t) shell_tzresult Lwt.t

  val typecheck_data :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    Script.expr * Script.expr * Z.t option -&gt;
    Gas.t shell_tzresult Lwt.t

  val pack_data :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    Script.expr * Script.expr * Z.t option -&gt;
    (MBytes.t * Gas.t) shell_tzresult Lwt.t

  val run_operation :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    packed_operation * Chain_id.t -&gt;
    (packed_protocol_data * Apply_results.packed_operation_metadata)
    shell_tzresult
    Lwt.t

  val entrypoint_type :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    Script.expr * string -&gt;
    Script.expr shell_tzresult Lwt.t

  val list_entrypoints :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    Script.expr -&gt;
    (Michelson_v1_primitives.prim list list * (string * Script.expr) list)
    shell_tzresult
    Lwt.t
end

module Forge : sig
  module Manager : sig
    val operations :
      'a #RPC_context.simple -&gt;
      'a -&gt;
      branch:Block_hash.t -&gt;
      source:public_key_hash -&gt;
      ?sourcePubKey:public_key -&gt;
      counter:counter -&gt;
      fee:Tez.t -&gt;
      gas_limit:Z.t -&gt;
      storage_limit:Z.t -&gt;
      packed_manager_operation list -&gt;
      MBytes.t shell_tzresult Lwt.t

    val reveal :
      'a #RPC_context.simple -&gt;
      'a -&gt;
      branch:Block_hash.t -&gt;
      source:public_key_hash -&gt;
      sourcePubKey:public_key -&gt;
      counter:counter -&gt;
      fee:Tez.t -&gt;
      unit -&gt;
      MBytes.t shell_tzresult Lwt.t

    val transaction :
      'a #RPC_context.simple -&gt;
      'a -&gt;
      branch:Block_hash.t -&gt;
      source:public_key_hash -&gt;
      ?sourcePubKey:public_key -&gt;
      counter:counter -&gt;
      amount:Tez.t -&gt;
      destination:Contract.t -&gt;
      ?entrypoint:string -&gt;
      ?parameters:Script.expr -&gt;
      gas_limit:Z.t -&gt;
      storage_limit:Z.t -&gt;
      fee:Tez.t -&gt;
      unit -&gt;
      MBytes.t shell_tzresult Lwt.t

    val origination :
      'a #RPC_context.simple -&gt;
      'a -&gt;
      branch:Block_hash.t -&gt;
      source:public_key_hash -&gt;
      ?sourcePubKey:public_key -&gt;
      counter:counter -&gt;
      balance:Tez.t -&gt;
      ?delegatePubKey:public_key_hash -&gt;
      script:Script.t -&gt;
      gas_limit:Z.t -&gt;
      storage_limit:Z.t -&gt;
      fee:Tez.t -&gt;
      unit -&gt;
      MBytes.t shell_tzresult Lwt.t

    val delegation :
      'a #RPC_context.simple -&gt;
      'a -&gt;
      branch:Block_hash.t -&gt;
      source:public_key_hash -&gt;
      ?sourcePubKey:public_key -&gt;
      counter:counter -&gt;
      fee:Tez.t -&gt;
      public_key_hash option -&gt;
      MBytes.t shell_tzresult Lwt.t
  end

  val endorsement :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    branch:Block_hash.t -&gt;
    level:Raw_level.t -&gt;
    unit -&gt;
    MBytes.t shell_tzresult Lwt.t

  val proposals :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    branch:Block_hash.t -&gt;
    source:public_key_hash -&gt;
    period:Voting_period.t -&gt;
    proposals:Protocol_hash.t list -&gt;
    unit -&gt;
    MBytes.t shell_tzresult Lwt.t

  val ballot :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    branch:Block_hash.t -&gt;
    source:public_key_hash -&gt;
    period:Voting_period.t -&gt;
    proposal:Protocol_hash.t -&gt;
    ballot:Vote.ballot -&gt;
    unit -&gt;
    MBytes.t shell_tzresult Lwt.t

  val seed_nonce_revelation :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    branch:Block_hash.t -&gt;
    level:Raw_level.t -&gt;
    nonce:Nonce.t -&gt;
    unit -&gt;
    MBytes.t shell_tzresult Lwt.t

  val double_baking_evidence :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    branch:Block_hash.t -&gt;
    bh1:Block_header.block_header -&gt;
    bh2:Block_header.block_header -&gt;
    unit -&gt;
    MBytes.t shell_tzresult Lwt.t

  val double_endorsement_evidence :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    branch:Block_hash.t -&gt;
    op1:Kind.endorsement operation -&gt;
    op2:Kind.endorsement operation -&gt;
    unit -&gt;
    MBytes.t shell_tzresult Lwt.t

  val protocol_data :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    priority:int -&gt;
    ?seed_nonce_hash:Nonce_hash.t -&gt;
    ?proof_of_work_nonce:MBytes.t -&gt;
    unit -&gt;
    MBytes.t shell_tzresult Lwt.t
end

module Parse : sig
  val operations :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    ?check:bool -&gt;
    Operation.raw list -&gt;
    Operation.packed list shell_tzresult Lwt.t

  val block :
    'a #RPC_context.simple -&gt;
    'a -&gt;
    Block_header.shell_header -&gt;
    MBytes.t -&gt;
    Block_header.protocol_data shell_tzresult Lwt.t
end

val register : unit -&gt; unit
</pre>
  </div>
  <div class="col-md-6">
    <a href="#helpers_services.mli"><code>Helpers_services_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Apply_results.
Require Tezos.Michelson_v1_primitives.
Require Tezos.Nonce_hash.
Require Tezos.Script_interpreter.
Require Tezos.Script_tc_errors.

Import Alpha_context.

(* extensible_type_definition `error` *)

Parameter current_level : forall {a : Set},
  RPC_context.simple a -&gt; option int32 -&gt; a -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.Level.t).

Parameter levels_in_current_cycle : forall {a : Set},
  RPC_context.simple a -&gt; option int32 -&gt; a -&gt;
  Lwt.t
    (Error_monad.shell_tzresult
      (Alpha_context.Raw_level.t * Alpha_context.Raw_level.t)).

Module Scripts.
  Parameter run_code : forall {a : Set},
    RPC_context.simple a -&gt; a -&gt; Alpha_context.Script.expr -&gt;
    Alpha_context.Script.expr * Alpha_context.Script.expr * Alpha_context.Tez.t
      * (|Chain_id|).(S.HASH.t) * option Alpha_context.Contract.t *
      option Alpha_context.Contract.t * option Z.t * string -&gt;
    Lwt.t
      (Error_monad.shell_tzresult
        (Alpha_context.Script.expr *
          list Alpha_context.packed_internal_operation *
          option Alpha_context.Contract.big_map_diff)).
  
  Parameter trace_code : forall {a : Set},
    RPC_context.simple a -&gt; a -&gt; Alpha_context.Script.expr -&gt;
    Alpha_context.Script.expr * Alpha_context.Script.expr * Alpha_context.Tez.t
      * (|Chain_id|).(S.HASH.t) * option Alpha_context.Contract.t *
      option Alpha_context.Contract.t * option Z.t * string -&gt;
    Lwt.t
      (Error_monad.shell_tzresult
        (Alpha_context.Script.expr *
          list Alpha_context.packed_internal_operation *
          Script_interpreter.execution_trace *
          option Alpha_context.Contract.big_map_diff)).
  
  Parameter typecheck_code : forall {a : Set},
    RPC_context.simple a -&gt; a -&gt; Alpha_context.Script.expr * option Z.t -&gt;
    Lwt.t
      (Error_monad.shell_tzresult
        (Script_tc_errors.type_map * Alpha_context.Gas.t)).
  
  Parameter typecheck_data : forall {a : Set},
    RPC_context.simple a -&gt; a -&gt;
    Alpha_context.Script.expr * Alpha_context.Script.expr * option Z.t -&gt;
    Lwt.t (Error_monad.shell_tzresult Alpha_context.Gas.t).
  
  Parameter pack_data : forall {a : Set},
    RPC_context.simple a -&gt; a -&gt;
    Alpha_context.Script.expr * Alpha_context.Script.expr * option Z.t -&gt;
    Lwt.t (Error_monad.shell_tzresult (MBytes.t * Alpha_context.Gas.t)).
  
  Parameter run_operation : forall {a : Set},
    RPC_context.simple a -&gt; a -&gt;
    Alpha_context.packed_operation * (|Chain_id|).(S.HASH.t) -&gt;
    Lwt.t
      (Error_monad.shell_tzresult
        (Alpha_context.packed_protocol_data *
          Apply_results.packed_operation_metadata)).
  
  Parameter entrypoint_type : forall {a : Set},
    RPC_context.simple a -&gt; a -&gt; Alpha_context.Script.expr * string -&gt;
    Lwt.t (Error_monad.shell_tzresult Alpha_context.Script.expr).
  
  Parameter list_entrypoints : forall {a : Set},
    RPC_context.simple a -&gt; a -&gt; Alpha_context.Script.expr -&gt;
    Lwt.t
      (Error_monad.shell_tzresult
        (list (list Michelson_v1_primitives.prim) *
          list (string * Alpha_context.Script.expr))).
End Scripts.

Module Forge.
  Module Manager.
    Parameter operations : forall {a : Set},
      RPC_context.simple a -&gt; a -&gt; (|Block_hash|).(S.HASH.t) -&gt;
      Alpha_context.public_key_hash -&gt; option Alpha_context.public_key -&gt;
      Alpha_context.counter -&gt; Alpha_context.Tez.t -&gt; Z.t -&gt; Z.t -&gt;
      list Alpha_context.packed_manager_operation -&gt;
      Lwt.t (Error_monad.shell_tzresult MBytes.t).
    
    Parameter reveal : forall {a : Set},
      RPC_context.simple a -&gt; a -&gt; (|Block_hash|).(S.HASH.t) -&gt;
      Alpha_context.public_key_hash -&gt; Alpha_context.public_key -&gt;
      Alpha_context.counter -&gt; Alpha_context.Tez.t -&gt; unit -&gt;
      Lwt.t (Error_monad.shell_tzresult MBytes.t).
    
    Parameter transaction : forall {a : Set},
      RPC_context.simple a -&gt; a -&gt; (|Block_hash|).(S.HASH.t) -&gt;
      Alpha_context.public_key_hash -&gt; option Alpha_context.public_key -&gt;
      Alpha_context.counter -&gt; Alpha_context.Tez.t -&gt;
      Alpha_context.Contract.t -&gt; option string -&gt;
      option Alpha_context.Script.expr -&gt; Z.t -&gt; Z.t -&gt; Alpha_context.Tez.t -&gt;
      unit -&gt; Lwt.t (Error_monad.shell_tzresult MBytes.t).
    
    Parameter origination : forall {a : Set},
      RPC_context.simple a -&gt; a -&gt; (|Block_hash|).(S.HASH.t) -&gt;
      Alpha_context.public_key_hash -&gt; option Alpha_context.public_key -&gt;
      Alpha_context.counter -&gt; Alpha_context.Tez.t -&gt;
      option Alpha_context.public_key_hash -&gt; Alpha_context.Script.t -&gt; Z.t -&gt;
      Z.t -&gt; Alpha_context.Tez.t -&gt; unit -&gt;
      Lwt.t (Error_monad.shell_tzresult MBytes.t).
    
    Parameter delegation : forall {a : Set},
      RPC_context.simple a -&gt; a -&gt; (|Block_hash|).(S.HASH.t) -&gt;
      Alpha_context.public_key_hash -&gt; option Alpha_context.public_key -&gt;
      Alpha_context.counter -&gt; Alpha_context.Tez.t -&gt;
      option Alpha_context.public_key_hash -&gt;
      Lwt.t (Error_monad.shell_tzresult MBytes.t).
  End Manager.
  
  Parameter endorsement : forall {a : Set},
    RPC_context.simple a -&gt; a -&gt; (|Block_hash|).(S.HASH.t) -&gt;
    Alpha_context.Raw_level.t -&gt; unit -&gt;
    Lwt.t (Error_monad.shell_tzresult MBytes.t).
  
  Parameter proposals : forall {a : Set},
    RPC_context.simple a -&gt; a -&gt; (|Block_hash|).(S.HASH.t) -&gt;
    Alpha_context.public_key_hash -&gt; Alpha_context.Voting_period.t -&gt;
    list (|Protocol_hash|).(S.HASH.t) -&gt; unit -&gt;
    Lwt.t (Error_monad.shell_tzresult MBytes.t).
  
  Parameter ballot : forall {a : Set},
    RPC_context.simple a -&gt; a -&gt; (|Block_hash|).(S.HASH.t) -&gt;
    Alpha_context.public_key_hash -&gt; Alpha_context.Voting_period.t -&gt;
    (|Protocol_hash|).(S.HASH.t) -&gt; Alpha_context.Vote.ballot -&gt; unit -&gt;
    Lwt.t (Error_monad.shell_tzresult MBytes.t).
  
  Parameter seed_nonce_revelation : forall {a : Set},
    RPC_context.simple a -&gt; a -&gt; (|Block_hash|).(S.HASH.t) -&gt;
    Alpha_context.Raw_level.t -&gt; Alpha_context.Nonce.t -&gt; unit -&gt;
    Lwt.t (Error_monad.shell_tzresult MBytes.t).
  
  Parameter double_baking_evidence : forall {a : Set},
    RPC_context.simple a -&gt; a -&gt; (|Block_hash|).(S.HASH.t) -&gt;
    Alpha_context.Block_header.block_header -&gt;
    Alpha_context.Block_header.block_header -&gt; unit -&gt;
    Lwt.t (Error_monad.shell_tzresult MBytes.t).
  
  Parameter double_endorsement_evidence : forall {a : Set},
    RPC_context.simple a -&gt; a -&gt; (|Block_hash|).(S.HASH.t) -&gt;
    Alpha_context.operation -&gt; Alpha_context.operation -&gt; unit -&gt;
    Lwt.t (Error_monad.shell_tzresult MBytes.t).
  
  Parameter protocol_data : forall {a : Set},
    RPC_context.simple a -&gt; a -&gt; int -&gt; option Nonce_hash.t -&gt;
    option MBytes.t -&gt; unit -&gt; Lwt.t (Error_monad.shell_tzresult MBytes.t).
End Forge.

Module Parse.
  Parameter operations : forall {a : Set},
    RPC_context.simple a -&gt; a -&gt; option bool -&gt;
    list Alpha_context.Operation.raw -&gt;
    Lwt.t (Error_monad.shell_tzresult (list Alpha_context.Operation.packed)).
  
  Parameter block : forall {a : Set},
    RPC_context.simple a -&gt; a -&gt; Alpha_context.Block_header.shell_header -&gt;
    MBytes.t -&gt;
    Lwt.t (Error_monad.shell_tzresult Alpha_context.Block_header.protocol_data).
End Parse.

Parameter register : unit -&gt; unit.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="init_storage.ml">
  <div style="margin: 20px;">
    <h3>Init_storage</h3>
    <ul>
      <li>OCaml size: 61 lines</li>
      <li>Coq size: 60 lines (-2% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#init_storage.ml"><code>init_storage.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(* This is the genesis protocol: initialise the state *)
let prepare_first_block ctxt ~typecheck ~level ~timestamp ~fitness =
  Raw_context.prepare_first_block ~level ~timestamp ~fitness ctxt
  &gt;&gt;=? fun (previous_protocol, ctxt) -&gt;
  Storage.Big_map.Next.init_with_default_value ctxt
  &gt;&gt;=? fun ctxt -&gt;
  match previous_protocol with
  | Genesis param -&gt;
      Commitment_storage.init ctxt param.commitments
      &gt;&gt;=? fun ctxt -&gt;
      Roll_storage.init ctxt
      &gt;&gt;=? fun ctxt -&gt;
      Seed_storage.init ctxt
      &gt;&gt;=? fun ctxt -&gt;
      Contract_storage.init ctxt
      &gt;&gt;=? fun ctxt -&gt;
      Bootstrap_storage.init
        ctxt
        ~typecheck
        ?ramp_up_cycles:param.security_deposit_ramp_up_cycles
        ?no_reward_cycles:param.no_reward_cycles
        param.bootstrap_accounts
        param.bootstrap_contracts
      &gt;&gt;=? fun ctxt -&gt;
      Roll_storage.init_first_cycles ctxt
      &gt;&gt;=? fun ctxt -&gt;
      Vote_storage.init ctxt
      &gt;&gt;=? fun ctxt -&gt;
      Storage.Block_priority.init ctxt 0
      &gt;&gt;=? fun ctxt -&gt;
      Vote_storage.freeze_listings ctxt &gt;&gt;=? fun ctxt -&gt; return ctxt
  | Alpha_previous -&gt;
      return ctxt

let prepare ctxt ~level ~predecessor_timestamp ~timestamp ~fitness =
  Raw_context.prepare ~level ~predecessor_timestamp ~timestamp ~fitness ctxt
</pre>
  </div>
  <div class="col-md-6">
    <a href="#init_storage.ml"><code>Init_storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Bootstrap_storage.
Require Tezos.Commitment_storage.
Require Tezos.Contract_storage.
Require Tezos.Parameters_repr.
Require Tezos.Raw_context.
Require Tezos.Roll_storage.
Require Tezos.Script_repr.
Require Tezos.Seed_storage.
Require Tezos.Storage_mli. Module Storage := Storage_mli.
Require Tezos.Vote_storage.

Definition prepare_first_block
  (ctxt : Context.t)
  (typecheck :
    Raw_context.t -&gt; Script_repr.t -&gt;
    Lwt.t
      (Error_monad.tzresult
        ((Script_repr.t * option Contract_storage.big_map_diff) * Raw_context.t)))
  (level : int32) (timestamp : Time.t) (fitness : (|Fitness|).(S.T.t))
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let=? '(previous_protocol, ctxt) :=
    Raw_context.prepare_first_block level timestamp fitness ctxt in
  let=? ctxt := Storage.Big_map.Next.init_with_default_value ctxt in
  match previous_protocol with
  | Raw_context.Genesis param =&gt;
    let=? ctxt :=
      Commitment_storage.init ctxt param.(Parameters_repr.t.commitments) in
    let=? ctxt := Roll_storage.init ctxt in
    let=? ctxt := Seed_storage.init ctxt in
    let=? ctxt := Contract_storage.init ctxt in
    let=? ctxt :=
      Bootstrap_storage.init ctxt typecheck
        param.(Parameters_repr.t.security_deposit_ramp_up_cycles)
        param.(Parameters_repr.t.no_reward_cycles)
        param.(Parameters_repr.t.bootstrap_accounts)
        param.(Parameters_repr.t.bootstrap_contracts) in
    let=? ctxt := Roll_storage.init_first_cycles ctxt in
    let=? ctxt := Vote_storage.init ctxt in
    let=? ctxt := Storage.Block_priority.init ctxt 0 in
    let=? ctxt := Vote_storage.freeze_listings ctxt in
    Error_monad.__return ctxt
  | Raw_context.Alpha_previous =&gt; Error_monad.__return ctxt
  end.

Definition prepare
  (ctxt : Context.t) (level : Int32.t) (predecessor_timestamp : Time.t)
  (timestamp : Time.t) (fitness : (|Fitness|).(S.T.t))
  : Lwt.t (Error_monad.tzresult Raw_context.context) :=
  Raw_context.prepare level predecessor_timestamp timestamp fitness ctxt.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="legacy_script_support_repr.ml">
  <div style="margin: 20px;">
    <h3>Legacy_script_support_repr</h3>
    <ul>
      <li>OCaml size: 828 lines</li>
      <li>Coq size: 1342 lines (+62% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#legacy_script_support_repr.ml"><code>legacy_script_support_repr.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(* Copyright (c) 2019 Nomadic Labs &lt;contact@nomadic-labs.com&gt;                *)
(* Copyright (c) 2019 Cryptium Labs &lt;contact@cryptium-labs.com&gt;              *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

let manager_script_code : Script_repr.lazy_expr =
  let open Micheline in
  let open Michelson_v1_primitives in
  Script_repr.lazy_expr @@ strip_locations
  @@ Seq
       ( 0,
         [ Prim
             ( 0,
               K_parameter,
               [ Prim
                   ( 0,
                     T_or,
                     [ Prim
                         ( 0,
                           T_lambda,
                           [ Prim (0, T_unit, [], []);
                             Prim
                               (0, T_list, [Prim (0, T_operation, [], [])], [])
                           ],
                           [&quot;%do&quot;] );
                       Prim (0, T_unit, [], [&quot;%default&quot;]) ],
                     [] ) ],
               [] );
           Prim (0, K_storage, [Prim (0, T_key_hash, [], [])], []);
           Prim
             ( 0,
               K_code,
               [ Seq
                   ( 0,
                     [ Seq
                         ( 0,
                           [ Seq
                               ( 0,
                                 [ Prim (0, I_DUP, [], []);
                                   Prim (0, I_CAR, [], []);
                                   Prim
                                     ( 0,
                                       I_DIP,
                                       [Seq (0, [Prim (0, I_CDR, [], [])])],
                                       [] ) ] ) ] );
                       Prim
                         ( 0,
                           I_IF_LEFT,
                           [ Seq
                               ( 0,
                                 [ Prim
                                     ( 0,
                                       I_PUSH,
                                       [ Prim (0, T_mutez, [], []);
                                         Int (0, Z.zero) ],
                                       [] );
                                   Prim (0, I_AMOUNT, [], []);
                                   Seq
                                     ( 0,
                                       [ Seq
                                           ( 0,
                                             [ Prim (0, I_COMPARE, [], []);
                                               Prim (0, I_EQ, [], []) ] );
                                         Prim
                                           ( 0,
                                             I_IF,
                                             [ Seq (0, []);
                                               Seq
                                                 ( 0,
                                                   [ Seq
                                                       ( 0,
                                                         [ Prim
                                                             (0, I_UNIT, [], []);
                                                           Prim
                                                             ( 0,
                                                               I_FAILWITH,
                                                               [],
                                                               [] ) ] ) ] ) ],
                                             [] ) ] );
                                   Seq
                                     ( 0,
                                       [ Prim
                                           ( 0,
                                             I_DIP,
                                             [ Seq
                                                 (0, [Prim (0, I_DUP, [], [])])
                                             ],
                                             [] );
                                         Prim (0, I_SWAP, [], []) ] );
                                   Prim (0, I_IMPLICIT_ACCOUNT, [], []);
                                   Prim (0, I_ADDRESS, [], []);
                                   Prim (0, I_SENDER, [], []);
                                   Seq
                                     ( 0,
                                       [ Seq
                                           ( 0,
                                             [ Prim (0, I_COMPARE, [], []);
                                               Prim (0, I_EQ, [], []) ] );
                                         Prim
                                           ( 0,
                                             I_IF,
                                             [ Seq (0, []);
                                               Seq
                                                 ( 0,
                                                   [ Seq
                                                       ( 0,
                                                         [ Prim
                                                             (0, I_UNIT, [], []);
                                                           Prim
                                                             ( 0,
                                                               I_FAILWITH,
                                                               [],
                                                               [] ) ] ) ] ) ],
                                             [] ) ] );
                                   Prim (0, I_UNIT, [], []);
                                   Prim (0, I_EXEC, [], []);
                                   Prim (0, I_PAIR, [], []) ] );
                             Seq
                               ( 0,
                                 [ Prim (0, I_DROP, [], []);
                                   Prim
                                     ( 0,
                                       I_NIL,
                                       [Prim (0, T_operation, [], [])],
                                       [] );
                                   Prim (0, I_PAIR, [], []) ] ) ],
                           [] ) ] ) ],
               [] ) ] )

(* Find the toplevel expression with a given prim type from list,
   because they can be in arbitrary order. *)
let find_toplevel toplevel exprs =
  let open Micheline in
  let rec iter toplevel = function
    | (Prim (_, prim, _, _) as found) :: _
      when String.equal toplevel (Michelson_v1_primitives.string_of_prim prim)
      -&gt;
        Some found
    | _ :: rest -&gt;
        iter toplevel rest
    | [] -&gt;
        None
  in
  iter (Michelson_v1_primitives.string_of_prim toplevel) exprs

let add_do :
    manager_pkh:Signature.Public_key_hash.t -&gt;
    script_code:Script_repr.lazy_expr -&gt;
    script_storage:Script_repr.lazy_expr -&gt;
    (Script_repr.lazy_expr * Script_repr.lazy_expr) tzresult Lwt.t =
 fun ~manager_pkh ~script_code ~script_storage -&gt;
  let open Micheline in
  let open Michelson_v1_primitives in
  Lwt.return (Script_repr.force_decode script_code)
  &gt;&gt;=? fun (script_code_expr, _gas_cost) -&gt;
  Lwt.return (Script_repr.force_decode script_storage)
  &gt;&gt;|? fun (script_storage_expr, _gas_cost) -&gt;
  let storage_expr = root script_storage_expr in
  match root script_code_expr with
  | Seq (_, toplevel) -&gt; (
    match
      ( find_toplevel K_parameter toplevel,
        find_toplevel K_storage toplevel,
        find_toplevel K_code toplevel )
    with
    | ( Some
          (Prim
            ( _,
              K_parameter,
              [Prim (_, parameter_type, parameter_expr, parameter_annot)],
              prim_param_annot )),
        Some
          (Prim
            ( _,
              K_storage,
              [ Prim
                  (_, code_storage_type, code_storage_expr, code_storage_annot)
              ],
              k_storage_annot )),
        Some (Prim (_, K_code, [code_expr], code_annot)) ) -&gt;
        (* Note that we intentionally don't deal with potential duplicate entrypoints in this migration as there already might be some in contracts that we don't touch. *)
        let migrated_code =
          Seq
            ( 0,
              [ Prim
                  ( 0,
                    K_parameter,
                    [ Prim
                        ( 0,
                          T_or,
                          [ Prim
                              ( 0,
                                T_lambda,
                                [ Prim (0, T_unit, [], []);
                                  Prim
                                    ( 0,
                                      T_list,
                                      [Prim (0, T_operation, [], [])],
                                      [] ) ],
                                [&quot;%do&quot;] );
                            Prim
                              ( 0,
                                parameter_type,
                                parameter_expr,
                                &quot;%default&quot; :: parameter_annot ) ],
                          [] ) ],
                    prim_param_annot );
                Prim
                  ( 0,
                    K_storage,
                    [ Prim
                        ( 0,
                          T_pair,
                          [ Prim (0, T_key_hash, [], []);
                            Prim
                              ( 0,
                                code_storage_type,
                                code_storage_expr,
                                code_storage_annot ) ],
                          [] ) ],
                    k_storage_annot );
                Prim
                  ( 0,
                    K_code,
                    [ Seq
                        ( 0,
                          [ Prim (0, I_DUP, [], []);
                            Prim (0, I_CAR, [], []);
                            Prim
                              ( 0,
                                I_IF_LEFT,
                                [ Seq
                                    ( 0,
                                      [ Prim
                                          ( 0,
                                            I_PUSH,
                                            [ Prim (0, T_mutez, [], []);
                                              Int (0, Z.zero) ],
                                            [] );
                                        Prim (0, I_AMOUNT, [], []);
                                        Seq
                                          ( 0,
                                            [ Seq
                                                ( 0,
                                                  [ Prim (0, I_COMPARE, [], []);
                                                    Prim (0, I_EQ, [], []) ] );
                                              Prim
                                                ( 0,
                                                  I_IF,
                                                  [ Seq (0, []);
                                                    Seq
                                                      ( 0,
                                                        [ Seq
                                                            ( 0,
                                                              [ Prim
                                                                  ( 0,
                                                                    I_UNIT,
                                                                    [],
                                                                    [] );
                                                                Prim
                                                                  ( 0,
                                                                    I_FAILWITH,
                                                                    [],
                                                                    [] ) ] ) ]
                                                      ) ],
                                                  [] ) ] );
                                        Seq
                                          ( 0,
                                            [ Prim
                                                ( 0,
                                                  I_DIP,
                                                  [ Seq
                                                      ( 0,
                                                        [ Prim
                                                            (0, I_DUP, [], [])
                                                        ] ) ],
                                                  [] );
                                              Prim (0, I_SWAP, [], []) ] );
                                        Prim (0, I_CDR, [], []);
                                        Prim (0, I_CAR, [], []);
                                        Prim (0, I_IMPLICIT_ACCOUNT, [], []);
                                        Prim (0, I_ADDRESS, [], []);
                                        Prim (0, I_SENDER, [], []);
                                        Seq
                                          ( 0,
                                            [ Prim (0, I_COMPARE, [], []);
                                              Prim (0, I_NEQ, [], []);
                                              Prim
                                                ( 0,
                                                  I_IF,
                                                  [ Seq
                                                      ( 0,
                                                        [ Prim
                                                            ( 0,
                                                              I_SENDER,
                                                              [],
                                                              [] );
                                                          Prim
                                                            ( 0,
                                                              I_PUSH,
                                                              [ Prim
                                                                  ( 0,
                                                                    T_string,
                                                                    [],
                                                                    [] );
                                                                String
                                                                  ( 0,
                                                                    &quot;Only the \
                                                                     owner \
                                                                     can \
                                                                     operate.&quot;
                                                                  ) ],
                                                              [] );
                                                          Prim
                                                            (0, I_PAIR, [], []);
                                                          Prim
                                                            ( 0,
                                                              I_FAILWITH,
                                                              [],
                                                              [] ) ] );
                                                    Seq
                                                      ( 0,
                                                        [ Prim
                                                            (0, I_UNIT, [], []);
                                                          Prim
                                                            (0, I_EXEC, [], []);
                                                          Prim
                                                            ( 0,
                                                              I_DIP,
                                                              [ Seq
                                                                  ( 0,
                                                                    [ Prim
                                                                        ( 0,
                                                                          I_CDR,
                                                                          [],
                                                                          [] )
                                                                    ] ) ],
                                                              [] );
                                                          Prim
                                                            (0, I_PAIR, [], [])
                                                        ] ) ],
                                                  [] ) ] ) ] );
                                  Seq
                                    ( 0,
                                      [ Prim
                                          ( 0,
                                            I_DIP,
                                            [ Seq
                                                ( 0,
                                                  [ Prim (0, I_CDR, [], []);
                                                    Prim (0, I_DUP, [], []);
                                                    Prim (0, I_CDR, [], []) ]
                                                ) ],
                                            [] );
                                        Prim (0, I_PAIR, [], []);
                                        code_expr;
                                        Prim (0, I_SWAP, [], []);
                                        Prim (0, I_CAR, [], []);
                                        Prim (0, I_SWAP, [], []);
                                        Seq
                                          ( 0,
                                            [ Seq
                                                ( 0,
                                                  [ Prim (0, I_DUP, [], []);
                                                    Prim (0, I_CAR, [], []);
                                                    Prim
                                                      ( 0,
                                                        I_DIP,
                                                        [ Seq
                                                            ( 0,
                                                              [ Prim
                                                                  ( 0,
                                                                    I_CDR,
                                                                    [],
                                                                    [] ) ] ) ],
                                                        [] ) ] ) ] );
                                        Prim
                                          ( 0,
                                            I_DIP,
                                            [ Seq
                                                ( 0,
                                                  [ Prim (0, I_SWAP, [], []);
                                                    Prim (0, I_PAIR, [], []) ]
                                                ) ],
                                            [] );
                                        Prim (0, I_PAIR, [], []) ] ) ],
                                [] ) ] ) ],
                    code_annot ) ] )
        in
        let migrated_storage =
          Prim
            ( 0,
              D_Pair,
              [ (* Instead of
                   `String (0, Signature.Public_key_hash.to_b58check manager_pkh)`
                   the storage is written as unparsed with [Optimized] *)
                Bytes
                  ( 0,
                    Data_encoding.Binary.to_bytes_exn
                      Signature.Public_key_hash.encoding
                      manager_pkh );
                storage_expr ],
              [] )
        in
        ( Script_repr.lazy_expr @@ strip_locations migrated_code,
          Script_repr.lazy_expr @@ strip_locations migrated_storage )
    | _ -&gt;
        (script_code, script_storage) )
  | _ -&gt;
      (script_code, script_storage)

let add_set_delegate :
    manager_pkh:Signature.Public_key_hash.t -&gt;
    script_code:Script_repr.lazy_expr -&gt;
    script_storage:Script_repr.lazy_expr -&gt;
    (Script_repr.lazy_expr * Script_repr.lazy_expr) tzresult Lwt.t =
 fun ~manager_pkh ~script_code ~script_storage -&gt;
  let open Micheline in
  let open Michelson_v1_primitives in
  Lwt.return (Script_repr.force_decode script_code)
  &gt;&gt;=? fun (script_code_expr, _gas_cost) -&gt;
  Lwt.return (Script_repr.force_decode script_storage)
  &gt;&gt;|? fun (script_storage_expr, _gas_cost) -&gt;
  let storage_expr = root script_storage_expr in
  match root script_code_expr with
  | Seq (_, toplevel) -&gt; (
    match
      ( find_toplevel K_parameter toplevel,
        find_toplevel K_storage toplevel,
        find_toplevel K_code toplevel )
    with
    | ( Some
          (Prim
            ( _,
              K_parameter,
              [Prim (_, parameter_type, parameter_expr, parameter_annot)],
              prim_param_annot )),
        Some
          (Prim
            ( _,
              K_storage,
              [ Prim
                  (_, code_storage_type, code_storage_expr, code_storage_annot)
              ],
              k_storage_annot )),
        Some (Prim (_, K_code, [code_expr], code_annot)) ) -&gt;
        (* Note that we intentionally don't deal with potential duplicate entrypoints in this migration as there already might be some in contracts that we don't touch. *)
        let migrated_code =
          Seq
            ( 0,
              [ Prim
                  ( 0,
                    K_parameter,
                    [ Prim
                        ( 0,
                          T_or,
                          [ Prim
                              ( 0,
                                T_or,
                                [ Prim (0, T_key_hash, [], [&quot;%set_delegate&quot;]);
                                  Prim (0, T_unit, [], [&quot;%remove_delegate&quot;]) ],
                                [] );
                            Prim
                              ( 0,
                                parameter_type,
                                parameter_expr,
                                &quot;%default&quot; :: parameter_annot ) ],
                          [] ) ],
                    prim_param_annot );
                Prim
                  ( 0,
                    K_storage,
                    [ Prim
                        ( 0,
                          T_pair,
                          [ Prim (0, T_key_hash, [], []);
                            Prim
                              ( 0,
                                code_storage_type,
                                code_storage_expr,
                                code_storage_annot ) ],
                          [] ) ],
                    k_storage_annot );
                Prim
                  ( 0,
                    K_code,
                    [ Seq
                        ( 0,
                          [ Prim (0, I_DUP, [], []);
                            Prim (0, I_CAR, [], []);
                            Prim
                              ( 0,
                                I_IF_LEFT,
                                [ Seq
                                    ( 0,
                                      [ Prim
                                          ( 0,
                                            I_PUSH,
                                            [ Prim (0, T_mutez, [], []);
                                              Int (0, Z.zero) ],
                                            [] );
                                        Prim (0, I_AMOUNT, [], []);
                                        Seq
                                          ( 0,
                                            [ Seq
                                                ( 0,
                                                  [ Prim (0, I_COMPARE, [], []);
                                                    Prim (0, I_EQ, [], []) ] );
                                              Prim
                                                ( 0,
                                                  I_IF,
                                                  [ Seq (0, []);
                                                    Seq
                                                      ( 0,
                                                        [ Seq
                                                            ( 0,
                                                              [ Prim
                                                                  ( 0,
                                                                    I_UNIT,
                                                                    [],
                                                                    [] );
                                                                Prim
                                                                  ( 0,
                                                                    I_FAILWITH,
                                                                    [],
                                                                    [] ) ] ) ]
                                                      ) ],
                                                  [] ) ] );
                                        Seq
                                          ( 0,
                                            [ Prim
                                                ( 0,
                                                  I_DIP,
                                                  [ Seq
                                                      ( 0,
                                                        [ Prim
                                                            (0, I_DUP, [], [])
                                                        ] ) ],
                                                  [] );
                                              Prim (0, I_SWAP, [], []) ] );
                                        Prim (0, I_CDR, [], []);
                                        Prim (0, I_CAR, [], []);
                                        Prim (0, I_IMPLICIT_ACCOUNT, [], []);
                                        Prim (0, I_ADDRESS, [], []);
                                        Prim (0, I_SENDER, [], []);
                                        Seq
                                          ( 0,
                                            [ Prim (0, I_COMPARE, [], []);
                                              Prim (0, I_NEQ, [], []);
                                              Prim
                                                ( 0,
                                                  I_IF,
                                                  [ Seq
                                                      ( 0,
                                                        [ Prim
                                                            ( 0,
                                                              I_SENDER,
                                                              [],
                                                              [] );
                                                          Prim
                                                            ( 0,
                                                              I_PUSH,
                                                              [ Prim
                                                                  ( 0,
                                                                    T_string,
                                                                    [],
                                                                    [] );
                                                                String
                                                                  ( 0,
                                                                    &quot;Only the \
                                                                     owner \
                                                                     can \
                                                                     operate.&quot;
                                                                  ) ],
                                                              [] );
                                                          Prim
                                                            (0, I_PAIR, [], []);
                                                          Prim
                                                            ( 0,
                                                              I_FAILWITH,
                                                              [],
                                                              [] ) ] );
                                                    Seq
                                                      ( 0,
                                                        [ Prim
                                                            ( 0,
                                                              I_DIP,
                                                              [ Seq
                                                                  ( 0,
                                                                    [ Prim
                                                                        ( 0,
                                                                          I_CDR,
                                                                          [],
                                                                          [] );
                                                                      Prim
                                                                        ( 0,
                                                                          I_NIL,
                                                                          [ Prim
                                                                              ( 
                                                                              0,
                                                                               T_operation,
                                                                               [],
                                                                               []
                                                                              )
                                                                          ],
                                                                          [] )
                                                                    ] ) ],
                                                              [] );
                                                          Prim
                                                            ( 0,
                                                              I_IF_LEFT,
                                                              [ Seq
                                                                  ( 0,
                                                                    [ Prim
                                                                        ( 0,
                                                                          I_SOME,
                                                                          [],
                                                                          [] );
                                                                      Prim
                                                                        ( 0,
                                                                          I_SET_DELEGATE,
                                                                          [],
                                                                          [] );
                                                                      Prim
                                                                        ( 0,
                                                                          I_CONS,
                                                                          [],
                                                                          [] );
                                                                      Prim
                                                                        ( 0,
                                                                          I_PAIR,
                                                                          [],
                                                                          [] )
                                                                    ] );
                                                                Seq
                                                                  ( 0,
                                                                    [ Prim
                                                                        ( 0,
                                                                          I_DROP,
                                                                          [],
                                                                          [] );
                                                                      Prim
                                                                        ( 0,
                                                                          I_NONE,
                                                                          [ Prim
                                                                              ( 
                                                                              0,
                                                                               T_key_hash,
                                                                               [],
                                                                               []
                                                                              )
                                                                          ],
                                                                          [] );
                                                                      Prim
                                                                        ( 0,
                                                                          I_SET_DELEGATE,
                                                                          [],
                                                                          [] );
                                                                      Prim
                                                                        ( 0,
                                                                          I_CONS,
                                                                          [],
                                                                          [] );
                                                                      Prim
                                                                        ( 0,
                                                                          I_PAIR,
                                                                          [],
                                                                          [] )
                                                                    ] ) ],
                                                              [] ) ] ) ],
                                                  [] ) ] ) ] );
                                  Seq
                                    ( 0,
                                      [ Prim
                                          ( 0,
                                            I_DIP,
                                            [ Seq
                                                ( 0,
                                                  [ Prim (0, I_CDR, [], []);
                                                    Prim (0, I_DUP, [], []);
                                                    Prim (0, I_CDR, [], []) ]
                                                ) ],
                                            [] );
                                        Prim (0, I_PAIR, [], []);
                                        code_expr;
                                        Prim (0, I_SWAP, [], []);
                                        Prim (0, I_CAR, [], []);
                                        Prim (0, I_SWAP, [], []);
                                        Seq
                                          ( 0,
                                            [ Seq
                                                ( 0,
                                                  [ Prim (0, I_DUP, [], []);
                                                    Prim (0, I_CAR, [], []);
                                                    Prim
                                                      ( 0,
                                                        I_DIP,
                                                        [ Seq
                                                            ( 0,
                                                              [ Prim
                                                                  ( 0,
                                                                    I_CDR,
                                                                    [],
                                                                    [] ) ] ) ],
                                                        [] ) ] ) ] );
                                        Prim
                                          ( 0,
                                            I_DIP,
                                            [ Seq
                                                ( 0,
                                                  [ Prim (0, I_SWAP, [], []);
                                                    Prim (0, I_PAIR, [], []) ]
                                                ) ],
                                            [] );
                                        Prim (0, I_PAIR, [], []) ] ) ],
                                [] ) ] ) ],
                    code_annot ) ] )
        in
        let migrated_storage =
          Prim
            ( 0,
              D_Pair,
              [ (* Instead of
                   `String (0, Signature.Public_key_hash.to_b58check manager_pkh)`
                   the storage is written as unparsed with [Optimized] *)
                Bytes
                  ( 0,
                    Data_encoding.Binary.to_bytes_exn
                      Signature.Public_key_hash.encoding
                      manager_pkh );
                storage_expr ],
              [] )
        in
        ( Script_repr.lazy_expr @@ strip_locations migrated_code,
          Script_repr.lazy_expr @@ strip_locations migrated_storage )
    | _ -&gt;
        (script_code, script_storage) )
  | _ -&gt;
      (script_code, script_storage)

let has_default_entrypoint expr =
  let open Micheline in
  let open Michelson_v1_primitives in
  match Script_repr.force_decode expr with
  | Error _ -&gt;
      false
  | Ok (expr, _) -&gt; (
    match root expr with
    | Seq (_, toplevel) -&gt; (
      match find_toplevel K_parameter toplevel with
      | Some (Prim (_, K_parameter, [_], [&quot;%default&quot;])) -&gt;
          false
      | Some (Prim (_, K_parameter, [parameter_expr], _)) -&gt;
          let rec has_default = function
            | Prim (_, T_or, [l; r], annots) -&gt;
                List.exists (String.equal &quot;%default&quot;) annots
                || has_default l || has_default r
            | Prim (_, _, _, annots) -&gt;
                List.exists (String.equal &quot;%default&quot;) annots
            | _ -&gt;
                false
          in
          has_default parameter_expr
      | Some _ | None -&gt;
          false )
    | _ -&gt;
        false )

let add_root_entrypoint :
    script_code:Script_repr.lazy_expr -&gt; Script_repr.lazy_expr tzresult Lwt.t =
 fun ~script_code -&gt;
  let open Micheline in
  let open Michelson_v1_primitives in
  Lwt.return (Script_repr.force_decode script_code)
  &gt;&gt;|? fun (script_code_expr, _gas_cost) -&gt;
  match root script_code_expr with
  | Seq (_, toplevel) -&gt;
      let migrated_code =
        Seq
          ( 0,
            List.map
              (function
                | Prim (_, K_parameter, [parameter_expr], _) -&gt;
                    Prim (0, K_parameter, [parameter_expr], [&quot;%root&quot;])
                | Prim (_, K_code, exprs, annots) -&gt;
                    let rec rewrite_self = function
                      | ( Int _
                        | String _
                        | Bytes _
                        | Prim (_, I_CREATE_CONTRACT, _, _) ) as leaf -&gt;
                          leaf
                      | Prim (_, I_SELF, [], annots) -&gt;
                          Prim (0, I_SELF, [], &quot;%root&quot; :: annots)
                      | Prim (_, name, args, annots) -&gt;
                          Prim (0, name, List.map rewrite_self args, annots)
                      | Seq (_, args) -&gt;
                          Seq (0, List.map rewrite_self args)
                    in
                    Prim (0, K_code, List.map rewrite_self exprs, annots)
                | other -&gt;
                    other)
              toplevel )
      in
      Script_repr.lazy_expr @@ strip_locations migrated_code
  | _ -&gt;
      script_code
</pre>
  </div>
  <div class="col-md-6">
    <a href="#legacy_script_support_repr.ml"><code>Legacy_script_support_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Gas_limit_repr.
Require Tezos.Michelson_v1_primitives.
Require Tezos.Script_repr.

Definition manager_script_code : Script_repr.lazy_expr :=
  Script_repr.__lazy_expr_value
    (Micheline.strip_locations
      (Micheline.Seq 0
        [
          Micheline.Prim 0 Michelson_v1_primitives.K_parameter
            [
              Micheline.Prim 0 Michelson_v1_primitives.T_or
                [
                  Micheline.Prim 0
                    Michelson_v1_primitives.T_lambda
                    [
                      Micheline.Prim
                        0
                        Michelson_v1_primitives.T_unit
                        nil
                        nil;
                      Micheline.Prim
                        0
                        Michelson_v1_primitives.T_list
                        [
                          Micheline.Prim
                            0
                            Michelson_v1_primitives.T_operation
                            nil
                            nil
                        ]
                        nil
                    ]
                    [
                      &quot;%do&quot;
                    ];
                  Micheline.Prim 0
                    Michelson_v1_primitives.T_unit
                    nil
                    [
                      &quot;%default&quot;
                    ]
                ] nil
            ] nil;
          Micheline.Prim 0 Michelson_v1_primitives.K_storage
            [ Micheline.Prim 0 Michelson_v1_primitives.T_key_hash nil nil ]
            nil;
          Micheline.Prim 0 Michelson_v1_primitives.K_code
            [
              Micheline.Seq 0
                [
                  Micheline.Seq 0
                    [
                      Micheline.Seq
                        0
                        [
                          Micheline.Prim
                            0
                            Michelson_v1_primitives.I_DUP
                            nil
                            nil;
                          Micheline.Prim
                            0
                            Michelson_v1_primitives.I_CAR
                            nil
                            nil;
                          Micheline.Prim
                            0
                            Michelson_v1_primitives.I_DIP
                            [
                              Micheline.Seq
                                0
                                [
                                  Micheline.Prim
                                    0
                                    Michelson_v1_primitives.I_CDR
                                    nil
                                    nil
                                ]
                            ]
                            nil
                        ]
                    ];
                  Micheline.Prim 0
                    Michelson_v1_primitives.I_IF_LEFT
                    [
                      Micheline.Seq
                        0
                        [
                          Micheline.Prim
                            0
                            Michelson_v1_primitives.I_PUSH
                            [
                              Micheline.Prim
                                0
                                Michelson_v1_primitives.T_mutez
                                nil
                                nil;
                              Micheline.Int
                                0
                                Z.zero
                            ]
                            nil;
                          Micheline.Prim
                            0
                            Michelson_v1_primitives.I_AMOUNT
                            nil
                            nil;
                          Micheline.Seq
                            0
                            [
                              Micheline.Seq
                                0
                                [
                                  Micheline.Prim
                                    0
                                    Michelson_v1_primitives.I_COMPARE
                                    nil
                                    nil;
                                  Micheline.Prim
                                    0
                                    Michelson_v1_primitives.I_EQ
                                    nil
                                    nil
                                ];
                              Micheline.Prim
                                0
                                Michelson_v1_primitives.I_IF
                                [
                                  Micheline.Seq
                                    0
                                    nil;
                                  Micheline.Seq
                                    0
                                    [
                                      Micheline.Seq
                                        0
                                        [
                                          Micheline.Prim
                                            0
                                            Michelson_v1_primitives.I_UNIT
                                            nil
                                            nil;
                                          Micheline.Prim
                                            0
                                            Michelson_v1_primitives.I_FAILWITH
                                            nil
                                            nil
                                        ]
                                    ]
                                ]
                                nil
                            ];
                          Micheline.Seq
                            0
                            [
                              Micheline.Prim
                                0
                                Michelson_v1_primitives.I_DIP
                                [
                                  Micheline.Seq
                                    0
                                    [
                                      Micheline.Prim
                                        0
                                        Michelson_v1_primitives.I_DUP
                                        nil
                                        nil
                                    ]
                                ]
                                nil;
                              Micheline.Prim
                                0
                                Michelson_v1_primitives.I_SWAP
                                nil
                                nil
                            ];
                          Micheline.Prim
                            0
                            Michelson_v1_primitives.I_IMPLICIT_ACCOUNT
                            nil
                            nil;
                          Micheline.Prim
                            0
                            Michelson_v1_primitives.I_ADDRESS
                            nil
                            nil;
                          Micheline.Prim
                            0
                            Michelson_v1_primitives.I_SENDER
                            nil
                            nil;
                          Micheline.Seq
                            0
                            [
                              Micheline.Seq
                                0
                                [
                                  Micheline.Prim
                                    0
                                    Michelson_v1_primitives.I_COMPARE
                                    nil
                                    nil;
                                  Micheline.Prim
                                    0
                                    Michelson_v1_primitives.I_EQ
                                    nil
                                    nil
                                ];
                              Micheline.Prim
                                0
                                Michelson_v1_primitives.I_IF
                                [
                                  Micheline.Seq
                                    0
                                    nil;
                                  Micheline.Seq
                                    0
                                    [
                                      Micheline.Seq
                                        0
                                        [
                                          Micheline.Prim
                                            0
                                            Michelson_v1_primitives.I_UNIT
                                            nil
                                            nil;
                                          Micheline.Prim
                                            0
                                            Michelson_v1_primitives.I_FAILWITH
                                            nil
                                            nil
                                        ]
                                    ]
                                ]
                                nil
                            ];
                          Micheline.Prim
                            0
                            Michelson_v1_primitives.I_UNIT
                            nil
                            nil;
                          Micheline.Prim
                            0
                            Michelson_v1_primitives.I_EXEC
                            nil
                            nil;
                          Micheline.Prim
                            0
                            Michelson_v1_primitives.I_PAIR
                            nil
                            nil
                        ];
                      Micheline.Seq
                        0
                        [
                          Micheline.Prim
                            0
                            Michelson_v1_primitives.I_DROP
                            nil
                            nil;
                          Micheline.Prim
                            0
                            Michelson_v1_primitives.I_NIL
                            [
                              Micheline.Prim
                                0
                                Michelson_v1_primitives.T_operation
                                nil
                                nil
                            ]
                            nil;
                          Micheline.Prim
                            0
                            Michelson_v1_primitives.I_PAIR
                            nil
                            nil
                        ]
                    ]
                    nil
                ]
            ] nil
        ])).

Definition find_toplevel {A : Set}
  (toplevel : Michelson_v1_primitives.prim)
  (exprs : list (Micheline.node A Michelson_v1_primitives.prim))
  : option (Micheline.node A Michelson_v1_primitives.prim) :=
  let fix iter {B : Set}
    (toplevel : String.t)
    (function_parameter : list (Micheline.node B Michelson_v1_primitives.prim))
    {struct toplevel}
    : option (Micheline.node B Michelson_v1_primitives.prim) :=
    match
      (function_parameter,
        match function_parameter with
        | cons ((Micheline.Prim _ prim _ _) as found) _ =&gt;
          String.equal toplevel (Michelson_v1_primitives.string_of_prim prim)
        | _ =&gt; false
        end) with
    | (cons ((Micheline.Prim _ prim _ _) as found) _, true) =&gt; Some found
    | (cons _ rest, _) =&gt; iter toplevel rest
    | ([], _) =&gt; None
    end in
  iter (Michelson_v1_primitives.string_of_prim toplevel) exprs.

Definition add_do
  (manager_pkh : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  (script_code : Script_repr.lazy_expr) (script_storage : Script_repr.lazy_expr)
  : Lwt.t (Error_monad.tzresult (Script_repr.lazy_expr * Script_repr.lazy_expr)) :=
  let=? '(script_code_expr, _gas_cost) :=
    Lwt.__return (Script_repr.force_decode script_code) in
  Error_monad.op_gtgtpipequestion
    (Lwt.__return (Script_repr.force_decode script_storage))
    (fun function_parameter =&gt;
      let '(script_storage_expr, _gas_cost) := function_parameter in
      let storage_expr := Micheline.root script_storage_expr in
      match Micheline.root script_code_expr with
      | Micheline.Seq _ toplevel =&gt;
        match
          ((find_toplevel Michelson_v1_primitives.K_parameter toplevel),
            (find_toplevel Michelson_v1_primitives.K_storage toplevel),
            (find_toplevel Michelson_v1_primitives.K_code toplevel)) with
        |
          (Some
            (Micheline.Prim _ Michelson_v1_primitives.K_parameter
              (cons
                (Micheline.Prim _ parameter_type parameter_expr parameter_annot)
                []) prim_param_annot),
            Some
              (Micheline.Prim _ Michelson_v1_primitives.K_storage
                (cons
                  (Micheline.Prim _ code_storage_type code_storage_expr
                    code_storage_annot) []) k_storage_annot),
            Some
              (Micheline.Prim _ Michelson_v1_primitives.K_code
                (cons code_expr []) code_annot)) =&gt;
          let migrated_code :=
            Micheline.Seq 0
              [
                Micheline.Prim 0 Michelson_v1_primitives.K_parameter
                  [
                    Micheline.Prim 0
                      Michelson_v1_primitives.T_or
                      [
                        Micheline.Prim
                          0
                          Michelson_v1_primitives.T_lambda
                          [
                            Micheline.Prim
                              0
                              Michelson_v1_primitives.T_unit
                              nil
                              nil;
                            Micheline.Prim
                              0
                              Michelson_v1_primitives.T_list
                              [
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.T_operation
                                  nil
                                  nil
                              ]
                              nil
                          ]
                          [
                            &quot;%do&quot;
                          ];
                        Micheline.Prim
                          0
                          parameter_type
                          parameter_expr
                          (cons
                            &quot;%default&quot;
                            parameter_annot)
                      ] nil
                  ] prim_param_annot;
                Micheline.Prim 0 Michelson_v1_primitives.K_storage
                  [
                    Micheline.Prim 0
                      Michelson_v1_primitives.T_pair
                      [
                        Micheline.Prim
                          0
                          Michelson_v1_primitives.T_key_hash
                          nil
                          nil;
                        Micheline.Prim
                          0
                          code_storage_type
                          code_storage_expr
                          code_storage_annot
                      ] nil
                  ] k_storage_annot;
                Micheline.Prim 0 Michelson_v1_primitives.K_code
                  [
                    Micheline.Seq 0
                      [
                        Micheline.Prim
                          0
                          Michelson_v1_primitives.I_DUP
                          nil
                          nil;
                        Micheline.Prim
                          0
                          Michelson_v1_primitives.I_CAR
                          nil
                          nil;
                        Micheline.Prim
                          0
                          Michelson_v1_primitives.I_IF_LEFT
                          [
                            Micheline.Seq
                              0
                              [
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_PUSH
                                  [
                                    Micheline.Prim
                                      0
                                      Michelson_v1_primitives.T_mutez
                                      nil
                                      nil;
                                    Micheline.Int
                                      0
                                      Z.zero
                                  ]
                                  nil;
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_AMOUNT
                                  nil
                                  nil;
                                Micheline.Seq
                                  0
                                  [
                                    Micheline.Seq
                                      0
                                      [
                                        Micheline.Prim
                                          0
                                          Michelson_v1_primitives.I_COMPARE
                                          nil
                                          nil;
                                        Micheline.Prim
                                          0
                                          Michelson_v1_primitives.I_EQ
                                          nil
                                          nil
                                      ];
                                    Micheline.Prim
                                      0
                                      Michelson_v1_primitives.I_IF
                                      [
                                        Micheline.Seq
                                          0
                                          nil;
                                        Micheline.Seq
                                          0
                                          [
                                            Micheline.Seq
                                              0
                                              [
                                                Micheline.Prim
                                                  0
                                                  Michelson_v1_primitives.I_UNIT
                                                  nil
                                                  nil;
                                                Micheline.Prim
                                                  0
                                                  Michelson_v1_primitives.I_FAILWITH
                                                  nil
                                                  nil
                                              ]
                                          ]
                                      ]
                                      nil
                                  ];
                                Micheline.Seq
                                  0
                                  [
                                    Micheline.Prim
                                      0
                                      Michelson_v1_primitives.I_DIP
                                      [
                                        Micheline.Seq
                                          0
                                          [
                                            Micheline.Prim
                                              0
                                              Michelson_v1_primitives.I_DUP
                                              nil
                                              nil
                                          ]
                                      ]
                                      nil;
                                    Micheline.Prim
                                      0
                                      Michelson_v1_primitives.I_SWAP
                                      nil
                                      nil
                                  ];
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_CDR
                                  nil
                                  nil;
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_CAR
                                  nil
                                  nil;
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_IMPLICIT_ACCOUNT
                                  nil
                                  nil;
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_ADDRESS
                                  nil
                                  nil;
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_SENDER
                                  nil
                                  nil;
                                Micheline.Seq
                                  0
                                  [
                                    Micheline.Prim
                                      0
                                      Michelson_v1_primitives.I_COMPARE
                                      nil
                                      nil;
                                    Micheline.Prim
                                      0
                                      Michelson_v1_primitives.I_NEQ
                                      nil
                                      nil;
                                    Micheline.Prim
                                      0
                                      Michelson_v1_primitives.I_IF
                                      [
                                        Micheline.Seq
                                          0
                                          [
                                            Micheline.Prim
                                              0
                                              Michelson_v1_primitives.I_SENDER
                                              nil
                                              nil;
                                            Micheline.Prim
                                              0
                                              Michelson_v1_primitives.I_PUSH
                                              [
                                                Micheline.Prim
                                                  0
                                                  Michelson_v1_primitives.T_string
                                                  nil
                                                  nil;
                                                Micheline.String
                                                  0
                                                  &quot;Only the owner can operate.&quot;
                                              ]
                                              nil;
                                            Micheline.Prim
                                              0
                                              Michelson_v1_primitives.I_PAIR
                                              nil
                                              nil;
                                            Micheline.Prim
                                              0
                                              Michelson_v1_primitives.I_FAILWITH
                                              nil
                                              nil
                                          ];
                                        Micheline.Seq
                                          0
                                          [
                                            Micheline.Prim
                                              0
                                              Michelson_v1_primitives.I_UNIT
                                              nil
                                              nil;
                                            Micheline.Prim
                                              0
                                              Michelson_v1_primitives.I_EXEC
                                              nil
                                              nil;
                                            Micheline.Prim
                                              0
                                              Michelson_v1_primitives.I_DIP
                                              [
                                                Micheline.Seq
                                                  0
                                                  [
                                                    Micheline.Prim
                                                      0
                                                      Michelson_v1_primitives.I_CDR
                                                      nil
                                                      nil
                                                  ]
                                              ]
                                              nil;
                                            Micheline.Prim
                                              0
                                              Michelson_v1_primitives.I_PAIR
                                              nil
                                              nil
                                          ]
                                      ]
                                      nil
                                  ]
                              ];
                            Micheline.Seq
                              0
                              [
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_DIP
                                  [
                                    Micheline.Seq
                                      0
                                      [
                                        Micheline.Prim
                                          0
                                          Michelson_v1_primitives.I_CDR
                                          nil
                                          nil;
                                        Micheline.Prim
                                          0
                                          Michelson_v1_primitives.I_DUP
                                          nil
                                          nil;
                                        Micheline.Prim
                                          0
                                          Michelson_v1_primitives.I_CDR
                                          nil
                                          nil
                                      ]
                                  ]
                                  nil;
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_PAIR
                                  nil
                                  nil;
                                code_expr;
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_SWAP
                                  nil
                                  nil;
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_CAR
                                  nil
                                  nil;
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_SWAP
                                  nil
                                  nil;
                                Micheline.Seq
                                  0
                                  [
                                    Micheline.Seq
                                      0
                                      [
                                        Micheline.Prim
                                          0
                                          Michelson_v1_primitives.I_DUP
                                          nil
                                          nil;
                                        Micheline.Prim
                                          0
                                          Michelson_v1_primitives.I_CAR
                                          nil
                                          nil;
                                        Micheline.Prim
                                          0
                                          Michelson_v1_primitives.I_DIP
                                          [
                                            Micheline.Seq
                                              0
                                              [
                                                Micheline.Prim
                                                  0
                                                  Michelson_v1_primitives.I_CDR
                                                  nil
                                                  nil
                                              ]
                                          ]
                                          nil
                                      ]
                                  ];
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_DIP
                                  [
                                    Micheline.Seq
                                      0
                                      [
                                        Micheline.Prim
                                          0
                                          Michelson_v1_primitives.I_SWAP
                                          nil
                                          nil;
                                        Micheline.Prim
                                          0
                                          Michelson_v1_primitives.I_PAIR
                                          nil
                                          nil
                                      ]
                                  ]
                                  nil;
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_PAIR
                                  nil
                                  nil
                              ]
                          ]
                          nil
                      ]
                  ] code_annot
              ] in
          let migrated_storage :=
            Micheline.Prim 0 Michelson_v1_primitives.D_Pair
              [
                Micheline.Bytes 0
                  (Data_encoding.Binary.to_bytes_exn
                    (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding)
                    manager_pkh);
                storage_expr
              ] nil in
          ((Script_repr.__lazy_expr_value
            (Micheline.strip_locations migrated_code)),
            (Script_repr.__lazy_expr_value
              (Micheline.strip_locations migrated_storage)))
        | _ =&gt; (script_code, script_storage)
        end
      | _ =&gt; (script_code, script_storage)
      end).

Definition add_set_delegate
  (manager_pkh : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  (script_code : Script_repr.lazy_expr) (script_storage : Script_repr.lazy_expr)
  : Lwt.t (Error_monad.tzresult (Script_repr.lazy_expr * Script_repr.lazy_expr)) :=
  let=? '(script_code_expr, _gas_cost) :=
    Lwt.__return (Script_repr.force_decode script_code) in
  Error_monad.op_gtgtpipequestion
    (Lwt.__return (Script_repr.force_decode script_storage))
    (fun function_parameter =&gt;
      let '(script_storage_expr, _gas_cost) := function_parameter in
      let storage_expr := Micheline.root script_storage_expr in
      match Micheline.root script_code_expr with
      | Micheline.Seq _ toplevel =&gt;
        match
          ((find_toplevel Michelson_v1_primitives.K_parameter toplevel),
            (find_toplevel Michelson_v1_primitives.K_storage toplevel),
            (find_toplevel Michelson_v1_primitives.K_code toplevel)) with
        |
          (Some
            (Micheline.Prim _ Michelson_v1_primitives.K_parameter
              (cons
                (Micheline.Prim _ parameter_type parameter_expr parameter_annot)
                []) prim_param_annot),
            Some
              (Micheline.Prim _ Michelson_v1_primitives.K_storage
                (cons
                  (Micheline.Prim _ code_storage_type code_storage_expr
                    code_storage_annot) []) k_storage_annot),
            Some
              (Micheline.Prim _ Michelson_v1_primitives.K_code
                (cons code_expr []) code_annot)) =&gt;
          let migrated_code :=
            Micheline.Seq 0
              [
                Micheline.Prim 0 Michelson_v1_primitives.K_parameter
                  [
                    Micheline.Prim 0
                      Michelson_v1_primitives.T_or
                      [
                        Micheline.Prim
                          0
                          Michelson_v1_primitives.T_or
                          [
                            Micheline.Prim
                              0
                              Michelson_v1_primitives.T_key_hash
                              nil
                              [
                                &quot;%set_delegate&quot;
                              ];
                            Micheline.Prim
                              0
                              Michelson_v1_primitives.T_unit
                              nil
                              [
                                &quot;%remove_delegate&quot;
                              ]
                          ]
                          nil;
                        Micheline.Prim
                          0
                          parameter_type
                          parameter_expr
                          (cons
                            &quot;%default&quot;
                            parameter_annot)
                      ] nil
                  ] prim_param_annot;
                Micheline.Prim 0 Michelson_v1_primitives.K_storage
                  [
                    Micheline.Prim 0
                      Michelson_v1_primitives.T_pair
                      [
                        Micheline.Prim
                          0
                          Michelson_v1_primitives.T_key_hash
                          nil
                          nil;
                        Micheline.Prim
                          0
                          code_storage_type
                          code_storage_expr
                          code_storage_annot
                      ] nil
                  ] k_storage_annot;
                Micheline.Prim 0 Michelson_v1_primitives.K_code
                  [
                    Micheline.Seq 0
                      [
                        Micheline.Prim
                          0
                          Michelson_v1_primitives.I_DUP
                          nil
                          nil;
                        Micheline.Prim
                          0
                          Michelson_v1_primitives.I_CAR
                          nil
                          nil;
                        Micheline.Prim
                          0
                          Michelson_v1_primitives.I_IF_LEFT
                          [
                            Micheline.Seq
                              0
                              [
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_PUSH
                                  [
                                    Micheline.Prim
                                      0
                                      Michelson_v1_primitives.T_mutez
                                      nil
                                      nil;
                                    Micheline.Int
                                      0
                                      Z.zero
                                  ]
                                  nil;
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_AMOUNT
                                  nil
                                  nil;
                                Micheline.Seq
                                  0
                                  [
                                    Micheline.Seq
                                      0
                                      [
                                        Micheline.Prim
                                          0
                                          Michelson_v1_primitives.I_COMPARE
                                          nil
                                          nil;
                                        Micheline.Prim
                                          0
                                          Michelson_v1_primitives.I_EQ
                                          nil
                                          nil
                                      ];
                                    Micheline.Prim
                                      0
                                      Michelson_v1_primitives.I_IF
                                      [
                                        Micheline.Seq
                                          0
                                          nil;
                                        Micheline.Seq
                                          0
                                          [
                                            Micheline.Seq
                                              0
                                              [
                                                Micheline.Prim
                                                  0
                                                  Michelson_v1_primitives.I_UNIT
                                                  nil
                                                  nil;
                                                Micheline.Prim
                                                  0
                                                  Michelson_v1_primitives.I_FAILWITH
                                                  nil
                                                  nil
                                              ]
                                          ]
                                      ]
                                      nil
                                  ];
                                Micheline.Seq
                                  0
                                  [
                                    Micheline.Prim
                                      0
                                      Michelson_v1_primitives.I_DIP
                                      [
                                        Micheline.Seq
                                          0
                                          [
                                            Micheline.Prim
                                              0
                                              Michelson_v1_primitives.I_DUP
                                              nil
                                              nil
                                          ]
                                      ]
                                      nil;
                                    Micheline.Prim
                                      0
                                      Michelson_v1_primitives.I_SWAP
                                      nil
                                      nil
                                  ];
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_CDR
                                  nil
                                  nil;
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_CAR
                                  nil
                                  nil;
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_IMPLICIT_ACCOUNT
                                  nil
                                  nil;
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_ADDRESS
                                  nil
                                  nil;
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_SENDER
                                  nil
                                  nil;
                                Micheline.Seq
                                  0
                                  [
                                    Micheline.Prim
                                      0
                                      Michelson_v1_primitives.I_COMPARE
                                      nil
                                      nil;
                                    Micheline.Prim
                                      0
                                      Michelson_v1_primitives.I_NEQ
                                      nil
                                      nil;
                                    Micheline.Prim
                                      0
                                      Michelson_v1_primitives.I_IF
                                      [
                                        Micheline.Seq
                                          0
                                          [
                                            Micheline.Prim
                                              0
                                              Michelson_v1_primitives.I_SENDER
                                              nil
                                              nil;
                                            Micheline.Prim
                                              0
                                              Michelson_v1_primitives.I_PUSH
                                              [
                                                Micheline.Prim
                                                  0
                                                  Michelson_v1_primitives.T_string
                                                  nil
                                                  nil;
                                                Micheline.String
                                                  0
                                                  &quot;Only the owner can operate.&quot;
                                              ]
                                              nil;
                                            Micheline.Prim
                                              0
                                              Michelson_v1_primitives.I_PAIR
                                              nil
                                              nil;
                                            Micheline.Prim
                                              0
                                              Michelson_v1_primitives.I_FAILWITH
                                              nil
                                              nil
                                          ];
                                        Micheline.Seq
                                          0
                                          [
                                            Micheline.Prim
                                              0
                                              Michelson_v1_primitives.I_DIP
                                              [
                                                Micheline.Seq
                                                  0
                                                  [
                                                    Micheline.Prim
                                                      0
                                                      Michelson_v1_primitives.I_CDR
                                                      nil
                                                      nil;
                                                    Micheline.Prim
                                                      0
                                                      Michelson_v1_primitives.I_NIL
                                                      [
                                                        Micheline.Prim
                                                          0
                                                          Michelson_v1_primitives.T_operation
                                                          nil
                                                          nil
                                                      ]
                                                      nil
                                                  ]
                                              ]
                                              nil;
                                            Micheline.Prim
                                              0
                                              Michelson_v1_primitives.I_IF_LEFT
                                              [
                                                Micheline.Seq
                                                  0
                                                  [
                                                    Micheline.Prim
                                                      0
                                                      Michelson_v1_primitives.I_SOME
                                                      nil
                                                      nil;
                                                    Micheline.Prim
                                                      0
                                                      Michelson_v1_primitives.I_SET_DELEGATE
                                                      nil
                                                      nil;
                                                    Micheline.Prim
                                                      0
                                                      Michelson_v1_primitives.I_CONS
                                                      nil
                                                      nil;
                                                    Micheline.Prim
                                                      0
                                                      Michelson_v1_primitives.I_PAIR
                                                      nil
                                                      nil
                                                  ];
                                                Micheline.Seq
                                                  0
                                                  [
                                                    Micheline.Prim
                                                      0
                                                      Michelson_v1_primitives.I_DROP
                                                      nil
                                                      nil;
                                                    Micheline.Prim
                                                      0
                                                      Michelson_v1_primitives.I_NONE
                                                      [
                                                        Micheline.Prim
                                                          0
                                                          Michelson_v1_primitives.T_key_hash
                                                          nil
                                                          nil
                                                      ]
                                                      nil;
                                                    Micheline.Prim
                                                      0
                                                      Michelson_v1_primitives.I_SET_DELEGATE
                                                      nil
                                                      nil;
                                                    Micheline.Prim
                                                      0
                                                      Michelson_v1_primitives.I_CONS
                                                      nil
                                                      nil;
                                                    Micheline.Prim
                                                      0
                                                      Michelson_v1_primitives.I_PAIR
                                                      nil
                                                      nil
                                                  ]
                                              ]
                                              nil
                                          ]
                                      ]
                                      nil
                                  ]
                              ];
                            Micheline.Seq
                              0
                              [
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_DIP
                                  [
                                    Micheline.Seq
                                      0
                                      [
                                        Micheline.Prim
                                          0
                                          Michelson_v1_primitives.I_CDR
                                          nil
                                          nil;
                                        Micheline.Prim
                                          0
                                          Michelson_v1_primitives.I_DUP
                                          nil
                                          nil;
                                        Micheline.Prim
                                          0
                                          Michelson_v1_primitives.I_CDR
                                          nil
                                          nil
                                      ]
                                  ]
                                  nil;
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_PAIR
                                  nil
                                  nil;
                                code_expr;
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_SWAP
                                  nil
                                  nil;
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_CAR
                                  nil
                                  nil;
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_SWAP
                                  nil
                                  nil;
                                Micheline.Seq
                                  0
                                  [
                                    Micheline.Seq
                                      0
                                      [
                                        Micheline.Prim
                                          0
                                          Michelson_v1_primitives.I_DUP
                                          nil
                                          nil;
                                        Micheline.Prim
                                          0
                                          Michelson_v1_primitives.I_CAR
                                          nil
                                          nil;
                                        Micheline.Prim
                                          0
                                          Michelson_v1_primitives.I_DIP
                                          [
                                            Micheline.Seq
                                              0
                                              [
                                                Micheline.Prim
                                                  0
                                                  Michelson_v1_primitives.I_CDR
                                                  nil
                                                  nil
                                              ]
                                          ]
                                          nil
                                      ]
                                  ];
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_DIP
                                  [
                                    Micheline.Seq
                                      0
                                      [
                                        Micheline.Prim
                                          0
                                          Michelson_v1_primitives.I_SWAP
                                          nil
                                          nil;
                                        Micheline.Prim
                                          0
                                          Michelson_v1_primitives.I_PAIR
                                          nil
                                          nil
                                      ]
                                  ]
                                  nil;
                                Micheline.Prim
                                  0
                                  Michelson_v1_primitives.I_PAIR
                                  nil
                                  nil
                              ]
                          ]
                          nil
                      ]
                  ] code_annot
              ] in
          let migrated_storage :=
            Micheline.Prim 0 Michelson_v1_primitives.D_Pair
              [
                Micheline.Bytes 0
                  (Data_encoding.Binary.to_bytes_exn
                    (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding)
                    manager_pkh);
                storage_expr
              ] nil in
          ((Script_repr.__lazy_expr_value
            (Micheline.strip_locations migrated_code)),
            (Script_repr.__lazy_expr_value
              (Micheline.strip_locations migrated_storage)))
        | _ =&gt; (script_code, script_storage)
        end
      | _ =&gt; (script_code, script_storage)
      end).

Definition has_default_entrypoint (expr : Script_repr.lazy_expr) : bool :=
  match Script_repr.force_decode expr with
  | Pervasives.Error _ =&gt; false
  | Pervasives.Ok (expr, _) =&gt;
    match Micheline.root expr with
    | Micheline.Seq _ toplevel =&gt;
      match find_toplevel Michelson_v1_primitives.K_parameter toplevel with
      |
        Some
          (Micheline.Prim _ Michelson_v1_primitives.K_parameter (cons _ [])
            (cons &quot;%default&quot; [])) =&gt; false
      |
        Some
          (Micheline.Prim _ Michelson_v1_primitives.K_parameter
            (cons parameter_expr []) _) =&gt;
        let fix has_default {A : Set}
          (function_parameter : Micheline.node A Michelson_v1_primitives.prim)
          {struct function_parameter} : bool :=
          match function_parameter with
          |
            Micheline.Prim _ Michelson_v1_primitives.T_or
              (cons l (cons __r_value [])) annots =&gt;
            Pervasives.op_pipepipe
              (List.__exists (String.equal &quot;%default&quot;) annots)
              (Pervasives.op_pipepipe (has_default l) (has_default __r_value))
          | Micheline.Prim _ _ _ annots =&gt;
            List.__exists (String.equal &quot;%default&quot;) annots
          | _ =&gt; false
          end in
        has_default parameter_expr
      | (Some _ | None) =&gt; false
      end
    | _ =&gt; false
    end
  end.

Definition add_root_entrypoint (script_code : Script_repr.lazy_expr)
  : Lwt.t (Error_monad.tzresult Script_repr.lazy_expr) :=
  Error_monad.op_gtgtpipequestion
    (Lwt.__return (Script_repr.force_decode script_code))
    (fun function_parameter =&gt;
      let '(script_code_expr, _gas_cost) := function_parameter in
      match Micheline.root script_code_expr with
      | Micheline.Seq _ toplevel =&gt;
        let migrated_code :=
          Micheline.Seq 0
            (List.map
              (fun function_parameter =&gt;
                match function_parameter with
                |
                  Micheline.Prim _ Michelson_v1_primitives.K_parameter
                    (cons parameter_expr []) _ =&gt;
                  Micheline.Prim 0 Michelson_v1_primitives.K_parameter
                    [ parameter_expr ] [ &quot;%root&quot; ]
                | Micheline.Prim _ Michelson_v1_primitives.K_code exprs annots
                  =&gt;
                  let fix rewrite_self
                    (function_parameter :
                      Micheline.node int Michelson_v1_primitives.prim)
                    {struct function_parameter}
                    : Micheline.node int Michelson_v1_primitives.prim :=
                    match function_parameter with
                    |
                      (Micheline.Int _ _ | Micheline.String _ _ |
                      Micheline.Bytes _ _ |
                      Micheline.Prim _ Michelson_v1_primitives.I_CREATE_CONTRACT
                        _ _) as leaf =&gt; leaf
                    | Micheline.Prim _ Michelson_v1_primitives.I_SELF [] annots
                      =&gt;
                      Micheline.Prim 0 Michelson_v1_primitives.I_SELF nil
                        (cons &quot;%root&quot; annots)
                    | Micheline.Prim _ name args annots =&gt;
                      Micheline.Prim 0 name (List.map rewrite_self args) annots
                    | Micheline.Seq _ args =&gt;
                      Micheline.Seq 0 (List.map rewrite_self args)
                    end in
                  Micheline.Prim 0 Michelson_v1_primitives.K_code
                    (List.map rewrite_self exprs) annots
                | other =&gt; other
                end) toplevel) in
        Script_repr.__lazy_expr_value (Micheline.strip_locations migrated_code)
      | _ =&gt; script_code
      end).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="legacy_script_support_repr.mli">
  <div style="margin: 20px;">
    <h3>Legacy_script_support_repr_mli</h3>
    <ul>
      <li>OCaml size: 67 lines</li>
      <li>Coq size: 29 lines (-57% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#legacy_script_support_repr.mli"><code>legacy_script_support_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(* Copyright (c) 2019 Nomadic Labs &lt;contact@nomadic-labs.com&gt;                *)
(* Copyright (c) 2019 Cryptium Labs &lt;contact@cryptium-labs.com&gt;              *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** This code mimics the now defunct scriptless KT1s.

    The manager contract is from:
    https://gitlab.com/nomadic-labs/mi-cho-coq/blob/7b42f2e970e1541af54f8a9b6820b4f18e847575/src/contracts/manager.tz
    The formal proof is at:
    https://gitlab.com/nomadic-labs/mi-cho-coq/blob/a7603e12021166e15890f6d504feebec2f945502/src/contracts_coq/manager.v *)
val manager_script_code : Script_repr.lazy_expr

(** This code mimics the now defunct &quot;spendable&quot; flags of KT1s by
    adding a [do] entrypoint, preserving the original script's at
    'default' entrypoint.

    The pseudo-code for the applied transformations is from:
    https://gitlab.com/nomadic-labs/mi-cho-coq/blob/7b42f2e970e1541af54f8a9b6820b4f18e847575/src/contracts/transform/add_do.tz *)
val add_do :
  manager_pkh:Signature.Public_key_hash.t -&gt;
  script_code:Script_repr.lazy_expr -&gt;
  script_storage:Script_repr.lazy_expr -&gt;
  (Script_repr.lazy_expr * Script_repr.lazy_expr) tzresult Lwt.t

(** This code mimics the now defunct &quot;spendable&quot; flags of KT1s by
    adding a [do] entrypoint, preserving the original script's at
    'default' entrypoint.

    The pseudo-code for the applied transformations is from:
    https://gitlab.com/nomadic-labs/mi-cho-coq/blob/7b42f2e970e1541af54f8a9b6820b4f18e847575/src/contracts/transform/add_set_delegate.tz *)
val add_set_delegate :
  manager_pkh:Signature.Public_key_hash.t -&gt;
  script_code:Script_repr.lazy_expr -&gt;
  script_storage:Script_repr.lazy_expr -&gt;
  (Script_repr.lazy_expr * Script_repr.lazy_expr) tzresult Lwt.t

(** Checks if a contract was declaring a default entrypoint somewhere
   else than at the root, in which case its type changes when
   entrypoints are activated. *)
val has_default_entrypoint : Script_repr.lazy_expr -&gt; bool

(** Adds a [%root] annotation on the toplevel parameter construct. *)
val add_root_entrypoint :
  script_code:Script_repr.lazy_expr -&gt; Script_repr.lazy_expr tzresult Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#legacy_script_support_repr.mli"><code>Legacy_script_support_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Script_repr.

Parameter manager_script_code : Script_repr.lazy_expr.

Parameter add_do :
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Script_repr.lazy_expr -&gt; Script_repr.lazy_expr -&gt;
  Lwt.t (Error_monad.tzresult (Script_repr.lazy_expr * Script_repr.lazy_expr)).

Parameter add_set_delegate :
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Script_repr.lazy_expr -&gt; Script_repr.lazy_expr -&gt;
  Lwt.t (Error_monad.tzresult (Script_repr.lazy_expr * Script_repr.lazy_expr)).

Parameter has_default_entrypoint : Script_repr.lazy_expr -&gt; bool.

Parameter add_root_entrypoint :
  Script_repr.lazy_expr -&gt; Lwt.t (Error_monad.tzresult Script_repr.lazy_expr).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="level_repr.ml">
  <div style="margin: 20px;">
    <h3>Level_repr</h3>
    <ul>
      <li>OCaml size: 187 lines</li>
      <li>Coq size: 210 lines (+12% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#level_repr.ml"><code>level_repr.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = {
  level : Raw_level_repr.t;
  level_position : int32;
  cycle : Cycle_repr.t;
  cycle_position : int32;
  voting_period : Voting_period_repr.t;
  voting_period_position : int32;
  expected_commitment : bool;
}

module CompareModule = Compare.Make (struct
  type nonrec t = t

  let compare {level = l1} {level = l2} = Raw_level_repr.compare l1 l2
end)

include CompareModule

type level = t

let pp ppf {level} = Raw_level_repr.pp ppf level

let pp_full ppf l =
  Format.fprintf
    ppf
    &quot;%a.%ld (cycle %a.%ld) (vote %a.%ld)&quot;
    Raw_level_repr.pp
    l.level
    l.level_position
    Cycle_repr.pp
    l.cycle
    l.cycle_position
    Voting_period_repr.pp
    l.voting_period
    l.voting_period_position

let encoding =
  let open Data_encoding in
  conv
    (fun { level;
           level_position;
           cycle;
           cycle_position;
           voting_period;
           voting_period_position;
           expected_commitment } -&gt;
      ( level,
        level_position,
        cycle,
        cycle_position,
        voting_period,
        voting_period_position,
        expected_commitment ))
    (fun ( level,
           level_position,
           cycle,
           cycle_position,
           voting_period,
           voting_period_position,
           expected_commitment ) -&gt;
      {
        level;
        level_position;
        cycle;
        cycle_position;
        voting_period;
        voting_period_position;
        expected_commitment;
      })
    (obj7
       (req
          &quot;level&quot;
          ~description:
            &quot;The level of the block relative to genesis. This is also the \
             Shell's notion of level&quot;
          Raw_level_repr.encoding)
       (req
          &quot;level_position&quot;
          ~description:
            &quot;The level of the block relative to the block that starts \
             protocol alpha. This is specific to the protocol alpha. Other \
             protocols might or might not include a similar notion.&quot;
          int32)
       (req
          &quot;cycle&quot;
          ~description:
            &quot;The current cycle's number. Note that cycles are a \
             protocol-specific notion. As a result, the cycle number starts \
             at 0 with the first block of protocol alpha.&quot;
          Cycle_repr.encoding)
       (req
          &quot;cycle_position&quot;
          ~description:
            &quot;The current level of the block relative to the first block of \
             the current cycle.&quot;
          int32)
       (req
          &quot;voting_period&quot;
          ~description:
            &quot;The current voting period's index. Note that cycles are a \
             protocol-specific notion. As a result, the voting period index \
             starts at 0 with the first block of protocol alpha.&quot;
          Voting_period_repr.encoding)
       (req
          &quot;voting_period_position&quot;
          ~description:
            &quot;The current level of the block relative to the first block of \
             the current voting period.&quot;
          int32)
       (req
          &quot;expected_commitment&quot;
          ~description:
            &quot;Tells wether the baker of this block has to commit a seed nonce \
             hash.&quot;
          bool))

let root_level first_level =
  {
    level = first_level;
    level_position = 0l;
    cycle = Cycle_repr.root;
    cycle_position = 0l;
    voting_period = Voting_period_repr.root;
    voting_period_position = 0l;
    expected_commitment = false;
  }

let from_raw_level ~first_level ~blocks_per_cycle ~blocks_per_voting_period
    ~blocks_per_commitment level =
  let raw_level = Raw_level_repr.to_int32 level in
  let first_level = Raw_level_repr.to_int32 first_level in
  let level_position =
    Compare.Int32.max 0l (Int32.sub raw_level first_level)
  in
  let cycle =
    Cycle_repr.of_int32_exn (Int32.div level_position blocks_per_cycle)
  in
  let cycle_position = Int32.rem level_position blocks_per_cycle in
  let voting_period =
    Voting_period_repr.of_int32_exn
      (Int32.div level_position blocks_per_voting_period)
  in
  let voting_period_position =
    Int32.rem level_position blocks_per_voting_period
  in
  let expected_commitment =
    Compare.Int32.(
      Int32.rem cycle_position blocks_per_commitment
      = Int32.pred blocks_per_commitment)
  in
  {
    level;
    level_position;
    cycle;
    cycle_position;
    voting_period;
    voting_period_position;
    expected_commitment;
  }

let diff {level = l1; _} {level = l2; _} =
  Int32.sub (Raw_level_repr.to_int32 l1) (Raw_level_repr.to_int32 l2)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#level_repr.ml"><code>Level_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Cycle_repr.
Require Tezos.Raw_level_repr.
Require Tezos.Voting_period_repr.

Module t.
  Record record : Set := Build {
    level : Raw_level_repr.t;
    level_position : int32;
    cycle : Cycle_repr.t;
    cycle_position : int32;
    voting_period : Voting_period_repr.t;
    voting_period_position : int32;
    expected_commitment : bool }.
  Definition with_level level (r : record) :=
    Build level r.(level_position) r.(cycle) r.(cycle_position)
      r.(voting_period) r.(voting_period_position) r.(expected_commitment).
  Definition with_level_position level_position (r : record) :=
    Build r.(level) level_position r.(cycle) r.(cycle_position)
      r.(voting_period) r.(voting_period_position) r.(expected_commitment).
  Definition with_cycle cycle (r : record) :=
    Build r.(level) r.(level_position) cycle r.(cycle_position)
      r.(voting_period) r.(voting_period_position) r.(expected_commitment).
  Definition with_cycle_position cycle_position (r : record) :=
    Build r.(level) r.(level_position) r.(cycle) cycle_position
      r.(voting_period) r.(voting_period_position) r.(expected_commitment).
  Definition with_voting_period voting_period (r : record) :=
    Build r.(level) r.(level_position) r.(cycle) r.(cycle_position)
      voting_period r.(voting_period_position) r.(expected_commitment).
  Definition with_voting_period_position voting_period_position (r : record) :=
    Build r.(level) r.(level_position) r.(cycle) r.(cycle_position)
      r.(voting_period) voting_period_position r.(expected_commitment).
  Definition with_expected_commitment expected_commitment (r : record) :=
    Build r.(level) r.(level_position) r.(cycle) r.(cycle_position)
      r.(voting_period) r.(voting_period_position) expected_commitment.
End t.
Definition t := t.record.

Definition CompareModule :=
  Compare.Make
    (let t : Set := t in
    let compare (function_parameter : t) : t -&gt; int :=
      let '{| t.level := l1 |} := function_parameter in
      fun function_parameter =&gt;
        let '{| t.level := l2 |} := function_parameter in
        Raw_level_repr.compare l1 l2 in
    existT (A := Set) _ _
      {|
        Compare.COMPARABLE.compare := compare
      |}).

Definition op_eq := (|CompareModule|).(Compare.S.op_eq).

Definition op_ltgt := (|CompareModule|).(Compare.S.op_ltgt).

Definition op_lt := (|CompareModule|).(Compare.S.op_lt).

Definition op_lteq := (|CompareModule|).(Compare.S.op_lteq).

Definition op_gteq := (|CompareModule|).(Compare.S.op_gteq).

Definition op_gt := (|CompareModule|).(Compare.S.op_gt).

Definition compare := (|CompareModule|).(Compare.S.compare).

Definition equal := (|CompareModule|).(Compare.S.equal).

Definition max := (|CompareModule|).(Compare.S.max).

Definition min := (|CompareModule|).(Compare.S.min).

Definition level : Set := t.

Definition pp (ppf : Format.formatter) (function_parameter : t) : unit :=
  let '{| t.level := level |} := function_parameter in
  Raw_level_repr.pp ppf level.

Definition pp_full (ppf : Format.formatter) (l : t) : unit :=
  Format.fprintf ppf
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.Alpha
        (CamlinternalFormatBasics.Char_literal &quot;.&quot; % char
          (CamlinternalFormatBasics.Int32 CamlinternalFormatBasics.Int_d
            CamlinternalFormatBasics.No_padding
            CamlinternalFormatBasics.No_precision
            (CamlinternalFormatBasics.String_literal &quot; (cycle &quot;
              (CamlinternalFormatBasics.Alpha
                (CamlinternalFormatBasics.Char_literal &quot;.&quot; % char
                  (CamlinternalFormatBasics.Int32 CamlinternalFormatBasics.Int_d
                    CamlinternalFormatBasics.No_padding
                    CamlinternalFormatBasics.No_precision
                    (CamlinternalFormatBasics.String_literal &quot;) (vote &quot;
                      (CamlinternalFormatBasics.Alpha
                        (CamlinternalFormatBasics.Char_literal &quot;.&quot; % char
                          (CamlinternalFormatBasics.Int32
                            CamlinternalFormatBasics.Int_d
                            CamlinternalFormatBasics.No_padding
                            CamlinternalFormatBasics.No_precision
                            (CamlinternalFormatBasics.Char_literal &quot;)&quot; % char
                              CamlinternalFormatBasics.End_of_format))))))))))))
      &quot;%a.%ld (cycle %a.%ld) (vote %a.%ld)&quot;) Raw_level_repr.pp l.(t.level)
    l.(t.level_position) Cycle_repr.pp l.(t.cycle) l.(t.cycle_position)
    Voting_period_repr.pp l.(t.voting_period) l.(t.voting_period_position).

Definition encoding : Data_encoding.encoding t :=
  Data_encoding.conv
    (fun function_parameter =&gt;
      let '{|
        t.level := level;
          t.level_position := level_position;
          t.cycle := cycle;
          t.cycle_position := cycle_position;
          t.voting_period := voting_period;
          t.voting_period_position := voting_period_position;
          t.expected_commitment := expected_commitment
          |} := function_parameter in
      (level, level_position, cycle, cycle_position, voting_period,
        voting_period_position, expected_commitment))
    (fun function_parameter =&gt;
      let
        '(level, level_position, cycle, cycle_position, voting_period,
          voting_period_position, expected_commitment) := function_parameter in
      {| t.level := level; t.level_position := level_position; t.cycle := cycle;
        t.cycle_position := cycle_position; t.voting_period := voting_period;
        t.voting_period_position := voting_period_position;
        t.expected_commitment := expected_commitment |}) None
    (Data_encoding.obj7
      (Data_encoding.req None
        (Some
          &quot;The level of the block relative to genesis. This is also the Shell's notion of level&quot;)
        &quot;level&quot; Raw_level_repr.encoding)
      (Data_encoding.req None
        (Some
          &quot;The level of the block relative to the block that starts protocol alpha. This is specific to the protocol alpha. Other protocols might or might not include a similar notion.&quot;)
        &quot;level_position&quot; Data_encoding.__int32_value)
      (Data_encoding.req None
        (Some
          &quot;The current cycle's number. Note that cycles are a protocol-specific notion. As a result, the cycle number starts at 0 with the first block of protocol alpha.&quot;)
        &quot;cycle&quot; Cycle_repr.encoding)
      (Data_encoding.req None
        (Some
          &quot;The current level of the block relative to the first block of the current cycle.&quot;)
        &quot;cycle_position&quot; Data_encoding.__int32_value)
      (Data_encoding.req None
        (Some
          &quot;The current voting period's index. Note that cycles are a protocol-specific notion. As a result, the voting period index starts at 0 with the first block of protocol alpha.&quot;)
        &quot;voting_period&quot; Voting_period_repr.encoding)
      (Data_encoding.req None
        (Some
          &quot;The current level of the block relative to the first block of the current voting period.&quot;)
        &quot;voting_period_position&quot; Data_encoding.__int32_value)
      (Data_encoding.req None
        (Some
          &quot;Tells wether the baker of this block has to commit a seed nonce hash.&quot;)
        &quot;expected_commitment&quot; Data_encoding.__bool_value)).

Definition root_level (first_level : Raw_level_repr.t) : t :=
  {| t.level := first_level;
    t.level_position :=
      (* ‚ùå Constant of type int32 is converted to int *)
      0; t.cycle := Cycle_repr.root;
    t.cycle_position :=
      (* ‚ùå Constant of type int32 is converted to int *)
      0; t.voting_period := Voting_period_repr.root;
    t.voting_period_position :=
      (* ‚ùå Constant of type int32 is converted to int *)
      0; t.expected_commitment := false |}.

Definition from_raw_level
  (first_level : Raw_level_repr.raw_level) (blocks_per_cycle : int32)
  (blocks_per_voting_period : int32) (blocks_per_commitment : int32)
  (level : Raw_level_repr.raw_level) : t :=
  let raw_level := Raw_level_repr.to_int32 level in
  let first_level := Raw_level_repr.to_int32 first_level in
  let level_position :=
    (|Compare.Int32|).(Compare.S.max)
      (* ‚ùå Constant of type int32 is converted to int *)
      0 (Int32.sub raw_level first_level) in
  let cycle :=
    Cycle_repr.of_int32_exn (Int32.div level_position blocks_per_cycle) in
  let cycle_position := Int32.rem level_position blocks_per_cycle in
  let voting_period :=
    Voting_period_repr.of_int32_exn
      (Int32.div level_position blocks_per_voting_period) in
  let voting_period_position :=
    Int32.rem level_position blocks_per_voting_period in
  let expected_commitment :=
    (|Compare.Int32|).(Compare.S.op_eq)
      (Int32.rem cycle_position blocks_per_commitment)
      (Int32.pred blocks_per_commitment) in
  {| t.level := level; t.level_position := level_position; t.cycle := cycle;
    t.cycle_position := cycle_position; t.voting_period := voting_period;
    t.voting_period_position := voting_period_position;
    t.expected_commitment := expected_commitment |}.

Definition diff (function_parameter : t) : t -&gt; int32 :=
  let '{| t.level := l1 |} := function_parameter in
  fun function_parameter =&gt;
    let '{| t.level := l2 |} := function_parameter in
    Int32.sub (Raw_level_repr.to_int32 l1) (Raw_level_repr.to_int32 l2).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="level_repr.mli">
  <div style="margin: 20px;">
    <h3>Level_repr_mli</h3>
    <ul>
      <li>OCaml size: 74 lines</li>
      <li>Coq size: 88 lines (+18% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#level_repr.mli"><code>level_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = private {
  level : Raw_level_repr.t;
      (** The level of the block relative to genesis. This
                              is also the Shell's notion of level. *)
  level_position : int32;
      (** The level of the block relative to the block that
                            starts protocol alpha. This is specific to the
                            protocol alpha. Other protocols might or might not
                            include a similar notion. *)
  cycle : Cycle_repr.t;
      (** The current cycle's number. Note that cycles are a
                          protocol-specific notion. As a result, the cycle
                          number starts at 0 with the first block of protocol
                          alpha. *)
  cycle_position : int32;
      (** The current level of the block relative to the first
                            block of the current cycle. *)
  voting_period : Voting_period_repr.t;
  voting_period_position : int32;
  expected_commitment : bool;
}

(* Note that, the type `t` above must respect some invariants (hence the
   `private` annotation). Notably:

   level_position = cycle * blocks_per_cycle + cycle_position
*)

type level = t

include Compare.S with type t := level

val encoding : level Data_encoding.t

val pp : Format.formatter -&gt; level -&gt; unit

val pp_full : Format.formatter -&gt; level -&gt; unit

val root_level : Raw_level_repr.t -&gt; level

val from_raw_level :
  first_level:Raw_level_repr.t -&gt;
  blocks_per_cycle:int32 -&gt;
  blocks_per_voting_period:int32 -&gt;
  blocks_per_commitment:int32 -&gt;
  Raw_level_repr.t -&gt;
  level

val diff : level -&gt; level -&gt; int32
</pre>
  </div>
  <div class="col-md-6">
    <a href="#level_repr.mli"><code>Level_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Cycle_repr.
Require Tezos.Raw_level_repr.
Require Tezos.Voting_period_repr.

Module t.
  Record record : Set := Build {
    level : Raw_level_repr.t;
    level_position : int32;
    cycle : Cycle_repr.t;
    cycle_position : int32;
    voting_period : Voting_period_repr.t;
    voting_period_position : int32;
    expected_commitment : bool }.
  Definition with_level level (r : record) :=
    Build level r.(level_position) r.(cycle) r.(cycle_position)
      r.(voting_period) r.(voting_period_position) r.(expected_commitment).
  Definition with_level_position level_position (r : record) :=
    Build r.(level) level_position r.(cycle) r.(cycle_position)
      r.(voting_period) r.(voting_period_position) r.(expected_commitment).
  Definition with_cycle cycle (r : record) :=
    Build r.(level) r.(level_position) cycle r.(cycle_position)
      r.(voting_period) r.(voting_period_position) r.(expected_commitment).
  Definition with_cycle_position cycle_position (r : record) :=
    Build r.(level) r.(level_position) r.(cycle) cycle_position
      r.(voting_period) r.(voting_period_position) r.(expected_commitment).
  Definition with_voting_period voting_period (r : record) :=
    Build r.(level) r.(level_position) r.(cycle) r.(cycle_position)
      voting_period r.(voting_period_position) r.(expected_commitment).
  Definition with_voting_period_position voting_period_position (r : record) :=
    Build r.(level) r.(level_position) r.(cycle) r.(cycle_position)
      r.(voting_period) voting_period_position r.(expected_commitment).
  Definition with_expected_commitment expected_commitment (r : record) :=
    Build r.(level) r.(level_position) r.(cycle) r.(cycle_position)
      r.(voting_period) r.(voting_period_position) expected_commitment.
End t.
Definition t := t.record.

Definition level : Set := t.

Parameter Included_S : {_ : unit &amp; Compare.S.signature (t := level)}.

Definition op_eq : level -&gt; level -&gt; bool := (|Included_S|).(Compare.S.op_eq).

Definition op_ltgt : level -&gt; level -&gt; bool :=
  (|Included_S|).(Compare.S.op_ltgt).

Definition op_lt : level -&gt; level -&gt; bool := (|Included_S|).(Compare.S.op_lt).

Definition op_lteq : level -&gt; level -&gt; bool :=
  (|Included_S|).(Compare.S.op_lteq).

Definition op_gteq : level -&gt; level -&gt; bool :=
  (|Included_S|).(Compare.S.op_gteq).

Definition op_gt : level -&gt; level -&gt; bool := (|Included_S|).(Compare.S.op_gt).

Definition compare : level -&gt; level -&gt; int :=
  (|Included_S|).(Compare.S.compare).

Definition equal : level -&gt; level -&gt; bool := (|Included_S|).(Compare.S.equal).

Definition max : level -&gt; level -&gt; level := (|Included_S|).(Compare.S.max).

Definition min : level -&gt; level -&gt; level := (|Included_S|).(Compare.S.min).

Parameter encoding : Data_encoding.t level.

Parameter pp : Format.formatter -&gt; level -&gt; unit.

Parameter pp_full : Format.formatter -&gt; level -&gt; unit.

Parameter root_level : Raw_level_repr.t -&gt; level.

Parameter from_raw_level :
  Raw_level_repr.t -&gt; int32 -&gt; int32 -&gt; int32 -&gt; Raw_level_repr.t -&gt; level.

Parameter diff : level -&gt; level -&gt; int32.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="level_storage.ml">
  <div style="margin: 20px;">
    <h3>Level_storage</h3>
    <ul>
      <li>OCaml size: 118 lines</li>
      <li>Coq size: 139 lines (+17% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#level_storage.ml"><code>level_storage.ml</code></a>&nbsp;<span class="label label-warning">2 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Level_repr

let from_raw c ?offset l =
  let l =
    match offset with
    | None -&gt;
        l
    | Some o -&gt;
        Raw_level_repr.(of_int32_exn (Int32.add (to_int32 l) o))
  in
  let constants = Raw_context.constants c in
  let first_level = Raw_context.first_level c in
  Level_repr.from_raw_level
    ~first_level
    ~blocks_per_cycle:constants.Constants_repr.blocks_per_cycle
    ~blocks_per_voting_period:constants.Constants_repr.blocks_per_voting_period
    ~blocks_per_commitment:constants.Constants_repr.blocks_per_commitment
    l

let root c = Level_repr.root_level (Raw_context.first_level c)

let succ c l = from_raw c (Raw_level_repr.succ l.level)

let pred c l =
  match Raw_level_repr.pred l.Level_repr.level with
  | None -&gt;
      None
  | Some l -&gt;
      Some (from_raw c l)

let current ctxt = Raw_context.current_level ctxt

let previous ctxt =
  let l = current ctxt in
  match pred ctxt l with
  | None -&gt;
      <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr> (* We never validate the Genesis... *)
  | Some p -&gt;
      p

let first_level_in_cycle ctxt c =
  let constants = Raw_context.constants ctxt in
  let first_level = Raw_context.first_level ctxt in
  from_raw
    ctxt
    (Raw_level_repr.of_int32_exn
       (Int32.add
          (Raw_level_repr.to_int32 first_level)
          (Int32.mul
             constants.Constants_repr.blocks_per_cycle
             (Cycle_repr.to_int32 c))))

let last_level_in_cycle ctxt c =
  match pred ctxt (first_level_in_cycle ctxt (Cycle_repr.succ c)) with
  | None -&gt;
      <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
  | Some x -&gt;
      x

let levels_in_cycle ctxt cycle =
  let first = first_level_in_cycle ctxt cycle in
  let rec loop n acc =
    if Cycle_repr.(n.cycle = first.cycle) then loop (succ ctxt n) (n :: acc)
    else acc
  in
  loop first []

let levels_in_current_cycle ctxt ?(offset = 0l) () =
  let current_cycle = Cycle_repr.to_int32 (current ctxt).cycle in
  let cycle = Int32.add current_cycle offset in
  if Compare.Int32.(cycle &lt; 0l) then []
  else
    let cycle = Cycle_repr.of_int32_exn cycle in
    levels_in_cycle ctxt cycle

let levels_with_commitments_in_cycle ctxt c =
  let first = first_level_in_cycle ctxt c in
  let rec loop n acc =
    if Cycle_repr.(n.cycle = first.cycle) then
      if n.expected_commitment then loop (succ ctxt n) (n :: acc)
      else loop (succ ctxt n) acc
    else acc
  in
  loop first []

let last_allowed_fork_level c =
  let level = Raw_context.current_level c in
  let preserved_cycles = Constants_storage.preserved_cycles c in
  match Cycle_repr.sub level.cycle preserved_cycles with
  | None -&gt;
      Raw_level_repr.root
  | Some cycle -&gt;
      (first_level_in_cycle c cycle).level
</pre>
  </div>
  <div class="col-md-6">
    <a href="#level_storage.ml"><code>Level_storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Constants_repr.
Require Tezos.Constants_storage.
Require Tezos.Cycle_repr.
Require Tezos.Level_repr.
Require Tezos.Raw_context.
Require Tezos.Raw_level_repr.

Import Level_repr.

Definition from_raw
  (c : Raw_context.context) (offset : option int32)
  (l : Raw_level_repr.raw_level) : Level_repr.level :=
  let l :=
    match offset with
    | None =&gt; l
    | Some o =&gt;
      Raw_level_repr.of_int32_exn (Int32.add (Raw_level_repr.to_int32 l) o)
    end in
  let constants := Raw_context.constants c in
  let first_level := Raw_context.first_level c in
  Level_repr.from_raw_level first_level
    constants.(Constants_repr.parametric.blocks_per_cycle)
    constants.(Constants_repr.parametric.blocks_per_voting_period)
    constants.(Constants_repr.parametric.blocks_per_commitment) l.

Definition root (c : Raw_context.context) : Level_repr.level :=
  Level_repr.root_level (Raw_context.first_level c).

Definition succ (c : Raw_context.context) (l : Level_repr.t)
  : Level_repr.level :=
  from_raw c None (Raw_level_repr.succ l.(Level_repr.t.level)).

Definition pred (c : Raw_context.context) (l : Level_repr.t)
  : option Level_repr.level :=
  match Raw_level_repr.pred l.(Level_repr.t.level) with
  | None =&gt; None
  | Some l =&gt; Some (from_raw c None l)
  end.

Definition current (ctxt : Raw_context.context) : Level_repr.t :=
  Raw_context.current_level ctxt.

Definition previous (ctxt : Raw_context.context) : Level_repr.level :=
  let l := current ctxt in
  match pred ctxt l with
  | None =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert Level_repr.level false
  | Some __p_value =&gt; __p_value
  end.

Definition first_level_in_cycle
  (ctxt : Raw_context.context) (c : Cycle_repr.cycle) : Level_repr.level :=
  let constants := Raw_context.constants ctxt in
  let first_level := Raw_context.first_level ctxt in
  from_raw ctxt None
    (Raw_level_repr.of_int32_exn
      (Int32.add (Raw_level_repr.to_int32 first_level)
        (Int32.mul constants.(Constants_repr.parametric.blocks_per_cycle)
          (Cycle_repr.to_int32 c)))).

Definition last_level_in_cycle
  (ctxt : Raw_context.context) (c : Cycle_repr.cycle) : Level_repr.level :=
  match pred ctxt (first_level_in_cycle ctxt (Cycle_repr.succ c)) with
  | None =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert Level_repr.level false
  | Some x =&gt; x
  end.

Definition levels_in_cycle
  (ctxt : Raw_context.context) (cycle : Cycle_repr.cycle) : list Level_repr.t :=
  let first := first_level_in_cycle ctxt cycle in
  let fix loop (n : Level_repr.t) (acc : list Level_repr.t) {struct n}
    : list Level_repr.t :=
    if Cycle_repr.op_eq n.(Level_repr.t.cycle) first.(Level_repr.t.cycle) then
      loop (succ ctxt n) (cons n acc)
    else
      acc in
  loop first nil.

Definition levels_in_current_cycle
  (ctxt : Raw_context.context) (op_staroptstar : option int32)
  : unit -&gt; list Level_repr.t :=
  let offset :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt;
      (* ‚ùå Constant of type int32 is converted to int *)
      0
    end in
  fun function_parameter =&gt;
    let '_ := function_parameter in
    let current_cycle := Cycle_repr.to_int32 (current ctxt).(Level_repr.t.cycle)
      in
    let cycle := Int32.add current_cycle offset in
    if
      (|Compare.Int32|).(Compare.S.op_lt) cycle
        (* ‚ùå Constant of type int32 is converted to int *)
        0 then
      nil
    else
      let cycle := Cycle_repr.of_int32_exn cycle in
      levels_in_cycle ctxt cycle.

Definition levels_with_commitments_in_cycle
  (ctxt : Raw_context.context) (c : Cycle_repr.cycle) : list Level_repr.t :=
  let first := first_level_in_cycle ctxt c in
  let fix loop (n : Level_repr.t) (acc : list Level_repr.t) {struct n}
    : list Level_repr.t :=
    if Cycle_repr.op_eq n.(Level_repr.t.cycle) first.(Level_repr.t.cycle) then
      if n.(Level_repr.t.expected_commitment) then
        loop (succ ctxt n) (cons n acc)
      else
        loop (succ ctxt n) acc
    else
      acc in
  loop first nil.

Definition last_allowed_fork_level (c : Raw_context.context)
  : Raw_level_repr.raw_level :=
  let level := Raw_context.current_level c in
  let preserved_cycles := Constants_storage.preserved_cycles c in
  match Cycle_repr.sub level.(Level_repr.t.cycle) preserved_cycles with
  | None =&gt; Raw_level_repr.root
  | Some cycle =&gt; (first_level_in_cycle c cycle).(Level_repr.t.level)
  end.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="level_storage.mli">
  <div style="margin: 20px;">
    <h3>Level_storage_mli</h3>
    <ul>
      <li>OCaml size: 51 lines</li>
      <li>Coq size: 42 lines (-18% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#level_storage.mli"><code>level_storage.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

val current : Raw_context.t -&gt; Level_repr.t

val previous : Raw_context.t -&gt; Level_repr.t

val root : Raw_context.t -&gt; Level_repr.t

val from_raw :
  Raw_context.t -&gt; ?offset:int32 -&gt; Raw_level_repr.t -&gt; Level_repr.t

val pred : Raw_context.t -&gt; Level_repr.t -&gt; Level_repr.t option

val succ : Raw_context.t -&gt; Level_repr.t -&gt; Level_repr.t

val first_level_in_cycle : Raw_context.t -&gt; Cycle_repr.t -&gt; Level_repr.t

val last_level_in_cycle : Raw_context.t -&gt; Cycle_repr.t -&gt; Level_repr.t

val levels_in_cycle : Raw_context.t -&gt; Cycle_repr.t -&gt; Level_repr.t list

val levels_in_current_cycle :
  Raw_context.t -&gt; ?offset:int32 -&gt; unit -&gt; Level_repr.t list

val levels_with_commitments_in_cycle :
  Raw_context.t -&gt; Cycle_repr.t -&gt; Level_repr.t list

val last_allowed_fork_level : Raw_context.t -&gt; Raw_level_repr.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#level_storage.mli"><code>Level_storage_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Cycle_repr.
Require Tezos.Level_repr.
Require Tezos.Raw_context.
Require Tezos.Raw_level_repr.

Parameter current : Raw_context.t -&gt; Level_repr.t.

Parameter previous : Raw_context.t -&gt; Level_repr.t.

Parameter root : Raw_context.t -&gt; Level_repr.t.

Parameter from_raw :
  Raw_context.t -&gt; option int32 -&gt; Raw_level_repr.t -&gt; Level_repr.t.

Parameter pred : Raw_context.t -&gt; Level_repr.t -&gt; option Level_repr.t.

Parameter succ : Raw_context.t -&gt; Level_repr.t -&gt; Level_repr.t.

Parameter first_level_in_cycle : Raw_context.t -&gt; Cycle_repr.t -&gt; Level_repr.t.

Parameter last_level_in_cycle : Raw_context.t -&gt; Cycle_repr.t -&gt; Level_repr.t.

Parameter levels_in_cycle : Raw_context.t -&gt; Cycle_repr.t -&gt; list Level_repr.t.

Parameter levels_in_current_cycle :
  Raw_context.t -&gt; option int32 -&gt; unit -&gt; list Level_repr.t.

Parameter levels_with_commitments_in_cycle :
  Raw_context.t -&gt; Cycle_repr.t -&gt; list Level_repr.t.

Parameter last_allowed_fork_level : Raw_context.t -&gt; Raw_level_repr.t.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="main.ml">
  <div style="margin: 20px;">
    <h3>Main</h3>
    <ul>
      <li>OCaml size: 376 lines</li>
      <li>Coq size: 604 lines (+60% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#main.ml"><code>main.ml</code></a>&nbsp;<span class="label label-warning">3 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(* Tezos Protocol Implementation - Protocol Signature Instance *)

type block_header_data = Alpha_context.Block_header.protocol_data

let block_header_data_encoding =
  Alpha_context.Block_header.protocol_data_encoding

type block_header_metadata = Apply_results.block_metadata

let block_header_metadata_encoding = Apply_results.block_metadata_encoding

type operation_data = Alpha_context.packed_protocol_data

let operation_data_encoding = Alpha_context.Operation.protocol_data_encoding

type operation_receipt = Apply_results.packed_operation_metadata

let operation_receipt_encoding = Apply_results.operation_metadata_encoding

let operation_data_and_receipt_encoding =
  Apply_results.operation_data_and_metadata_encoding

let acceptable_passes = Alpha_context.Operation.acceptable_passes

let max_block_length = Alpha_context.Block_header.max_header_length

let max_operation_data_length =
  Alpha_context.Constants.max_operation_data_length

let validation_passes =
  let max_anonymous_operations =
    Alpha_context.Constants.max_revelations_per_block
    + (* allow 100 wallet activations or denunciations per block *) 100
  in
  Updater.
    [ {max_size = 32 * 1024; max_op = Some 32};
      (* 32 endorsements *)
      {max_size = 32 * 1024; max_op = None};
      (* 32k of voting operations *)
      {
        max_size = max_anonymous_operations * 1024;
        max_op = Some max_anonymous_operations;
      };
      {max_size = 512 * 1024; max_op = None} ]

(* 512kB *)

let rpc_services =
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Alpha_services.register ()</abbr> ;
  Services_registration.get_rpc_services ()

type validation_mode =
  | Application of {
      block_header : Alpha_context.Block_header.block_header;
      baker : Alpha_context.public_key_hash;
      block_delay : Alpha_context.Period.t;
    }
  | Partial_application of {
      block_header : Alpha_context.Block_header.block_header;
      baker : Alpha_context.public_key_hash;
      block_delay : Alpha_context.Period.t;
    }
  | Partial_construction of {predecessor : Block_hash.t}
  | Full_construction of {
      predecessor : Block_hash.t;
      protocol_data : Alpha_context.Block_header.contents;
      baker : Alpha_context.public_key_hash;
      block_delay : Alpha_context.Period.t;
    }

type validation_state = {
  mode : validation_mode;
  chain_id : Chain_id.t;
  ctxt : Alpha_context.t;
  op_count : int;
}

let current_context {ctxt; _} = return (Alpha_context.finalize ctxt).context

let begin_partial_application ~chain_id ~ancestor_context:ctxt
    ~predecessor_timestamp ~predecessor_fitness
    (block_header : Alpha_context.Block_header.block_header) =
  let {Alpha_context.Block_header.shell; _} = block_header in
  let level = shell.level in
  let fitness = predecessor_fitness in
  let timestamp = shell.timestamp in
  Alpha_context.prepare ~level ~predecessor_timestamp ~timestamp ~fitness ctxt
  &gt;&gt;=? fun ctxt -&gt;
  Apply.begin_application ctxt chain_id block_header predecessor_timestamp
  &gt;&gt;=? fun (ctxt, baker, block_delay) -&gt;
  let mode =
    Partial_application
      {block_header; baker = Signature.Public_key.hash baker; block_delay}
  in
  return {mode; chain_id; ctxt; op_count = 0}

let begin_application ~chain_id ~predecessor_context:ctxt
    ~predecessor_timestamp ~predecessor_fitness
    (block_header : Alpha_context.Block_header.block_header) =
  let {Alpha_context.Block_header.shell; _} = block_header in
  let level = shell.level in
  let fitness = predecessor_fitness in
  let timestamp = shell.timestamp in
  Alpha_context.prepare ~level ~predecessor_timestamp ~timestamp ~fitness ctxt
  &gt;&gt;=? fun ctxt -&gt;
  Apply.begin_application ctxt chain_id block_header predecessor_timestamp
  &gt;&gt;=? fun (ctxt, baker, block_delay) -&gt;
  let mode =
    Application
      {block_header; baker = Signature.Public_key.hash baker; block_delay}
  in
  return {mode; chain_id; ctxt; op_count = 0}

let begin_construction ~chain_id ~predecessor_context:ctxt
    ~predecessor_timestamp ~predecessor_level:pred_level
    ~predecessor_fitness:pred_fitness ~predecessor ~timestamp
    ?(protocol_data : block_header_data option) () =
  let level = Int32.succ pred_level in
  let fitness = pred_fitness in
  Alpha_context.prepare ~level ~predecessor_timestamp ~timestamp ~fitness ctxt
  &gt;&gt;=? fun ctxt -&gt;
  ( match protocol_data with
  | None -&gt;
      Apply.begin_partial_construction ctxt
      &gt;&gt;=? fun ctxt -&gt;
      let mode = Partial_construction {predecessor} in
      return (mode, ctxt)
  | Some proto_header -&gt;
      Apply.begin_full_construction
        ctxt
        predecessor_timestamp
        proto_header.contents
      &gt;&gt;=? fun (ctxt, protocol_data, baker, block_delay) -&gt;
      let mode =
        let baker = Signature.Public_key.hash baker in
        Full_construction {predecessor; baker; protocol_data; block_delay}
      in
      return (mode, ctxt) )
  &gt;&gt;=? fun (mode, ctxt) -&gt; return {mode; chain_id; ctxt; op_count = 0}

let apply_operation ({mode; chain_id; ctxt; op_count; _} as data)
    (operation : Alpha_context.packed_operation) =
  match mode with
  | Partial_application _
    when not
           (List.exists
              (Compare.Int.equal 0)
              (Alpha_context.Operation.acceptable_passes operation)) -&gt;
      (* Multipass validation only considers operations in pass 0. *)
      let op_count = op_count + 1 in
      return ({data with ctxt; op_count}, Apply_results.No_operation_metadata)
  | _ -&gt;
      let {shell; protocol_data = Operation_data protocol_data} = operation in
      let operation : _ Alpha_context.operation = {shell; protocol_data} in
      let (predecessor, baker) =
        match mode with
        | Partial_application
            {block_header = {shell = {predecessor; _}; _}; baker}
        | Application {block_header = {shell = {predecessor; _}; _}; baker}
        | Full_construction {predecessor; baker; _} -&gt;
            (predecessor, baker)
        | Partial_construction {predecessor} -&gt;
            (predecessor, Signature.Public_key_hash.zero)
      in
      Apply.apply_operation
        ctxt
        chain_id
        Optimized
        predecessor
        baker
        (Alpha_context.Operation.hash operation)
        operation
      &gt;&gt;=? fun (ctxt, result) -&gt;
      let op_count = op_count + 1 in
      return
        ({data with ctxt; op_count}, Apply_results.Operation_metadata result)

let finalize_block {mode; ctxt; op_count} =
  match mode with
  | Partial_construction _ -&gt;
      let level = Alpha_context.Level.current ctxt in
      Alpha_context.Vote.get_current_period_kind ctxt
      &gt;&gt;=? fun voting_period_kind -&gt;
      let baker = Signature.Public_key_hash.zero in
      Signature.Public_key_hash.Map.fold
        (fun delegate deposit ctxt -&gt;
          ctxt
          &gt;&gt;=? fun ctxt -&gt;
          Alpha_context.Delegate.freeze_deposit ctxt delegate deposit)
        (Alpha_context.get_deposits ctxt)
        (return ctxt)
      &gt;&gt;=? fun ctxt -&gt;
      let ctxt = Alpha_context.finalize ctxt in
      return
        ( ctxt,
          Apply_results.
            {
              baker;
              level;
              voting_period_kind;
              nonce_hash = None;
              consumed_gas = Z.zero;
              deactivated = [];
              balance_updates = [];
            } )
  | Partial_application {block_header; baker; block_delay} -&gt;
      let level = Alpha_context.Level.current ctxt in
      let included_endorsements = Alpha_context.included_endorsements ctxt in
      Apply.check_minimum_endorsements
        ctxt
        block_header.protocol_data.contents
        block_delay
        included_endorsements
      &gt;&gt;=? fun () -&gt;
      Alpha_context.Vote.get_current_period_kind ctxt
      &gt;&gt;=? fun voting_period_kind -&gt;
      let ctxt = Alpha_context.finalize ctxt in
      return
        ( ctxt,
          Apply_results.
            {
              baker;
              level;
              voting_period_kind;
              nonce_hash = None;
              consumed_gas = Z.zero;
              deactivated = [];
              balance_updates = [];
            } )
  | Application
      { baker;
        block_delay;
        block_header = {protocol_data = {contents = protocol_data; _}; _} }
  | Full_construction {protocol_data; baker; block_delay; _} -&gt;
      Apply.finalize_application ctxt protocol_data baker ~block_delay
      &gt;&gt;=? fun (ctxt, receipt) -&gt;
      let level = Alpha_context.Level.current ctxt in
      let priority = protocol_data.priority in
      let raw_level = Alpha_context.Raw_level.to_int32 level.level in
      let fitness = Alpha_context.Fitness.current ctxt in
      let commit_message =
        Format.asprintf
          &quot;lvl %ld, fit 1:%Ld, prio %d, %d ops&quot;
          raw_level
          fitness
          priority
          op_count
      in
      let ctxt = Alpha_context.finalize ~commit_message ctxt in
      return (ctxt, receipt)

let compare_operations op1 op2 =
  let open Alpha_context in
  let (Operation_data op1) = op1.protocol_data in
  let (Operation_data op2) = op2.protocol_data in
  match[@coq_match_with_default] (op1.contents, op2.contents) with
  | (Single (Endorsement _), Single (Endorsement _)) -&gt;
      0
  | (_, Single (Endorsement _)) -&gt;
      1
  | (Single (Endorsement _), _) -&gt;
      -1
  | (Single (Seed_nonce_revelation _), Single (Seed_nonce_revelation _)) -&gt;
      0
  | (_, Single (Seed_nonce_revelation _)) -&gt;
      1
  | (Single (Seed_nonce_revelation _), _) -&gt;
      -1
  | ( Single (Double_endorsement_evidence _),
      Single (Double_endorsement_evidence _) ) -&gt;
      0
  | (_, Single (Double_endorsement_evidence _)) -&gt;
      1
  | (Single (Double_endorsement_evidence _), _) -&gt;
      -1
  | (Single (Double_baking_evidence _), Single (Double_baking_evidence _)) -&gt;
      0
  | (_, Single (Double_baking_evidence _)) -&gt;
      1
  | (Single (Double_baking_evidence _), _) -&gt;
      -1
  | (Single (Activate_account _), Single (Activate_account _)) -&gt;
      0
  | (_, Single (Activate_account _)) -&gt;
      1
  | (Single (Activate_account _), _) -&gt;
      -1
  | (Single (Proposals _), Single (Proposals _)) -&gt;
      0
  | (_, Single (Proposals _)) -&gt;
      1
  | (Single (Proposals _), _) -&gt;
      -1
  | (Single (Ballot _), Single (Ballot _)) -&gt;
      0
  | (_, Single (Ballot _)) -&gt;
      1
  | (Single (Ballot _), _) -&gt;
      -1
  (* Manager operations with smaller counter are pre-validated first. *)
  | (Single (Manager_operation op1), Single (Manager_operation op2)) -&gt;
      Z.compare op1.counter op2.counter
  | (Cons (Manager_operation op1, _), Single (Manager_operation op2)) -&gt;
      Z.compare op1.counter op2.counter
  | (Single (Manager_operation op1), Cons (Manager_operation op2, _)) -&gt;
      Z.compare op1.counter op2.counter
  | (Cons (Manager_operation op1, _), Cons (Manager_operation op2, _)) -&gt;
      Z.compare op1.counter op2.counter

let init ctxt block_header =
  let level = block_header.Block_header.level in
  let fitness = block_header.fitness in
  let timestamp = block_header.timestamp in
  let typecheck (ctxt : Alpha_context.context)
      (script : Alpha_context.Script.t) =
    Script_ir_translator.parse_script ctxt ~legacy:false script
    &gt;&gt;=? fun (Ex_script parsed_script, ctxt) -&gt;
    Script_ir_translator.extract_big_map_diff
      ctxt
      Optimized
      parsed_script.storage_type
      parsed_script.storage
      ~to_duplicate:Script_ir_translator.no_big_map_id
      ~to_update:Script_ir_translator.no_big_map_id
      ~temporary:false
    &gt;&gt;=? fun (storage, big_map_diff, ctxt) -&gt;
    Script_ir_translator.unparse_data
      ctxt
      Optimized
      parsed_script.storage_type
      storage
    &gt;&gt;=? fun (storage, ctxt) -&gt;
    let storage =
      Alpha_context.Script.lazy_expr (Micheline.strip_locations storage)
    in
    return (({script with storage}, big_map_diff), ctxt)
  in
  Alpha_context.prepare_first_block ~typecheck ~level ~timestamp ~fitness ctxt
  &gt;&gt;=? fun ctxt -&gt; return (Alpha_context.finalize ctxt)

<abbr class="mark-warning" title="We do not handle types with both a synonym and a type definition">type operation = Alpha_context.packed_operation = {
  shell : Operation.shell_header;
  protocol_data : operation_data;
}</abbr>

<abbr class="mark-warning" title="We do not handle types with both a synonym and a type definition">type block_header = Alpha_context.Block_header.block_header = {
  shell : Block_header.shell_header;
  protocol_data : block_header_data;
}</abbr>

(* Vanity nonce: 313282890 *)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#main.ml"><code>Main.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Apply.
Require Tezos.Apply_results.
Require Tezos.Block_header_repr.
Require Tezos.Script_ir_translator.
Require Tezos.Script_typed_ir.
Require Tezos.Services_registration.

Definition block_header_data : Set := Alpha_context.Block_header.protocol_data.

Definition block_header_data_encoding
  : Data_encoding.encoding Alpha_context.Block_header.protocol_data :=
  Alpha_context.Block_header.protocol_data_encoding.

Definition block_header_metadata : Set := Apply_results.block_metadata.

Definition block_header_metadata_encoding
  : Data_encoding.encoding Apply_results.block_metadata :=
  Apply_results.block_metadata_encoding.

Definition operation_data : Set := Alpha_context.packed_protocol_data.

Definition operation_data_encoding
  : Data_encoding.t Alpha_context.Operation.packed_protocol_data :=
  Alpha_context.Operation.protocol_data_encoding.

Definition operation_receipt : Set := Apply_results.packed_operation_metadata.

Definition operation_receipt_encoding
  : Data_encoding.t Apply_results.packed_operation_metadata :=
  Apply_results.operation_metadata_encoding.

Definition operation_data_and_receipt_encoding
  : Data_encoding.t
    (Alpha_context.Operation.packed_protocol_data *
      Apply_results.packed_operation_metadata) :=
  Apply_results.operation_data_and_metadata_encoding.

Definition acceptable_passes : Alpha_context.packed_operation -&gt; list int :=
  Alpha_context.Operation.acceptable_passes.

Definition max_block_length : int :=
  Alpha_context.Block_header.max_header_length.

Definition max_operation_data_length : int :=
  Alpha_context.Constants.max_operation_data_length.

Definition validation_passes : list Updater.quota :=
  let max_anonymous_operations :=
    Pervasives.op_plus Alpha_context.Constants.max_revelations_per_block 100 in
  [
    {| Updater.quota.max_size := Pervasives.op_star 32 1024;
      Updater.quota.max_op := Some 32 |};
    {| Updater.quota.max_size := Pervasives.op_star 32 1024;
      Updater.quota.max_op := None |};
    {|
      Updater.quota.max_size := Pervasives.op_star max_anonymous_operations 1024;
      Updater.quota.max_op := Some max_anonymous_operations |};
    {| Updater.quota.max_size := Pervasives.op_star 512 1024;
      Updater.quota.max_op := None |}
  ].

Definition rpc_services : RPC_directory.directory Updater.rpc_context :=
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  Services_registration.get_rpc_services tt.

Module ConstructorRecords_validation_mode.
  Module validation_mode.
    Module Application.
      Record record {block_header baker block_delay : Set} : Set := Build {
        block_header : block_header;
        baker : baker;
        block_delay : block_delay }.
      Arguments record : clear implicits.
      Definition with_block_header {t_block_header t_baker t_block_delay}
        block_header (r : record t_block_header t_baker t_block_delay) :=
        Build t_block_header t_baker t_block_delay block_header r.(baker)
          r.(block_delay).
      Definition with_baker {t_block_header t_baker t_block_delay} baker
        (r : record t_block_header t_baker t_block_delay) :=
        Build t_block_header t_baker t_block_delay r.(block_header) baker
          r.(block_delay).
      Definition with_block_delay {t_block_header t_baker t_block_delay}
        block_delay (r : record t_block_header t_baker t_block_delay) :=
        Build t_block_header t_baker t_block_delay r.(block_header) r.(baker)
          block_delay.
    End Application.
    Definition Application_skeleton := Application.record.
    
    Module Partial_application.
      Record record {block_header baker block_delay : Set} : Set := Build {
        block_header : block_header;
        baker : baker;
        block_delay : block_delay }.
      Arguments record : clear implicits.
      Definition with_block_header {t_block_header t_baker t_block_delay}
        block_header (r : record t_block_header t_baker t_block_delay) :=
        Build t_block_header t_baker t_block_delay block_header r.(baker)
          r.(block_delay).
      Definition with_baker {t_block_header t_baker t_block_delay} baker
        (r : record t_block_header t_baker t_block_delay) :=
        Build t_block_header t_baker t_block_delay r.(block_header) baker
          r.(block_delay).
      Definition with_block_delay {t_block_header t_baker t_block_delay}
        block_delay (r : record t_block_header t_baker t_block_delay) :=
        Build t_block_header t_baker t_block_delay r.(block_header) r.(baker)
          block_delay.
    End Partial_application.
    Definition Partial_application_skeleton := Partial_application.record.
    
    Module Partial_construction.
      Record record {predecessor : Set} : Set := Build {
        predecessor : predecessor }.
      Arguments record : clear implicits.
      Definition with_predecessor {t_predecessor} predecessor
        (r : record t_predecessor) :=
        Build t_predecessor predecessor.
    End Partial_construction.
    Definition Partial_construction_skeleton := Partial_construction.record.
    
    Module Full_construction.
      Record record {predecessor protocol_data baker block_delay : Set} : Set := Build {
        predecessor : predecessor;
        protocol_data : protocol_data;
        baker : baker;
        block_delay : block_delay }.
      Arguments record : clear implicits.
      Definition with_predecessor
        {t_predecessor t_protocol_data t_baker t_block_delay} predecessor
        (r : record t_predecessor t_protocol_data t_baker t_block_delay) :=
        Build t_predecessor t_protocol_data t_baker t_block_delay predecessor
          r.(protocol_data) r.(baker) r.(block_delay).
      Definition with_protocol_data
        {t_predecessor t_protocol_data t_baker t_block_delay} protocol_data
        (r : record t_predecessor t_protocol_data t_baker t_block_delay) :=
        Build t_predecessor t_protocol_data t_baker t_block_delay
          r.(predecessor) protocol_data r.(baker) r.(block_delay).
      Definition with_baker
        {t_predecessor t_protocol_data t_baker t_block_delay} baker
        (r : record t_predecessor t_protocol_data t_baker t_block_delay) :=
        Build t_predecessor t_protocol_data t_baker t_block_delay
          r.(predecessor) r.(protocol_data) baker r.(block_delay).
      Definition with_block_delay
        {t_predecessor t_protocol_data t_baker t_block_delay} block_delay
        (r : record t_predecessor t_protocol_data t_baker t_block_delay) :=
        Build t_predecessor t_protocol_data t_baker t_block_delay
          r.(predecessor) r.(protocol_data) r.(baker) block_delay.
    End Full_construction.
    Definition Full_construction_skeleton := Full_construction.record.
  End validation_mode.
End ConstructorRecords_validation_mode.
Import ConstructorRecords_validation_mode.

Reserved Notation &quot;'validation_mode.Application&quot;.
Reserved Notation &quot;'validation_mode.Partial_application&quot;.
Reserved Notation &quot;'validation_mode.Partial_construction&quot;.
Reserved Notation &quot;'validation_mode.Full_construction&quot;.

Inductive validation_mode : Set :=
| Application : 'validation_mode.Application -&gt; validation_mode
| Partial_application : 'validation_mode.Partial_application -&gt; validation_mode
| Partial_construction :
  'validation_mode.Partial_construction -&gt; validation_mode
| Full_construction : 'validation_mode.Full_construction -&gt; validation_mode

where &quot;'validation_mode.Application&quot; :=
  (validation_mode.Application_skeleton Alpha_context.Block_header.block_header
    Alpha_context.public_key_hash Alpha_context.Period.t)
and &quot;'validation_mode.Partial_application&quot; :=
  (validation_mode.Partial_application_skeleton
    Alpha_context.Block_header.block_header Alpha_context.public_key_hash
    Alpha_context.Period.t)
and &quot;'validation_mode.Partial_construction&quot; :=
  (validation_mode.Partial_construction_skeleton (|Block_hash|).(S.HASH.t))
and &quot;'validation_mode.Full_construction&quot; :=
  (validation_mode.Full_construction_skeleton (|Block_hash|).(S.HASH.t)
    Alpha_context.Block_header.contents Alpha_context.public_key_hash
    Alpha_context.Period.t).

Module validation_mode.
  Include ConstructorRecords_validation_mode.validation_mode.
  Definition Application := 'validation_mode.Application.
  Definition Partial_application := 'validation_mode.Partial_application.
  Definition Partial_construction := 'validation_mode.Partial_construction.
  Definition Full_construction := 'validation_mode.Full_construction.
End validation_mode.

Module validation_state.
  Record record : Set := Build {
    mode : validation_mode;
    chain_id : (|Chain_id|).(S.HASH.t);
    ctxt : Alpha_context.t;
    op_count : int }.
  Definition with_mode mode (r : record) :=
    Build mode r.(chain_id) r.(ctxt) r.(op_count).
  Definition with_chain_id chain_id (r : record) :=
    Build r.(mode) chain_id r.(ctxt) r.(op_count).
  Definition with_ctxt ctxt (r : record) :=
    Build r.(mode) r.(chain_id) ctxt r.(op_count).
  Definition with_op_count op_count (r : record) :=
    Build r.(mode) r.(chain_id) r.(ctxt) op_count.
End validation_state.
Definition validation_state := validation_state.record.

Definition current_context (function_parameter : validation_state)
  : Lwt.t (Error_monad.tzresult Context.t) :=
  let '{| validation_state.ctxt := ctxt |} := function_parameter in
  Error_monad.__return
    (Alpha_context.finalize None ctxt).(Updater.validation_result.context).

Definition begin_partial_application
  (chain_id : (|Chain_id|).(S.HASH.t)) (ctxt : Context.t)
  (predecessor_timestamp : Time.t)
  (predecessor_fitness : Alpha_context.Fitness.t)
  (block_header : Alpha_context.Block_header.block_header)
  : Lwt.t (Error_monad.tzresult validation_state) :=
  let '{| Alpha_context.Block_header.block_header.shell := shell |} :=
    block_header in
  let level := shell.(Block_header.shell_header.level) in
  let fitness := predecessor_fitness in
  let timestamp := shell.(Block_header.shell_header.timestamp) in
  let=? ctxt :=
    Alpha_context.prepare ctxt level predecessor_timestamp timestamp fitness in
  let=? '(ctxt, baker, block_delay) :=
    Apply.begin_application ctxt chain_id block_header predecessor_timestamp in
  let mode :=
    Partial_application
      {| validation_mode.Partial_application.block_header := block_header;
        validation_mode.Partial_application.baker :=
          (|Signature.Public_key|).(S.SPublic_key.__hash_value) baker;
        validation_mode.Partial_application.block_delay := block_delay |} in
  Error_monad.__return
    {| validation_state.mode := mode; validation_state.chain_id := chain_id;
      validation_state.ctxt := ctxt; validation_state.op_count := 0 |}.

Definition begin_application
  (chain_id : (|Chain_id|).(S.HASH.t)) (ctxt : Context.t)
  (predecessor_timestamp : Time.t)
  (predecessor_fitness : Alpha_context.Fitness.t)
  (block_header : Alpha_context.Block_header.block_header)
  : Lwt.t (Error_monad.tzresult validation_state) :=
  let '{| Alpha_context.Block_header.block_header.shell := shell |} :=
    block_header in
  let level := shell.(Block_header.shell_header.level) in
  let fitness := predecessor_fitness in
  let timestamp := shell.(Block_header.shell_header.timestamp) in
  let=? ctxt :=
    Alpha_context.prepare ctxt level predecessor_timestamp timestamp fitness in
  let=? '(ctxt, baker, block_delay) :=
    Apply.begin_application ctxt chain_id block_header predecessor_timestamp in
  let mode :=
    Application
      {| validation_mode.Application.block_header := block_header;
        validation_mode.Application.baker :=
          (|Signature.Public_key|).(S.SPublic_key.__hash_value) baker;
        validation_mode.Application.block_delay := block_delay |} in
  Error_monad.__return
    {| validation_state.mode := mode; validation_state.chain_id := chain_id;
      validation_state.ctxt := ctxt; validation_state.op_count := 0 |}.

Definition begin_construction
  (chain_id : (|Chain_id|).(S.HASH.t)) (ctxt : Context.t)
  (predecessor_timestamp : Time.t) (pred_level : int32)
  (pred_fitness : Alpha_context.Fitness.t)
  (predecessor : (|Block_hash|).(S.HASH.t)) (timestamp : Time.t)
  (protocol_data : option block_header_data) (function_parameter : unit)
  : Lwt.t (Error_monad.tzresult validation_state) :=
  let '_ := function_parameter in
  let level := Int32.succ pred_level in
  let fitness := pred_fitness in
  let=? ctxt :=
    Alpha_context.prepare ctxt level predecessor_timestamp timestamp fitness in
  let=? '(mode, ctxt) :=
    match protocol_data with
    | None =&gt;
      let=? ctxt := Apply.begin_partial_construction ctxt in
      let mode :=
        Partial_construction
          {| validation_mode.Partial_construction.predecessor := predecessor |}
        in
      Error_monad.__return (mode, ctxt)
    | Some proto_header =&gt;
      let=? '(ctxt, protocol_data, baker, block_delay) :=
        Apply.begin_full_construction ctxt predecessor_timestamp
          proto_header.(Alpha_context.Block_header.protocol_data.contents) in
      let mode :=
        let baker := (|Signature.Public_key|).(S.SPublic_key.__hash_value) baker
          in
        Full_construction
          {| validation_mode.Full_construction.predecessor := predecessor;
            validation_mode.Full_construction.protocol_data := protocol_data;
            validation_mode.Full_construction.baker := baker;
            validation_mode.Full_construction.block_delay := block_delay |} in
      Error_monad.__return (mode, ctxt)
    end in
  Error_monad.__return
    {| validation_state.mode := mode; validation_state.chain_id := chain_id;
      validation_state.ctxt := ctxt; validation_state.op_count := 0 |}.

Definition apply_operation (function_parameter : validation_state)
  : Alpha_context.packed_operation -&gt;
  Lwt.t
    (Error_monad.tzresult
      (validation_state * Apply_results.packed_operation_metadata)) :=
  let
    '{|
      validation_state.mode := mode;
        validation_state.chain_id := chain_id;
        validation_state.ctxt := ctxt;
        validation_state.op_count := op_count
        |} as data := function_parameter in
  fun operation =&gt;
    match
      (mode,
        match mode with
        | Partial_application _ =&gt;
          Pervasives.not
            (List.__exists ((|Compare.Int|).(Compare.S.equal) 0)
              (Alpha_context.Operation.acceptable_passes operation))
        | _ =&gt; false
        end) with
    | (Partial_application _, true) =&gt;
      let op_count := Pervasives.op_plus op_count 1 in
      Error_monad.__return
        ((validation_state.with_op_count op_count
          (validation_state.with_ctxt ctxt data)),
          Apply_results.No_operation_metadata)
    | (_, _) =&gt;
      let '{|
        Alpha_context.packed_operation.shell := shell;
          Alpha_context.packed_operation.protocol_data :=
            Alpha_context.Operation_data protocol_data
          |} := operation in
      let operation :=
        {| Alpha_context.operation.shell := shell;
          Alpha_context.operation.protocol_data := protocol_data |} in
      let '(predecessor, baker) :=
        match mode with
        |
          (Partial_application {|
            validation_mode.Partial_application.block_header := {|
              Alpha_context.Block_header.block_header.shell := {|
                Block_header.shell_header.predecessor := predecessor
                  |}
                |};
              validation_mode.Partial_application.baker := baker
              |} |
          Application {|
            validation_mode.Application.block_header := {|
              Alpha_context.Block_header.block_header.shell := {|
                Block_header.shell_header.predecessor := predecessor
                  |}
                |};
              validation_mode.Application.baker := baker
              |} |
          Full_construction {|
            validation_mode.Full_construction.predecessor := predecessor;
              validation_mode.Full_construction.baker := baker
              |}) =&gt; (predecessor, baker)
        |
          Partial_construction {|
            validation_mode.Partial_construction.predecessor := predecessor
              |} =&gt;
          (predecessor, (|Signature.Public_key_hash|).(S.SPublic_key_hash.zero))
        end in
      let=? '(ctxt, __result_value) :=
        Apply.apply_operation ctxt chain_id Script_ir_translator.Optimized
          predecessor baker (Alpha_context.Operation.__hash_value operation)
          operation in
      let op_count := Pervasives.op_plus op_count 1 in
      Error_monad.__return
        ((validation_state.with_op_count op_count
          (validation_state.with_ctxt ctxt data)),
          (Apply_results.Operation_metadata __result_value))
    end.

Definition finalize_block (function_parameter : validation_state)
  : Lwt.t
    (Error_monad.tzresult
      (Updater.validation_result * Apply_results.block_metadata)) :=
  let '{|
    validation_state.mode := mode;
      validation_state.ctxt := ctxt;
      validation_state.op_count := op_count
      |} := function_parameter in
  match mode with
  | Partial_construction _ =&gt;
    let level := Alpha_context.Level.current ctxt in
    let=? voting_period_kind := Alpha_context.Vote.get_current_period_kind ctxt
      in
    let baker := (|Signature.Public_key_hash|).(S.SPublic_key_hash.zero) in
    let=? ctxt :=
      (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.fold)
        (fun delegate =&gt;
          fun deposit =&gt;
            fun ctxt =&gt;
              let=? ctxt := ctxt in
              Alpha_context.Delegate.freeze_deposit ctxt delegate deposit)
        (Alpha_context.get_deposits ctxt) (Error_monad.__return ctxt) in
    let ctxt := Alpha_context.finalize None ctxt in
    Error_monad.__return
      (ctxt,
        {| Apply_results.block_metadata.baker := baker;
          Apply_results.block_metadata.level := level;
          Apply_results.block_metadata.voting_period_kind := voting_period_kind;
          Apply_results.block_metadata.nonce_hash := None;
          Apply_results.block_metadata.consumed_gas := Z.zero;
          Apply_results.block_metadata.deactivated := nil;
          Apply_results.block_metadata.balance_updates := nil |})
  |
    Partial_application {|
      validation_mode.Partial_application.block_header := block_header;
        validation_mode.Partial_application.baker := baker;
        validation_mode.Partial_application.block_delay := block_delay
        |} =&gt;
    let level := Alpha_context.Level.current ctxt in
    let included_endorsements := Alpha_context.included_endorsements ctxt in
    let=? '_ :=
      Apply.check_minimum_endorsements ctxt
        block_header.(Alpha_context.Block_header.block_header.protocol_data).(Alpha_context.Block_header.protocol_data.contents)
        block_delay included_endorsements in
    let=? voting_period_kind := Alpha_context.Vote.get_current_period_kind ctxt
      in
    let ctxt := Alpha_context.finalize None ctxt in
    Error_monad.__return
      (ctxt,
        {| Apply_results.block_metadata.baker := baker;
          Apply_results.block_metadata.level := level;
          Apply_results.block_metadata.voting_period_kind := voting_period_kind;
          Apply_results.block_metadata.nonce_hash := None;
          Apply_results.block_metadata.consumed_gas := Z.zero;
          Apply_results.block_metadata.deactivated := nil;
          Apply_results.block_metadata.balance_updates := nil |})
  |
    (Application {|
      validation_mode.Application.block_header := {|
        Alpha_context.Block_header.block_header.protocol_data := {|
          Alpha_context.Block_header.protocol_data.contents := protocol_data
            |}
          |};
        validation_mode.Application.baker := baker;
        validation_mode.Application.block_delay := block_delay
        |} |
    Full_construction {|
      validation_mode.Full_construction.protocol_data := protocol_data;
        validation_mode.Full_construction.baker := baker;
        validation_mode.Full_construction.block_delay := block_delay
        |}) =&gt;
    let=? '(ctxt, receipt) :=
      Apply.finalize_application ctxt protocol_data baker block_delay in
    let level := Alpha_context.Level.current ctxt in
    let priority := protocol_data.(Alpha_context.Block_header.contents.priority)
      in
    let raw_level :=
      Alpha_context.Raw_level.to_int32 level.(Alpha_context.Level.t.level) in
    let fitness := Alpha_context.Fitness.current ctxt in
    let commit_message :=
      Format.asprintf
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.String_literal &quot;lvl &quot;
            (CamlinternalFormatBasics.Int32 CamlinternalFormatBasics.Int_d
              CamlinternalFormatBasics.No_padding
              CamlinternalFormatBasics.No_precision
              (CamlinternalFormatBasics.String_literal &quot;, fit 1:&quot;
                (CamlinternalFormatBasics.Int64 CamlinternalFormatBasics.Int_d
                  CamlinternalFormatBasics.No_padding
                  CamlinternalFormatBasics.No_precision
                  (CamlinternalFormatBasics.String_literal &quot;, prio &quot;
                    (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_d
                      CamlinternalFormatBasics.No_padding
                      CamlinternalFormatBasics.No_precision
                      (CamlinternalFormatBasics.String_literal &quot;, &quot;
                        (CamlinternalFormatBasics.Int
                          CamlinternalFormatBasics.Int_d
                          CamlinternalFormatBasics.No_padding
                          CamlinternalFormatBasics.No_precision
                          (CamlinternalFormatBasics.String_literal &quot; ops&quot;
                            CamlinternalFormatBasics.End_of_format)))))))))
          &quot;lvl %ld, fit 1:%Ld, prio %d, %d ops&quot;) raw_level fitness priority
        op_count in
    let ctxt := Alpha_context.finalize (Some commit_message) ctxt in
    Error_monad.__return (ctxt, receipt)
  end.

Definition compare_operations
  (op1 : Alpha_context.packed_operation) (op2 : Alpha_context.packed_operation)
  : int :=
  let 'Alpha_context.Operation_data op1 :=
    op1.(Alpha_context.packed_operation.protocol_data) in
  let 'Alpha_context.Operation_data op2 :=
    op2.(Alpha_context.packed_operation.protocol_data) in
  match
    (op1.(Alpha_context.protocol_data.contents),
      op2.(Alpha_context.protocol_data.contents)) with
  |
    (Alpha_context.Single (Alpha_context.Endorsement _),
      Alpha_context.Single (Alpha_context.Endorsement _)) =&gt; 0
  | (_, Alpha_context.Single (Alpha_context.Endorsement _)) =&gt; 1
  | (Alpha_context.Single (Alpha_context.Endorsement _), _) =&gt; (-1)
  |
    (Alpha_context.Single (Alpha_context.Seed_nonce_revelation _),
      Alpha_context.Single (Alpha_context.Seed_nonce_revelation _)) =&gt; 0
  | (_, Alpha_context.Single (Alpha_context.Seed_nonce_revelation _)) =&gt; 1
  | (Alpha_context.Single (Alpha_context.Seed_nonce_revelation _), _) =&gt; (-1)
  |
    (Alpha_context.Single (Alpha_context.Double_endorsement_evidence _),
      Alpha_context.Single (Alpha_context.Double_endorsement_evidence _)) =&gt; 0
  | (_, Alpha_context.Single (Alpha_context.Double_endorsement_evidence _)) =&gt; 1
  | (Alpha_context.Single (Alpha_context.Double_endorsement_evidence _), _) =&gt;
    (-1)
  |
    (Alpha_context.Single (Alpha_context.Double_baking_evidence _),
      Alpha_context.Single (Alpha_context.Double_baking_evidence _)) =&gt; 0
  | (_, Alpha_context.Single (Alpha_context.Double_baking_evidence _)) =&gt; 1
  | (Alpha_context.Single (Alpha_context.Double_baking_evidence _), _) =&gt; (-1)
  |
    (Alpha_context.Single (Alpha_context.Activate_account _),
      Alpha_context.Single (Alpha_context.Activate_account _)) =&gt; 0
  | (_, Alpha_context.Single (Alpha_context.Activate_account _)) =&gt; 1
  | (Alpha_context.Single (Alpha_context.Activate_account _), _) =&gt; (-1)
  |
    (Alpha_context.Single (Alpha_context.Proposals _),
      Alpha_context.Single (Alpha_context.Proposals _)) =&gt; 0
  | (_, Alpha_context.Single (Alpha_context.Proposals _)) =&gt; 1
  | (Alpha_context.Single (Alpha_context.Proposals _), _) =&gt; (-1)
  |
    (Alpha_context.Single (Alpha_context.Ballot _),
      Alpha_context.Single (Alpha_context.Ballot _)) =&gt; 0
  | (_, Alpha_context.Single (Alpha_context.Ballot _)) =&gt; 1
  | (Alpha_context.Single (Alpha_context.Ballot _), _) =&gt; (-1)
  |
    (Alpha_context.Single (Alpha_context.Manager_operation op1),
      Alpha_context.Single (Alpha_context.Manager_operation op2)) =&gt;
    Z.compare op1.(Alpha_context.contents.Manager_operation.counter)
      op2.(Alpha_context.contents.Manager_operation.counter)
  |
    (Alpha_context.Cons (Alpha_context.Manager_operation op1) _,
      Alpha_context.Single (Alpha_context.Manager_operation op2)) =&gt;
    Z.compare op1.(Alpha_context.contents.Manager_operation.counter)
      op2.(Alpha_context.contents.Manager_operation.counter)
  |
    (Alpha_context.Single (Alpha_context.Manager_operation op1),
      Alpha_context.Cons (Alpha_context.Manager_operation op2) _) =&gt;
    Z.compare op1.(Alpha_context.contents.Manager_operation.counter)
      op2.(Alpha_context.contents.Manager_operation.counter)
  |
    (Alpha_context.Cons (Alpha_context.Manager_operation op1) _,
      Alpha_context.Cons (Alpha_context.Manager_operation op2) _) =&gt;
    Z.compare op1.(Alpha_context.contents.Manager_operation.counter)
      op2.(Alpha_context.contents.Manager_operation.counter)
  | _ =&gt; unreachable_gadt_branch
  end.

Definition init (ctxt : Context.t) (block_header : Block_header.shell_header)
  : Lwt.t (Error_monad.tzresult Updater.validation_result) :=
  let level := block_header.(Block_header.shell_header.level) in
  let fitness := block_header.(Block_header.shell_header.fitness) in
  let timestamp := block_header.(Block_header.shell_header.timestamp) in
  let typecheck (ctxt : Alpha_context.context) (script : Alpha_context.Script.t)
    : Lwt.t
      (Error_monad.tzresult
        ((Alpha_context.Script.t * option Alpha_context.Contract.big_map_diff) *
          Alpha_context.context)) :=
    let=? '(Script_ir_translator.Ex_script parsed_script, ctxt) :=
      Script_ir_translator.parse_script None ctxt false script in
    let 'existT _ __Ex_script_'b [parsed_script, ctxt] :=
      existT (A := Set)
        (fun __Ex_script_'b =&gt;
          [Script_typed_ir.script __Ex_script_'b ** Alpha_context.context]) _
        [parsed_script, ctxt] in
    let=? '(storage, big_map_diff, ctxt) :=
      Script_ir_translator.extract_big_map_diff ctxt
        Script_ir_translator.Optimized false Script_ir_translator.no_big_map_id
        Script_ir_translator.no_big_map_id
        parsed_script.(Script_typed_ir.script.storage_type)
        parsed_script.(Script_typed_ir.script.storage) in
    let=? '(storage, ctxt) :=
      Script_ir_translator.unparse_data ctxt Script_ir_translator.Optimized
        parsed_script.(Script_typed_ir.script.storage_type) storage in
    let storage :=
      Alpha_context.Script.__lazy_expr_value (Micheline.strip_locations storage)
      in
    Error_monad.__return
      (((Alpha_context.Script.t.with_storage storage script), big_map_diff),
        ctxt) in
  let=? ctxt :=
    Alpha_context.prepare_first_block ctxt typecheck level timestamp fitness in
  Error_monad.__return (Alpha_context.finalize None ctxt).

Definition operation : Set := Alpha_context.packed_operation.

Definition block_header : Set := Alpha_context.Block_header.block_header.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="main.mli">
  <div style="margin: 20px;">
    <h3>Main_mli</h3>
    <ul>
      <li>OCaml size: 62 lines</li>
      <li>Coq size: 250 lines (+303% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#main.mli"><code>main.mli</code></a>&nbsp;<span class="label label-warning">2 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Tezos Protocol Implementation - Protocol Signature Instance *)

type validation_mode =
  | Application of {
      block_header : Alpha_context.Block_header.block_header;
      baker : Alpha_context.public_key_hash;
      block_delay : Alpha_context.Period.t;
    }
  | Partial_application of {
      block_header : Alpha_context.Block_header.block_header;
      baker : Alpha_context.public_key_hash;
      block_delay : Alpha_context.Period.t;
    }
  | Partial_construction of {predecessor : Block_hash.t}
  | Full_construction of {
      predecessor : Block_hash.t;
      protocol_data : Alpha_context.Block_header.contents;
      baker : Alpha_context.public_key_hash;
      block_delay : Alpha_context.Period.t;
    }

type validation_state = {
  mode : validation_mode;
  chain_id : Chain_id.t;
  ctxt : Alpha_context.t;
  op_count : int;
}

include
  <abbr class="mark-warning" title="Can only do `with` on types in module types using type expressions rather than type definitions

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Can only do `with` on types in module types using type expressions rather than type definitions">Updater.PROTOCOL
    with type block_header_data = Alpha_context.Block_header.protocol_data
     and type block_header_metadata = Apply_results.block_metadata
     and type block_header = Alpha_context.Block_header.block_header
     and type operation_data = Alpha_context.packed_protocol_data
     and type operation_receipt = Apply_results.packed_operation_metadata
     and type operation = Alpha_context.packed_operation
     and type validation_state := validation_state</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#main.mli"><code>Main_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Apply_results.

Module ConstructorRecords_validation_mode.
  Module validation_mode.
    Module Application.
      Record record {block_header baker block_delay : Set} : Set := Build {
        block_header : block_header;
        baker : baker;
        block_delay : block_delay }.
      Arguments record : clear implicits.
      Definition with_block_header {t_block_header t_baker t_block_delay}
        block_header (r : record t_block_header t_baker t_block_delay) :=
        Build t_block_header t_baker t_block_delay block_header r.(baker)
          r.(block_delay).
      Definition with_baker {t_block_header t_baker t_block_delay} baker
        (r : record t_block_header t_baker t_block_delay) :=
        Build t_block_header t_baker t_block_delay r.(block_header) baker
          r.(block_delay).
      Definition with_block_delay {t_block_header t_baker t_block_delay}
        block_delay (r : record t_block_header t_baker t_block_delay) :=
        Build t_block_header t_baker t_block_delay r.(block_header) r.(baker)
          block_delay.
    End Application.
    Definition Application_skeleton := Application.record.
    
    Module Partial_application.
      Record record {block_header baker block_delay : Set} : Set := Build {
        block_header : block_header;
        baker : baker;
        block_delay : block_delay }.
      Arguments record : clear implicits.
      Definition with_block_header {t_block_header t_baker t_block_delay}
        block_header (r : record t_block_header t_baker t_block_delay) :=
        Build t_block_header t_baker t_block_delay block_header r.(baker)
          r.(block_delay).
      Definition with_baker {t_block_header t_baker t_block_delay} baker
        (r : record t_block_header t_baker t_block_delay) :=
        Build t_block_header t_baker t_block_delay r.(block_header) baker
          r.(block_delay).
      Definition with_block_delay {t_block_header t_baker t_block_delay}
        block_delay (r : record t_block_header t_baker t_block_delay) :=
        Build t_block_header t_baker t_block_delay r.(block_header) r.(baker)
          block_delay.
    End Partial_application.
    Definition Partial_application_skeleton := Partial_application.record.
    
    Module Partial_construction.
      Record record {predecessor : Set} : Set := Build {
        predecessor : predecessor }.
      Arguments record : clear implicits.
      Definition with_predecessor {t_predecessor} predecessor
        (r : record t_predecessor) :=
        Build t_predecessor predecessor.
    End Partial_construction.
    Definition Partial_construction_skeleton := Partial_construction.record.
    
    Module Full_construction.
      Record record {predecessor protocol_data baker block_delay : Set} : Set := Build {
        predecessor : predecessor;
        protocol_data : protocol_data;
        baker : baker;
        block_delay : block_delay }.
      Arguments record : clear implicits.
      Definition with_predecessor
        {t_predecessor t_protocol_data t_baker t_block_delay} predecessor
        (r : record t_predecessor t_protocol_data t_baker t_block_delay) :=
        Build t_predecessor t_protocol_data t_baker t_block_delay predecessor
          r.(protocol_data) r.(baker) r.(block_delay).
      Definition with_protocol_data
        {t_predecessor t_protocol_data t_baker t_block_delay} protocol_data
        (r : record t_predecessor t_protocol_data t_baker t_block_delay) :=
        Build t_predecessor t_protocol_data t_baker t_block_delay
          r.(predecessor) protocol_data r.(baker) r.(block_delay).
      Definition with_baker
        {t_predecessor t_protocol_data t_baker t_block_delay} baker
        (r : record t_predecessor t_protocol_data t_baker t_block_delay) :=
        Build t_predecessor t_protocol_data t_baker t_block_delay
          r.(predecessor) r.(protocol_data) baker r.(block_delay).
      Definition with_block_delay
        {t_predecessor t_protocol_data t_baker t_block_delay} block_delay
        (r : record t_predecessor t_protocol_data t_baker t_block_delay) :=
        Build t_predecessor t_protocol_data t_baker t_block_delay
          r.(predecessor) r.(protocol_data) r.(baker) block_delay.
    End Full_construction.
    Definition Full_construction_skeleton := Full_construction.record.
  End validation_mode.
End ConstructorRecords_validation_mode.
Import ConstructorRecords_validation_mode.

Reserved Notation &quot;'validation_mode.Application&quot;.
Reserved Notation &quot;'validation_mode.Partial_application&quot;.
Reserved Notation &quot;'validation_mode.Partial_construction&quot;.
Reserved Notation &quot;'validation_mode.Full_construction&quot;.

Inductive validation_mode : Set :=
| Application : 'validation_mode.Application -&gt; validation_mode
| Partial_application : 'validation_mode.Partial_application -&gt; validation_mode
| Partial_construction :
  'validation_mode.Partial_construction -&gt; validation_mode
| Full_construction : 'validation_mode.Full_construction -&gt; validation_mode

where &quot;'validation_mode.Application&quot; :=
  (validation_mode.Application_skeleton Alpha_context.Block_header.block_header
    Alpha_context.public_key_hash Alpha_context.Period.t)
and &quot;'validation_mode.Partial_application&quot; :=
  (validation_mode.Partial_application_skeleton
    Alpha_context.Block_header.block_header Alpha_context.public_key_hash
    Alpha_context.Period.t)
and &quot;'validation_mode.Partial_construction&quot; :=
  (validation_mode.Partial_construction_skeleton (|Block_hash|).(S.HASH.t))
and &quot;'validation_mode.Full_construction&quot; :=
  (validation_mode.Full_construction_skeleton (|Block_hash|).(S.HASH.t)
    Alpha_context.Block_header.contents Alpha_context.public_key_hash
    Alpha_context.Period.t).

Module validation_mode.
  Include ConstructorRecords_validation_mode.validation_mode.
  Definition Application := 'validation_mode.Application.
  Definition Partial_application := 'validation_mode.Partial_application.
  Definition Partial_construction := 'validation_mode.Partial_construction.
  Definition Full_construction := 'validation_mode.Full_construction.
End validation_mode.

Module validation_state.
  Record record : Set := Build {
    mode : validation_mode;
    chain_id : (|Chain_id|).(S.HASH.t);
    ctxt : Alpha_context.t;
    op_count : int }.
  Definition with_mode mode (r : record) :=
    Build mode r.(chain_id) r.(ctxt) r.(op_count).
  Definition with_chain_id chain_id (r : record) :=
    Build r.(mode) chain_id r.(ctxt) r.(op_count).
  Definition with_ctxt ctxt (r : record) :=
    Build r.(mode) r.(chain_id) ctxt r.(op_count).
  Definition with_op_count op_count (r : record) :=
    Build r.(mode) r.(chain_id) r.(ctxt) op_count.
End validation_state.
Definition validation_state := validation_state.record.

Parameter Included_PROTOCOL :
  {'[block_header, operation] : [Set ** Set] &amp;
    Updater.PROTOCOL.signature
      (block_header_data := Alpha_context.Block_header.protocol_data)
      (block_header := block_header)
      (block_header_metadata := Apply_results.block_metadata)
      (operation_data := Alpha_context.packed_protocol_data)
      (operation_receipt := Apply_results.packed_operation_metadata)
      (operation := operation) (validation_state := validation_state)}.

Definition max_block_length : int :=
  (|Included_PROTOCOL|).(Updater.PROTOCOL.max_block_length).

Definition max_operation_data_length : int :=
  (|Included_PROTOCOL|).(Updater.PROTOCOL.max_operation_data_length).

Definition validation_passes : list Updater.quota :=
  (|Included_PROTOCOL|).(Updater.PROTOCOL.validation_passes).

Definition block_header_data :=
  (|Included_PROTOCOL|).(Updater.PROTOCOL.block_header_data).

Definition block_header_data_encoding : Data_encoding.t block_header_data :=
  (|Included_PROTOCOL|).(Updater.PROTOCOL.block_header_data_encoding).

Definition block_header :=
  (|Included_PROTOCOL|).(Updater.PROTOCOL.block_header).

Definition block_header_metadata :=
  (|Included_PROTOCOL|).(Updater.PROTOCOL.block_header_metadata).

Definition block_header_metadata_encoding :
  Data_encoding.t block_header_metadata :=
  (|Included_PROTOCOL|).(Updater.PROTOCOL.block_header_metadata_encoding).

Definition operation_data :=
  (|Included_PROTOCOL|).(Updater.PROTOCOL.operation_data).

Definition operation_receipt :=
  (|Included_PROTOCOL|).(Updater.PROTOCOL.operation_receipt).

Definition operation := (|Included_PROTOCOL|).(Updater.PROTOCOL.operation).

Definition operation_data_encoding : Data_encoding.t operation_data :=
  (|Included_PROTOCOL|).(Updater.PROTOCOL.operation_data_encoding).

Definition operation_receipt_encoding : Data_encoding.t operation_receipt :=
  (|Included_PROTOCOL|).(Updater.PROTOCOL.operation_receipt_encoding).

Definition operation_data_and_receipt_encoding :
  Data_encoding.t (operation_data * operation_receipt) :=
  (|Included_PROTOCOL|).(Updater.PROTOCOL.operation_data_and_receipt_encoding).

Definition acceptable_passes : operation -&gt; list int :=
  (|Included_PROTOCOL|).(Updater.PROTOCOL.acceptable_passes).

Definition compare_operations : operation -&gt; operation -&gt; int :=
  (|Included_PROTOCOL|).(Updater.PROTOCOL.compare_operations).

Definition current_context :
  validation_state -&gt; Lwt.t (Error_monad.tzresult Context.t) :=
  (|Included_PROTOCOL|).(Updater.PROTOCOL.current_context).

Definition begin_partial_application :
  (|Chain_id|).(S.HASH.t) -&gt; Context.t -&gt; Time.t -&gt; (|Fitness|).(S.T.t) -&gt;
  block_header -&gt; Lwt.t (Error_monad.tzresult validation_state) :=
  (|Included_PROTOCOL|).(Updater.PROTOCOL.begin_partial_application).

Definition begin_application :
  (|Chain_id|).(S.HASH.t) -&gt; Context.t -&gt; Time.t -&gt; (|Fitness|).(S.T.t) -&gt;
  block_header -&gt; Lwt.t (Error_monad.tzresult validation_state) :=
  (|Included_PROTOCOL|).(Updater.PROTOCOL.begin_application).

Definition begin_construction :
  (|Chain_id|).(S.HASH.t) -&gt; Context.t -&gt; Time.t -&gt; Int32.t -&gt;
  (|Fitness|).(S.T.t) -&gt; (|Block_hash|).(S.HASH.t) -&gt; Time.t -&gt;
  option block_header_data -&gt; unit -&gt;
  Lwt.t (Error_monad.tzresult validation_state) :=
  (|Included_PROTOCOL|).(Updater.PROTOCOL.begin_construction).

Definition apply_operation :
  validation_state -&gt; operation -&gt;
  Lwt.t (Error_monad.tzresult (validation_state * operation_receipt)) :=
  (|Included_PROTOCOL|).(Updater.PROTOCOL.apply_operation).

Definition finalize_block :
  validation_state -&gt;
  Lwt.t
    (Error_monad.tzresult (Updater.validation_result * block_header_metadata))
  := (|Included_PROTOCOL|).(Updater.PROTOCOL.finalize_block).

Definition rpc_services : RPC_directory.t Updater.rpc_context :=
  (|Included_PROTOCOL|).(Updater.PROTOCOL.rpc_services).

Definition init :
  Context.t -&gt; Block_header.shell_header -&gt;
  Lwt.t (Error_monad.tzresult Updater.validation_result) :=
  (|Included_PROTOCOL|).(Updater.PROTOCOL.init).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="manager_repr.ml">
  <div style="margin: 20px;">
    <h3>Manager_repr</h3>
    <ul>
      <li>OCaml size: 54 lines</li>
      <li>Coq size: 45 lines (-17% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#manager_repr.ml"><code>manager_repr.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(* Tezos Protocol Implementation - Low level Repr. of Managers' keys *)

type manager_key =
  | Hash of Signature.Public_key_hash.t
  | Public_key of Signature.Public_key.t

type t = manager_key

open Data_encoding

let hash_case tag =
  case
    tag
    ~title:&quot;Public_key_hash&quot;
    Signature.Public_key_hash.encoding
    (function Hash hash -&gt; Some hash | _ -&gt; None)
    (fun hash -&gt; Hash hash)

let pubkey_case tag =
  case
    tag
    ~title:&quot;Public_key&quot;
    Signature.Public_key.encoding
    (function Public_key hash -&gt; Some hash | _ -&gt; None)
    (fun hash -&gt; Public_key hash)

let encoding = union [hash_case (Tag 0); pubkey_case (Tag 1)]

let is_not_Storage_sigs_VALUE = ()
</pre>
  </div>
  <div class="col-md-6">
    <a href="#manager_repr.ml"><code>Manager_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.

Inductive manager_key : Set :=
| Hash : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt; manager_key
| Public_key : (|Signature.Public_key|).(S.SPublic_key.t) -&gt; manager_key.

Definition t : Set := manager_key.

Import Data_encoding.

Definition hash_case (tag : Data_encoding.case_tag)
  : Data_encoding.case manager_key :=
  Data_encoding.__case_value &quot;Public_key_hash&quot; None tag
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding)
    (fun function_parameter =&gt;
      match function_parameter with
      | Hash __hash_value =&gt; Some __hash_value
      | _ =&gt; None
      end) (fun __hash_value =&gt; Hash __hash_value).

Definition pubkey_case (tag : Data_encoding.case_tag)
  : Data_encoding.case manager_key :=
  Data_encoding.__case_value &quot;Public_key&quot; None tag
    (|Signature.Public_key|).(S.SPublic_key.encoding)
    (fun function_parameter =&gt;
      match function_parameter with
      | Public_key __hash_value =&gt; Some __hash_value
      | _ =&gt; None
      end) (fun __hash_value =&gt; Public_key __hash_value).

Definition encoding : Data_encoding.encoding manager_key :=
  Data_encoding.union None
    [ hash_case (Data_encoding.Tag 0); pubkey_case (Data_encoding.Tag 1) ].

Definition is_not_Storage_sigs_VALUE : unit := tt.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="manager_repr.mli">
  <div style="margin: 20px;">
    <h3>Manager_repr_mli</h3>
    <ul>
      <li>OCaml size: 40 lines</li>
      <li>Coq size: 21 lines (-48% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#manager_repr.mli"><code>manager_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(* Tezos Protocol Implementation - Low level Repr. of Managers' keys *)

(** The public key of the manager of a contract is reveled only after the
    first operation. At Origination time, the manager provides only the hash
    of its public key that is stored in the contract. When the public key
    is actually reveeld, the public key instead of the hash of the key *)
type manager_key =
  | Hash of Signature.Public_key_hash.t
  | Public_key of Signature.Public_key.t

type t = manager_key

val encoding : t Data_encoding.encoding

val is_not_Storage_sigs_VALUE : unit
</pre>
  </div>
  <div class="col-md-6">
    <a href="#manager_repr.mli"><code>Manager_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.

Inductive manager_key : Set :=
| Hash : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt; manager_key
| Public_key : (|Signature.Public_key|).(S.SPublic_key.t) -&gt; manager_key.

Definition t : Set := manager_key.

Parameter encoding : Data_encoding.encoding t.

Parameter is_not_Storage_sigs_VALUE : unit.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="michelson_v1_gas.ml">
  <div style="margin: 20px;">
    <h3>Michelson_v1_gas</h3>
    <ul>
      <li>OCaml size: 767 lines</li>
      <li>Coq size: 952 lines (+24% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#michelson_v1_gas.ml"><code>michelson_v1_gas.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context
open Gas

module Cost_of = struct
  let log2 =
    let rec help acc = function 0 -&gt; acc | n -&gt; help (acc + 1) (n / 2) in
    help 1

  let z_bytes (z : Z.t) =
    let bits = Z.numbits z in
    (7 + bits) / 8

  let int_bytes (z : Script_int.num) = z_bytes (Script_int.to_zint z)

  let timestamp_bytes (t : Script_timestamp.t) =
    let z = Script_timestamp.to_zint t in
    z_bytes z

  (* For now, returns size in bytes, but this could get more complicated... *)
  let rec size_of_comparable :
      type a b. (a, b) Script_typed_ir.comparable_struct -&gt; a -&gt; int =
   fun wit v -&gt;
    match[@coq_match_gadt] (wit, v) with
    | (Int_key _, (v : Script_int_repr.num)) -&gt;
        int_bytes v
    | (Nat_key _, (v : Script_int_repr.num)) -&gt;
        int_bytes v
    | (String_key _, (v : string)) -&gt;
        String.length v
    | (Bytes_key _, (v : MBytes.t)) -&gt;
        MBytes.length v
    | (Bool_key _, _) -&gt;
        8
    | (Key_hash_key _, _) -&gt;
        Signature.Public_key_hash.size
    | (Timestamp_key _, (v : Script_timestamp.t)) -&gt;
        timestamp_bytes v
    | (Address_key _, _) -&gt;
        Signature.Public_key_hash.size
    | (Mutez_key _, _) -&gt;
        8
    | (Pair_key ((l, _), (r, _), _), (v : _ * _)) -&gt;
        let (lval, rval) = v in
        size_of_comparable l lval + size_of_comparable r rval

  let string length = alloc_bytes_cost length

  let bytes length = alloc_mbytes_cost length

  let manager_operation = step_cost 10_000

  module Legacy = struct
    let zint z = alloc_bits_cost (Z.numbits z)

    let set_to_list : type item. item Script_typed_ir.set -&gt; cost =
     fun (module Box) -&gt; alloc_cost @@ Pervasives.(Box.size * 2)

    let map_to_list : type key value. (key, value) Script_typed_ir.map -&gt; cost
        =
     fun (module Box) -&gt;
      let size = snd Box.boxed in
      3 *@ alloc_cost size

    let z_to_int64 = step_cost 2 +@ alloc_cost 1

    let hash data len = (10 *@ step_cost (MBytes.length data)) +@ bytes len

    let set_access : type elt. elt -&gt; elt Script_typed_ir.set -&gt; int =
     fun _key (module Box) -&gt; log2 @@ Box.size

    let set_update key _presence set = set_access key set *@ alloc_cost 3
  end

  module Interpreter = struct
    let cycle = atomic_step_cost 10

    let nop = free

    let stack_op = atomic_step_cost 10

    let push = atomic_step_cost 10

    let wrap = atomic_step_cost 10

    let variant_no_data = atomic_step_cost 10

    let branch = atomic_step_cost 10

    let pair = atomic_step_cost 10

    let pair_access = atomic_step_cost 10

    let cons = atomic_step_cost 10

    let loop_size = atomic_step_cost 5

    let loop_cycle = atomic_step_cost 10

    let loop_iter = atomic_step_cost 20

    let loop_map = atomic_step_cost 30

    let empty_set = atomic_step_cost 10

    let set_to_list : type elt. elt Script_typed_ir.set -&gt; cost =
     fun (module Box) -&gt; atomic_step_cost (Box.size * 20)

    let set_mem : type elt. elt -&gt; elt Script_typed_ir.set -&gt; cost =
     fun elt (module Box) -&gt;
      let elt_bytes = size_of_comparable Box.elt_ty elt in
      atomic_step_cost ((1 + (elt_bytes / 82)) * log2 Box.size)

    let set_update : type elt. elt -&gt; bool -&gt; elt Script_typed_ir.set -&gt; cost =
     fun elt _ (module Box) -&gt;
      let elt_bytes = size_of_comparable Box.elt_ty elt in
      atomic_step_cost ((1 + (elt_bytes / 82)) * log2 Box.size)

    let set_size = atomic_step_cost 10

    let empty_map = atomic_step_cost 10

    let map_to_list : type key value. (key, value) Script_typed_ir.map -&gt; cost
        =
     fun (module Box) -&gt;
      let size = snd Box.boxed in
      atomic_step_cost (size * 20)

    let map_access :
        type key value. key -&gt; (key, value) Script_typed_ir.map -&gt; cost =
     fun key (module Box) -&gt;
      let map_card = snd Box.boxed in
      let key_bytes = size_of_comparable Box.key_ty key in
      atomic_step_cost ((1 + (key_bytes / 70)) * log2 map_card)

    let map_mem = map_access

    let map_get = map_access

    let map_update :
        type key value.
        key -&gt; value option -&gt; (key, value) Script_typed_ir.map -&gt; cost =
     fun key _value (module Box) -&gt;
      let map_card = snd Box.boxed in
      let key_bytes = size_of_comparable Box.key_ty key in
      atomic_step_cost ((1 + (key_bytes / 38)) * log2 map_card)

    let map_size = atomic_step_cost 10

    let add_timestamp (t1 : Script_timestamp.t) (t2 : Script_int.num) =
      let bytes1 = timestamp_bytes t1 in
      let bytes2 = int_bytes t2 in
      atomic_step_cost (51 + (Compare.Int.max bytes1 bytes2 / 62))

    let sub_timestamp = add_timestamp

    let diff_timestamps (t1 : Script_timestamp.t) (t2 : Script_timestamp.t) =
      let bytes1 = timestamp_bytes t1 in
      let bytes2 = timestamp_bytes t2 in
      atomic_step_cost (51 + (Compare.Int.max bytes1 bytes2 / 62))

    let rec concat_loop l acc =
      match l with [] -&gt; 30 | _ :: tl -&gt; concat_loop tl (acc + 30)

    let concat_string string_list =
      atomic_step_cost (concat_loop string_list 0)

    let slice_string string_length =
      atomic_step_cost (40 + (string_length / 70))

    let concat_bytes bytes_list = atomic_step_cost (concat_loop bytes_list 0)

    let int64_op = atomic_step_cost 61

    let z_to_int64 = atomic_step_cost 20

    let int64_to_z = atomic_step_cost 20

    let bool_binop _ _ = atomic_step_cost 10

    let bool_unop _ = atomic_step_cost 10

    let abs int = atomic_step_cost (61 + (int_bytes int / 70))

    let int _int = free

    let neg = abs

    let add i1 i2 =
      atomic_step_cost
        (51 + (Compare.Int.max (int_bytes i1) (int_bytes i2) / 62))

    let sub = add

    let mul i1 i2 =
      let bytes = Compare.Int.max (int_bytes i1) (int_bytes i2) in
      atomic_step_cost (51 + (bytes / 6 * log2 bytes))

    let indic_lt x y = if Compare.Int.(x &lt; y) then 1 else 0

    let div i1 i2 =
      let bytes1 = int_bytes i1 in
      let bytes2 = int_bytes i2 in
      let cost = indic_lt bytes2 bytes1 * (bytes1 - bytes2) * bytes2 in
      atomic_step_cost (51 + (cost / 3151))

    let shift_left _i _shift_bits = atomic_step_cost 30

    let shift_right _i _shift_bits = atomic_step_cost 30

    let logor i1 i2 =
      let bytes1 = int_bytes i1 in
      let bytes2 = int_bytes i2 in
      atomic_step_cost (51 + (Compare.Int.max bytes1 bytes2 / 70))

    let logand i1 i2 =
      let bytes1 = int_bytes i1 in
      let bytes2 = int_bytes i2 in
      atomic_step_cost (51 + (Compare.Int.min bytes1 bytes2 / 70))

    let logxor = logor

    let lognot i = atomic_step_cost (51 + (int_bytes i / 20))

    let exec = atomic_step_cost 10

    let compare_bool _ _ = atomic_step_cost 30

    let compare_string s1 s2 =
      let bytes1 = String.length s1 in
      let bytes2 = String.length s2 in
      atomic_step_cost (30 + (Compare.Int.min bytes1 bytes2 / 123))

    let compare_bytes b1 b2 =
      let bytes1 = MBytes.length b1 in
      let bytes2 = MBytes.length b2 in
      atomic_step_cost (30 + (Compare.Int.min bytes1 bytes2 / 123))

    let compare_tez _ _ = atomic_step_cost 30

    let compare_zint i1 i2 =
      atomic_step_cost
        (51 + (Compare.Int.min (int_bytes i1) (int_bytes i2) / 82))

    let compare_key_hash _ _ = atomic_step_cost 92

    let compare_timestamp t1 t2 =
      let bytes1 = timestamp_bytes t1 in
      let bytes2 = timestamp_bytes t2 in
      atomic_step_cost (51 + (Compare.Int.min bytes1 bytes2 / 82))

    let compare_address _ _ = atomic_step_cost 92

    let compare_res = atomic_step_cost 30

    let unpack_failed bytes =
      (* We cannot instrument failed deserialization,
         so we take worst case fees: a set of size 1 bytes values. *)
      let len = MBytes.length bytes in
      (len *@ alloc_mbytes_cost 1)
      +@ (len *@ (log2 len *@ (alloc_cost 3 +@ step_cost 1)))

    let address = atomic_step_cost 10

    let contract = step_cost 10000

    let transfer = step_cost 10

    let create_account = step_cost 10

    let create_contract = step_cost 10

    let implicit_account = step_cost 10

    let set_delegate = step_cost 10 +@ write_bytes_cost (Z.of_int 32)

    let balance = atomic_step_cost 10

    let now = atomic_step_cost 10

    let check_signature_secp256k1 bytes = atomic_step_cost (10342 + (bytes / 5))

    let check_signature_ed25519 bytes = atomic_step_cost (36864 + (bytes / 5))

    let check_signature_p256 bytes = atomic_step_cost (36864 + (bytes / 5))

    let check_signature (pkey : Signature.public_key) bytes =
      match pkey with
      | Ed25519 _ -&gt;
          check_signature_ed25519 (MBytes.length bytes)
      | Secp256k1 _ -&gt;
          check_signature_secp256k1 (MBytes.length bytes)
      | P256 _ -&gt;
          check_signature_p256 (MBytes.length bytes)

    let hash_key = atomic_step_cost 30

    let hash_blake2b b = atomic_step_cost (102 + (MBytes.length b / 5))

    let hash_sha256 b = atomic_step_cost (409 + MBytes.length b)

    let hash_sha512 b =
      let bytes = MBytes.length b in
      atomic_step_cost (409 + ((bytes lsr 1) + (bytes lsr 4)))

    let steps_to_quota = atomic_step_cost 10

    let source = atomic_step_cost 10

    let self = atomic_step_cost 10

    let amount = atomic_step_cost 10

    let chain_id = step_cost 1

    let stack_n_op n =
      atomic_step_cost (20 + ((n lsr 1) + (n lsr 2) + (n lsr 4)))

    let apply = alloc_cost 8 +@ step_cost 1

    let rec compare :
        type a s. (a, s) Script_typed_ir.comparable_struct -&gt; a -&gt; a -&gt; cost =
     fun ty x y -&gt;
      match[@coq_match_gadt] (ty, x, y) with
      | (Bool_key _, (x : bool), (y : bool)) -&gt;
          compare_bool x y
      | (String_key _, (x : string), (y : string)) -&gt;
          compare_string x y
      | (Bytes_key _, (x : MBytes.t), (y : MBytes.t)) -&gt;
          compare_bytes x y
      | (Mutez_key _, x, y) -&gt;
          compare_tez x y
      | (Int_key _, (x : Script_int_repr.num), (y : Script_int_repr.num)) -&gt;
          compare_zint x y
      | (Nat_key _, (x : Script_int_repr.num), (y : Script_int_repr.num)) -&gt;
          compare_zint x y
      | (Key_hash_key _, x, y) -&gt;
          compare_key_hash x y
      | (Timestamp_key _, (x : Script_timestamp.t), (y : Script_timestamp.t))
        -&gt;
          compare_timestamp x y
      | (Address_key _, x, y) -&gt;
          compare_address x y
      | (Pair_key ((tl, _), (tr, _), _), (x : _ * _), (y : _ * _)) -&gt;
          (* Reasonable over-approximation of the cost of lexicographic comparison. *)
          let (xl, xr) = x in
          let (yl, yr) = y in
          compare tl xl yl +@ compare tr xr yr
  end

  module Typechecking = struct
    let cycle = step_cost 1

    let bool = free

    let unit = free

    let string = string

    let bytes = bytes

    let z = Legacy.zint

    let int_of_string str =
      alloc_cost @@ Pervasives.( / ) (String.length str) 5

    let tez = step_cost 1 +@ alloc_cost 1

    let string_timestamp = step_cost 3 +@ alloc_cost 3

    let key = step_cost 3 +@ alloc_cost 3

    let key_hash = step_cost 1 +@ alloc_cost 1

    let signature = step_cost 1 +@ alloc_cost 1

    let chain_id = step_cost 1 +@ alloc_cost 1

    let contract = step_cost 5

    let get_script = step_cost 20 +@ alloc_cost 5

    let contract_exists = step_cost 15 +@ alloc_cost 5

    let pair = alloc_cost 2

    let union = alloc_cost 1

    let lambda = alloc_cost 5 +@ step_cost 3

    let some = alloc_cost 1

    let none = alloc_cost 0

    let list_element = alloc_cost 2 +@ step_cost 1

    let set_element size = log2 size *@ (alloc_cost 3 +@ step_cost 2)

    let map_element size = log2 size *@ (alloc_cost 4 +@ step_cost 2)

    let primitive_type = alloc_cost 1

    let one_arg_type = alloc_cost 2

    let two_arg_type = alloc_cost 3

    let operation b = bytes b

    let type_ nb_args = alloc_cost (nb_args + 1)

    (* Cost of parsing instruction, is cost of allocation of
       constructor + cost of contructor parameters + cost of
       allocation on the stack type *)
    let instr : type b a. (b, a) Script_typed_ir.instr -&gt; cost =
     fun i -&gt;
      let open Script_typed_ir in
      alloc_cost 1
      +@
      (* cost of allocation of constructor *)
      match i with
      | Drop -&gt;
          alloc_cost 0
      | Dup -&gt;
          alloc_cost 1
      | Swap -&gt;
          alloc_cost 0
      | Const _ -&gt;
          alloc_cost 1
      | Cons_pair -&gt;
          alloc_cost 2
      | Car -&gt;
          alloc_cost 1
      | Cdr -&gt;
          alloc_cost 1
      | Cons_some -&gt;
          alloc_cost 2
      | Cons_none _ -&gt;
          alloc_cost 3
      | If_none _ -&gt;
          alloc_cost 2
      | Left -&gt;
          alloc_cost 3
      | Right -&gt;
          alloc_cost 3
      | If_left _ -&gt;
          alloc_cost 2
      | Cons_list -&gt;
          alloc_cost 1
      | Nil -&gt;
          alloc_cost 1
      | If_cons _ -&gt;
          alloc_cost 2
      | List_map _ -&gt;
          alloc_cost 5
      | List_iter _ -&gt;
          alloc_cost 4
      | List_size -&gt;
          alloc_cost 1
      | Empty_set _ -&gt;
          alloc_cost 1
      | Set_iter _ -&gt;
          alloc_cost 4
      | Set_mem -&gt;
          alloc_cost 1
      | Set_update -&gt;
          alloc_cost 1
      | Set_size -&gt;
          alloc_cost 1
      | Empty_map _ -&gt;
          alloc_cost 2
      | Map_map _ -&gt;
          alloc_cost 5
      | Map_iter _ -&gt;
          alloc_cost 4
      | Map_mem -&gt;
          alloc_cost 1
      | Map_get -&gt;
          alloc_cost 1
      | Map_update -&gt;
          alloc_cost 1
      | Map_size -&gt;
          alloc_cost 1
      | Empty_big_map _ -&gt;
          alloc_cost 2
      | Big_map_mem -&gt;
          alloc_cost 1
      | Big_map_get -&gt;
          alloc_cost 1
      | Big_map_update -&gt;
          alloc_cost 1
      | Concat_string -&gt;
          alloc_cost 1
      | Concat_string_pair -&gt;
          alloc_cost 1
      | Concat_bytes -&gt;
          alloc_cost 1
      | Concat_bytes_pair -&gt;
          alloc_cost 1
      | Slice_string -&gt;
          alloc_cost 1
      | Slice_bytes -&gt;
          alloc_cost 1
      | String_size -&gt;
          alloc_cost 1
      | Bytes_size -&gt;
          alloc_cost 1
      | Add_seconds_to_timestamp -&gt;
          alloc_cost 1
      | Add_timestamp_to_seconds -&gt;
          alloc_cost 1
      | Sub_timestamp_seconds -&gt;
          alloc_cost 1
      | Diff_timestamps -&gt;
          alloc_cost 1
      | Add_tez -&gt;
          alloc_cost 1
      | Sub_tez -&gt;
          alloc_cost 1
      | Mul_teznat -&gt;
          alloc_cost 1
      | Mul_nattez -&gt;
          alloc_cost 1
      | Ediv_teznat -&gt;
          alloc_cost 1
      | Ediv_tez -&gt;
          alloc_cost 1
      | Or -&gt;
          alloc_cost 1
      | And -&gt;
          alloc_cost 1
      | Xor -&gt;
          alloc_cost 1
      | Not -&gt;
          alloc_cost 1
      | Is_nat -&gt;
          alloc_cost 1
      | Neg_nat -&gt;
          alloc_cost 1
      | Neg_int -&gt;
          alloc_cost 1
      | Abs_int -&gt;
          alloc_cost 1
      | Int_nat -&gt;
          alloc_cost 1
      | Add_intint -&gt;
          alloc_cost 1
      | Add_intnat -&gt;
          alloc_cost 1
      | Add_natint -&gt;
          alloc_cost 1
      | Add_natnat -&gt;
          alloc_cost 1
      | Sub_int -&gt;
          alloc_cost 1
      | Mul_intint -&gt;
          alloc_cost 1
      | Mul_intnat -&gt;
          alloc_cost 1
      | Mul_natint -&gt;
          alloc_cost 1
      | Mul_natnat -&gt;
          alloc_cost 1
      | Ediv_intint -&gt;
          alloc_cost 1
      | Ediv_intnat -&gt;
          alloc_cost 1
      | Ediv_natint -&gt;
          alloc_cost 1
      | Ediv_natnat -&gt;
          alloc_cost 1
      | Lsl_nat -&gt;
          alloc_cost 1
      | Lsr_nat -&gt;
          alloc_cost 1
      | Or_nat -&gt;
          alloc_cost 1
      | And_nat -&gt;
          alloc_cost 1
      | And_int_nat -&gt;
          alloc_cost 1
      | Xor_nat -&gt;
          alloc_cost 1
      | Not_nat -&gt;
          alloc_cost 1
      | Not_int -&gt;
          alloc_cost 1
      | Seq _ -&gt;
          alloc_cost 8
      | If _ -&gt;
          alloc_cost 8
      | Loop _ -&gt;
          alloc_cost 4
      | Loop_left _ -&gt;
          alloc_cost 5
      | Dip _ -&gt;
          alloc_cost 4
      | Exec -&gt;
          alloc_cost 1
      | Apply _ -&gt;
          alloc_cost 1
      | Lambda _ -&gt;
          alloc_cost 2
      | Failwith _ -&gt;
          alloc_cost 1
      | Nop -&gt;
          alloc_cost 0
      | Compare _ -&gt;
          alloc_cost 1
      | Eq -&gt;
          alloc_cost 1
      | Neq -&gt;
          alloc_cost 1
      | Lt -&gt;
          alloc_cost 1
      | Gt -&gt;
          alloc_cost 1
      | Le -&gt;
          alloc_cost 1
      | Ge -&gt;
          alloc_cost 1
      | Address -&gt;
          alloc_cost 1
      | Contract _ -&gt;
          alloc_cost 2
      | Transfer_tokens -&gt;
          alloc_cost 1
      | Create_account -&gt;
          alloc_cost 2
      | Implicit_account -&gt;
          alloc_cost 1
      | Create_contract _ -&gt;
          alloc_cost 8
      (* Deducted the cost of removed arguments manager, spendable and delegatable:
           - manager: key_hash = 1
           - spendable: bool = 0
           - delegatable: bool = 0
        *)
      | Create_contract_2 _ -&gt;
          alloc_cost 7
      | Set_delegate -&gt;
          alloc_cost 1
      | Now -&gt;
          alloc_cost 1
      | Balance -&gt;
          alloc_cost 1
      | Check_signature -&gt;
          alloc_cost 1
      | Hash_key -&gt;
          alloc_cost 1
      | Pack _ -&gt;
          alloc_cost 2
      | Unpack _ -&gt;
          alloc_cost 2
      | Blake2b -&gt;
          alloc_cost 1
      | Sha256 -&gt;
          alloc_cost 1
      | Sha512 -&gt;
          alloc_cost 1
      | Steps_to_quota -&gt;
          alloc_cost 1
      | Source -&gt;
          alloc_cost 1
      | Sender -&gt;
          alloc_cost 1
      | Self _ -&gt;
          alloc_cost 2
      | Amount -&gt;
          alloc_cost 1
      | Dig (n, _) -&gt;
          n *@ alloc_cost 1 (* _ is a unary development of n *)
      | Dug (n, _) -&gt;
          n *@ alloc_cost 1
      | Dipn (n, _, _) -&gt;
          n *@ alloc_cost 1
      | Dropn (n, _) -&gt;
          n *@ alloc_cost 1
      | ChainId -&gt;
          alloc_cost 1
  end

  module Unparse = struct
    let prim_cost l annot = Script.prim_node_cost_nonrec_of_length l annot

    let seq_cost = Script.seq_node_cost_nonrec_of_length

    let string_cost length = Script.string_node_cost_of_length length

    let cycle = step_cost 1

    let bool = prim_cost 0 []

    let unit = prim_cost 0 []

    (* We count the length of strings and bytes to prevent hidden
       miscalculations due to non detectable expansion of sharing. *)
    let string s = Script.string_node_cost s

    let bytes s = Script.bytes_node_cost s

    let z i = Script.int_node_cost i

    let int i = Script.int_node_cost (Script_int.to_zint i)

    let tez = Script.int_node_cost_of_numbits 60 (* int64 bound *)

    let timestamp x = Script_timestamp.to_zint x |&gt; Script_int.of_zint |&gt; int

    let operation bytes = Script.bytes_node_cost bytes

    let chain_id bytes = Script.bytes_node_cost bytes

    let key = string_cost 54

    let key_hash = string_cost 36

    let signature = string_cost 128

    let contract = string_cost 36

    let pair = prim_cost 2 []

    let union = prim_cost 1 []

    let some = prim_cost 1 []

    let none = prim_cost 0 []

    let list_element = alloc_cost 2

    let set_element = alloc_cost 2

    let map_element = alloc_cost 2

    let one_arg_type = prim_cost 1

    let two_arg_type = prim_cost 2

    let set_to_list = Legacy.set_to_list

    let map_to_list = Legacy.map_to_list
  end
end
</pre>
  </div>
  <div class="col-md-6">
    <a href="#michelson_v1_gas.ml"><code>Michelson_v1_gas.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Script_int_repr.
Require Tezos.Script_typed_ir.

Import Alpha_context.

Import Alpha_context.Gas.

Module Cost_of.
  Definition log2 : int -&gt; int :=
    let fix help (acc : int) (function_parameter : int) {struct acc} : int :=
      match function_parameter with
      | 0 =&gt; acc
      | n =&gt; help (Pervasives.op_plus acc 1) (Pervasives.op_div n 2)
      end in
    help 1.
  
  Definition z_bytes (z : Z.t) : int :=
    let bits := Z.numbits z in
    Pervasives.op_div (Pervasives.op_plus 7 bits) 8.
  
  Definition int_bytes (z : Alpha_context.Script_int.num) : int :=
    z_bytes (Alpha_context.Script_int.to_zint z).
  
  Definition timestamp_bytes (__t_value : Alpha_context.Script_timestamp.t)
    : int :=
    let z := Alpha_context.Script_timestamp.to_zint __t_value in
    z_bytes z.
  
  Fixpoint size_of_comparable {a : Set}
    (wit : Script_typed_ir.comparable_struct) (v : a) {struct wit} : int :=
    match (wit, v) with
    | (Script_typed_ir.Int_key _, _ as v) =&gt;
      let v := cast Script_int_repr.num v in
      int_bytes v
    
    | (Script_typed_ir.Nat_key _, _ as v) =&gt;
      let v := cast Script_int_repr.num v in
      int_bytes v
    
    | (Script_typed_ir.String_key _, _ as v) =&gt;
      let v := cast string v in
      String.length v
    
    | (Script_typed_ir.Bytes_key _, _ as v) =&gt;
      let v := cast MBytes.t v in
      MBytes.length v
    
    | (Script_typed_ir.Bool_key _, _) =&gt; 8
    
    | (Script_typed_ir.Key_hash_key _, _) =&gt;
      (|Signature.Public_key_hash|).(S.SPublic_key_hash.size)
    
    | (Script_typed_ir.Timestamp_key _, _ as v) =&gt;
      let v := cast Alpha_context.Script_timestamp.t v in
      timestamp_bytes v
    
    | (Script_typed_ir.Address_key _, _) =&gt;
      (|Signature.Public_key_hash|).(S.SPublic_key_hash.size)
    
    | (Script_typed_ir.Mutez_key _, _) =&gt; 8
    
    | (Script_typed_ir.Pair_key (l, _) (__r_value, _) _, _ as v) =&gt;
      let 'existT _ [__0, __1] [l, __r_value, v] :=
        cast_exists (Es := [Set ** Set])
          (fun '[__0, __1] =&gt;
            [Script_typed_ir.comparable_struct **
              Script_typed_ir.comparable_struct ** __0 * __1]) [l, __r_value, v]
        in
      let '(lval, rval) := v in
      Pervasives.op_plus (size_of_comparable l lval)
        (size_of_comparable __r_value rval)
    end.
  
  Definition __string_value (length : int) : Alpha_context.Gas.cost :=
    Alpha_context.Gas.alloc_bytes_cost length.
  
  Definition __bytes_value (length : int) : Alpha_context.Gas.cost :=
    Alpha_context.Gas.alloc_mbytes_cost length.
  
  Definition manager_operation : Alpha_context.Gas.cost :=
    Alpha_context.Gas.step_cost 10000.
  
  Module Legacy.
    Definition zint (z : Z.t) : Alpha_context.Gas.cost :=
      Alpha_context.Gas.alloc_bits_cost (Z.numbits z).
    
    Definition set_to_list {item : Set} (Box : Script_typed_ir.set item)
      : Alpha_context.Gas.cost :=
      let 'existS _ _ Box := Box in
      Alpha_context.Gas.alloc_cost
        (Pervasives.op_star Box.(Script_typed_ir.Boxed_set.size) 2).
    
    Definition map_to_list {key value : Set}
      (Box : Script_typed_ir.map key value) : Alpha_context.Gas.cost :=
      let 'existS _ _ Box := Box in
      let size := Pervasives.snd Box.(Script_typed_ir.Boxed_map.boxed) in
      Alpha_context.Gas.op_starat 3 (Alpha_context.Gas.alloc_cost size).
    
    Definition z_to_int64 : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.step_cost 2)
        (Alpha_context.Gas.alloc_cost 1).
    
    Definition __hash_value (data : MBytes.t) (len : int)
      : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat
        (Alpha_context.Gas.op_starat 10
          (Alpha_context.Gas.step_cost (MBytes.length data)))
        (__bytes_value len).
    
    Definition set_access {elt : Set}
      (_key : elt) (Box : Script_typed_ir.set elt) : int :=
      let 'existS _ _ Box := Box in
      log2 Box.(Script_typed_ir.Boxed_set.size).
    
    Definition set_update {A B : Set}
      (__key_value : A) (_presence : B) (set : Script_typed_ir.set A)
      : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_starat (set_access __key_value set)
        (Alpha_context.Gas.alloc_cost 3).
  End Legacy.
  
  Module Interpreter.
    Definition cycle : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition nop : Alpha_context.Gas.cost := Alpha_context.Gas.free.
    
    Definition stack_op : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition push : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition wrap : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition variant_no_data : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition branch : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition pair : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition pair_access : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition __cons_value : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition loop_size : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 5.
    
    Definition loop_cycle : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition loop_iter : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 20.
    
    Definition loop_map : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 30.
    
    Definition empty_set : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition set_to_list {elt : Set} (Box : Script_typed_ir.set elt)
      : Alpha_context.Gas.cost :=
      let 'existS _ _ Box := Box in
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_star Box.(Script_typed_ir.Boxed_set.size) 20).
    
    Definition set_mem {elt : Set}
      (__elt_value : elt) (Box : Script_typed_ir.set elt)
      : Alpha_context.Gas.cost :=
      let 'existS _ _ Box := Box in
      let elt_bytes :=
        size_of_comparable Box.(Script_typed_ir.Boxed_set.elt_ty) __elt_value in
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_star
          (Pervasives.op_plus 1 (Pervasives.op_div elt_bytes 82))
          (log2 Box.(Script_typed_ir.Boxed_set.size))).
    
    Definition set_update {elt : Set}
      (__elt_value : elt) (function_parameter : bool)
      : Script_typed_ir.set elt -&gt; Alpha_context.Gas.cost :=
      let '_ := function_parameter in
      fun Box =&gt;
        let 'existS _ _ Box := Box in
        let elt_bytes :=
          size_of_comparable Box.(Script_typed_ir.Boxed_set.elt_ty) __elt_value
          in
        Alpha_context.Gas.atomic_step_cost
          (Pervasives.op_star
            (Pervasives.op_plus 1 (Pervasives.op_div elt_bytes 82))
            (log2 Box.(Script_typed_ir.Boxed_set.size))).
    
    Definition set_size : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition empty_map : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition map_to_list {key value : Set}
      (Box : Script_typed_ir.map key value) : Alpha_context.Gas.cost :=
      let 'existS _ _ Box := Box in
      let size := Pervasives.snd Box.(Script_typed_ir.Boxed_map.boxed) in
      Alpha_context.Gas.atomic_step_cost (Pervasives.op_star size 20).
    
    Definition map_access {key value : Set}
      (__key_value : key) (Box : Script_typed_ir.map key value)
      : Alpha_context.Gas.cost :=
      let 'existS _ _ Box := Box in
      let map_card := Pervasives.snd Box.(Script_typed_ir.Boxed_map.boxed) in
      let key_bytes :=
        size_of_comparable Box.(Script_typed_ir.Boxed_map.key_ty) __key_value in
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_star
          (Pervasives.op_plus 1 (Pervasives.op_div key_bytes 70))
          (log2 map_card)).
    
    Definition map_mem {A B : Set}
      : A -&gt; Script_typed_ir.map A B -&gt; Alpha_context.Gas.cost := map_access.
    
    Definition map_get {A B : Set}
      : A -&gt; Script_typed_ir.map A B -&gt; Alpha_context.Gas.cost := map_access.
    
    Definition map_update {key value : Set}
      (__key_value : key) (_value : option value)
      (Box : Script_typed_ir.map key value) : Alpha_context.Gas.cost :=
      let 'existS _ _ Box := Box in
      let map_card := Pervasives.snd Box.(Script_typed_ir.Boxed_map.boxed) in
      let key_bytes :=
        size_of_comparable Box.(Script_typed_ir.Boxed_map.key_ty) __key_value in
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_star
          (Pervasives.op_plus 1 (Pervasives.op_div key_bytes 38))
          (log2 map_card)).
    
    Definition map_size : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition add_timestamp
      (t1 : Alpha_context.Script_timestamp.t)
      (t2 : Alpha_context.Script_int.num) : Alpha_context.Gas.cost :=
      let bytes1 := timestamp_bytes t1 in
      let bytes2 := int_bytes t2 in
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 51
          (Pervasives.op_div ((|Compare.Int|).(Compare.S.max) bytes1 bytes2) 62)).
    
    Definition sub_timestamp
      : Alpha_context.Script_timestamp.t -&gt; Alpha_context.Script_int.num -&gt;
      Alpha_context.Gas.cost := add_timestamp.
    
    Definition diff_timestamps
      (t1 : Alpha_context.Script_timestamp.t)
      (t2 : Alpha_context.Script_timestamp.t) : Alpha_context.Gas.cost :=
      let bytes1 := timestamp_bytes t1 in
      let bytes2 := timestamp_bytes t2 in
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 51
          (Pervasives.op_div ((|Compare.Int|).(Compare.S.max) bytes1 bytes2) 62)).
    
    Fixpoint concat_loop {A : Set} (l : list A) (acc : int) {struct l} : int :=
      match l with
      | [] =&gt; 30
      | cons _ tl =&gt; concat_loop tl (Pervasives.op_plus acc 30)
      end.
    
    Definition concat_string {A : Set} (string_list : list A)
      : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost (concat_loop string_list 0).
    
    Definition slice_string (string_length : int) : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 40 (Pervasives.op_div string_length 70)).
    
    Definition concat_bytes {A : Set} (bytes_list : list A)
      : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost (concat_loop bytes_list 0).
    
    Definition int64_op : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 61.
    
    Definition z_to_int64 : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 20.
    
    Definition int64_to_z : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 20.
    
    Definition bool_binop {A B : Set} (function_parameter : A)
      : B -&gt; Alpha_context.Gas.cost :=
      let '_ := function_parameter in
      fun function_parameter =&gt;
        let '_ := function_parameter in
        Alpha_context.Gas.atomic_step_cost 10.
    
    Definition bool_unop {A : Set} (function_parameter : A)
      : Alpha_context.Gas.cost :=
      let '_ := function_parameter in
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition abs (__int_value : Alpha_context.Script_int.num)
      : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 61 (Pervasives.op_div (int_bytes __int_value) 70)).
    
    Definition __int_value {A : Set} (_int : A) : Alpha_context.Gas.cost :=
      Alpha_context.Gas.free.
    
    Definition neg : Alpha_context.Script_int.num -&gt; Alpha_context.Gas.cost :=
      abs.
    
    Definition add
      (i1 : Alpha_context.Script_int.num) (i2 : Alpha_context.Script_int.num)
      : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 51
          (Pervasives.op_div
            ((|Compare.Int|).(Compare.S.max) (int_bytes i1) (int_bytes i2)) 62)).
    
    Definition sub
      : Alpha_context.Script_int.num -&gt; Alpha_context.Script_int.num -&gt;
      Alpha_context.Gas.cost := add.
    
    Definition mul
      (i1 : Alpha_context.Script_int.num) (i2 : Alpha_context.Script_int.num)
      : Alpha_context.Gas.cost :=
      let __bytes_value :=
        (|Compare.Int|).(Compare.S.max) (int_bytes i1) (int_bytes i2) in
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 51
          (Pervasives.op_star (Pervasives.op_div __bytes_value 6)
            (log2 __bytes_value))).
    
    Definition indic_lt
      (x : (|Compare.Int|).(Compare.S.t)) (y : (|Compare.Int|).(Compare.S.t))
      : int :=
      if (|Compare.Int|).(Compare.S.op_lt) x y then
        1
      else
        0.
    
    Definition div
      (i1 : Alpha_context.Script_int.num) (i2 : Alpha_context.Script_int.num)
      : Alpha_context.Gas.cost :=
      let bytes1 := int_bytes i1 in
      let bytes2 := int_bytes i2 in
      let cost :=
        Pervasives.op_star
          (Pervasives.op_star (indic_lt bytes2 bytes1)
            (Pervasives.op_minus bytes1 bytes2)) bytes2 in
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 51 (Pervasives.op_div cost 3151)).
    
    Definition shift_left {A B : Set} (_i : A) (_shift_bits : B)
      : Alpha_context.Gas.cost := Alpha_context.Gas.atomic_step_cost 30.
    
    Definition shift_right {A B : Set} (_i : A) (_shift_bits : B)
      : Alpha_context.Gas.cost := Alpha_context.Gas.atomic_step_cost 30.
    
    Definition logor
      (i1 : Alpha_context.Script_int.num) (i2 : Alpha_context.Script_int.num)
      : Alpha_context.Gas.cost :=
      let bytes1 := int_bytes i1 in
      let bytes2 := int_bytes i2 in
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 51
          (Pervasives.op_div ((|Compare.Int|).(Compare.S.max) bytes1 bytes2) 70)).
    
    Definition logand
      (i1 : Alpha_context.Script_int.num) (i2 : Alpha_context.Script_int.num)
      : Alpha_context.Gas.cost :=
      let bytes1 := int_bytes i1 in
      let bytes2 := int_bytes i2 in
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 51
          (Pervasives.op_div ((|Compare.Int|).(Compare.S.min) bytes1 bytes2) 70)).
    
    Definition logxor
      : Alpha_context.Script_int.num -&gt; Alpha_context.Script_int.num -&gt;
      Alpha_context.Gas.cost := logor.
    
    Definition lognot (i : Alpha_context.Script_int.num)
      : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 51 (Pervasives.op_div (int_bytes i) 20)).
    
    Definition exec : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition compare_bool {A B : Set} (function_parameter : A)
      : B -&gt; Alpha_context.Gas.cost :=
      let '_ := function_parameter in
      fun function_parameter =&gt;
        let '_ := function_parameter in
        Alpha_context.Gas.atomic_step_cost 30.
    
    Definition compare_string (s1 : string) (s2 : string)
      : Alpha_context.Gas.cost :=
      let bytes1 := String.length s1 in
      let bytes2 := String.length s2 in
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 30
          (Pervasives.op_div ((|Compare.Int|).(Compare.S.min) bytes1 bytes2) 123)).
    
    Definition compare_bytes (b1 : MBytes.t) (b2 : MBytes.t)
      : Alpha_context.Gas.cost :=
      let bytes1 := MBytes.length b1 in
      let bytes2 := MBytes.length b2 in
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 30
          (Pervasives.op_div ((|Compare.Int|).(Compare.S.min) bytes1 bytes2) 123)).
    
    Definition compare_tez {A B : Set} (function_parameter : A)
      : B -&gt; Alpha_context.Gas.cost :=
      let '_ := function_parameter in
      fun function_parameter =&gt;
        let '_ := function_parameter in
        Alpha_context.Gas.atomic_step_cost 30.
    
    Definition compare_zint
      (i1 : Alpha_context.Script_int.num) (i2 : Alpha_context.Script_int.num)
      : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 51
          (Pervasives.op_div
            ((|Compare.Int|).(Compare.S.min) (int_bytes i1) (int_bytes i2)) 82)).
    
    Definition compare_key_hash {A B : Set} (function_parameter : A)
      : B -&gt; Alpha_context.Gas.cost :=
      let '_ := function_parameter in
      fun function_parameter =&gt;
        let '_ := function_parameter in
        Alpha_context.Gas.atomic_step_cost 92.
    
    Definition compare_timestamp
      (t1 : Alpha_context.Script_timestamp.t)
      (t2 : Alpha_context.Script_timestamp.t) : Alpha_context.Gas.cost :=
      let bytes1 := timestamp_bytes t1 in
      let bytes2 := timestamp_bytes t2 in
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 51
          (Pervasives.op_div ((|Compare.Int|).(Compare.S.min) bytes1 bytes2) 82)).
    
    Definition compare_address {A B : Set} (function_parameter : A)
      : B -&gt; Alpha_context.Gas.cost :=
      let '_ := function_parameter in
      fun function_parameter =&gt;
        let '_ := function_parameter in
        Alpha_context.Gas.atomic_step_cost 92.
    
    Definition compare_res : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 30.
    
    Definition unpack_failed (__bytes_value : MBytes.t)
      : Alpha_context.Gas.cost :=
      let len := MBytes.length __bytes_value in
      Alpha_context.Gas.op_plusat
        (Alpha_context.Gas.op_starat len (Alpha_context.Gas.alloc_mbytes_cost 1))
        (Alpha_context.Gas.op_starat len
          (Alpha_context.Gas.op_starat (log2 len)
            (Alpha_context.Gas.op_plusat (Alpha_context.Gas.alloc_cost 3)
              (Alpha_context.Gas.step_cost 1)))).
    
    Definition address : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition contract : Alpha_context.Gas.cost :=
      Alpha_context.Gas.step_cost 10000.
    
    Definition transfer : Alpha_context.Gas.cost :=
      Alpha_context.Gas.step_cost 10.
    
    Definition create_account : Alpha_context.Gas.cost :=
      Alpha_context.Gas.step_cost 10.
    
    Definition create_contract : Alpha_context.Gas.cost :=
      Alpha_context.Gas.step_cost 10.
    
    Definition implicit_account : Alpha_context.Gas.cost :=
      Alpha_context.Gas.step_cost 10.
    
    Definition set_delegate : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.step_cost 10)
        (Alpha_context.Gas.write_bytes_cost (Z.of_int 32)).
    
    Definition balance : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition now : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition check_signature_secp256k1 (__bytes_value : int)
      : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 10342 (Pervasives.op_div __bytes_value 5)).
    
    Definition check_signature_ed25519 (__bytes_value : int)
      : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 36864 (Pervasives.op_div __bytes_value 5)).
    
    Definition check_signature_p256 (__bytes_value : int)
      : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 36864 (Pervasives.op_div __bytes_value 5)).
    
    Definition check_signature
      (pkey : Signature.public_key) (__bytes_value : MBytes.t)
      : Alpha_context.Gas.cost :=
      match pkey with
      | Signature.Ed25519 _ =&gt;
        check_signature_ed25519 (MBytes.length __bytes_value)
      | Signature.Secp256k1 _ =&gt;
        check_signature_secp256k1 (MBytes.length __bytes_value)
      | Signature.P256 _ =&gt; check_signature_p256 (MBytes.length __bytes_value)
      end.
    
    Definition hash_key : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 30.
    
    Definition hash_blake2b (__b_value : MBytes.t) : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 102 (Pervasives.op_div (MBytes.length __b_value) 5)).
    
    Definition hash_sha256 (__b_value : MBytes.t) : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 409 (MBytes.length __b_value)).
    
    Definition hash_sha512 (__b_value : MBytes.t) : Alpha_context.Gas.cost :=
      let __bytes_value := MBytes.length __b_value in
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 409
          (Pervasives.op_plus (Pervasives.lsr __bytes_value 1)
            (Pervasives.lsr __bytes_value 4))).
    
    Definition steps_to_quota : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition source : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition self : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition amount : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost 10.
    
    Definition chain_id : Alpha_context.Gas.cost :=
      Alpha_context.Gas.step_cost 1.
    
    Definition stack_n_op (n : int) : Alpha_context.Gas.cost :=
      Alpha_context.Gas.atomic_step_cost
        (Pervasives.op_plus 20
          (Pervasives.op_plus
            (Pervasives.op_plus (Pervasives.lsr n 1) (Pervasives.lsr n 2))
            (Pervasives.lsr n 4))).
    
    Definition apply : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.alloc_cost 8)
        (Alpha_context.Gas.step_cost 1).
    
    Fixpoint compare {a : Set}
      (ty : Script_typed_ir.comparable_struct) (x : a) (y : a) {struct ty}
      : Alpha_context.Gas.cost :=
      match (ty, x, y) with
      | (Script_typed_ir.Bool_key _, _ as x, _ as y) =&gt;
        let '[x, y] := cast [bool ** bool] [x, y] in
        compare_bool x y
      
      | (Script_typed_ir.String_key _, _ as x, _ as y) =&gt;
        let '[x, y] := cast [string ** string] [x, y] in
        compare_string x y
      
      | (Script_typed_ir.Bytes_key _, _ as x, _ as y) =&gt;
        let '[x, y] := cast [MBytes.t ** MBytes.t] [x, y] in
        compare_bytes x y
      
      | (Script_typed_ir.Mutez_key _, x, y) =&gt;
        let '[x, y] := cast [a ** a] [x, y] in
        compare_tez x y
      
      | (Script_typed_ir.Int_key _, _ as x, _ as y) =&gt;
        let '[x, y] := cast [Script_int_repr.num ** Script_int_repr.num] [x, y]
          in
        compare_zint x y
      
      | (Script_typed_ir.Nat_key _, _ as x, _ as y) =&gt;
        let '[x, y] := cast [Script_int_repr.num ** Script_int_repr.num] [x, y]
          in
        compare_zint x y
      
      | (Script_typed_ir.Key_hash_key _, x, y) =&gt;
        let '[x, y] := cast [a ** a] [x, y] in
        compare_key_hash x y
      
      | (Script_typed_ir.Timestamp_key _, _ as x, _ as y) =&gt;
        let '[x, y] :=
          cast
            [Alpha_context.Script_timestamp.t **
              Alpha_context.Script_timestamp.t] [x, y] in
        compare_timestamp x y
      
      | (Script_typed_ir.Address_key _, x, y) =&gt;
        let '[x, y] := cast [a ** a] [x, y] in
        compare_address x y
      
      | (Script_typed_ir.Pair_key (tl, _) (tr, _) _, _ as x, _ as y) =&gt;
        let 'existT _ [__0, __1] [tl, tr, x, y] :=
          cast_exists (Es := [Set ** Set])
            (fun '[__0, __1] =&gt;
              [Script_typed_ir.comparable_struct **
                Script_typed_ir.comparable_struct ** __0 * __1 ** __0 * __1])
            [tl, tr, x, y] in
        let '(xl, xr) := x in
        let '(yl, yr) := y in
        Alpha_context.Gas.op_plusat (compare tl xl yl) (compare tr xr yr)
      end.
  End Interpreter.
  
  Module Typechecking.
    Definition cycle : Alpha_context.Gas.cost := Alpha_context.Gas.step_cost 1.
    
    Definition __bool_value : Alpha_context.Gas.cost := Alpha_context.Gas.free.
    
    Definition __unit_value : Alpha_context.Gas.cost := Alpha_context.Gas.free.
    
    Definition __string_value : int -&gt; Alpha_context.Gas.cost := __string_value.
    
    Definition __bytes_value : int -&gt; Alpha_context.Gas.cost := __bytes_value.
    
    Definition z : Z.t -&gt; Alpha_context.Gas.cost := Legacy.zint.
    
    Definition int_of_string (str : string) : Alpha_context.Gas.cost :=
      Alpha_context.Gas.alloc_cost (Pervasives.op_div (String.length str) 5).
    
    Definition tez : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.step_cost 1)
        (Alpha_context.Gas.alloc_cost 1).
    
    Definition string_timestamp : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.step_cost 3)
        (Alpha_context.Gas.alloc_cost 3).
    
    Definition __key_value : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.step_cost 3)
        (Alpha_context.Gas.alloc_cost 3).
    
    Definition key_hash : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.step_cost 1)
        (Alpha_context.Gas.alloc_cost 1).
    
    Definition signature : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.step_cost 1)
        (Alpha_context.Gas.alloc_cost 1).
    
    Definition chain_id : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.step_cost 1)
        (Alpha_context.Gas.alloc_cost 1).
    
    Definition contract : Alpha_context.Gas.cost :=
      Alpha_context.Gas.step_cost 5.
    
    Definition get_script : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.step_cost 20)
        (Alpha_context.Gas.alloc_cost 5).
    
    Definition contract_exists : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.step_cost 15)
        (Alpha_context.Gas.alloc_cost 5).
    
    Definition pair : Alpha_context.Gas.cost := Alpha_context.Gas.alloc_cost 2.
    
    Definition union : Alpha_context.Gas.cost := Alpha_context.Gas.alloc_cost 1.
    
    Definition lambda : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.alloc_cost 5)
        (Alpha_context.Gas.step_cost 3).
    
    Definition some : Alpha_context.Gas.cost := Alpha_context.Gas.alloc_cost 1.
    
    Definition none : Alpha_context.Gas.cost := Alpha_context.Gas.alloc_cost 0.
    
    Definition list_element : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.alloc_cost 2)
        (Alpha_context.Gas.step_cost 1).
    
    Definition set_element (size : int) : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_starat (log2 size)
        (Alpha_context.Gas.op_plusat (Alpha_context.Gas.alloc_cost 3)
          (Alpha_context.Gas.step_cost 2)).
    
    Definition map_element (size : int) : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_starat (log2 size)
        (Alpha_context.Gas.op_plusat (Alpha_context.Gas.alloc_cost 4)
          (Alpha_context.Gas.step_cost 2)).
    
    Definition primitive_type : Alpha_context.Gas.cost :=
      Alpha_context.Gas.alloc_cost 1.
    
    Definition one_arg_type : Alpha_context.Gas.cost :=
      Alpha_context.Gas.alloc_cost 2.
    
    Definition two_arg_type : Alpha_context.Gas.cost :=
      Alpha_context.Gas.alloc_cost 3.
    
    Definition operation (__b_value : int) : Alpha_context.Gas.cost :=
      __bytes_value __b_value.
    
    Definition type_ (nb_args : int) : Alpha_context.Gas.cost :=
      Alpha_context.Gas.alloc_cost (Pervasives.op_plus nb_args 1).
    
    Definition instr (i : Script_typed_ir.instr) : Alpha_context.Gas.cost :=
      Alpha_context.Gas.op_plusat (Alpha_context.Gas.alloc_cost 1)
        match i with
        | Script_typed_ir.Drop =&gt; Alpha_context.Gas.alloc_cost 0
        | Script_typed_ir.Dup =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Swap =&gt; Alpha_context.Gas.alloc_cost 0
        | Script_typed_ir.Const _ =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Cons_pair =&gt; Alpha_context.Gas.alloc_cost 2
        | Script_typed_ir.Car =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Cdr =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Cons_some =&gt; Alpha_context.Gas.alloc_cost 2
        | Script_typed_ir.Cons_none _ =&gt; Alpha_context.Gas.alloc_cost 3
        | Script_typed_ir.If_none _ _ =&gt; Alpha_context.Gas.alloc_cost 2
        | Script_typed_ir.Left =&gt; Alpha_context.Gas.alloc_cost 3
        | Script_typed_ir.Right =&gt; Alpha_context.Gas.alloc_cost 3
        | Script_typed_ir.If_left _ _ =&gt; Alpha_context.Gas.alloc_cost 2
        | Script_typed_ir.Cons_list =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Nil =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.If_cons _ _ =&gt; Alpha_context.Gas.alloc_cost 2
        | Script_typed_ir.List_map _ =&gt; Alpha_context.Gas.alloc_cost 5
        | Script_typed_ir.List_iter _ =&gt; Alpha_context.Gas.alloc_cost 4
        | Script_typed_ir.List_size =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Empty_set _ =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Set_iter _ =&gt; Alpha_context.Gas.alloc_cost 4
        | Script_typed_ir.Set_mem =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Set_update =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Set_size =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Empty_map _ _ =&gt; Alpha_context.Gas.alloc_cost 2
        | Script_typed_ir.Map_map _ =&gt; Alpha_context.Gas.alloc_cost 5
        | Script_typed_ir.Map_iter _ =&gt; Alpha_context.Gas.alloc_cost 4
        | Script_typed_ir.Map_mem =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Map_get =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Map_update =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Map_size =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Empty_big_map _ _ =&gt; Alpha_context.Gas.alloc_cost 2
        | Script_typed_ir.Big_map_mem =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Big_map_get =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Big_map_update =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Concat_string =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Concat_string_pair =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Concat_bytes =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Concat_bytes_pair =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Slice_string =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Slice_bytes =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.String_size =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Bytes_size =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Add_seconds_to_timestamp =&gt;
          Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Add_timestamp_to_seconds =&gt;
          Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Sub_timestamp_seconds =&gt;
          Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Diff_timestamps =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Add_tez =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Sub_tez =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Mul_teznat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Mul_nattez =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Ediv_teznat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Ediv_tez =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Or =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.And =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Xor =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Not =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Is_nat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Neg_nat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Neg_int =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Abs_int =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Int_nat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Add_intint =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Add_intnat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Add_natint =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Add_natnat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Sub_int =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Mul_intint =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Mul_intnat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Mul_natint =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Mul_natnat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Ediv_intint =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Ediv_intnat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Ediv_natint =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Ediv_natnat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Lsl_nat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Lsr_nat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Or_nat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.And_nat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.And_int_nat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Xor_nat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Not_nat =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Not_int =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Seq _ _ =&gt; Alpha_context.Gas.alloc_cost 8
        | Script_typed_ir.If _ _ =&gt; Alpha_context.Gas.alloc_cost 8
        | Script_typed_ir.Loop _ =&gt; Alpha_context.Gas.alloc_cost 4
        | Script_typed_ir.Loop_left _ =&gt; Alpha_context.Gas.alloc_cost 5
        | Script_typed_ir.Dip _ =&gt; Alpha_context.Gas.alloc_cost 4
        | Script_typed_ir.Exec =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Apply _ =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Lambda _ =&gt; Alpha_context.Gas.alloc_cost 2
        | Script_typed_ir.Failwith _ =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Nop =&gt; Alpha_context.Gas.alloc_cost 0
        | Script_typed_ir.Compare _ =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Eq =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Neq =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Lt =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Gt =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Le =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Ge =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Address =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Contract _ _ =&gt; Alpha_context.Gas.alloc_cost 2
        | Script_typed_ir.Transfer_tokens =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Create_account =&gt; Alpha_context.Gas.alloc_cost 2
        | Script_typed_ir.Implicit_account =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Create_contract _ _ _ _ =&gt;
          Alpha_context.Gas.alloc_cost 8
        | Script_typed_ir.Create_contract_2 _ _ _ _ =&gt;
          Alpha_context.Gas.alloc_cost 7
        | Script_typed_ir.Set_delegate =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Now =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Balance =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Check_signature =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Hash_key =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Pack _ =&gt; Alpha_context.Gas.alloc_cost 2
        | Script_typed_ir.Unpack _ =&gt; Alpha_context.Gas.alloc_cost 2
        | Script_typed_ir.Blake2b =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Sha256 =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Sha512 =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Steps_to_quota =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Source =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Sender =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Self _ _ =&gt; Alpha_context.Gas.alloc_cost 2
        | Script_typed_ir.Amount =&gt; Alpha_context.Gas.alloc_cost 1
        | Script_typed_ir.Dig n _ =&gt;
          Alpha_context.Gas.op_starat n (Alpha_context.Gas.alloc_cost 1)
        | Script_typed_ir.Dug n _ =&gt;
          Alpha_context.Gas.op_starat n (Alpha_context.Gas.alloc_cost 1)
        | Script_typed_ir.Dipn n _ _ =&gt;
          Alpha_context.Gas.op_starat n (Alpha_context.Gas.alloc_cost 1)
        | Script_typed_ir.Dropn n _ =&gt;
          Alpha_context.Gas.op_starat n (Alpha_context.Gas.alloc_cost 1)
        | Script_typed_ir.ChainId =&gt; Alpha_context.Gas.alloc_cost 1
        end.
  End Typechecking.
  
  Module Unparse.
    Definition prim_cost (l : int) (annot : Alpha_context.Script.annot)
      : Alpha_context.Gas.cost :=
      Alpha_context.Script.prim_node_cost_nonrec_of_length l annot.
    
    Definition seq_cost : int -&gt; Alpha_context.Gas.cost :=
      Alpha_context.Script.seq_node_cost_nonrec_of_length.
    
    Definition string_cost (length : int) : Alpha_context.Gas.cost :=
      Alpha_context.Script.string_node_cost_of_length length.
    
    Definition cycle : Alpha_context.Gas.cost := Alpha_context.Gas.step_cost 1.
    
    Definition __bool_value : Alpha_context.Gas.cost := prim_cost 0 nil.
    
    Definition __unit_value : Alpha_context.Gas.cost := prim_cost 0 nil.
    
    Definition __string_value (s : string) : Alpha_context.Gas.cost :=
      Alpha_context.Script.string_node_cost s.
    
    Definition __bytes_value (s : MBytes.t) : Alpha_context.Gas.cost :=
      Alpha_context.Script.bytes_node_cost s.
    
    Definition z (i : Z.t) : Alpha_context.Gas.cost :=
      Alpha_context.Script.int_node_cost i.
    
    Definition __int_value (i : Alpha_context.Script_int.num)
      : Alpha_context.Gas.cost :=
      Alpha_context.Script.int_node_cost (Alpha_context.Script_int.to_zint i).
    
    Definition tez : Alpha_context.Gas.cost :=
      Alpha_context.Script.int_node_cost_of_numbits 60.
    
    Definition timestamp (x : Alpha_context.Script_timestamp.t)
      : Alpha_context.Gas.cost :=
      __int_value
        (Alpha_context.Script_int.of_zint
          (Alpha_context.Script_timestamp.to_zint x)).
    
    Definition operation (__bytes_value : MBytes.t) : Alpha_context.Gas.cost :=
      Alpha_context.Script.bytes_node_cost __bytes_value.
    
    Definition chain_id (__bytes_value : MBytes.t) : Alpha_context.Gas.cost :=
      Alpha_context.Script.bytes_node_cost __bytes_value.
    
    Definition __key_value : Alpha_context.Gas.cost := string_cost 54.
    
    Definition key_hash : Alpha_context.Gas.cost := string_cost 36.
    
    Definition signature : Alpha_context.Gas.cost := string_cost 128.
    
    Definition contract : Alpha_context.Gas.cost := string_cost 36.
    
    Definition pair : Alpha_context.Gas.cost := prim_cost 2 nil.
    
    Definition union : Alpha_context.Gas.cost := prim_cost 1 nil.
    
    Definition some : Alpha_context.Gas.cost := prim_cost 1 nil.
    
    Definition none : Alpha_context.Gas.cost := prim_cost 0 nil.
    
    Definition list_element : Alpha_context.Gas.cost :=
      Alpha_context.Gas.alloc_cost 2.
    
    Definition set_element : Alpha_context.Gas.cost :=
      Alpha_context.Gas.alloc_cost 2.
    
    Definition map_element : Alpha_context.Gas.cost :=
      Alpha_context.Gas.alloc_cost 2.
    
    Definition one_arg_type
      : Alpha_context.Script.annot -&gt; Alpha_context.Gas.cost := prim_cost 1.
    
    Definition two_arg_type
      : Alpha_context.Script.annot -&gt; Alpha_context.Gas.cost := prim_cost 2.
    
    Definition set_to_list {A : Set}
      : Script_typed_ir.set A -&gt; Alpha_context.Gas.cost := Legacy.set_to_list.
    
    Definition map_to_list {A B : Set}
      : Script_typed_ir.map A B -&gt; Alpha_context.Gas.cost := Legacy.map_to_list.
  End Unparse.
End Cost_of.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="michelson_v1_gas.mli">
  <div style="margin: 20px;">
    <h3>Michelson_v1_gas_mli</h3>
    <ul>
      <li>OCaml size: 316 lines</li>
      <li>Coq size: 341 lines (+7% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#michelson_v1_gas.mli"><code>michelson_v1_gas.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

module Cost_of : sig
  val manager_operation : Gas.cost

  module Legacy : sig
    val z_to_int64 : Gas.cost

    val hash : MBytes.t -&gt; int -&gt; Gas.cost

    val map_to_list : ('b, 'c) Script_typed_ir.map -&gt; Gas.cost

    val set_update : 'a -&gt; bool -&gt; 'a Script_typed_ir.set -&gt; Gas.cost
  end

  module Interpreter : sig
    val cycle : Gas.cost

    val loop_cycle : Gas.cost

    val loop_size : Gas.cost

    val loop_iter : Gas.cost

    val loop_map : Gas.cost

    val nop : Gas.cost

    val stack_op : Gas.cost

    val stack_n_op : int -&gt; Gas.cost

    val bool_binop : 'a -&gt; 'b -&gt; Gas.cost

    val bool_unop : 'a -&gt; Gas.cost

    val pair : Gas.cost

    val pair_access : Gas.cost

    val cons : Gas.cost

    val variant_no_data : Gas.cost

    val branch : Gas.cost

    val concat_string : string list -&gt; Gas.cost

    val concat_bytes : MBytes.t list -&gt; Gas.cost

    val slice_string : int -&gt; Gas.cost

    val map_mem : 'a -&gt; ('a, 'b) Script_typed_ir.map -&gt; Gas.cost

    val map_to_list : ('a, 'b) Script_typed_ir.map -&gt; Gas.cost

    val map_get : 'a -&gt; ('a, 'b) Script_typed_ir.map -&gt; Gas.cost

    val map_update :
      'a -&gt; 'b option -&gt; ('a, 'b) Script_typed_ir.map -&gt; Gas.cost

    val map_size : Gas.cost

    val set_to_list : 'a Script_typed_ir.set -&gt; Gas.cost

    val set_update : 'a -&gt; bool -&gt; 'a Script_typed_ir.set -&gt; Gas.cost

    val set_mem : 'a -&gt; 'a Script_typed_ir.set -&gt; Gas.cost

    val mul : Script_int.num -&gt; Script_int.num -&gt; Gas.cost

    val div : Script_int.num -&gt; Script_int.num -&gt; Gas.cost

    val add : Script_int.num -&gt; Script_int.num -&gt; Gas.cost

    val sub : Script_int.num -&gt; Script_int.num -&gt; Gas.cost

    val abs : Script_int.num -&gt; Gas.cost

    val neg : Script_int.num -&gt; Gas.cost

    val int : 'a -&gt; Gas.cost

    val add_timestamp : Script_timestamp.t -&gt; Script_int.num -&gt; Gas.cost

    val sub_timestamp : Script_timestamp.t -&gt; Script_int.num -&gt; Gas.cost

    val diff_timestamps : Script_timestamp.t -&gt; Script_timestamp.t -&gt; Gas.cost

    val empty_set : Gas.cost

    val set_size : Gas.cost

    val empty_map : Gas.cost

    val int64_op : Gas.cost

    val z_to_int64 : Gas.cost

    val int64_to_z : Gas.cost

    val logor : Script_int.num -&gt; Script_int.num -&gt; Gas.cost

    val logand : Script_int.num -&gt; Script_int.num -&gt; Gas.cost

    val logxor : Script_int.num -&gt; Script_int.num -&gt; Gas.cost

    val lognot : Script_int.num -&gt; Gas.cost

    val shift_left : Script_int.num -&gt; Script_int.num -&gt; Gas.cost

    val shift_right : Script_int.num -&gt; Script_int.num -&gt; Gas.cost

    val exec : Gas.cost

    val push : Gas.cost

    val compare_res : Gas.cost

    val unpack_failed : MBytes.t -&gt; Gas.cost

    val address : Gas.cost

    val contract : Gas.cost

    val transfer : Gas.cost

    val create_account : Gas.cost

    val create_contract : Gas.cost

    val implicit_account : Gas.cost

    val set_delegate : Gas.cost

    val balance : Gas.cost

    val now : Gas.cost

    val check_signature : public_key -&gt; MBytes.t -&gt; Gas.cost

    val hash_key : Gas.cost

    val hash_blake2b : MBytes.t -&gt; Gas.cost

    val hash_sha256 : MBytes.t -&gt; Gas.cost

    val hash_sha512 : MBytes.t -&gt; Gas.cost

    val steps_to_quota : Gas.cost

    val source : Gas.cost

    val self : Gas.cost

    val amount : Gas.cost

    val chain_id : Gas.cost

    val wrap : Gas.cost

    val compare : 'a Script_typed_ir.comparable_ty -&gt; 'a -&gt; 'a -&gt; Gas.cost

    val apply : Gas.cost
  end

  module Typechecking : sig
    val cycle : Gas.cost

    val unit : Gas.cost

    val bool : Gas.cost

    val tez : Gas.cost

    val z : Z.t -&gt; Gas.cost

    val string : int -&gt; Gas.cost

    val bytes : int -&gt; Gas.cost

    val int_of_string : string -&gt; Gas.cost

    val string_timestamp : Gas.cost

    val key : Gas.cost

    val key_hash : Gas.cost

    val signature : Gas.cost

    val chain_id : Gas.cost

    val contract : Gas.cost

    (** Gas.Cost of getting the code for a contract *)
    val get_script : Gas.cost

    val contract_exists : Gas.cost

    (** Additional Gas.cost of parsing a pair over the Gas.cost of parsing each type  *)
    val pair : Gas.cost

    val union : Gas.cost

    val lambda : Gas.cost

    val some : Gas.cost

    val none : Gas.cost

    val list_element : Gas.cost

    val set_element : int -&gt; Gas.cost

    val map_element : int -&gt; Gas.cost

    val primitive_type : Gas.cost

    val one_arg_type : Gas.cost

    val two_arg_type : Gas.cost

    val operation : int -&gt; Gas.cost

    (** Cost of parsing a type *)
    val type_ : int -&gt; Gas.cost

    (** Cost of parsing an instruction *)
    val instr : ('a, 'b) Script_typed_ir.instr -&gt; Gas.cost
  end

  module Unparse : sig
    val prim_cost : int -&gt; Script.annot -&gt; Gas.cost

    val seq_cost : int -&gt; Gas.cost

    val cycle : Gas.cost

    val unit : Gas.cost

    val bool : Gas.cost

    val z : Z.t -&gt; Gas.cost

    val int : Script_int.num -&gt; Gas.cost

    val tez : Gas.cost

    val string : string -&gt; Gas.cost

    val bytes : MBytes.t -&gt; Gas.cost

    val timestamp : Script_timestamp.t -&gt; Gas.cost

    val key : Gas.cost

    val key_hash : Gas.cost

    val signature : Gas.cost

    val operation : MBytes.t -&gt; Gas.cost

    val chain_id : MBytes.t -&gt; Gas.cost

    val contract : Gas.cost

    (** Additional Gas.cost of parsing a pair over the Gas.cost of parsing each type  *)
    val pair : Gas.cost

    val union : Gas.cost

    val some : Gas.cost

    val none : Gas.cost

    val list_element : Gas.cost

    val set_element : Gas.cost

    val map_element : Gas.cost

    val one_arg_type : Script.annot -&gt; Gas.cost

    val two_arg_type : Script.annot -&gt; Gas.cost

    val set_to_list : 'a Script_typed_ir.set -&gt; Gas.cost

    val map_to_list : ('a, 'b) Script_typed_ir.map -&gt; Gas.cost
  end
end
</pre>
  </div>
  <div class="col-md-6">
    <a href="#michelson_v1_gas.mli"><code>Michelson_v1_gas_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Script_typed_ir.

Import Alpha_context.

Module Cost_of.
  Parameter manager_operation : Alpha_context.Gas.cost.
  
  Module Legacy.
    Parameter z_to_int64 : Alpha_context.Gas.cost.
    
    Parameter __hash_value : MBytes.t -&gt; int -&gt; Alpha_context.Gas.cost.
    
    Parameter map_to_list : forall {b c : Set},
      Script_typed_ir.map b c -&gt; Alpha_context.Gas.cost.
    
    Parameter set_update : forall {a : Set},
      a -&gt; bool -&gt; Script_typed_ir.set a -&gt; Alpha_context.Gas.cost.
  End Legacy.
  
  Module Interpreter.
    Parameter cycle : Alpha_context.Gas.cost.
    
    Parameter loop_cycle : Alpha_context.Gas.cost.
    
    Parameter loop_size : Alpha_context.Gas.cost.
    
    Parameter loop_iter : Alpha_context.Gas.cost.
    
    Parameter loop_map : Alpha_context.Gas.cost.
    
    Parameter nop : Alpha_context.Gas.cost.
    
    Parameter stack_op : Alpha_context.Gas.cost.
    
    Parameter stack_n_op : int -&gt; Alpha_context.Gas.cost.
    
    Parameter bool_binop : forall {a b : Set}, a -&gt; b -&gt; Alpha_context.Gas.cost.
    
    Parameter bool_unop : forall {a : Set}, a -&gt; Alpha_context.Gas.cost.
    
    Parameter pair : Alpha_context.Gas.cost.
    
    Parameter pair_access : Alpha_context.Gas.cost.
    
    Parameter __cons_value : Alpha_context.Gas.cost.
    
    Parameter variant_no_data : Alpha_context.Gas.cost.
    
    Parameter branch : Alpha_context.Gas.cost.
    
    Parameter concat_string : list string -&gt; Alpha_context.Gas.cost.
    
    Parameter concat_bytes : list MBytes.t -&gt; Alpha_context.Gas.cost.
    
    Parameter slice_string : int -&gt; Alpha_context.Gas.cost.
    
    Parameter map_mem : forall {a b : Set},
      a -&gt; Script_typed_ir.map a b -&gt; Alpha_context.Gas.cost.
    
    Parameter map_to_list : forall {a b : Set},
      Script_typed_ir.map a b -&gt; Alpha_context.Gas.cost.
    
    Parameter map_get : forall {a b : Set},
      a -&gt; Script_typed_ir.map a b -&gt; Alpha_context.Gas.cost.
    
    Parameter map_update : forall {a b : Set},
      a -&gt; option b -&gt; Script_typed_ir.map a b -&gt; Alpha_context.Gas.cost.
    
    Parameter map_size : Alpha_context.Gas.cost.
    
    Parameter set_to_list : forall {a : Set},
      Script_typed_ir.set a -&gt; Alpha_context.Gas.cost.
    
    Parameter set_update : forall {a : Set},
      a -&gt; bool -&gt; Script_typed_ir.set a -&gt; Alpha_context.Gas.cost.
    
    Parameter set_mem : forall {a : Set},
      a -&gt; Script_typed_ir.set a -&gt; Alpha_context.Gas.cost.
    
    Parameter mul :
      Alpha_context.Script_int.num -&gt; Alpha_context.Script_int.num -&gt;
      Alpha_context.Gas.cost.
    
    Parameter div :
      Alpha_context.Script_int.num -&gt; Alpha_context.Script_int.num -&gt;
      Alpha_context.Gas.cost.
    
    Parameter add :
      Alpha_context.Script_int.num -&gt; Alpha_context.Script_int.num -&gt;
      Alpha_context.Gas.cost.
    
    Parameter sub :
      Alpha_context.Script_int.num -&gt; Alpha_context.Script_int.num -&gt;
      Alpha_context.Gas.cost.
    
    Parameter abs : Alpha_context.Script_int.num -&gt; Alpha_context.Gas.cost.
    
    Parameter neg : Alpha_context.Script_int.num -&gt; Alpha_context.Gas.cost.
    
    Parameter __int_value : forall {a : Set}, a -&gt; Alpha_context.Gas.cost.
    
    Parameter add_timestamp :
      Alpha_context.Script_timestamp.t -&gt; Alpha_context.Script_int.num -&gt;
      Alpha_context.Gas.cost.
    
    Parameter sub_timestamp :
      Alpha_context.Script_timestamp.t -&gt; Alpha_context.Script_int.num -&gt;
      Alpha_context.Gas.cost.
    
    Parameter diff_timestamps :
      Alpha_context.Script_timestamp.t -&gt; Alpha_context.Script_timestamp.t -&gt;
      Alpha_context.Gas.cost.
    
    Parameter empty_set : Alpha_context.Gas.cost.
    
    Parameter set_size : Alpha_context.Gas.cost.
    
    Parameter empty_map : Alpha_context.Gas.cost.
    
    Parameter int64_op : Alpha_context.Gas.cost.
    
    Parameter z_to_int64 : Alpha_context.Gas.cost.
    
    Parameter int64_to_z : Alpha_context.Gas.cost.
    
    Parameter logor :
      Alpha_context.Script_int.num -&gt; Alpha_context.Script_int.num -&gt;
      Alpha_context.Gas.cost.
    
    Parameter logand :
      Alpha_context.Script_int.num -&gt; Alpha_context.Script_int.num -&gt;
      Alpha_context.Gas.cost.
    
    Parameter logxor :
      Alpha_context.Script_int.num -&gt; Alpha_context.Script_int.num -&gt;
      Alpha_context.Gas.cost.
    
    Parameter lognot : Alpha_context.Script_int.num -&gt; Alpha_context.Gas.cost.
    
    Parameter shift_left :
      Alpha_context.Script_int.num -&gt; Alpha_context.Script_int.num -&gt;
      Alpha_context.Gas.cost.
    
    Parameter shift_right :
      Alpha_context.Script_int.num -&gt; Alpha_context.Script_int.num -&gt;
      Alpha_context.Gas.cost.
    
    Parameter exec : Alpha_context.Gas.cost.
    
    Parameter push : Alpha_context.Gas.cost.
    
    Parameter compare_res : Alpha_context.Gas.cost.
    
    Parameter unpack_failed : MBytes.t -&gt; Alpha_context.Gas.cost.
    
    Parameter address : Alpha_context.Gas.cost.
    
    Parameter contract : Alpha_context.Gas.cost.
    
    Parameter transfer : Alpha_context.Gas.cost.
    
    Parameter create_account : Alpha_context.Gas.cost.
    
    Parameter create_contract : Alpha_context.Gas.cost.
    
    Parameter implicit_account : Alpha_context.Gas.cost.
    
    Parameter set_delegate : Alpha_context.Gas.cost.
    
    Parameter balance : Alpha_context.Gas.cost.
    
    Parameter now : Alpha_context.Gas.cost.
    
    Parameter check_signature :
      Alpha_context.public_key -&gt; MBytes.t -&gt; Alpha_context.Gas.cost.
    
    Parameter hash_key : Alpha_context.Gas.cost.
    
    Parameter hash_blake2b : MBytes.t -&gt; Alpha_context.Gas.cost.
    
    Parameter hash_sha256 : MBytes.t -&gt; Alpha_context.Gas.cost.
    
    Parameter hash_sha512 : MBytes.t -&gt; Alpha_context.Gas.cost.
    
    Parameter steps_to_quota : Alpha_context.Gas.cost.
    
    Parameter source : Alpha_context.Gas.cost.
    
    Parameter self : Alpha_context.Gas.cost.
    
    Parameter amount : Alpha_context.Gas.cost.
    
    Parameter chain_id : Alpha_context.Gas.cost.
    
    Parameter wrap : Alpha_context.Gas.cost.
    
    Parameter compare : forall {a : Set},
      Script_typed_ir.comparable_ty -&gt; a -&gt; a -&gt; Alpha_context.Gas.cost.
    
    Parameter apply : Alpha_context.Gas.cost.
  End Interpreter.
  
  Module Typechecking.
    Parameter cycle : Alpha_context.Gas.cost.
    
    Parameter __unit_value : Alpha_context.Gas.cost.
    
    Parameter __bool_value : Alpha_context.Gas.cost.
    
    Parameter tez : Alpha_context.Gas.cost.
    
    Parameter z : Z.t -&gt; Alpha_context.Gas.cost.
    
    Parameter __string_value : int -&gt; Alpha_context.Gas.cost.
    
    Parameter __bytes_value : int -&gt; Alpha_context.Gas.cost.
    
    Parameter int_of_string : string -&gt; Alpha_context.Gas.cost.
    
    Parameter string_timestamp : Alpha_context.Gas.cost.
    
    Parameter __key_value : Alpha_context.Gas.cost.
    
    Parameter key_hash : Alpha_context.Gas.cost.
    
    Parameter signature : Alpha_context.Gas.cost.
    
    Parameter chain_id : Alpha_context.Gas.cost.
    
    Parameter contract : Alpha_context.Gas.cost.
    
    Parameter get_script : Alpha_context.Gas.cost.
    
    Parameter contract_exists : Alpha_context.Gas.cost.
    
    Parameter pair : Alpha_context.Gas.cost.
    
    Parameter union : Alpha_context.Gas.cost.
    
    Parameter lambda : Alpha_context.Gas.cost.
    
    Parameter some : Alpha_context.Gas.cost.
    
    Parameter none : Alpha_context.Gas.cost.
    
    Parameter list_element : Alpha_context.Gas.cost.
    
    Parameter set_element : int -&gt; Alpha_context.Gas.cost.
    
    Parameter map_element : int -&gt; Alpha_context.Gas.cost.
    
    Parameter primitive_type : Alpha_context.Gas.cost.
    
    Parameter one_arg_type : Alpha_context.Gas.cost.
    
    Parameter two_arg_type : Alpha_context.Gas.cost.
    
    Parameter operation : int -&gt; Alpha_context.Gas.cost.
    
    Parameter type_ : int -&gt; Alpha_context.Gas.cost.
    
    Parameter instr : Script_typed_ir.instr -&gt; Alpha_context.Gas.cost.
  End Typechecking.
  
  Module Unparse.
    Parameter prim_cost :
      int -&gt; Alpha_context.Script.annot -&gt; Alpha_context.Gas.cost.
    
    Parameter seq_cost : int -&gt; Alpha_context.Gas.cost.
    
    Parameter cycle : Alpha_context.Gas.cost.
    
    Parameter __unit_value : Alpha_context.Gas.cost.
    
    Parameter __bool_value : Alpha_context.Gas.cost.
    
    Parameter z : Z.t -&gt; Alpha_context.Gas.cost.
    
    Parameter __int_value :
      Alpha_context.Script_int.num -&gt; Alpha_context.Gas.cost.
    
    Parameter tez : Alpha_context.Gas.cost.
    
    Parameter __string_value : string -&gt; Alpha_context.Gas.cost.
    
    Parameter __bytes_value : MBytes.t -&gt; Alpha_context.Gas.cost.
    
    Parameter timestamp :
      Alpha_context.Script_timestamp.t -&gt; Alpha_context.Gas.cost.
    
    Parameter __key_value : Alpha_context.Gas.cost.
    
    Parameter key_hash : Alpha_context.Gas.cost.
    
    Parameter signature : Alpha_context.Gas.cost.
    
    Parameter operation : MBytes.t -&gt; Alpha_context.Gas.cost.
    
    Parameter chain_id : MBytes.t -&gt; Alpha_context.Gas.cost.
    
    Parameter contract : Alpha_context.Gas.cost.
    
    Parameter pair : Alpha_context.Gas.cost.
    
    Parameter union : Alpha_context.Gas.cost.
    
    Parameter some : Alpha_context.Gas.cost.
    
    Parameter none : Alpha_context.Gas.cost.
    
    Parameter list_element : Alpha_context.Gas.cost.
    
    Parameter set_element : Alpha_context.Gas.cost.
    
    Parameter map_element : Alpha_context.Gas.cost.
    
    Parameter one_arg_type :
      Alpha_context.Script.annot -&gt; Alpha_context.Gas.cost.
    
    Parameter two_arg_type :
      Alpha_context.Script.annot -&gt; Alpha_context.Gas.cost.
    
    Parameter set_to_list : forall {a : Set},
      Script_typed_ir.set a -&gt; Alpha_context.Gas.cost.
    
    Parameter map_to_list : forall {a b : Set},
      Script_typed_ir.map a b -&gt; Alpha_context.Gas.cost.
  End Unparse.
End Cost_of.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="michelson_v1_primitives.ml">
  <div style="margin: 20px;">
    <h3>Michelson_v1_primitives</h3>
    <ul>
      <li>OCaml size: 872 lines</li>
      <li>Coq size: 620 lines (-29% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#michelson_v1_primitives.ml"><code>michelson_v1_primitives.ml</code></a>&nbsp;<span class="label label-warning">7 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Micheline

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Unknown_primitive_name of string</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Invalid_case of string</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | Invalid_primitive_name of
      string Micheline.canonical * Micheline.canonical_location</abbr>

type prim =
  | K_parameter
  | K_storage
  | K_code
  | D_False
  | D_Elt
  | D_Left
  | D_None
  | D_Pair
  | D_Right
  | D_Some
  | D_True
  | D_Unit
  | I_PACK
  | I_UNPACK
  | I_BLAKE2B
  | I_SHA256
  | I_SHA512
  | I_ABS
  | I_ADD
  | I_AMOUNT
  | I_AND
  | I_BALANCE
  | I_CAR
  | I_CDR
  | I_CHAIN_ID
  | I_CHECK_SIGNATURE
  | I_COMPARE
  | I_CONCAT
  | I_CONS
  | I_CREATE_ACCOUNT
  | I_CREATE_CONTRACT
  | I_IMPLICIT_ACCOUNT
  | I_DIP
  | I_DROP
  | I_DUP
  | I_EDIV
  | I_EMPTY_BIG_MAP
  | I_EMPTY_MAP
  | I_EMPTY_SET
  | I_EQ
  | I_EXEC
  | I_APPLY
  | I_FAILWITH
  | I_GE
  | I_GET
  | I_GT
  | I_HASH_KEY
  | I_IF
  | I_IF_CONS
  | I_IF_LEFT
  | I_IF_NONE
  | I_INT
  | I_LAMBDA
  | I_LE
  | I_LEFT
  | I_LOOP
  | I_LSL
  | I_LSR
  | I_LT
  | I_MAP
  | I_MEM
  | I_MUL
  | I_NEG
  | I_NEQ
  | I_NIL
  | I_NONE
  | I_NOT
  | I_NOW
  | I_OR
  | I_PAIR
  | I_PUSH
  | I_RIGHT
  | I_SIZE
  | I_SOME
  | I_SOURCE
  | I_SENDER
  | I_SELF
  | I_SLICE
  | I_STEPS_TO_QUOTA
  | I_SUB
  | I_SWAP
  | I_TRANSFER_TOKENS
  | I_SET_DELEGATE
  | I_UNIT
  | I_UPDATE
  | I_XOR
  | I_ITER
  | I_LOOP_LEFT
  | I_ADDRESS
  | I_CONTRACT
  | I_ISNAT
  | I_CAST
  | I_RENAME
  | I_DIG
  | I_DUG
  | T_bool
  | T_contract
  | T_int
  | T_key
  | T_key_hash
  | T_lambda
  | T_list
  | T_map
  | T_big_map
  | T_nat
  | T_option
  | T_or
  | T_pair
  | T_set
  | T_signature
  | T_string
  | T_bytes
  | T_mutez
  | T_timestamp
  | T_unit
  | T_operation
  | T_address
  | T_chain_id

let valid_case name =
  let is_lower = function '_' | 'a' .. 'z' -&gt; true | _ -&gt; false in
  let is_upper = function '_' | 'A' .. 'Z' -&gt; true | _ -&gt; false in
  let rec for_all a b f =
    Compare.Int.(a &gt; b) || (f a &amp;&amp; for_all (a + 1) b f)
  in
  let len = String.length name in
  Compare.Int.(len &lt;&gt; 0)
  &amp;&amp; Compare.Char.(name.[0] &lt;&gt; '_')
  &amp;&amp; ( (is_upper name.[0] &amp;&amp; for_all 1 (len - 1) (fun i -&gt; is_upper name.[i]))
     || (is_upper name.[0] &amp;&amp; for_all 1 (len - 1) (fun i -&gt; is_lower name.[i]))
     || (is_lower name.[0] &amp;&amp; for_all 1 (len - 1) (fun i -&gt; is_lower name.[i]))
     )

let string_of_prim = function
  | K_parameter -&gt;
      &quot;parameter&quot;
  | K_storage -&gt;
      &quot;storage&quot;
  | K_code -&gt;
      &quot;code&quot;
  | D_False -&gt;
      &quot;False&quot;
  | D_Elt -&gt;
      &quot;Elt&quot;
  | D_Left -&gt;
      &quot;Left&quot;
  | D_None -&gt;
      &quot;None&quot;
  | D_Pair -&gt;
      &quot;Pair&quot;
  | D_Right -&gt;
      &quot;Right&quot;
  | D_Some -&gt;
      &quot;Some&quot;
  | D_True -&gt;
      &quot;True&quot;
  | D_Unit -&gt;
      &quot;Unit&quot;
  | I_PACK -&gt;
      &quot;PACK&quot;
  | I_UNPACK -&gt;
      &quot;UNPACK&quot;
  | I_BLAKE2B -&gt;
      &quot;BLAKE2B&quot;
  | I_SHA256 -&gt;
      &quot;SHA256&quot;
  | I_SHA512 -&gt;
      &quot;SHA512&quot;
  | I_ABS -&gt;
      &quot;ABS&quot;
  | I_ADD -&gt;
      &quot;ADD&quot;
  | I_AMOUNT -&gt;
      &quot;AMOUNT&quot;
  | I_AND -&gt;
      &quot;AND&quot;
  | I_BALANCE -&gt;
      &quot;BALANCE&quot;
  | I_CAR -&gt;
      &quot;CAR&quot;
  | I_CDR -&gt;
      &quot;CDR&quot;
  | I_CHAIN_ID -&gt;
      &quot;CHAIN_ID&quot;
  | I_CHECK_SIGNATURE -&gt;
      &quot;CHECK_SIGNATURE&quot;
  | I_COMPARE -&gt;
      &quot;COMPARE&quot;
  | I_CONCAT -&gt;
      &quot;CONCAT&quot;
  | I_CONS -&gt;
      &quot;CONS&quot;
  | I_CREATE_ACCOUNT -&gt;
      &quot;CREATE_ACCOUNT&quot;
  | I_CREATE_CONTRACT -&gt;
      &quot;CREATE_CONTRACT&quot;
  | I_IMPLICIT_ACCOUNT -&gt;
      &quot;IMPLICIT_ACCOUNT&quot;
  | I_DIP -&gt;
      &quot;DIP&quot;
  | I_DROP -&gt;
      &quot;DROP&quot;
  | I_DUP -&gt;
      &quot;DUP&quot;
  | I_EDIV -&gt;
      &quot;EDIV&quot;
  | I_EMPTY_BIG_MAP -&gt;
      &quot;EMPTY_BIG_MAP&quot;
  | I_EMPTY_MAP -&gt;
      &quot;EMPTY_MAP&quot;
  | I_EMPTY_SET -&gt;
      &quot;EMPTY_SET&quot;
  | I_EQ -&gt;
      &quot;EQ&quot;
  | I_EXEC -&gt;
      &quot;EXEC&quot;
  | I_APPLY -&gt;
      &quot;APPLY&quot;
  | I_FAILWITH -&gt;
      &quot;FAILWITH&quot;
  | I_GE -&gt;
      &quot;GE&quot;
  | I_GET -&gt;
      &quot;GET&quot;
  | I_GT -&gt;
      &quot;GT&quot;
  | I_HASH_KEY -&gt;
      &quot;HASH_KEY&quot;
  | I_IF -&gt;
      &quot;IF&quot;
  | I_IF_CONS -&gt;
      &quot;IF_CONS&quot;
  | I_IF_LEFT -&gt;
      &quot;IF_LEFT&quot;
  | I_IF_NONE -&gt;
      &quot;IF_NONE&quot;
  | I_INT -&gt;
      &quot;INT&quot;
  | I_LAMBDA -&gt;
      &quot;LAMBDA&quot;
  | I_LE -&gt;
      &quot;LE&quot;
  | I_LEFT -&gt;
      &quot;LEFT&quot;
  | I_LOOP -&gt;
      &quot;LOOP&quot;
  | I_LSL -&gt;
      &quot;LSL&quot;
  | I_LSR -&gt;
      &quot;LSR&quot;
  | I_LT -&gt;
      &quot;LT&quot;
  | I_MAP -&gt;
      &quot;MAP&quot;
  | I_MEM -&gt;
      &quot;MEM&quot;
  | I_MUL -&gt;
      &quot;MUL&quot;
  | I_NEG -&gt;
      &quot;NEG&quot;
  | I_NEQ -&gt;
      &quot;NEQ&quot;
  | I_NIL -&gt;
      &quot;NIL&quot;
  | I_NONE -&gt;
      &quot;NONE&quot;
  | I_NOT -&gt;
      &quot;NOT&quot;
  | I_NOW -&gt;
      &quot;NOW&quot;
  | I_OR -&gt;
      &quot;OR&quot;
  | I_PAIR -&gt;
      &quot;PAIR&quot;
  | I_PUSH -&gt;
      &quot;PUSH&quot;
  | I_RIGHT -&gt;
      &quot;RIGHT&quot;
  | I_SIZE -&gt;
      &quot;SIZE&quot;
  | I_SOME -&gt;
      &quot;SOME&quot;
  | I_SOURCE -&gt;
      &quot;SOURCE&quot;
  | I_SENDER -&gt;
      &quot;SENDER&quot;
  | I_SELF -&gt;
      &quot;SELF&quot;
  | I_SLICE -&gt;
      &quot;SLICE&quot;
  | I_STEPS_TO_QUOTA -&gt;
      &quot;STEPS_TO_QUOTA&quot;
  | I_SUB -&gt;
      &quot;SUB&quot;
  | I_SWAP -&gt;
      &quot;SWAP&quot;
  | I_TRANSFER_TOKENS -&gt;
      &quot;TRANSFER_TOKENS&quot;
  | I_SET_DELEGATE -&gt;
      &quot;SET_DELEGATE&quot;
  | I_UNIT -&gt;
      &quot;UNIT&quot;
  | I_UPDATE -&gt;
      &quot;UPDATE&quot;
  | I_XOR -&gt;
      &quot;XOR&quot;
  | I_ITER -&gt;
      &quot;ITER&quot;
  | I_LOOP_LEFT -&gt;
      &quot;LOOP_LEFT&quot;
  | I_ADDRESS -&gt;
      &quot;ADDRESS&quot;
  | I_CONTRACT -&gt;
      &quot;CONTRACT&quot;
  | I_ISNAT -&gt;
      &quot;ISNAT&quot;
  | I_CAST -&gt;
      &quot;CAST&quot;
  | I_RENAME -&gt;
      &quot;RENAME&quot;
  | I_DIG -&gt;
      &quot;DIG&quot;
  | I_DUG -&gt;
      &quot;DUG&quot;
  | T_bool -&gt;
      &quot;bool&quot;
  | T_contract -&gt;
      &quot;contract&quot;
  | T_int -&gt;
      &quot;int&quot;
  | T_key -&gt;
      &quot;key&quot;
  | T_key_hash -&gt;
      &quot;key_hash&quot;
  | T_lambda -&gt;
      &quot;lambda&quot;
  | T_list -&gt;
      &quot;list&quot;
  | T_map -&gt;
      &quot;map&quot;
  | T_big_map -&gt;
      &quot;big_map&quot;
  | T_nat -&gt;
      &quot;nat&quot;
  | T_option -&gt;
      &quot;option&quot;
  | T_or -&gt;
      &quot;or&quot;
  | T_pair -&gt;
      &quot;pair&quot;
  | T_set -&gt;
      &quot;set&quot;
  | T_signature -&gt;
      &quot;signature&quot;
  | T_string -&gt;
      &quot;string&quot;
  | T_bytes -&gt;
      &quot;bytes&quot;
  | T_mutez -&gt;
      &quot;mutez&quot;
  | T_timestamp -&gt;
      &quot;timestamp&quot;
  | T_unit -&gt;
      &quot;unit&quot;
  | T_operation -&gt;
      &quot;operation&quot;
  | T_address -&gt;
      &quot;address&quot;
  | T_chain_id -&gt;
      &quot;chain_id&quot;

let prim_of_string = function
  | &quot;parameter&quot; -&gt;
      ok K_parameter
  | &quot;storage&quot; -&gt;
      ok K_storage
  | &quot;code&quot; -&gt;
      ok K_code
  | &quot;False&quot; -&gt;
      ok D_False
  | &quot;Elt&quot; -&gt;
      ok D_Elt
  | &quot;Left&quot; -&gt;
      ok D_Left
  | &quot;None&quot; -&gt;
      ok D_None
  | &quot;Pair&quot; -&gt;
      ok D_Pair
  | &quot;Right&quot; -&gt;
      ok D_Right
  | &quot;Some&quot; -&gt;
      ok D_Some
  | &quot;True&quot; -&gt;
      ok D_True
  | &quot;Unit&quot; -&gt;
      ok D_Unit
  | &quot;PACK&quot; -&gt;
      ok I_PACK
  | &quot;UNPACK&quot; -&gt;
      ok I_UNPACK
  | &quot;BLAKE2B&quot; -&gt;
      ok I_BLAKE2B
  | &quot;SHA256&quot; -&gt;
      ok I_SHA256
  | &quot;SHA512&quot; -&gt;
      ok I_SHA512
  | &quot;ABS&quot; -&gt;
      ok I_ABS
  | &quot;ADD&quot; -&gt;
      ok I_ADD
  | &quot;AMOUNT&quot; -&gt;
      ok I_AMOUNT
  | &quot;AND&quot; -&gt;
      ok I_AND
  | &quot;BALANCE&quot; -&gt;
      ok I_BALANCE
  | &quot;CAR&quot; -&gt;
      ok I_CAR
  | &quot;CDR&quot; -&gt;
      ok I_CDR
  | &quot;CHAIN_ID&quot; -&gt;
      ok I_CHAIN_ID
  | &quot;CHECK_SIGNATURE&quot; -&gt;
      ok I_CHECK_SIGNATURE
  | &quot;COMPARE&quot; -&gt;
      ok I_COMPARE
  | &quot;CONCAT&quot; -&gt;
      ok I_CONCAT
  | &quot;CONS&quot; -&gt;
      ok I_CONS
  | &quot;CREATE_ACCOUNT&quot; -&gt;
      ok I_CREATE_ACCOUNT
  | &quot;CREATE_CONTRACT&quot; -&gt;
      ok I_CREATE_CONTRACT
  | &quot;IMPLICIT_ACCOUNT&quot; -&gt;
      ok I_IMPLICIT_ACCOUNT
  | &quot;DIP&quot; -&gt;
      ok I_DIP
  | &quot;DROP&quot; -&gt;
      ok I_DROP
  | &quot;DUP&quot; -&gt;
      ok I_DUP
  | &quot;EDIV&quot; -&gt;
      ok I_EDIV
  | &quot;EMPTY_BIG_MAP&quot; -&gt;
      ok I_EMPTY_BIG_MAP
  | &quot;EMPTY_MAP&quot; -&gt;
      ok I_EMPTY_MAP
  | &quot;EMPTY_SET&quot; -&gt;
      ok I_EMPTY_SET
  | &quot;EQ&quot; -&gt;
      ok I_EQ
  | &quot;EXEC&quot; -&gt;
      ok I_EXEC
  | &quot;APPLY&quot; -&gt;
      ok I_APPLY
  | &quot;FAILWITH&quot; -&gt;
      ok I_FAILWITH
  | &quot;GE&quot; -&gt;
      ok I_GE
  | &quot;GET&quot; -&gt;
      ok I_GET
  | &quot;GT&quot; -&gt;
      ok I_GT
  | &quot;HASH_KEY&quot; -&gt;
      ok I_HASH_KEY
  | &quot;IF&quot; -&gt;
      ok I_IF
  | &quot;IF_CONS&quot; -&gt;
      ok I_IF_CONS
  | &quot;IF_LEFT&quot; -&gt;
      ok I_IF_LEFT
  | &quot;IF_NONE&quot; -&gt;
      ok I_IF_NONE
  | &quot;INT&quot; -&gt;
      ok I_INT
  | &quot;LAMBDA&quot; -&gt;
      ok I_LAMBDA
  | &quot;LE&quot; -&gt;
      ok I_LE
  | &quot;LEFT&quot; -&gt;
      ok I_LEFT
  | &quot;LOOP&quot; -&gt;
      ok I_LOOP
  | &quot;LSL&quot; -&gt;
      ok I_LSL
  | &quot;LSR&quot; -&gt;
      ok I_LSR
  | &quot;LT&quot; -&gt;
      ok I_LT
  | &quot;MAP&quot; -&gt;
      ok I_MAP
  | &quot;MEM&quot; -&gt;
      ok I_MEM
  | &quot;MUL&quot; -&gt;
      ok I_MUL
  | &quot;NEG&quot; -&gt;
      ok I_NEG
  | &quot;NEQ&quot; -&gt;
      ok I_NEQ
  | &quot;NIL&quot; -&gt;
      ok I_NIL
  | &quot;NONE&quot; -&gt;
      ok I_NONE
  | &quot;NOT&quot; -&gt;
      ok I_NOT
  | &quot;NOW&quot; -&gt;
      ok I_NOW
  | &quot;OR&quot; -&gt;
      ok I_OR
  | &quot;PAIR&quot; -&gt;
      ok I_PAIR
  | &quot;PUSH&quot; -&gt;
      ok I_PUSH
  | &quot;RIGHT&quot; -&gt;
      ok I_RIGHT
  | &quot;SIZE&quot; -&gt;
      ok I_SIZE
  | &quot;SOME&quot; -&gt;
      ok I_SOME
  | &quot;SOURCE&quot; -&gt;
      ok I_SOURCE
  | &quot;SENDER&quot; -&gt;
      ok I_SENDER
  | &quot;SELF&quot; -&gt;
      ok I_SELF
  | &quot;SLICE&quot; -&gt;
      ok I_SLICE
  | &quot;STEPS_TO_QUOTA&quot; -&gt;
      ok I_STEPS_TO_QUOTA
  | &quot;SUB&quot; -&gt;
      ok I_SUB
  | &quot;SWAP&quot; -&gt;
      ok I_SWAP
  | &quot;TRANSFER_TOKENS&quot; -&gt;
      ok I_TRANSFER_TOKENS
  | &quot;SET_DELEGATE&quot; -&gt;
      ok I_SET_DELEGATE
  | &quot;UNIT&quot; -&gt;
      ok I_UNIT
  | &quot;UPDATE&quot; -&gt;
      ok I_UPDATE
  | &quot;XOR&quot; -&gt;
      ok I_XOR
  | &quot;ITER&quot; -&gt;
      ok I_ITER
  | &quot;LOOP_LEFT&quot; -&gt;
      ok I_LOOP_LEFT
  | &quot;ADDRESS&quot; -&gt;
      ok I_ADDRESS
  | &quot;CONTRACT&quot; -&gt;
      ok I_CONTRACT
  | &quot;ISNAT&quot; -&gt;
      ok I_ISNAT
  | &quot;CAST&quot; -&gt;
      ok I_CAST
  | &quot;RENAME&quot; -&gt;
      ok I_RENAME
  | &quot;DIG&quot; -&gt;
      ok I_DIG
  | &quot;DUG&quot; -&gt;
      ok I_DUG
  | &quot;bool&quot; -&gt;
      ok T_bool
  | &quot;contract&quot; -&gt;
      ok T_contract
  | &quot;int&quot; -&gt;
      ok T_int
  | &quot;key&quot; -&gt;
      ok T_key
  | &quot;key_hash&quot; -&gt;
      ok T_key_hash
  | &quot;lambda&quot; -&gt;
      ok T_lambda
  | &quot;list&quot; -&gt;
      ok T_list
  | &quot;map&quot; -&gt;
      ok T_map
  | &quot;big_map&quot; -&gt;
      ok T_big_map
  | &quot;nat&quot; -&gt;
      ok T_nat
  | &quot;option&quot; -&gt;
      ok T_option
  | &quot;or&quot; -&gt;
      ok T_or
  | &quot;pair&quot; -&gt;
      ok T_pair
  | &quot;set&quot; -&gt;
      ok T_set
  | &quot;signature&quot; -&gt;
      ok T_signature
  | &quot;string&quot; -&gt;
      ok T_string
  | &quot;bytes&quot; -&gt;
      ok T_bytes
  | &quot;mutez&quot; -&gt;
      ok T_mutez
  | &quot;timestamp&quot; -&gt;
      ok T_timestamp
  | &quot;unit&quot; -&gt;
      ok T_unit
  | &quot;operation&quot; -&gt;
      ok T_operation
  | &quot;address&quot; -&gt;
      ok T_address
  | &quot;chain_id&quot; -&gt;
      ok T_chain_id
  | n -&gt;
      if valid_case n then error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Unknown_primitive_name n)</abbr>
      else error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_case n)</abbr>

let prims_of_strings expr =
  let rec convert = function
    | Int (l, x) -&gt;
        ok (Int (l, x))
    | String (l, x) -&gt;
        ok (String (l, x))
    | Bytes (l, x) -&gt;
        ok (Bytes (l, x))
    | Prim (loc, prim, args, annot) -&gt;
        Error_monad.record_trace
          <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_primitive_name (expr, loc))</abbr>
          (prim_of_string prim)
        &gt;&gt;? fun prim -&gt;
        List.fold_left
          (fun acc arg -&gt;
            acc &gt;&gt;? fun args -&gt; convert arg &gt;&gt;? fun arg -&gt; ok (arg :: args))
          (ok [])
          args
        &gt;&gt;? fun args -&gt; ok (Prim (0, prim, List.rev args, annot))
    | Seq (_, args) -&gt;
        List.fold_left
          (fun acc arg -&gt;
            acc &gt;&gt;? fun args -&gt; convert arg &gt;&gt;? fun arg -&gt; ok (arg :: args))
          (ok [])
          args
        &gt;&gt;? fun args -&gt; ok (Seq (0, List.rev args))
  in
  convert (root expr) &gt;&gt;? fun expr -&gt; ok (strip_locations expr)

let strings_of_prims expr =
  let rec convert = function
    | Int (l, x) -&gt;
        Int (l, x)
    | String (l, x) -&gt;
        String (l, x)
    | Bytes (l, x) -&gt;
        Bytes (l, x)
    | Prim (_, prim, args, annot) -&gt;
        let prim = string_of_prim prim in
        let args = List.map convert args in
        Prim (0, prim, args, annot)
    | Seq (_, args) -&gt;
        let args = List.map convert args in
        Seq (0, args)
  in
  strip_locations (convert (root expr))

let prim_encoding =
  let open Data_encoding in
  def &quot;michelson.v1.primitives&quot;
  @@ string_enum
       [ (* /!\ NEW INSTRUCTIONS MUST BE ADDED AT THE END OF THE STRING_ENUM, FOR BACKWARD COMPATIBILITY OF THE ENCODING. *)
         (&quot;parameter&quot;, K_parameter);
         (&quot;storage&quot;, K_storage);
         (&quot;code&quot;, K_code);
         (&quot;False&quot;, D_False);
         (&quot;Elt&quot;, D_Elt);
         (&quot;Left&quot;, D_Left);
         (&quot;None&quot;, D_None);
         (&quot;Pair&quot;, D_Pair);
         (&quot;Right&quot;, D_Right);
         (&quot;Some&quot;, D_Some);
         (* /!\ NEW INSTRUCTIONS MUST BE ADDED AT THE END OF THE STRING_ENUM, FOR BACKWARD COMPATIBILITY OF THE ENCODING. *)
         (&quot;True&quot;, D_True);
         (&quot;Unit&quot;, D_Unit);
         (&quot;PACK&quot;, I_PACK);
         (&quot;UNPACK&quot;, I_UNPACK);
         (&quot;BLAKE2B&quot;, I_BLAKE2B);
         (&quot;SHA256&quot;, I_SHA256);
         (&quot;SHA512&quot;, I_SHA512);
         (&quot;ABS&quot;, I_ABS);
         (&quot;ADD&quot;, I_ADD);
         (&quot;AMOUNT&quot;, I_AMOUNT);
         (* /!\ NEW INSTRUCTIONS MUST BE ADDED AT THE END OF THE STRING_ENUM, FOR BACKWARD COMPATIBILITY OF THE ENCODING. *)
         (&quot;AND&quot;, I_AND);
         (&quot;BALANCE&quot;, I_BALANCE);
         (&quot;CAR&quot;, I_CAR);
         (&quot;CDR&quot;, I_CDR);
         (&quot;CHECK_SIGNATURE&quot;, I_CHECK_SIGNATURE);
         (&quot;COMPARE&quot;, I_COMPARE);
         (&quot;CONCAT&quot;, I_CONCAT);
         (&quot;CONS&quot;, I_CONS);
         (&quot;CREATE_ACCOUNT&quot;, I_CREATE_ACCOUNT);
         (&quot;CREATE_CONTRACT&quot;, I_CREATE_CONTRACT);
         (* /!\ NEW INSTRUCTIONS MUST BE ADDED AT THE END OF THE STRING_ENUM, FOR BACKWARD COMPATIBILITY OF THE ENCODING. *)
         (&quot;IMPLICIT_ACCOUNT&quot;, I_IMPLICIT_ACCOUNT);
         (&quot;DIP&quot;, I_DIP);
         (&quot;DROP&quot;, I_DROP);
         (&quot;DUP&quot;, I_DUP);
         (&quot;EDIV&quot;, I_EDIV);
         (&quot;EMPTY_MAP&quot;, I_EMPTY_MAP);
         (&quot;EMPTY_SET&quot;, I_EMPTY_SET);
         (&quot;EQ&quot;, I_EQ);
         (&quot;EXEC&quot;, I_EXEC);
         (&quot;FAILWITH&quot;, I_FAILWITH);
         (* /!\ NEW INSTRUCTIONS MUST BE ADDED AT THE END OF THE STRING_ENUM, FOR BACKWARD COMPATIBILITY OF THE ENCODING. *)
         (&quot;GE&quot;, I_GE);
         (&quot;GET&quot;, I_GET);
         (&quot;GT&quot;, I_GT);
         (&quot;HASH_KEY&quot;, I_HASH_KEY);
         (&quot;IF&quot;, I_IF);
         (&quot;IF_CONS&quot;, I_IF_CONS);
         (&quot;IF_LEFT&quot;, I_IF_LEFT);
         (&quot;IF_NONE&quot;, I_IF_NONE);
         (&quot;INT&quot;, I_INT);
         (&quot;LAMBDA&quot;, I_LAMBDA);
         (* /!\ NEW INSTRUCTIONS MUST BE ADDED AT THE END OF THE STRING_ENUM, FOR BACKWARD COMPATIBILITY OF THE ENCODING. *)
         (&quot;LE&quot;, I_LE);
         (&quot;LEFT&quot;, I_LEFT);
         (&quot;LOOP&quot;, I_LOOP);
         (&quot;LSL&quot;, I_LSL);
         (&quot;LSR&quot;, I_LSR);
         (&quot;LT&quot;, I_LT);
         (&quot;MAP&quot;, I_MAP);
         (&quot;MEM&quot;, I_MEM);
         (&quot;MUL&quot;, I_MUL);
         (&quot;NEG&quot;, I_NEG);
         (* /!\ NEW INSTRUCTIONS MUST BE ADDED AT THE END OF THE STRING_ENUM, FOR BACKWARD COMPATIBILITY OF THE ENCODING. *)
         (&quot;NEQ&quot;, I_NEQ);
         (&quot;NIL&quot;, I_NIL);
         (&quot;NONE&quot;, I_NONE);
         (&quot;NOT&quot;, I_NOT);
         (&quot;NOW&quot;, I_NOW);
         (&quot;OR&quot;, I_OR);
         (&quot;PAIR&quot;, I_PAIR);
         (&quot;PUSH&quot;, I_PUSH);
         (&quot;RIGHT&quot;, I_RIGHT);
         (&quot;SIZE&quot;, I_SIZE);
         (* /!\ NEW INSTRUCTIONS MUST BE ADDED AT THE END OF THE STRING_ENUM, FOR BACKWARD COMPATIBILITY OF THE ENCODING. *)
         (&quot;SOME&quot;, I_SOME);
         (&quot;SOURCE&quot;, I_SOURCE);
         (&quot;SENDER&quot;, I_SENDER);
         (&quot;SELF&quot;, I_SELF);
         (&quot;STEPS_TO_QUOTA&quot;, I_STEPS_TO_QUOTA);
         (&quot;SUB&quot;, I_SUB);
         (&quot;SWAP&quot;, I_SWAP);
         (&quot;TRANSFER_TOKENS&quot;, I_TRANSFER_TOKENS);
         (&quot;SET_DELEGATE&quot;, I_SET_DELEGATE);
         (&quot;UNIT&quot;, I_UNIT);
         (* /!\ NEW INSTRUCTIONS MUST BE ADDED AT THE END OF THE STRING_ENUM, FOR BACKWARD COMPATIBILITY OF THE ENCODING. *)
         (&quot;UPDATE&quot;, I_UPDATE);
         (&quot;XOR&quot;, I_XOR);
         (&quot;ITER&quot;, I_ITER);
         (&quot;LOOP_LEFT&quot;, I_LOOP_LEFT);
         (&quot;ADDRESS&quot;, I_ADDRESS);
         (&quot;CONTRACT&quot;, I_CONTRACT);
         (&quot;ISNAT&quot;, I_ISNAT);
         (&quot;CAST&quot;, I_CAST);
         (&quot;RENAME&quot;, I_RENAME);
         (&quot;bool&quot;, T_bool);
         (* /!\ NEW INSTRUCTIONS MUST BE ADDED AT THE END OF THE STRING_ENUM, FOR BACKWARD COMPATIBILITY OF THE ENCODING. *)
         (&quot;contract&quot;, T_contract);
         (&quot;int&quot;, T_int);
         (&quot;key&quot;, T_key);
         (&quot;key_hash&quot;, T_key_hash);
         (&quot;lambda&quot;, T_lambda);
         (&quot;list&quot;, T_list);
         (&quot;map&quot;, T_map);
         (&quot;big_map&quot;, T_big_map);
         (&quot;nat&quot;, T_nat);
         (&quot;option&quot;, T_option);
         (* /!\ NEW INSTRUCTIONS MUST BE ADDED AT THE END OF THE STRING_ENUM, FOR BACKWARD COMPATIBILITY OF THE ENCODING. *)
         (&quot;or&quot;, T_or);
         (&quot;pair&quot;, T_pair);
         (&quot;set&quot;, T_set);
         (&quot;signature&quot;, T_signature);
         (&quot;string&quot;, T_string);
         (&quot;bytes&quot;, T_bytes);
         (&quot;mutez&quot;, T_mutez);
         (&quot;timestamp&quot;, T_timestamp);
         (&quot;unit&quot;, T_unit);
         (&quot;operation&quot;, T_operation);
         (* /!\ NEW INSTRUCTIONS MUST BE ADDED AT THE END OF THE STRING_ENUM, FOR BACKWARD COMPATIBILITY OF THE ENCODING. *)
         (&quot;address&quot;, T_address);
         (* Alpha_002 addition *)
         (&quot;SLICE&quot;, I_SLICE);
         (* Alpha_005 addition *)
         (&quot;DIG&quot;, I_DIG);
         (&quot;DUG&quot;, I_DUG);
         (&quot;EMPTY_BIG_MAP&quot;, I_EMPTY_BIG_MAP);
         (&quot;APPLY&quot;, I_APPLY);
         (&quot;chain_id&quot;, T_chain_id);
         (&quot;CHAIN_ID&quot;, I_CHAIN_ID)
         (* New instructions must be added here, for backward compatibility of the encoding. *)
        ]

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.unknown_primitive_name&quot;
    ~title:&quot;Unknown primitive name&quot;
    ~description:&quot;In a script or data expression, a primitive was unknown.&quot;
    ~pp:(fun ppf n -&gt; Format.fprintf ppf &quot;Unknown primitive %s.&quot; n)
    Data_encoding.(obj1 (req &quot;wrong_primitive_name&quot; string))
    (function Unknown_primitive_name got -&gt; Some got | _ -&gt; None)
    (fun got -&gt; Unknown_primitive_name got) ;
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.invalid_primitive_name_case&quot;
    ~title:&quot;Invalid primitive name case&quot;
    ~description:
      &quot;In a script or data expression, a primitive name is neither uppercase, \
       lowercase or capitalized.&quot;
    ~pp:(fun ppf n -&gt; Format.fprintf ppf &quot;Primitive %s has invalid case.&quot; n)
    Data_encoding.(obj1 (req &quot;wrong_primitive_name&quot; string))
    (function Invalid_case name -&gt; Some name | _ -&gt; None)
    (fun name -&gt; Invalid_case name) ;
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.invalid_primitive_name&quot;
    ~title:&quot;Invalid primitive name&quot;
    ~description:
      &quot;In a script or data expression, a primitive name is unknown or has a \
       wrong case.&quot;
    ~pp:(fun ppf _ -&gt; Format.fprintf ppf &quot;Invalid primitive.&quot;)
    Data_encoding.(
      obj2
        (req
           &quot;expression&quot;
           (Micheline.canonical_encoding ~variant:&quot;generic&quot; string))
        (req &quot;location&quot; Micheline.canonical_location_encoding))
    (function
      | Invalid_primitive_name (expr, loc) -&gt; Some (expr, loc) | _ -&gt; None)
    (fun (expr, loc) -&gt; Invalid_primitive_name (expr, loc))</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#michelson_v1_primitives.ml"><code>Michelson_v1_primitives.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.

Import Micheline.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

Inductive prim : Set :=
| K_parameter : prim
| K_storage : prim
| K_code : prim
| D_False : prim
| D_Elt : prim
| D_Left : prim
| D_None : prim
| D_Pair : prim
| D_Right : prim
| D_Some : prim
| D_True : prim
| D_Unit : prim
| I_PACK : prim
| I_UNPACK : prim
| I_BLAKE2B : prim
| I_SHA256 : prim
| I_SHA512 : prim
| I_ABS : prim
| I_ADD : prim
| I_AMOUNT : prim
| I_AND : prim
| I_BALANCE : prim
| I_CAR : prim
| I_CDR : prim
| I_CHAIN_ID : prim
| I_CHECK_SIGNATURE : prim
| I_COMPARE : prim
| I_CONCAT : prim
| I_CONS : prim
| I_CREATE_ACCOUNT : prim
| I_CREATE_CONTRACT : prim
| I_IMPLICIT_ACCOUNT : prim
| I_DIP : prim
| I_DROP : prim
| I_DUP : prim
| I_EDIV : prim
| I_EMPTY_BIG_MAP : prim
| I_EMPTY_MAP : prim
| I_EMPTY_SET : prim
| I_EQ : prim
| I_EXEC : prim
| I_APPLY : prim
| I_FAILWITH : prim
| I_GE : prim
| I_GET : prim
| I_GT : prim
| I_HASH_KEY : prim
| I_IF : prim
| I_IF_CONS : prim
| I_IF_LEFT : prim
| I_IF_NONE : prim
| I_INT : prim
| I_LAMBDA : prim
| I_LE : prim
| I_LEFT : prim
| I_LOOP : prim
| I_LSL : prim
| I_LSR : prim
| I_LT : prim
| I_MAP : prim
| I_MEM : prim
| I_MUL : prim
| I_NEG : prim
| I_NEQ : prim
| I_NIL : prim
| I_NONE : prim
| I_NOT : prim
| I_NOW : prim
| I_OR : prim
| I_PAIR : prim
| I_PUSH : prim
| I_RIGHT : prim
| I_SIZE : prim
| I_SOME : prim
| I_SOURCE : prim
| I_SENDER : prim
| I_SELF : prim
| I_SLICE : prim
| I_STEPS_TO_QUOTA : prim
| I_SUB : prim
| I_SWAP : prim
| I_TRANSFER_TOKENS : prim
| I_SET_DELEGATE : prim
| I_UNIT : prim
| I_UPDATE : prim
| I_XOR : prim
| I_ITER : prim
| I_LOOP_LEFT : prim
| I_ADDRESS : prim
| I_CONTRACT : prim
| I_ISNAT : prim
| I_CAST : prim
| I_RENAME : prim
| I_DIG : prim
| I_DUG : prim
| T_bool : prim
| T_contract : prim
| T_int : prim
| T_key : prim
| T_key_hash : prim
| T_lambda : prim
| T_list : prim
| T_map : prim
| T_big_map : prim
| T_nat : prim
| T_option : prim
| T_or : prim
| T_pair : prim
| T_set : prim
| T_signature : prim
| T_string : prim
| T_bytes : prim
| T_mutez : prim
| T_timestamp : prim
| T_unit : prim
| T_operation : prim
| T_address : prim
| T_chain_id : prim.

Definition valid_case (name : string) : bool :=
  let is_lower (function_parameter : ascii) : bool :=
    match function_parameter with
    |
      (&quot;_&quot; % char | &quot;a&quot; % char | &quot;b&quot; % char | &quot;c&quot; % char | &quot;d&quot; % char |
      &quot;e&quot; % char | &quot;f&quot; % char | &quot;g&quot; % char | &quot;h&quot; % char | &quot;i&quot; % char |
      &quot;j&quot; % char | &quot;k&quot; % char | &quot;l&quot; % char | &quot;m&quot; % char | &quot;n&quot; % char |
      &quot;o&quot; % char | &quot;p&quot; % char | &quot;q&quot; % char | &quot;r&quot; % char | &quot;s&quot; % char |
      &quot;t&quot; % char | &quot;u&quot; % char | &quot;v&quot; % char | &quot;w&quot; % char | &quot;x&quot; % char |
      &quot;y&quot; % char | &quot;z&quot; % char) =&gt; true
    | _ =&gt; false
    end in
  let is_upper (function_parameter : ascii) : bool :=
    match function_parameter with
    |
      (&quot;_&quot; % char | &quot;A&quot; % char | &quot;B&quot; % char | &quot;C&quot; % char | &quot;D&quot; % char |
      &quot;E&quot; % char | &quot;F&quot; % char | &quot;G&quot; % char | &quot;H&quot; % char | &quot;I&quot; % char |
      &quot;J&quot; % char | &quot;K&quot; % char | &quot;L&quot; % char | &quot;M&quot; % char | &quot;N&quot; % char |
      &quot;O&quot; % char | &quot;P&quot; % char | &quot;Q&quot; % char | &quot;R&quot; % char | &quot;S&quot; % char |
      &quot;T&quot; % char | &quot;U&quot; % char | &quot;V&quot; % char | &quot;W&quot; % char | &quot;X&quot; % char |
      &quot;Y&quot; % char | &quot;Z&quot; % char) =&gt; true
    | _ =&gt; false
    end in
  let fix for_all
    (__a_value : (|Compare.Int|).(Compare.S.t))
    (__b_value : (|Compare.Int|).(Compare.S.t))
    (f : (|Compare.Int|).(Compare.S.t) -&gt; bool) {struct __a_value} : bool :=
    Pervasives.op_pipepipe
      ((|Compare.Int|).(Compare.S.op_gt) __a_value __b_value)
      (Pervasives.op_andand (f __a_value)
        (for_all (Pervasives.op_plus __a_value 1) __b_value f)) in
  let len := String.length name in
  Pervasives.op_andand ((|Compare.Int|).(Compare.S.op_ltgt) len 0)
    (Pervasives.op_andand
      ((|Compare.Char|).(Compare.S.op_ltgt) (String.get name 0) &quot;_&quot; % char)
      (Pervasives.op_pipepipe
        (Pervasives.op_andand (is_upper (String.get name 0))
          (for_all 1 (Pervasives.op_minus len 1)
            (fun i =&gt; is_upper (String.get name i))))
        (Pervasives.op_pipepipe
          (Pervasives.op_andand (is_upper (String.get name 0))
            (for_all 1 (Pervasives.op_minus len 1)
              (fun i =&gt; is_lower (String.get name i))))
          (Pervasives.op_andand (is_lower (String.get name 0))
            (for_all 1 (Pervasives.op_minus len 1)
              (fun i =&gt; is_lower (String.get name i))))))).

Definition string_of_prim (function_parameter : prim) : string :=
  match function_parameter with
  | K_parameter =&gt; &quot;parameter&quot;
  | K_storage =&gt; &quot;storage&quot;
  | K_code =&gt; &quot;code&quot;
  | D_False =&gt; &quot;False&quot;
  | D_Elt =&gt; &quot;Elt&quot;
  | D_Left =&gt; &quot;Left&quot;
  | D_None =&gt; &quot;None&quot;
  | D_Pair =&gt; &quot;Pair&quot;
  | D_Right =&gt; &quot;Right&quot;
  | D_Some =&gt; &quot;Some&quot;
  | D_True =&gt; &quot;True&quot;
  | D_Unit =&gt; &quot;Unit&quot;
  | I_PACK =&gt; &quot;PACK&quot;
  | I_UNPACK =&gt; &quot;UNPACK&quot;
  | I_BLAKE2B =&gt; &quot;BLAKE2B&quot;
  | I_SHA256 =&gt; &quot;SHA256&quot;
  | I_SHA512 =&gt; &quot;SHA512&quot;
  | I_ABS =&gt; &quot;ABS&quot;
  | I_ADD =&gt; &quot;ADD&quot;
  | I_AMOUNT =&gt; &quot;AMOUNT&quot;
  | I_AND =&gt; &quot;AND&quot;
  | I_BALANCE =&gt; &quot;BALANCE&quot;
  | I_CAR =&gt; &quot;CAR&quot;
  | I_CDR =&gt; &quot;CDR&quot;
  | I_CHAIN_ID =&gt; &quot;CHAIN_ID&quot;
  | I_CHECK_SIGNATURE =&gt; &quot;CHECK_SIGNATURE&quot;
  | I_COMPARE =&gt; &quot;COMPARE&quot;
  | I_CONCAT =&gt; &quot;CONCAT&quot;
  | I_CONS =&gt; &quot;CONS&quot;
  | I_CREATE_ACCOUNT =&gt; &quot;CREATE_ACCOUNT&quot;
  | I_CREATE_CONTRACT =&gt; &quot;CREATE_CONTRACT&quot;
  | I_IMPLICIT_ACCOUNT =&gt; &quot;IMPLICIT_ACCOUNT&quot;
  | I_DIP =&gt; &quot;DIP&quot;
  | I_DROP =&gt; &quot;DROP&quot;
  | I_DUP =&gt; &quot;DUP&quot;
  | I_EDIV =&gt; &quot;EDIV&quot;
  | I_EMPTY_BIG_MAP =&gt; &quot;EMPTY_BIG_MAP&quot;
  | I_EMPTY_MAP =&gt; &quot;EMPTY_MAP&quot;
  | I_EMPTY_SET =&gt; &quot;EMPTY_SET&quot;
  | I_EQ =&gt; &quot;EQ&quot;
  | I_EXEC =&gt; &quot;EXEC&quot;
  | I_APPLY =&gt; &quot;APPLY&quot;
  | I_FAILWITH =&gt; &quot;FAILWITH&quot;
  | I_GE =&gt; &quot;GE&quot;
  | I_GET =&gt; &quot;GET&quot;
  | I_GT =&gt; &quot;GT&quot;
  | I_HASH_KEY =&gt; &quot;HASH_KEY&quot;
  | I_IF =&gt; &quot;IF&quot;
  | I_IF_CONS =&gt; &quot;IF_CONS&quot;
  | I_IF_LEFT =&gt; &quot;IF_LEFT&quot;
  | I_IF_NONE =&gt; &quot;IF_NONE&quot;
  | I_INT =&gt; &quot;INT&quot;
  | I_LAMBDA =&gt; &quot;LAMBDA&quot;
  | I_LE =&gt; &quot;LE&quot;
  | I_LEFT =&gt; &quot;LEFT&quot;
  | I_LOOP =&gt; &quot;LOOP&quot;
  | I_LSL =&gt; &quot;LSL&quot;
  | I_LSR =&gt; &quot;LSR&quot;
  | I_LT =&gt; &quot;LT&quot;
  | I_MAP =&gt; &quot;MAP&quot;
  | I_MEM =&gt; &quot;MEM&quot;
  | I_MUL =&gt; &quot;MUL&quot;
  | I_NEG =&gt; &quot;NEG&quot;
  | I_NEQ =&gt; &quot;NEQ&quot;
  | I_NIL =&gt; &quot;NIL&quot;
  | I_NONE =&gt; &quot;NONE&quot;
  | I_NOT =&gt; &quot;NOT&quot;
  | I_NOW =&gt; &quot;NOW&quot;
  | I_OR =&gt; &quot;OR&quot;
  | I_PAIR =&gt; &quot;PAIR&quot;
  | I_PUSH =&gt; &quot;PUSH&quot;
  | I_RIGHT =&gt; &quot;RIGHT&quot;
  | I_SIZE =&gt; &quot;SIZE&quot;
  | I_SOME =&gt; &quot;SOME&quot;
  | I_SOURCE =&gt; &quot;SOURCE&quot;
  | I_SENDER =&gt; &quot;SENDER&quot;
  | I_SELF =&gt; &quot;SELF&quot;
  | I_SLICE =&gt; &quot;SLICE&quot;
  | I_STEPS_TO_QUOTA =&gt; &quot;STEPS_TO_QUOTA&quot;
  | I_SUB =&gt; &quot;SUB&quot;
  | I_SWAP =&gt; &quot;SWAP&quot;
  | I_TRANSFER_TOKENS =&gt; &quot;TRANSFER_TOKENS&quot;
  | I_SET_DELEGATE =&gt; &quot;SET_DELEGATE&quot;
  | I_UNIT =&gt; &quot;UNIT&quot;
  | I_UPDATE =&gt; &quot;UPDATE&quot;
  | I_XOR =&gt; &quot;XOR&quot;
  | I_ITER =&gt; &quot;ITER&quot;
  | I_LOOP_LEFT =&gt; &quot;LOOP_LEFT&quot;
  | I_ADDRESS =&gt; &quot;ADDRESS&quot;
  | I_CONTRACT =&gt; &quot;CONTRACT&quot;
  | I_ISNAT =&gt; &quot;ISNAT&quot;
  | I_CAST =&gt; &quot;CAST&quot;
  | I_RENAME =&gt; &quot;RENAME&quot;
  | I_DIG =&gt; &quot;DIG&quot;
  | I_DUG =&gt; &quot;DUG&quot;
  | T_bool =&gt; &quot;bool&quot;
  | T_contract =&gt; &quot;contract&quot;
  | T_int =&gt; &quot;int&quot;
  | T_key =&gt; &quot;key&quot;
  | T_key_hash =&gt; &quot;key_hash&quot;
  | T_lambda =&gt; &quot;lambda&quot;
  | T_list =&gt; &quot;list&quot;
  | T_map =&gt; &quot;map&quot;
  | T_big_map =&gt; &quot;big_map&quot;
  | T_nat =&gt; &quot;nat&quot;
  | T_option =&gt; &quot;option&quot;
  | T_or =&gt; &quot;or&quot;
  | T_pair =&gt; &quot;pair&quot;
  | T_set =&gt; &quot;set&quot;
  | T_signature =&gt; &quot;signature&quot;
  | T_string =&gt; &quot;string&quot;
  | T_bytes =&gt; &quot;bytes&quot;
  | T_mutez =&gt; &quot;mutez&quot;
  | T_timestamp =&gt; &quot;timestamp&quot;
  | T_unit =&gt; &quot;unit&quot;
  | T_operation =&gt; &quot;operation&quot;
  | T_address =&gt; &quot;address&quot;
  | T_chain_id =&gt; &quot;chain_id&quot;
  end.

Definition prim_of_string (function_parameter : string)
  : Error_monad.tzresult prim :=
  match function_parameter with
  | &quot;parameter&quot; =&gt; Error_monad.ok K_parameter
  | &quot;storage&quot; =&gt; Error_monad.ok K_storage
  | &quot;code&quot; =&gt; Error_monad.ok K_code
  | &quot;False&quot; =&gt; Error_monad.ok D_False
  | &quot;Elt&quot; =&gt; Error_monad.ok D_Elt
  | &quot;Left&quot; =&gt; Error_monad.ok D_Left
  | &quot;None&quot; =&gt; Error_monad.ok D_None
  | &quot;Pair&quot; =&gt; Error_monad.ok D_Pair
  | &quot;Right&quot; =&gt; Error_monad.ok D_Right
  | &quot;Some&quot; =&gt; Error_monad.ok D_Some
  | &quot;True&quot; =&gt; Error_monad.ok D_True
  | &quot;Unit&quot; =&gt; Error_monad.ok D_Unit
  | &quot;PACK&quot; =&gt; Error_monad.ok I_PACK
  | &quot;UNPACK&quot; =&gt; Error_monad.ok I_UNPACK
  | &quot;BLAKE2B&quot; =&gt; Error_monad.ok I_BLAKE2B
  | &quot;SHA256&quot; =&gt; Error_monad.ok I_SHA256
  | &quot;SHA512&quot; =&gt; Error_monad.ok I_SHA512
  | &quot;ABS&quot; =&gt; Error_monad.ok I_ABS
  | &quot;ADD&quot; =&gt; Error_monad.ok I_ADD
  | &quot;AMOUNT&quot; =&gt; Error_monad.ok I_AMOUNT
  | &quot;AND&quot; =&gt; Error_monad.ok I_AND
  | &quot;BALANCE&quot; =&gt; Error_monad.ok I_BALANCE
  | &quot;CAR&quot; =&gt; Error_monad.ok I_CAR
  | &quot;CDR&quot; =&gt; Error_monad.ok I_CDR
  | &quot;CHAIN_ID&quot; =&gt; Error_monad.ok I_CHAIN_ID
  | &quot;CHECK_SIGNATURE&quot; =&gt; Error_monad.ok I_CHECK_SIGNATURE
  | &quot;COMPARE&quot; =&gt; Error_monad.ok I_COMPARE
  | &quot;CONCAT&quot; =&gt; Error_monad.ok I_CONCAT
  | &quot;CONS&quot; =&gt; Error_monad.ok I_CONS
  | &quot;CREATE_ACCOUNT&quot; =&gt; Error_monad.ok I_CREATE_ACCOUNT
  | &quot;CREATE_CONTRACT&quot; =&gt; Error_monad.ok I_CREATE_CONTRACT
  | &quot;IMPLICIT_ACCOUNT&quot; =&gt; Error_monad.ok I_IMPLICIT_ACCOUNT
  | &quot;DIP&quot; =&gt; Error_monad.ok I_DIP
  | &quot;DROP&quot; =&gt; Error_monad.ok I_DROP
  | &quot;DUP&quot; =&gt; Error_monad.ok I_DUP
  | &quot;EDIV&quot; =&gt; Error_monad.ok I_EDIV
  | &quot;EMPTY_BIG_MAP&quot; =&gt; Error_monad.ok I_EMPTY_BIG_MAP
  | &quot;EMPTY_MAP&quot; =&gt; Error_monad.ok I_EMPTY_MAP
  | &quot;EMPTY_SET&quot; =&gt; Error_monad.ok I_EMPTY_SET
  | &quot;EQ&quot; =&gt; Error_monad.ok I_EQ
  | &quot;EXEC&quot; =&gt; Error_monad.ok I_EXEC
  | &quot;APPLY&quot; =&gt; Error_monad.ok I_APPLY
  | &quot;FAILWITH&quot; =&gt; Error_monad.ok I_FAILWITH
  | &quot;GE&quot; =&gt; Error_monad.ok I_GE
  | &quot;GET&quot; =&gt; Error_monad.ok I_GET
  | &quot;GT&quot; =&gt; Error_monad.ok I_GT
  | &quot;HASH_KEY&quot; =&gt; Error_monad.ok I_HASH_KEY
  | &quot;IF&quot; =&gt; Error_monad.ok I_IF
  | &quot;IF_CONS&quot; =&gt; Error_monad.ok I_IF_CONS
  | &quot;IF_LEFT&quot; =&gt; Error_monad.ok I_IF_LEFT
  | &quot;IF_NONE&quot; =&gt; Error_monad.ok I_IF_NONE
  | &quot;INT&quot; =&gt; Error_monad.ok I_INT
  | &quot;LAMBDA&quot; =&gt; Error_monad.ok I_LAMBDA
  | &quot;LE&quot; =&gt; Error_monad.ok I_LE
  | &quot;LEFT&quot; =&gt; Error_monad.ok I_LEFT
  | &quot;LOOP&quot; =&gt; Error_monad.ok I_LOOP
  | &quot;LSL&quot; =&gt; Error_monad.ok I_LSL
  | &quot;LSR&quot; =&gt; Error_monad.ok I_LSR
  | &quot;LT&quot; =&gt; Error_monad.ok I_LT
  | &quot;MAP&quot; =&gt; Error_monad.ok I_MAP
  | &quot;MEM&quot; =&gt; Error_monad.ok I_MEM
  | &quot;MUL&quot; =&gt; Error_monad.ok I_MUL
  | &quot;NEG&quot; =&gt; Error_monad.ok I_NEG
  | &quot;NEQ&quot; =&gt; Error_monad.ok I_NEQ
  | &quot;NIL&quot; =&gt; Error_monad.ok I_NIL
  | &quot;NONE&quot; =&gt; Error_monad.ok I_NONE
  | &quot;NOT&quot; =&gt; Error_monad.ok I_NOT
  | &quot;NOW&quot; =&gt; Error_monad.ok I_NOW
  | &quot;OR&quot; =&gt; Error_monad.ok I_OR
  | &quot;PAIR&quot; =&gt; Error_monad.ok I_PAIR
  | &quot;PUSH&quot; =&gt; Error_monad.ok I_PUSH
  | &quot;RIGHT&quot; =&gt; Error_monad.ok I_RIGHT
  | &quot;SIZE&quot; =&gt; Error_monad.ok I_SIZE
  | &quot;SOME&quot; =&gt; Error_monad.ok I_SOME
  | &quot;SOURCE&quot; =&gt; Error_monad.ok I_SOURCE
  | &quot;SENDER&quot; =&gt; Error_monad.ok I_SENDER
  | &quot;SELF&quot; =&gt; Error_monad.ok I_SELF
  | &quot;SLICE&quot; =&gt; Error_monad.ok I_SLICE
  | &quot;STEPS_TO_QUOTA&quot; =&gt; Error_monad.ok I_STEPS_TO_QUOTA
  | &quot;SUB&quot; =&gt; Error_monad.ok I_SUB
  | &quot;SWAP&quot; =&gt; Error_monad.ok I_SWAP
  | &quot;TRANSFER_TOKENS&quot; =&gt; Error_monad.ok I_TRANSFER_TOKENS
  | &quot;SET_DELEGATE&quot; =&gt; Error_monad.ok I_SET_DELEGATE
  | &quot;UNIT&quot; =&gt; Error_monad.ok I_UNIT
  | &quot;UPDATE&quot; =&gt; Error_monad.ok I_UPDATE
  | &quot;XOR&quot; =&gt; Error_monad.ok I_XOR
  | &quot;ITER&quot; =&gt; Error_monad.ok I_ITER
  | &quot;LOOP_LEFT&quot; =&gt; Error_monad.ok I_LOOP_LEFT
  | &quot;ADDRESS&quot; =&gt; Error_monad.ok I_ADDRESS
  | &quot;CONTRACT&quot; =&gt; Error_monad.ok I_CONTRACT
  | &quot;ISNAT&quot; =&gt; Error_monad.ok I_ISNAT
  | &quot;CAST&quot; =&gt; Error_monad.ok I_CAST
  | &quot;RENAME&quot; =&gt; Error_monad.ok I_RENAME
  | &quot;DIG&quot; =&gt; Error_monad.ok I_DIG
  | &quot;DUG&quot; =&gt; Error_monad.ok I_DUG
  | &quot;bool&quot; =&gt; Error_monad.ok T_bool
  | &quot;contract&quot; =&gt; Error_monad.ok T_contract
  | &quot;int&quot; =&gt; Error_monad.ok T_int
  | &quot;key&quot; =&gt; Error_monad.ok T_key
  | &quot;key_hash&quot; =&gt; Error_monad.ok T_key_hash
  | &quot;lambda&quot; =&gt; Error_monad.ok T_lambda
  | &quot;list&quot; =&gt; Error_monad.ok T_list
  | &quot;map&quot; =&gt; Error_monad.ok T_map
  | &quot;big_map&quot; =&gt; Error_monad.ok T_big_map
  | &quot;nat&quot; =&gt; Error_monad.ok T_nat
  | &quot;option&quot; =&gt; Error_monad.ok T_option
  | &quot;or&quot; =&gt; Error_monad.ok T_or
  | &quot;pair&quot; =&gt; Error_monad.ok T_pair
  | &quot;set&quot; =&gt; Error_monad.ok T_set
  | &quot;signature&quot; =&gt; Error_monad.ok T_signature
  | &quot;string&quot; =&gt; Error_monad.ok T_string
  | &quot;bytes&quot; =&gt; Error_monad.ok T_bytes
  | &quot;mutez&quot; =&gt; Error_monad.ok T_mutez
  | &quot;timestamp&quot; =&gt; Error_monad.ok T_timestamp
  | &quot;unit&quot; =&gt; Error_monad.ok T_unit
  | &quot;operation&quot; =&gt; Error_monad.ok T_operation
  | &quot;address&quot; =&gt; Error_monad.ok T_address
  | &quot;chain_id&quot; =&gt; Error_monad.ok T_chain_id
  | n =&gt;
    if valid_case n then
      Error_monad.__error_value extensible_type_value
    else
      Error_monad.__error_value extensible_type_value
  end.

Definition prims_of_strings (expr : Micheline.canonical string)
  : Error_monad.tzresult (Micheline.canonical prim) :=
  let fix convert
    (function_parameter : Micheline.node Micheline.canonical_location string)
    {struct function_parameter}
    : Error_monad.tzresult (Micheline.node Micheline.canonical_location prim) :=
    match function_parameter with
    | Micheline.Int l x =&gt; Error_monad.ok (Micheline.Int l x)
    | Micheline.String l x =&gt; Error_monad.ok (Micheline.String l x)
    | Micheline.Bytes l x =&gt; Error_monad.ok (Micheline.Bytes l x)
    | Micheline.Prim loc prim args annot =&gt;
      let? prim :=
        Error_monad.record_trace extensible_type_value (prim_of_string prim) in
      let? args :=
        List.fold_left
          (fun acc =&gt;
            fun arg =&gt;
              let? args := acc in
              let? arg := convert arg in
              Error_monad.ok (cons arg args)) (Error_monad.ok nil) args in
      Error_monad.ok (Micheline.Prim 0 prim (List.rev args) annot)
    | Micheline.Seq _ args =&gt;
      let? args :=
        List.fold_left
          (fun acc =&gt;
            fun arg =&gt;
              let? args := acc in
              let? arg := convert arg in
              Error_monad.ok (cons arg args)) (Error_monad.ok nil) args in
      Error_monad.ok (Micheline.Seq 0 (List.rev args))
    end in
  let? expr := convert (Micheline.root expr) in
  Error_monad.ok (Micheline.strip_locations expr).

Definition strings_of_prims (expr : Micheline.canonical prim)
  : Micheline.canonical string :=
  let fix convert (function_parameter : Micheline.node int prim)
    {struct function_parameter} : Micheline.node int string :=
    match function_parameter with
    | Micheline.Int l x =&gt; Micheline.Int l x
    | Micheline.String l x =&gt; Micheline.String l x
    | Micheline.Bytes l x =&gt; Micheline.Bytes l x
    | Micheline.Prim _ prim args annot =&gt;
      let prim := string_of_prim prim in
      let args := List.map convert args in
      Micheline.Prim 0 prim args annot
    | Micheline.Seq _ args =&gt;
      let args := List.map convert args in
      Micheline.Seq 0 args
    end in
  Micheline.strip_locations (convert (Micheline.root expr)).

Definition prim_encoding : Data_encoding.encoding prim :=
  (let arg := Data_encoding.def &quot;michelson.v1.primitives&quot; in
  fun eta =&gt; arg None None eta)
    (Data_encoding.string_enum
      [
        (&quot;parameter&quot;, K_parameter);
        (&quot;storage&quot;, K_storage);
        (&quot;code&quot;, K_code);
        (&quot;False&quot;, D_False);
        (&quot;Elt&quot;, D_Elt);
        (&quot;Left&quot;, D_Left);
        (&quot;None&quot;, D_None);
        (&quot;Pair&quot;, D_Pair);
        (&quot;Right&quot;, D_Right);
        (&quot;Some&quot;, D_Some);
        (&quot;True&quot;, D_True);
        (&quot;Unit&quot;, D_Unit);
        (&quot;PACK&quot;, I_PACK);
        (&quot;UNPACK&quot;, I_UNPACK);
        (&quot;BLAKE2B&quot;, I_BLAKE2B);
        (&quot;SHA256&quot;, I_SHA256);
        (&quot;SHA512&quot;, I_SHA512);
        (&quot;ABS&quot;, I_ABS);
        (&quot;ADD&quot;, I_ADD);
        (&quot;AMOUNT&quot;, I_AMOUNT);
        (&quot;AND&quot;, I_AND);
        (&quot;BALANCE&quot;, I_BALANCE);
        (&quot;CAR&quot;, I_CAR);
        (&quot;CDR&quot;, I_CDR);
        (&quot;CHECK_SIGNATURE&quot;, I_CHECK_SIGNATURE);
        (&quot;COMPARE&quot;, I_COMPARE);
        (&quot;CONCAT&quot;, I_CONCAT);
        (&quot;CONS&quot;, I_CONS);
        (&quot;CREATE_ACCOUNT&quot;, I_CREATE_ACCOUNT);
        (&quot;CREATE_CONTRACT&quot;, I_CREATE_CONTRACT);
        (&quot;IMPLICIT_ACCOUNT&quot;, I_IMPLICIT_ACCOUNT);
        (&quot;DIP&quot;, I_DIP);
        (&quot;DROP&quot;, I_DROP);
        (&quot;DUP&quot;, I_DUP);
        (&quot;EDIV&quot;, I_EDIV);
        (&quot;EMPTY_MAP&quot;, I_EMPTY_MAP);
        (&quot;EMPTY_SET&quot;, I_EMPTY_SET);
        (&quot;EQ&quot;, I_EQ);
        (&quot;EXEC&quot;, I_EXEC);
        (&quot;FAILWITH&quot;, I_FAILWITH);
        (&quot;GE&quot;, I_GE);
        (&quot;GET&quot;, I_GET);
        (&quot;GT&quot;, I_GT);
        (&quot;HASH_KEY&quot;, I_HASH_KEY);
        (&quot;IF&quot;, I_IF);
        (&quot;IF_CONS&quot;, I_IF_CONS);
        (&quot;IF_LEFT&quot;, I_IF_LEFT);
        (&quot;IF_NONE&quot;, I_IF_NONE);
        (&quot;INT&quot;, I_INT);
        (&quot;LAMBDA&quot;, I_LAMBDA);
        (&quot;LE&quot;, I_LE);
        (&quot;LEFT&quot;, I_LEFT);
        (&quot;LOOP&quot;, I_LOOP);
        (&quot;LSL&quot;, I_LSL);
        (&quot;LSR&quot;, I_LSR);
        (&quot;LT&quot;, I_LT);
        (&quot;MAP&quot;, I_MAP);
        (&quot;MEM&quot;, I_MEM);
        (&quot;MUL&quot;, I_MUL);
        (&quot;NEG&quot;, I_NEG);
        (&quot;NEQ&quot;, I_NEQ);
        (&quot;NIL&quot;, I_NIL);
        (&quot;NONE&quot;, I_NONE);
        (&quot;NOT&quot;, I_NOT);
        (&quot;NOW&quot;, I_NOW);
        (&quot;OR&quot;, I_OR);
        (&quot;PAIR&quot;, I_PAIR);
        (&quot;PUSH&quot;, I_PUSH);
        (&quot;RIGHT&quot;, I_RIGHT);
        (&quot;SIZE&quot;, I_SIZE);
        (&quot;SOME&quot;, I_SOME);
        (&quot;SOURCE&quot;, I_SOURCE);
        (&quot;SENDER&quot;, I_SENDER);
        (&quot;SELF&quot;, I_SELF);
        (&quot;STEPS_TO_QUOTA&quot;, I_STEPS_TO_QUOTA);
        (&quot;SUB&quot;, I_SUB);
        (&quot;SWAP&quot;, I_SWAP);
        (&quot;TRANSFER_TOKENS&quot;, I_TRANSFER_TOKENS);
        (&quot;SET_DELEGATE&quot;, I_SET_DELEGATE);
        (&quot;UNIT&quot;, I_UNIT);
        (&quot;UPDATE&quot;, I_UPDATE);
        (&quot;XOR&quot;, I_XOR);
        (&quot;ITER&quot;, I_ITER);
        (&quot;LOOP_LEFT&quot;, I_LOOP_LEFT);
        (&quot;ADDRESS&quot;, I_ADDRESS);
        (&quot;CONTRACT&quot;, I_CONTRACT);
        (&quot;ISNAT&quot;, I_ISNAT);
        (&quot;CAST&quot;, I_CAST);
        (&quot;RENAME&quot;, I_RENAME);
        (&quot;bool&quot;, T_bool);
        (&quot;contract&quot;, T_contract);
        (&quot;int&quot;, T_int);
        (&quot;key&quot;, T_key);
        (&quot;key_hash&quot;, T_key_hash);
        (&quot;lambda&quot;, T_lambda);
        (&quot;list&quot;, T_list);
        (&quot;map&quot;, T_map);
        (&quot;big_map&quot;, T_big_map);
        (&quot;nat&quot;, T_nat);
        (&quot;option&quot;, T_option);
        (&quot;or&quot;, T_or);
        (&quot;pair&quot;, T_pair);
        (&quot;set&quot;, T_set);
        (&quot;signature&quot;, T_signature);
        (&quot;string&quot;, T_string);
        (&quot;bytes&quot;, T_bytes);
        (&quot;mutez&quot;, T_mutez);
        (&quot;timestamp&quot;, T_timestamp);
        (&quot;unit&quot;, T_unit);
        (&quot;operation&quot;, T_operation);
        (&quot;address&quot;, T_address);
        (&quot;SLICE&quot;, I_SLICE);
        (&quot;DIG&quot;, I_DIG);
        (&quot;DUG&quot;, I_DUG);
        (&quot;EMPTY_BIG_MAP&quot;, I_EMPTY_BIG_MAP);
        (&quot;APPLY&quot;, I_APPLY);
        (&quot;chain_id&quot;, T_chain_id);
        (&quot;CHAIN_ID&quot;, I_CHAIN_ID)
      ]).

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="michelson_v1_primitives.mli">
  <div style="margin: 20px;">
    <h3>Michelson_v1_primitives_mli</h3>
    <ul>
      <li>OCaml size: 165 lines</li>
      <li>Coq size: 149 lines (-10% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#michelson_v1_primitives.mli"><code>michelson_v1_primitives.mli</code></a>&nbsp;<span class="label label-warning">3 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Unknown_primitive_name of string</abbr> (* `Permanent *)

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Invalid_case of string</abbr> (* `Permanent *)

<abbr class="mark-warning" title="Extensible types are not handled.">type error +=
  | Invalid_primitive_name of
      string Micheline.canonical * Micheline.canonical_location</abbr>

(* `Permanent *)

type prim =
  | K_parameter
  | K_storage
  | K_code
  | D_False
  | D_Elt
  | D_Left
  | D_None
  | D_Pair
  | D_Right
  | D_Some
  | D_True
  | D_Unit
  | I_PACK
  | I_UNPACK
  | I_BLAKE2B
  | I_SHA256
  | I_SHA512
  | I_ABS
  | I_ADD
  | I_AMOUNT
  | I_AND
  | I_BALANCE
  | I_CAR
  | I_CDR
  | I_CHAIN_ID
  | I_CHECK_SIGNATURE
  | I_COMPARE
  | I_CONCAT
  | I_CONS
  | I_CREATE_ACCOUNT
  | I_CREATE_CONTRACT
  | I_IMPLICIT_ACCOUNT
  | I_DIP
  | I_DROP
  | I_DUP
  | I_EDIV
  | I_EMPTY_BIG_MAP
  | I_EMPTY_MAP
  | I_EMPTY_SET
  | I_EQ
  | I_EXEC
  | I_APPLY
  | I_FAILWITH
  | I_GE
  | I_GET
  | I_GT
  | I_HASH_KEY
  | I_IF
  | I_IF_CONS
  | I_IF_LEFT
  | I_IF_NONE
  | I_INT
  | I_LAMBDA
  | I_LE
  | I_LEFT
  | I_LOOP
  | I_LSL
  | I_LSR
  | I_LT
  | I_MAP
  | I_MEM
  | I_MUL
  | I_NEG
  | I_NEQ
  | I_NIL
  | I_NONE
  | I_NOT
  | I_NOW
  | I_OR
  | I_PAIR
  | I_PUSH
  | I_RIGHT
  | I_SIZE
  | I_SOME
  | I_SOURCE
  | I_SENDER
  | I_SELF
  | I_SLICE
  | I_STEPS_TO_QUOTA
  | I_SUB
  | I_SWAP
  | I_TRANSFER_TOKENS
  | I_SET_DELEGATE
  | I_UNIT
  | I_UPDATE
  | I_XOR
  | I_ITER
  | I_LOOP_LEFT
  | I_ADDRESS
  | I_CONTRACT
  | I_ISNAT
  | I_CAST
  | I_RENAME
  | I_DIG
  | I_DUG
  | T_bool
  | T_contract
  | T_int
  | T_key
  | T_key_hash
  | T_lambda
  | T_list
  | T_map
  | T_big_map
  | T_nat
  | T_option
  | T_or
  | T_pair
  | T_set
  | T_signature
  | T_string
  | T_bytes
  | T_mutez
  | T_timestamp
  | T_unit
  | T_operation
  | T_address
  | T_chain_id

val prim_encoding : prim Data_encoding.encoding

val string_of_prim : prim -&gt; string

val prim_of_string : string -&gt; prim tzresult

val prims_of_strings :
  string Micheline.canonical -&gt; prim Micheline.canonical tzresult

val strings_of_prims : prim Micheline.canonical -&gt; string Micheline.canonical
</pre>
  </div>
  <div class="col-md-6">
    <a href="#michelson_v1_primitives.mli"><code>Michelson_v1_primitives_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.

(* extensible_type_definition `error` *)

(* extensible_type_definition `error` *)

(* extensible_type_definition `error` *)

Inductive prim : Set :=
| K_parameter : prim
| K_storage : prim
| K_code : prim
| D_False : prim
| D_Elt : prim
| D_Left : prim
| D_None : prim
| D_Pair : prim
| D_Right : prim
| D_Some : prim
| D_True : prim
| D_Unit : prim
| I_PACK : prim
| I_UNPACK : prim
| I_BLAKE2B : prim
| I_SHA256 : prim
| I_SHA512 : prim
| I_ABS : prim
| I_ADD : prim
| I_AMOUNT : prim
| I_AND : prim
| I_BALANCE : prim
| I_CAR : prim
| I_CDR : prim
| I_CHAIN_ID : prim
| I_CHECK_SIGNATURE : prim
| I_COMPARE : prim
| I_CONCAT : prim
| I_CONS : prim
| I_CREATE_ACCOUNT : prim
| I_CREATE_CONTRACT : prim
| I_IMPLICIT_ACCOUNT : prim
| I_DIP : prim
| I_DROP : prim
| I_DUP : prim
| I_EDIV : prim
| I_EMPTY_BIG_MAP : prim
| I_EMPTY_MAP : prim
| I_EMPTY_SET : prim
| I_EQ : prim
| I_EXEC : prim
| I_APPLY : prim
| I_FAILWITH : prim
| I_GE : prim
| I_GET : prim
| I_GT : prim
| I_HASH_KEY : prim
| I_IF : prim
| I_IF_CONS : prim
| I_IF_LEFT : prim
| I_IF_NONE : prim
| I_INT : prim
| I_LAMBDA : prim
| I_LE : prim
| I_LEFT : prim
| I_LOOP : prim
| I_LSL : prim
| I_LSR : prim
| I_LT : prim
| I_MAP : prim
| I_MEM : prim
| I_MUL : prim
| I_NEG : prim
| I_NEQ : prim
| I_NIL : prim
| I_NONE : prim
| I_NOT : prim
| I_NOW : prim
| I_OR : prim
| I_PAIR : prim
| I_PUSH : prim
| I_RIGHT : prim
| I_SIZE : prim
| I_SOME : prim
| I_SOURCE : prim
| I_SENDER : prim
| I_SELF : prim
| I_SLICE : prim
| I_STEPS_TO_QUOTA : prim
| I_SUB : prim
| I_SWAP : prim
| I_TRANSFER_TOKENS : prim
| I_SET_DELEGATE : prim
| I_UNIT : prim
| I_UPDATE : prim
| I_XOR : prim
| I_ITER : prim
| I_LOOP_LEFT : prim
| I_ADDRESS : prim
| I_CONTRACT : prim
| I_ISNAT : prim
| I_CAST : prim
| I_RENAME : prim
| I_DIG : prim
| I_DUG : prim
| T_bool : prim
| T_contract : prim
| T_int : prim
| T_key : prim
| T_key_hash : prim
| T_lambda : prim
| T_list : prim
| T_map : prim
| T_big_map : prim
| T_nat : prim
| T_option : prim
| T_or : prim
| T_pair : prim
| T_set : prim
| T_signature : prim
| T_string : prim
| T_bytes : prim
| T_mutez : prim
| T_timestamp : prim
| T_unit : prim
| T_operation : prim
| T_address : prim
| T_chain_id : prim.

Parameter prim_encoding : Data_encoding.encoding prim.

Parameter string_of_prim : prim -&gt; string.

Parameter prim_of_string : string -&gt; Error_monad.tzresult prim.

Parameter prims_of_strings :
  Micheline.canonical string -&gt; Error_monad.tzresult (Micheline.canonical prim).

Parameter strings_of_prims :
  Micheline.canonical prim -&gt; Micheline.canonical string.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="misc.ml">
  <div style="margin: 20px;">
    <h3>Misc</h3>
    <ul>
      <li>OCaml size: 91 lines</li>
      <li>Coq size: 152 lines (+67% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#misc.ml"><code>misc.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type 'a lazyt = unit -&gt; 'a

type 'a lazy_list_t = LCons of 'a * 'a lazy_list_t tzresult Lwt.t lazyt

type 'a lazy_list = 'a lazy_list_t tzresult Lwt.t

let rec ( --&gt; ) i j =
  (* [i; i+1; ...; j] *)
  if Compare.Int.(i &gt; j) then [] else i :: (succ i --&gt; j)

let rec ( ---&gt; ) i j =
  (* [i; i+1; ...; j] *)
  if Compare.Int32.(i &gt; j) then [] else i :: (Int32.succ i ---&gt; j)

let rec do_slashes delim path l acc limit i =
  if Compare.Int.(i &gt;= l) then List.rev acc
  else if Compare.Char.(path.[i] = delim) then
    do_slashes delim path l acc limit (i + 1)
  else do_split delim path l acc limit i

and do_split delim path l acc limit i =
  if Compare.Int.(limit &lt;= 0) then
    if Compare.Int.(i = l) then List.rev acc
    else List.rev (String.sub path i (l - i) :: acc)
  else do_component delim path l acc (pred limit) i i

and do_component delim path l acc limit i j =
  if Compare.Int.(j &gt;= l) then
    if Compare.Int.(i = j) then List.rev acc
    else List.rev (String.sub path i (j - i) :: acc)
  else if Compare.Char.(path.[j] = delim) then
    do_slashes delim path l (String.sub path i (j - i) :: acc) limit j
  else do_component delim path l acc limit i (j + 1)

let split delim ?(limit = max_int) path =
  let l = String.length path in
  if Compare.Int.(limit &gt; 0) then do_slashes delim path l [] limit 0 else [path]

let pp_print_paragraph ppf description =
  Format.fprintf
    ppf
    &quot;@[%a@]&quot;
    Format.(pp_print_list ~pp_sep:pp_print_space pp_print_string)
    (split ' ' description)

let take n l =
  let rec loop acc n xs =
    if Compare.Int.(n &lt;= 0) then Some (List.rev acc, xs)
    else match xs with [] -&gt; None | x :: xs -&gt; loop (x :: acc) (n - 1) xs
  in
  loop [] n l

let remove_prefix ~prefix s =
  let x = String.length prefix in
  let n = String.length s in
  if Compare.Int.(n &gt;= x) &amp;&amp; Compare.String.(String.sub s 0 x = prefix) then
    Some (String.sub s x (n - x))
  else None

let rec remove_elem_from_list nb = function
  | [] -&gt;
      []
  | _ :: _ as l when Compare.Int.(nb &lt;= 0) -&gt;
      l
  | _ :: tl -&gt;
      remove_elem_from_list (nb - 1) tl
</pre>
  </div>
  <div class="col-md-6">
    <a href="#misc.ml"><code>Misc.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.

Definition lazyt (a : Set) : Set := unit -&gt; a.

Inductive lazy_list_t (a : Set) : Set :=
| LCons :
  a -&gt; lazyt (Lwt.t (Error_monad.tzresult (lazy_list_t a))) -&gt; lazy_list_t a.

Arguments LCons {_}.

Definition lazy_list (a : Set) : Set :=
  Lwt.t (Error_monad.tzresult (lazy_list_t a)).

Fixpoint op_minusminusgt
  (i : (|Compare.Int|).(Compare.S.t)) (j : (|Compare.Int|).(Compare.S.t))
  {struct i} : list (|Compare.Int|).(Compare.S.t) :=
  if (|Compare.Int|).(Compare.S.op_gt) i j then
    nil
  else
    cons i (op_minusminusgt (Pervasives.succ i) j).

Fixpoint op_minusminusminusgt
  (i : (|Compare.Int32|).(Compare.S.t)) (j : (|Compare.Int32|).(Compare.S.t))
  {struct i} : list (|Compare.Int32|).(Compare.S.t) :=
  if (|Compare.Int32|).(Compare.S.op_gt) i j then
    nil
  else
    cons i (op_minusminusminusgt (Int32.succ i) j).

Fixpoint do_slashes
  (delim : (|Compare.Char|).(Compare.S.t)) (path : string)
  (l : (|Compare.Int|).(Compare.S.t)) (acc : list string)
  (limit : (|Compare.Int|).(Compare.S.t)) (i : (|Compare.Int|).(Compare.S.t))
  {struct delim} : list string :=
  if (|Compare.Int|).(Compare.S.op_gteq) i l then
    List.rev acc
  else
    if (|Compare.Char|).(Compare.S.op_eq) (String.get path i) delim then
      do_slashes delim path l acc limit (Pervasives.op_plus i 1)
    else
      do_split delim path l acc limit i

with do_split
  (delim : (|Compare.Char|).(Compare.S.t)) (path : string)
  (l : (|Compare.Int|).(Compare.S.t)) (acc : list string)
  (limit : (|Compare.Int|).(Compare.S.t)) (i : (|Compare.Int|).(Compare.S.t))
  {struct delim} : list string :=
  if (|Compare.Int|).(Compare.S.op_lteq) limit 0 then
    if (|Compare.Int|).(Compare.S.op_eq) i l then
      List.rev acc
    else
      List.rev (cons (String.sub path i (Pervasives.op_minus l i)) acc)
  else
    do_component delim path l acc (Pervasives.pred limit) i i

with do_component
  (delim : (|Compare.Char|).(Compare.S.t)) (path : string)
  (l : (|Compare.Int|).(Compare.S.t)) (acc : list string)
  (limit : (|Compare.Int|).(Compare.S.t)) (i : (|Compare.Int|).(Compare.S.t))
  (j : (|Compare.Int|).(Compare.S.t)) {struct delim} : list string :=
  if (|Compare.Int|).(Compare.S.op_gteq) j l then
    if (|Compare.Int|).(Compare.S.op_eq) i j then
      List.rev acc
    else
      List.rev (cons (String.sub path i (Pervasives.op_minus j i)) acc)
  else
    if (|Compare.Char|).(Compare.S.op_eq) (String.get path j) delim then
      do_slashes delim path l
        (cons (String.sub path i (Pervasives.op_minus j i)) acc) limit j
    else
      do_component delim path l acc limit i (Pervasives.op_plus j 1).

Definition split
  (delim : (|Compare.Char|).(Compare.S.t))
  (op_staroptstar : option (|Compare.Int|).(Compare.S.t))
  : string -&gt; list string :=
  let limit :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; Pervasives.max_int
    end in
  fun path =&gt;
    let l := String.length path in
    if (|Compare.Int|).(Compare.S.op_gt) limit 0 then
      do_slashes delim path l nil limit 0
    else
      [ path ].

Definition pp_print_paragraph (ppf : Format.formatter) (description : string)
  : unit :=
  Format.fprintf ppf
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.Formatting_gen
        (CamlinternalFormatBasics.Open_box
          (CamlinternalFormatBasics.Format
            CamlinternalFormatBasics.End_of_format &quot;&quot;))
        (CamlinternalFormatBasics.Alpha
          (CamlinternalFormatBasics.Formatting_lit
            CamlinternalFormatBasics.Close_box
            CamlinternalFormatBasics.End_of_format))) &quot;@[%a@]&quot;)
    (Format.pp_print_list (Some Format.pp_print_space) Format.pp_print_string)
    (split &quot; &quot; % char None description).

Definition take {A : Set} (n : (|Compare.Int|).(Compare.S.t)) (l : list A)
  : option (list A * list A) :=
  let fix loop {B : Set}
    (acc : list B) (n : (|Compare.Int|).(Compare.S.t)) (xs : list B)
    {struct acc} : option (list B * list B) :=
    if (|Compare.Int|).(Compare.S.op_lteq) n 0 then
      Some ((List.rev acc), xs)
    else
      match xs with
      | [] =&gt; None
      | cons x xs =&gt; loop (cons x acc) (Pervasives.op_minus n 1) xs
      end in
  loop nil n l.

Definition remove_prefix
  (prefix : (|Compare.String|).(Compare.S.t)) (s : string) : option string :=
  let x := String.length prefix in
  let n := String.length s in
  if
    Pervasives.op_andand ((|Compare.Int|).(Compare.S.op_gteq) n x)
      ((|Compare.String|).(Compare.S.op_eq) (String.sub s 0 x) prefix) then
    Some (String.sub s x (Pervasives.op_minus n x))
  else
    None.

Fixpoint remove_elem_from_list {A : Set}
  (nb : (|Compare.Int|).(Compare.S.t)) (function_parameter : list A) {struct nb}
  : list A :=
  match
    (function_parameter,
      match function_parameter with
      | (cons _ _) as l =&gt; (|Compare.Int|).(Compare.S.op_lteq) nb 0
      | _ =&gt; false
      end) with
  | ([], _) =&gt; nil
  | ((cons _ _) as l, true) =&gt; l
  | (cons _ tl, _) =&gt; remove_elem_from_list (Pervasives.op_minus nb 1) tl
  end.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="misc.mli">
  <div style="margin: 20px;">
    <h3>Misc_mli</h3>
    <ul>
      <li>OCaml size: 47 lines</li>
      <li>Coq size: 34 lines (-28% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#misc.mli"><code>misc.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** {2 Helper functions} *)

type 'a lazyt = unit -&gt; 'a

type 'a lazy_list_t = LCons of 'a * 'a lazy_list_t tzresult Lwt.t lazyt

type 'a lazy_list = 'a lazy_list_t tzresult Lwt.t

(** Include bounds *)
val ( --&gt; ) : int -&gt; int -&gt; int list

val ( ---&gt; ) : Int32.t -&gt; Int32.t -&gt; Int32.t list

val pp_print_paragraph : Format.formatter -&gt; string -&gt; unit

val take : int -&gt; 'a list -&gt; ('a list * 'a list) option

(** Some (input with [prefix] removed), if string has [prefix], else [None] *)
val remove_prefix : prefix:string -&gt; string -&gt; string option

(** [remove nb list] remove the first [nb] elements from the list [list]. *)
val remove_elem_from_list : int -&gt; 'a list -&gt; 'a list
</pre>
  </div>
  <div class="col-md-6">
    <a href="#misc.mli"><code>Misc_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.

Definition lazyt (a : Set) : Set := unit -&gt; a.

Inductive lazy_list_t (a : Set) : Set :=
| LCons :
  a -&gt; lazyt (Lwt.t (Error_monad.tzresult (lazy_list_t a))) -&gt; lazy_list_t a.

Arguments LCons {_}.

Definition lazy_list (a : Set) : Set :=
  Lwt.t (Error_monad.tzresult (lazy_list_t a)).

Parameter op_minusminusgt : int -&gt; int -&gt; list int.

Parameter op_minusminusminusgt : Int32.t -&gt; Int32.t -&gt; list Int32.t.

Parameter pp_print_paragraph : Format.formatter -&gt; string -&gt; unit.

Parameter take : forall {a : Set}, int -&gt; list a -&gt; option (list a * list a).

Parameter remove_prefix : string -&gt; string -&gt; option string.

Parameter remove_elem_from_list : forall {a : Set}, int -&gt; list a -&gt; list a.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="nonce_hash.ml">
  <div style="margin: 20px;">
    <h3>Nonce_hash</h3>
    <ul>
      <li>OCaml size: 44 lines</li>
      <li>Coq size: 103 lines (+134% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#nonce_hash.ml"><code>nonce_hash.ml</code></a>&nbsp;<span class="label label-warning">1 warning</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(* 32 *)
let nonce_hash = &quot;\069\220\169&quot; (* nce(53) *)

module Blake2BModule =
  Blake2B.Make
    (Base58)
    (struct
      let name = &quot;cycle_nonce&quot;

      let title = &quot;A nonce hash&quot;

      let b58check_prefix = nonce_hash

      let size = None
    end)

include Blake2BModule

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () = Base58.check_encoded_prefix b58check_encoding &quot;nce&quot; 53</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#nonce_hash.ml"><code>Nonce_hash.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.

Definition nonce_hash : string := &quot;E\220\169&quot;.

Definition Blake2BModule :=
  (Blake2B.Make
    (existT (A := unit) (fun _ =&gt; _) tt
      {|
        Blake2B.SRegister.register_encoding {_} := Base58.register_encoding
      |}))
    (let name := &quot;cycle_nonce&quot; in
    let title := &quot;A nonce hash&quot; in
    let b58check_prefix := nonce_hash in
    let size {A : Set} : option A :=
      None in
    existT (A := unit) (fun _ =&gt; _) tt
      {|
        Blake2B.PrefixedName.name := name;
        Blake2B.PrefixedName.title := title;
        Blake2B.PrefixedName.size := size;
        Blake2B.PrefixedName.b58check_prefix := b58check_prefix
      |}).

Definition t := (|Blake2BModule|).(S.HASH.t).

Definition name := (|Blake2BModule|).(S.HASH.name).

Definition title := (|Blake2BModule|).(S.HASH.title).

Definition pp := (|Blake2BModule|).(S.HASH.pp).

Definition pp_short := (|Blake2BModule|).(S.HASH.pp_short).

Definition op_eq := (|Blake2BModule|).(S.HASH.op_eq).

Definition op_ltgt := (|Blake2BModule|).(S.HASH.op_ltgt).

Definition op_lt := (|Blake2BModule|).(S.HASH.op_lt).

Definition op_lteq := (|Blake2BModule|).(S.HASH.op_lteq).

Definition op_gteq := (|Blake2BModule|).(S.HASH.op_gteq).

Definition op_gt := (|Blake2BModule|).(S.HASH.op_gt).

Definition compare := (|Blake2BModule|).(S.HASH.compare).

Definition equal := (|Blake2BModule|).(S.HASH.equal).

Definition max := (|Blake2BModule|).(S.HASH.max).

Definition min := (|Blake2BModule|).(S.HASH.min).

Definition hash_bytes := (|Blake2BModule|).(S.HASH.hash_bytes).

Definition hash_string := (|Blake2BModule|).(S.HASH.hash_string).

Definition zero := (|Blake2BModule|).(S.HASH.zero).

Definition size := (|Blake2BModule|).(S.HASH.size).

Definition to_bytes := (|Blake2BModule|).(S.HASH.to_bytes).

Definition of_bytes_opt := (|Blake2BModule|).(S.HASH.of_bytes_opt).

Definition of_bytes_exn := (|Blake2BModule|).(S.HASH.of_bytes_exn).

Definition to_b58check := (|Blake2BModule|).(S.HASH.to_b58check).

Definition to_short_b58check := (|Blake2BModule|).(S.HASH.to_short_b58check).

Definition of_b58check_exn := (|Blake2BModule|).(S.HASH.of_b58check_exn).

Definition of_b58check_opt := (|Blake2BModule|).(S.HASH.of_b58check_opt).

Definition b58check_encoding := (|Blake2BModule|).(S.HASH.b58check_encoding).

Definition encoding := (|Blake2BModule|).(S.HASH.encoding).

Definition rpc_arg := (|Blake2BModule|).(S.HASH.rpc_arg).

Definition to_path := (|Blake2BModule|).(S.HASH.to_path).

Definition of_path := (|Blake2BModule|).(S.HASH.of_path).

Definition of_path_exn := (|Blake2BModule|).(S.HASH.of_path_exn).

Definition prefix_path := (|Blake2BModule|).(S.HASH.prefix_path).

Definition path_length := (|Blake2BModule|).(S.HASH.path_length).

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="nonce_storage.ml">
  <div style="margin: 20px;">
    <h3>Nonce_storage</h3>
    <ul>
      <li>OCaml size: 127 lines</li>
      <li>Coq size: 93 lines (-27% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#nonce_storage.ml"><code>nonce_storage.ml</code></a>&nbsp;<span class="label label-warning">7 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = Seed_repr.nonce

type nonce = t

let encoding = Seed_repr.nonce_encoding

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | Too_late_revelation
  | Too_early_revelation
  | Previously_revealed_nonce
  | Unexpected_nonce</abbr>

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  register_error_kind
    `Branch
    ~id:&quot;nonce.too_late_revelation&quot;
    ~title:&quot;Too late nonce revelation&quot;
    ~description:&quot;Nonce revelation happens too late&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf ppf &quot;This nonce cannot be revealed anymore.&quot;)
    Data_encoding.unit
    (function Too_late_revelation -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Too_late_revelation) ;
  register_error_kind
    `Temporary
    ~id:&quot;nonce.too_early_revelation&quot;
    ~title:&quot;Too early nonce revelation&quot;
    ~description:&quot;Nonce revelation happens before cycle end&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf ppf &quot;This nonce should not yet be revealed&quot;)
    Data_encoding.unit
    (function Too_early_revelation -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Too_early_revelation) ;
  register_error_kind
    `Branch
    ~id:&quot;nonce.previously_revealed&quot;
    ~title:&quot;Previously revealed nonce&quot;
    ~description:&quot;Duplicated revelation for a nonce.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;This nonce was previously revealed&quot;)
    Data_encoding.unit
    (function Previously_revealed_nonce -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Previously_revealed_nonce) ;
  register_error_kind
    `Branch
    ~id:&quot;nonce.unexpected&quot;
    ~title:&quot;Unexpected nonce&quot;
    ~description:
      &quot;The provided nonce is inconsistent with the committed nonce hash.&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf
        ppf
        &quot;This nonce revelation is invalid (inconsistent with the committed \
         hash)&quot;)
    Data_encoding.unit
    (function Unexpected_nonce -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Unexpected_nonce)</abbr>

(* checks that the level of a revelation is not too early or too late wrt to the
   current context and that a nonce has not been already revealed for that level *)
let get_unrevealed ctxt level =
  let cur_level = Level_storage.current ctxt in
  match Cycle_repr.pred cur_level.cycle with
  | None -&gt;
      fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Too_early_revelation</abbr> (* no revelations during cycle 0 *)
  | Some revealed_cycle -&gt; (
      if Cycle_repr.(revealed_cycle &lt; level.Level_repr.cycle) then
        fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Too_early_revelation</abbr>
      else if Cycle_repr.(level.Level_repr.cycle &lt; revealed_cycle) then
        fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Too_late_revelation</abbr>
      else
        Storage.Seed.Nonce.get ctxt level
        &gt;&gt;=? function
        | Revealed _ -&gt;
            fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Previously_revealed_nonce</abbr>
        | Unrevealed status -&gt;
            return status )

let record_hash ctxt unrevealed =
  let level = Level_storage.current ctxt in
  Storage.Seed.Nonce.init ctxt level (Unrevealed unrevealed)

let reveal ctxt level nonce =
  get_unrevealed ctxt level
  &gt;&gt;=? fun unrevealed -&gt;
  fail_unless
    (Seed_repr.check_hash nonce unrevealed.nonce_hash)
    <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Unexpected_nonce</abbr>
  &gt;&gt;=? fun () -&gt;
  Storage.Seed.Nonce.set ctxt level (Revealed nonce)
  &gt;&gt;=? fun ctxt -&gt; return ctxt

type unrevealed = Storage.unrevealed_nonce

type status = Storage.nonce_status

let get = Storage.Seed.Nonce.get

let of_bytes = Seed_repr.make_nonce

let hash = Seed_repr.hash

let check_hash = Seed_repr.check_hash
</pre>
  </div>
  <div class="col-md-6">
    <a href="#nonce_storage.ml"><code>Nonce_storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Cycle_repr.
Require Tezos.Level_repr.
Require Tezos.Level_storage.
Require Tezos.Nonce_hash.
Require Tezos.Raw_context.
Require Tezos.Seed_repr.
Require Tezos.Storage_mli. Module Storage := Storage_mli.
Require Tezos.Storage_sigs.

Definition t : Set := Seed_repr.nonce.

Definition nonce : Set := t.

Definition encoding : Data_encoding.t Seed_repr.nonce :=
  Seed_repr.nonce_encoding.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition get_unrevealed (ctxt : Raw_context.t) (level : Level_repr.t)
  : Lwt.t (Error_monad.tzresult Storage.unrevealed_nonce) :=
  let cur_level := Level_storage.current ctxt in
  match Cycle_repr.pred cur_level.(Level_repr.t.cycle) with
  | None =&gt; Error_monad.fail extensible_type_value
  | Some revealed_cycle =&gt;
    if Cycle_repr.op_lt revealed_cycle level.(Level_repr.t.cycle) then
      Error_monad.fail extensible_type_value
    else
      if Cycle_repr.op_lt level.(Level_repr.t.cycle) revealed_cycle then
        Error_monad.fail extensible_type_value
      else
        let=? function_parameter :=
          (|Storage.Seed.Nonce|).(Storage_sigs.Non_iterable_indexed_data_storage.get)
            ctxt level in
        match function_parameter with
        | Storage.Revealed _ =&gt; Error_monad.fail extensible_type_value
        | Storage.Unrevealed status =&gt; Error_monad.__return status
        end
  end.

Definition record_hash
  (ctxt : Raw_context.t) (unrevealed : Storage.unrevealed_nonce)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let level := Level_storage.current ctxt in
  (|Storage.Seed.Nonce|).(Storage_sigs.Non_iterable_indexed_data_storage.init)
    ctxt level (Storage.Unrevealed unrevealed).

Definition reveal
  (ctxt : Raw_context.t) (level : Level_repr.t)
  (__nonce_value : Seed_repr.nonce)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let=? unrevealed := get_unrevealed ctxt level in
  let=? '_ :=
    Error_monad.fail_unless
      (Seed_repr.check_hash __nonce_value
        unrevealed.(Storage.unrevealed_nonce.nonce_hash)) extensible_type_value
    in
  let=? ctxt :=
    (|Storage.Seed.Nonce|).(Storage_sigs.Non_iterable_indexed_data_storage.set)
      ctxt level (Storage.Revealed __nonce_value) in
  Error_monad.__return ctxt.

Definition unrevealed : Set := Storage.unrevealed_nonce.

Definition status : Set := Storage.nonce_status.

Definition get
  : (|Storage.Seed.Nonce|).(Storage_sigs.Non_iterable_indexed_data_storage.context)
  -&gt; Level_repr.t -&gt; Lwt.t (Error_monad.tzresult Storage.nonce_status) :=
  (|Storage.Seed.Nonce|).(Storage_sigs.Non_iterable_indexed_data_storage.get).

Definition of_bytes : MBytes.t -&gt; Error_monad.tzresult Seed_repr.nonce :=
  Seed_repr.make_nonce.

Definition __hash_value : Seed_repr.nonce -&gt; Nonce_hash.t :=
  Seed_repr.__hash_value.

Definition check_hash : Seed_repr.nonce -&gt; Nonce_hash.t -&gt; bool :=
  Seed_repr.check_hash.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="nonce_storage.mli">
  <div style="margin: 20px;">
    <h3>Nonce_storage_mli</h3>
    <ul>
      <li>OCaml size: 53 lines</li>
      <li>Coq size: 44 lines (-17% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#nonce_storage.mli"><code>nonce_storage.mli</code></a>&nbsp;<span class="label label-warning">1 warning</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

<abbr class="mark-warning" title="Extensible types are not handled.">type error +=
  | Too_late_revelation
  | Too_early_revelation
  | Previously_revealed_nonce
  | Unexpected_nonce</abbr>

type t = Seed_repr.nonce

type nonce = t

val encoding : nonce Data_encoding.t

type unrevealed = Storage.unrevealed_nonce

type status = Storage.nonce_status

val get : Raw_context.t -&gt; Level_repr.t -&gt; status tzresult Lwt.t

val record_hash : Raw_context.t -&gt; unrevealed -&gt; Raw_context.t tzresult Lwt.t

val reveal :
  Raw_context.t -&gt; Level_repr.t -&gt; nonce -&gt; Raw_context.t tzresult Lwt.t

val of_bytes : MBytes.t -&gt; nonce tzresult

val hash : nonce -&gt; Nonce_hash.t

val check_hash : nonce -&gt; Nonce_hash.t -&gt; bool
</pre>
  </div>
  <div class="col-md-6">
    <a href="#nonce_storage.mli"><code>Nonce_storage_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Level_repr.
Require Tezos.Nonce_hash.
Require Tezos.Raw_context.
Require Tezos.Seed_repr.
Require Tezos.Storage_mli. Module Storage := Storage_mli.

(* extensible_type_definition `error` *)

Definition t : Set := Seed_repr.nonce.

Definition nonce : Set := t.

Parameter encoding : Data_encoding.t nonce.

Definition unrevealed : Set := Storage.unrevealed_nonce.

Definition status : Set := Storage.nonce_status.

Parameter get :
  Raw_context.t -&gt; Level_repr.t -&gt; Lwt.t (Error_monad.tzresult status).

Parameter record_hash :
  Raw_context.t -&gt; unrevealed -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter reveal :
  Raw_context.t -&gt; Level_repr.t -&gt; nonce -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter of_bytes : MBytes.t -&gt; Error_monad.tzresult nonce.

Parameter __hash_value : nonce -&gt; Nonce_hash.t.

Parameter check_hash : nonce -&gt; Nonce_hash.t -&gt; bool.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="operation_repr.ml">
  <div style="margin: 20px;">
    <h3>Operation_repr</h3>
    <ul>
      <li>OCaml size: 880 lines</li>
      <li>Coq size: 1527 lines (+73% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#operation_repr.ml"><code>operation_repr.ml</code></a>&nbsp;<span class="label label-warning">7 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(* Tezos Protocol Implementation - Low level Repr. of Operations *)

module Kind = struct
  type seed_nonce_revelation = Seed_nonce_revelation_kind

  type double_endorsement_evidence = Double_endorsement_evidence_kind

  type double_baking_evidence = Double_baking_evidence_kind

  type activate_account = Activate_account_kind

  type endorsement = Endorsement_kind

  type proposals = Proposals_kind

  type ballot = Ballot_kind

  type reveal = Reveal_kind

  type transaction = Transaction_kind

  type origination = Origination_kind

  type delegation = Delegation_kind

  type 'a manager =
    | Reveal_manager_kind : reveal manager
    | Transaction_manager_kind : transaction manager
    | Origination_manager_kind : origination manager
    | Delegation_manager_kind : delegation manager
end

type raw = Operation.t

let raw_encoding = Operation.encoding

type _ contents_list =
  | Single : 'kind contents -&gt; 'kind contents_list
  | Cons :
      'kind Kind.manager contents * 'rest Kind.manager contents_list
      -&gt; ('kind * 'rest) Kind.manager contents_list

and 'kind protocol_data = {
  contents : 'kind contents_list;
  signature : Signature.t option;
}

and 'kind operation = {
  shell : Operation.shell_header;
  protocol_data : 'kind protocol_data;
}

and _ contents =
  | Endorsement : {level : Raw_level_repr.t} -&gt; Kind.endorsement contents
  | Seed_nonce_revelation : {
      level : Raw_level_repr.t;
      nonce : Seed_repr.nonce;
    }
      -&gt; Kind.seed_nonce_revelation contents
  | Double_endorsement_evidence : {
      op1 : Kind.endorsement operation;
      op2 : Kind.endorsement operation;
    }
      -&gt; Kind.double_endorsement_evidence contents
  | Double_baking_evidence : {
      bh1 : Block_header_repr.block_header;
      bh2 : Block_header_repr.block_header;
    }
      -&gt; Kind.double_baking_evidence contents
  | Activate_account : {
      id : Ed25519.Public_key_hash.t;
      activation_code : Blinded_public_key_hash.activation_code;
    }
      -&gt; Kind.activate_account contents
  | Proposals : {
      source : Signature.Public_key_hash.t;
      period : Voting_period_repr.t;
      proposals : Protocol_hash.t list;
    }
      -&gt; Kind.proposals contents
  | Ballot : {
      source : Signature.Public_key_hash.t;
      period : Voting_period_repr.t;
      proposal : Protocol_hash.t;
      ballot : Vote_repr.ballot;
    }
      -&gt; Kind.ballot contents
  | Manager_operation : {
      source : Signature.Public_key_hash.t;
      fee : Tez_repr.tez;
      counter : counter;
      operation : 'kind manager_operation;
      gas_limit : Z.t;
      storage_limit : Z.t;
    }
      -&gt; 'kind Kind.manager contents

and _ manager_operation =
  | Reveal : Signature.Public_key.t -&gt; Kind.reveal manager_operation
  | Transaction : {
      amount : Tez_repr.tez;
      parameters : Script_repr.lazy_expr;
      entrypoint : string;
      destination : Contract_repr.contract;
    }
      -&gt; Kind.transaction manager_operation
  | Origination : {
      delegate : Signature.Public_key_hash.t option;
      script : Script_repr.t;
      credit : Tez_repr.tez;
      preorigination : Contract_repr.t option;
    }
      -&gt; Kind.origination manager_operation
  | Delegation :
      Signature.Public_key_hash.t option
      -&gt; Kind.delegation manager_operation

and counter = Z.t

let manager_kind : type kind. kind manager_operation -&gt; kind Kind.manager =
  function
  | Reveal _ -&gt;
      Kind.Reveal_manager_kind
  | Transaction _ -&gt;
      Kind.Transaction_manager_kind
  | Origination _ -&gt;
      Kind.Origination_manager_kind
  | Delegation _ -&gt;
      Kind.Delegation_manager_kind

type 'kind internal_operation = {
  source : Contract_repr.contract;
  operation : 'kind manager_operation;
  nonce : int;
}

type packed_manager_operation =
  | Manager : 'kind manager_operation -&gt; packed_manager_operation

type packed_contents = Contents : 'kind contents -&gt; packed_contents

type packed_contents_list =
  | Contents_list : 'kind contents_list -&gt; packed_contents_list

type packed_protocol_data =
  | Operation_data : 'kind protocol_data -&gt; packed_protocol_data

type packed_operation = {
  shell : Operation.shell_header;
  protocol_data : packed_protocol_data;
}

let pack ({shell; protocol_data} : _ operation) : packed_operation =
  {shell; protocol_data = Operation_data protocol_data}

type packed_internal_operation =
  | Internal_operation : 'kind internal_operation -&gt; packed_internal_operation

let rec to_list = function
  | Contents_list content -&gt; (
    match content with
    | Single o -&gt;
        [Contents o]
    | Cons (o, os) -&gt;
        Contents o :: to_list (Contents_list os) )

let rec of_list = function
  | [] -&gt;
      <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
  | [Contents o] -&gt;
      Contents_list (Single o)
  | Contents o :: os -&gt; (
      let (Contents_list os) = of_list os in
      match (o, os) with
      | (Manager_operation _, Single (Manager_operation _)) -&gt;
          Contents_list (Cons (o, os))
      | (Manager_operation _, Cons _) -&gt;
          Contents_list (Cons (o, os))
      | _ -&gt;
          Pervasives.failwith
            &quot;Operation list of length &gt; 1 should only contains manager \
             operations.&quot; )

module Encoding = struct
  open Data_encoding

  let case tag name args proj inj =
    let open Data_encoding in
    case
      tag
      ~title:(String.capitalize_ascii name)
      (merge_objs (obj1 (req &quot;kind&quot; (constant name))) args)
      (fun x -&gt; match proj x with None -&gt; None | Some x -&gt; Some ((), x))
      (fun ((), x) -&gt; inj x)

  module Manager_operations = struct
    type 'kind case =
      | MCase : {
          tag : int;
          name : string;
          encoding : 'a Data_encoding.t;
          select : packed_manager_operation -&gt; 'kind manager_operation option;
          proj : 'kind manager_operation -&gt; 'a;
          inj : 'a -&gt; 'kind manager_operation;
        }
          -&gt; 'kind case
    [@@coq_force_gadt]

    let reveal_case =
      MCase
        {
          tag = 0;
          name = &quot;reveal&quot;;
          encoding = obj1 (req &quot;public_key&quot; Signature.Public_key.encoding);
          select = (function Manager (Reveal _ as op) -&gt; Some op | _ -&gt; None);
          proj = (function[@coq_match_with_default] Reveal pkh -&gt; pkh);
          inj = (fun pkh -&gt; Reveal pkh);
        }

    let entrypoint_encoding =
      def
        ~title:&quot;entrypoint&quot;
        ~description:&quot;Named entrypoint to a Michelson smart contract&quot;
        &quot;entrypoint&quot;
      @@
      let builtin_case tag name =
        Data_encoding.case
          (Tag tag)
          ~title:name
          (constant name)
          (fun n -&gt; if Compare.String.(n = name) then Some () else None)
          (fun () -&gt; name)
      in
      union
        [ builtin_case 0 &quot;default&quot;;
          builtin_case 1 &quot;root&quot;;
          builtin_case 2 &quot;do&quot;;
          builtin_case 3 &quot;set_delegate&quot;;
          builtin_case 4 &quot;remove_delegate&quot;;
          Data_encoding.case
            (Tag 255)
            ~title:&quot;named&quot;
            (Bounded.string 31)
            (fun s -&gt; Some s)
            (fun s -&gt; s) ]

    let transaction_case =
      MCase
        {
          tag = 1;
          name = &quot;transaction&quot;;
          encoding =
            obj3
              (req &quot;amount&quot; Tez_repr.encoding)
              (req &quot;destination&quot; Contract_repr.encoding)
              (opt
                 &quot;parameters&quot;
                 (obj2
                    (req &quot;entrypoint&quot; entrypoint_encoding)
                    (req &quot;value&quot; Script_repr.lazy_expr_encoding)));
          select =
            (function Manager (Transaction _ as op) -&gt; Some op | _ -&gt; None);
          proj =
            (function[@coq_match_with_default]
            | Transaction {amount; destination; parameters; entrypoint} -&gt;
                let parameters =
                  if
                    Script_repr.is_unit_parameter parameters
                    &amp;&amp; Compare.String.(entrypoint = &quot;default&quot;)
                  then None
                  else Some (entrypoint, parameters)
                in
                (amount, destination, parameters));
          inj =
            (fun (amount, destination, parameters) -&gt;
              let (entrypoint, parameters) =
                match parameters with
                | None -&gt;
                    (&quot;default&quot;, Script_repr.unit_parameter)
                | Some (entrypoint, value) -&gt;
                    (entrypoint, value)
              in
              Transaction {amount; destination; parameters; entrypoint});
        }

    let origination_case =
      MCase
        {
          tag = 2;
          name = &quot;origination&quot;;
          encoding =
            obj3
              (req &quot;balance&quot; Tez_repr.encoding)
              (opt &quot;delegate&quot; Signature.Public_key_hash.encoding)
              (req &quot;script&quot; Script_repr.encoding);
          select =
            (function Manager (Origination _ as op) -&gt; Some op | _ -&gt; None);
          proj =
            (function[@coq_match_with_default]
            | Origination
                { credit;
                  delegate;
                  script;
                  preorigination =
                    _
                    (* the hash is only used internally
                               when originating from smart
                               contracts, don't serialize it *)
                } -&gt;
                (credit, delegate, script));
          inj =
            (fun (credit, delegate, script) -&gt;
              Origination {credit; delegate; script; preorigination = None});
        }

    let delegation_case =
      MCase
        {
          tag = 3;
          name = &quot;delegation&quot;;
          encoding = obj1 (opt &quot;delegate&quot; Signature.Public_key_hash.encoding);
          select =
            (function Manager (Delegation _ as op) -&gt; Some op | _ -&gt; None);
          proj = (function[@coq_match_with_default] Delegation key -&gt; key);
          inj = (fun key -&gt; Delegation key);
        }

    let encoding =
      let make (MCase {tag; name; encoding; select; proj; inj}) =
        case
          (Tag tag)
          name
          encoding
          (fun o -&gt;
            match select o with None -&gt; None | Some o -&gt; Some (proj o))
          (fun x -&gt; Manager (inj x))
      in
      union
        ~tag_size:`Uint8
        [ make reveal_case;
          make transaction_case;
          make origination_case;
          make delegation_case ]
  end

  type 'b case =
    | Case : {
        tag : int;
        name : string;
        encoding : 'a Data_encoding.t;
        select : packed_contents -&gt; 'b contents option;
        proj : 'b contents -&gt; 'a;
        inj : 'a -&gt; 'b contents;
      }
        -&gt; 'b case
  [@@coq_force_gadt]

  let raw_endorsement_encoding = obj1 (req &quot;level&quot; Raw_level_repr.encoding)

  let endorsement_case =
    Case
      {
        tag = 0;
        name = &quot;endorsement&quot;;
        encoding = raw_endorsement_encoding;
        select =
          (function Contents (Endorsement _ as op) -&gt; Some op | _ -&gt; None);
        proj = (fun [@coq_match_with_default] (Endorsement {level}) -&gt; level);
        inj = (fun level -&gt; Endorsement {level});
      }

  let endorsement_encoding =
    let make = function
      | Case {tag; name; encoding; select = _; proj; inj} -&gt;
          case
            (Tag tag)
            name
            encoding
            (fun o -&gt; Some (proj o))
            (fun x -&gt; inj x)
    in
    let to_list : Kind.endorsement contents_list -&gt; _ =
      function[@coq_match_with_default]
      | Single o -&gt;
          o
    in
    let of_list : Kind.endorsement contents -&gt; _ = function o -&gt; Single o in
    def &quot;inlined.endorsement&quot;
    @@ conv
         (fun ({shell; protocol_data = {contents; signature}} : _ operation) -&gt;
           (shell, (contents, signature)))
         (fun (shell, (contents, signature)) -&gt;
           ({shell; protocol_data = {contents; signature}} : _ operation))
         (merge_objs
            Operation.shell_header_encoding
            (obj2
               (req
                  &quot;operations&quot;
                  ( conv to_list of_list
                  @@ def &quot;inlined.endorsement.contents&quot;
                  @@ union [make endorsement_case] ))
               (varopt &quot;signature&quot; Signature.encoding)))

  let seed_nonce_revelation_case =
    Case
      {
        tag = 1;
        name = &quot;seed_nonce_revelation&quot;;
        encoding =
          obj2
            (req &quot;level&quot; Raw_level_repr.encoding)
            (req &quot;nonce&quot; Seed_repr.nonce_encoding);
        select =
          (function
          | Contents (Seed_nonce_revelation _ as op) -&gt; Some op | _ -&gt; None);
        proj =
          (fun [@coq_match_with_default] (Seed_nonce_revelation {level; nonce}) -&gt;
            (level, nonce));
        inj = (fun (level, nonce) -&gt; Seed_nonce_revelation {level; nonce});
      }

  let double_endorsement_evidence_case : Kind.double_endorsement_evidence case
      =
    Case
      {
        tag = 2;
        name = &quot;double_endorsement_evidence&quot;;
        encoding =
          obj2
            (req &quot;op1&quot; (dynamic_size endorsement_encoding))
            (req &quot;op2&quot; (dynamic_size endorsement_encoding));
        select =
          (function
          | Contents (Double_endorsement_evidence _ as op) -&gt;
              Some op
          | _ -&gt;
              None);
        proj =
          (fun [@coq_match_with_default] (Double_endorsement_evidence
                                           {op1; op2}) -&gt;
            (op1, op2));
        inj = (fun (op1, op2) -&gt; Double_endorsement_evidence {op1; op2});
      }

  let double_baking_evidence_case =
    Case
      {
        tag = 3;
        name = &quot;double_baking_evidence&quot;;
        encoding =
          obj2
            (req &quot;bh1&quot; (dynamic_size Block_header_repr.encoding))
            (req &quot;bh2&quot; (dynamic_size Block_header_repr.encoding));
        select =
          (function
          | Contents (Double_baking_evidence _ as op) -&gt; Some op | _ -&gt; None);
        proj =
          (fun [@coq_match_with_default] (Double_baking_evidence {bh1; bh2}) -&gt;
            (bh1, bh2));
        inj = (fun (bh1, bh2) -&gt; Double_baking_evidence {bh1; bh2});
      }

  let activate_account_case =
    Case
      {
        tag = 4;
        name = &quot;activate_account&quot;;
        encoding =
          obj2
            (req &quot;pkh&quot; Ed25519.Public_key_hash.encoding)
            (req &quot;secret&quot; Blinded_public_key_hash.activation_code_encoding);
        select =
          (function
          | Contents (Activate_account _ as op) -&gt; Some op | _ -&gt; None);
        proj =
          (fun [@coq_match_with_default] (Activate_account
                                           {id; activation_code}) -&gt;
            (id, activation_code));
        inj =
          (fun (id, activation_code) -&gt; Activate_account {id; activation_code});
      }

  let proposals_case =
    Case
      {
        tag = 5;
        name = &quot;proposals&quot;;
        encoding =
          obj3
            (req &quot;source&quot; Signature.Public_key_hash.encoding)
            (req &quot;period&quot; Voting_period_repr.encoding)
            (req &quot;proposals&quot; (list Protocol_hash.encoding));
        select =
          (function Contents (Proposals _ as op) -&gt; Some op | _ -&gt; None);
        proj =
          (fun [@coq_match_with_default] (Proposals
                                           {source; period; proposals}) -&gt;
            (source, period, proposals));
        inj =
          (fun (source, period, proposals) -&gt;
            Proposals {source; period; proposals});
      }

  let ballot_case =
    Case
      {
        tag = 6;
        name = &quot;ballot&quot;;
        encoding =
          obj4
            (req &quot;source&quot; Signature.Public_key_hash.encoding)
            (req &quot;period&quot; Voting_period_repr.encoding)
            (req &quot;proposal&quot; Protocol_hash.encoding)
            (req &quot;ballot&quot; Vote_repr.ballot_encoding);
        select = (function Contents (Ballot _ as op) -&gt; Some op | _ -&gt; None);
        proj =
          (function[@coq_match_with_default]
          | Ballot {source; period; proposal; ballot} -&gt;
              (source, period, proposal, ballot));
        inj =
          (fun (source, period, proposal, ballot) -&gt;
            Ballot {source; period; proposal; ballot});
      }

  let manager_encoding =
    obj5
      (req &quot;source&quot; Signature.Public_key_hash.encoding)
      (req &quot;fee&quot; Tez_repr.encoding)
      (req &quot;counter&quot; (check_size 10 n))
      (req &quot;gas_limit&quot; (check_size 10 n))
      (req &quot;storage_limit&quot; (check_size 10 n))

  let extract : type kind. kind Kind.manager contents -&gt; _ =
   fun [@coq_match_with_default] (Manager_operation
                                   { source;
                                     fee;
                                     counter;
                                     gas_limit;
                                     storage_limit;
                                     operation = _ }) -&gt;
    (source, fee, counter, gas_limit, storage_limit)

  let rebuild (source, fee, counter, gas_limit, storage_limit) operation =
    Manager_operation
      {source; fee; counter; gas_limit; storage_limit; operation}

  let make_manager_case tag (type kind)
      (Manager_operations.MCase mcase : kind Manager_operations.case) =
    Case
      {
        tag;
        name = mcase.name;
        encoding = merge_objs manager_encoding mcase.encoding;
        select =
          (function
          | Contents (Manager_operation ({operation; _} as op)) -&gt; (
            match mcase.select (Manager operation) with
            | None -&gt;
                None
            | Some operation -&gt;
                Some (Manager_operation {op with operation}) )
          | _ -&gt;
              None);
        proj =
          (function[@coq_match_with_default]
          | Manager_operation {operation; _} as op -&gt;
              (extract op, mcase.proj operation));
        inj = (fun (op, contents) -&gt; rebuild op (mcase.inj contents));
      }

  let reveal_case = make_manager_case 107 Manager_operations.reveal_case

  let transaction_case =
    make_manager_case 108 Manager_operations.transaction_case

  let origination_case =
    make_manager_case 109 Manager_operations.origination_case

  let delegation_case =
    make_manager_case 110 Manager_operations.delegation_case

  let contents_encoding =
    let make (Case {tag; name; encoding; select; proj; inj}) =
      case
        (Tag tag)
        name
        encoding
        (fun o -&gt; match select o with None -&gt; None | Some o -&gt; Some (proj o))
        (fun x -&gt; Contents (inj x))
    in
    def &quot;operation.alpha.contents&quot;
    @@ union
         [ make endorsement_case;
           make seed_nonce_revelation_case;
           make double_endorsement_evidence_case;
           make double_baking_evidence_case;
           make activate_account_case;
           make proposals_case;
           make ballot_case;
           make reveal_case;
           make transaction_case;
           make origination_case;
           make delegation_case ]

  let contents_list_encoding =
    conv to_list of_list (Variable.list contents_encoding)

  let optional_signature_encoding =
    conv
      (function Some s -&gt; s | None -&gt; Signature.zero)
      (fun s -&gt; if Signature.equal s Signature.zero then None else Some s)
      Signature.encoding

  let protocol_data_encoding =
    def &quot;operation.alpha.contents_and_signature&quot;
    @@ conv
         (fun (Operation_data {contents; signature}) -&gt;
           (Contents_list contents, signature))
         (fun (Contents_list contents, signature) -&gt;
           Operation_data {contents; signature})
         (obj2
            (req &quot;contents&quot; contents_list_encoding)
            (req &quot;signature&quot; optional_signature_encoding))

  let operation_encoding =
    conv
      (fun {shell; protocol_data} -&gt; (shell, protocol_data))
      (fun (shell, protocol_data) -&gt; {shell; protocol_data})
      (merge_objs Operation.shell_header_encoding protocol_data_encoding)

  let unsigned_operation_encoding =
    def &quot;operation.alpha.unsigned_operation&quot;
    @@ merge_objs
         Operation.shell_header_encoding
         (obj1 (req &quot;contents&quot; contents_list_encoding))

  let internal_operation_encoding =
    def &quot;operation.alpha.internal_operation&quot;
    @@ conv
         (fun (Internal_operation {source; operation; nonce}) -&gt;
           ((source, nonce), Manager operation))
         (fun ((source, nonce), Manager operation) -&gt;
           Internal_operation {source; operation; nonce})
         (merge_objs
            (obj2 (req &quot;source&quot; Contract_repr.encoding) (req &quot;nonce&quot; uint16))
            Manager_operations.encoding)
end

let encoding = Encoding.operation_encoding

let contents_encoding = Encoding.contents_encoding

let contents_list_encoding = Encoding.contents_list_encoding

let protocol_data_encoding = Encoding.protocol_data_encoding

let unsigned_operation_encoding = Encoding.unsigned_operation_encoding

let internal_operation_encoding = Encoding.internal_operation_encoding

let raw ({shell; protocol_data} : _ operation) =
  let proto =
    Data_encoding.Binary.to_bytes_exn
      protocol_data_encoding
      (Operation_data protocol_data)
  in
  {Operation.shell; proto}

let acceptable_passes (op : packed_operation) =
  let (Operation_data protocol_data) = op.protocol_data in
  match protocol_data.contents with
  | Single (Endorsement _) -&gt;
      [0]
  | Single (Proposals _) -&gt;
      [1]
  | Single (Ballot _) -&gt;
      [1]
  | Single (Seed_nonce_revelation _) -&gt;
      [2]
  | Single (Double_endorsement_evidence _) -&gt;
      [2]
  | Single (Double_baking_evidence _) -&gt;
      [2]
  | Single (Activate_account _) -&gt;
      [2]
  | Single (Manager_operation _) -&gt;
      [3]
  | Cons _ -&gt;
      [3]

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Invalid_signature</abbr> (* `Permanent *)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Missing_signature</abbr> (* `Permanent *)

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  register_error_kind
    `Permanent
    ~id:&quot;operation.invalid_signature&quot;
    ~title:&quot;Invalid operation signature&quot;
    ~description:
      &quot;The operation signature is ill-formed or has been made with the wrong \
       public key&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;The operation signature is invalid&quot;)
    Data_encoding.unit
    (function Invalid_signature -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Invalid_signature) ;
  register_error_kind
    `Permanent
    ~id:&quot;operation.missing_signature&quot;
    ~title:&quot;Missing operation signature&quot;
    ~description:
      &quot;The operation is of a kind that must be signed, but the signature is \
       missing&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;The operation requires a signature&quot;)
    Data_encoding.unit
    (function Missing_signature -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Missing_signature)</abbr>

let check_signature_sync (type kind) key chain_id
    ({shell; protocol_data} : kind operation) =
  let check ~watermark contents signature =
    let unsigned_operation =
      Data_encoding.Binary.to_bytes_exn
        unsigned_operation_encoding
        (shell, contents)
    in
    if Signature.check ~watermark key signature unsigned_operation then Ok ()
    else error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_signature</abbr>
  in
  match (protocol_data.contents, protocol_data.signature) with
  | (Single _, None) -&gt;
      error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Missing_signature</abbr>
  | (Cons _, None) -&gt;
      error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Missing_signature</abbr>
  | ((Single (Endorsement _) as contents), Some signature) -&gt;
      check
        ~watermark:(Endorsement chain_id)
        (Contents_list contents)
        signature
  | ((Single _ as contents), Some signature) -&gt;
      check ~watermark:Generic_operation (Contents_list contents) signature
  | ((Cons _ as contents), Some signature) -&gt;
      check ~watermark:Generic_operation (Contents_list contents) signature

let check_signature pk chain_id op =
  Lwt.return (check_signature_sync pk chain_id op)

let hash_raw = Operation.hash

let hash (o : _ operation) =
  let proto =
    Data_encoding.Binary.to_bytes_exn
      protocol_data_encoding
      (Operation_data o.protocol_data)
  in
  Operation.hash {shell = o.shell; proto}

let hash_packed (o : packed_operation) =
  let proto =
    Data_encoding.Binary.to_bytes_exn protocol_data_encoding o.protocol_data
  in
  Operation.hash {shell = o.shell; proto}

type ('a, 'b) eq = Eq : ('a, 'a) eq

let equal_manager_operation_kind :
    type a b. a manager_operation -&gt; b manager_operation -&gt; (a, b) eq option =
 fun op1 op2 -&gt;
  match (op1, op2) with
  | (Reveal _, Reveal _) -&gt;
      Some Eq
  | (Reveal _, _) -&gt;
      None
  | (Transaction _, Transaction _) -&gt;
      Some Eq
  | (Transaction _, _) -&gt;
      None
  | (Origination _, Origination _) -&gt;
      Some Eq
  | (Origination _, _) -&gt;
      None
  | (Delegation _, Delegation _) -&gt;
      Some Eq
  | (Delegation _, _) -&gt;
      None

let equal_contents_kind :
    type a b. a contents -&gt; b contents -&gt; (a, b) eq option =
 fun op1 op2 -&gt;
  match (op1, op2) with
  | (Endorsement _, Endorsement _) -&gt;
      Some Eq
  | (Endorsement _, _) -&gt;
      None
  | (Seed_nonce_revelation _, Seed_nonce_revelation _) -&gt;
      Some Eq
  | (Seed_nonce_revelation _, _) -&gt;
      None
  | (Double_endorsement_evidence _, Double_endorsement_evidence _) -&gt;
      Some Eq
  | (Double_endorsement_evidence _, _) -&gt;
      None
  | (Double_baking_evidence _, Double_baking_evidence _) -&gt;
      Some Eq
  | (Double_baking_evidence _, _) -&gt;
      None
  | (Activate_account _, Activate_account _) -&gt;
      Some Eq
  | (Activate_account _, _) -&gt;
      None
  | (Proposals _, Proposals _) -&gt;
      Some Eq
  | (Proposals _, _) -&gt;
      None
  | (Ballot _, Ballot _) -&gt;
      Some Eq
  | (Ballot _, _) -&gt;
      None
  | (Manager_operation op1, Manager_operation op2) -&gt; (
    match equal_manager_operation_kind op1.operation op2.operation with
    | None -&gt;
        None
    | Some Eq -&gt;
        Some Eq )
  | (Manager_operation _, _) -&gt;
      None

let rec equal_contents_kind_list :
    type a b. a contents_list -&gt; b contents_list -&gt; (a, b) eq option =
 fun op1 op2 -&gt;
  match (op1, op2) with
  | (Single op1, Single op2) -&gt;
      equal_contents_kind op1 op2
  | (Single _, Cons _) -&gt;
      None
  | (Cons _, Single _) -&gt;
      None
  | (Cons (op1, ops1), Cons (op2, ops2)) -&gt; (
    match equal_contents_kind op1 op2 with
    | None -&gt;
        None
    | Some Eq -&gt; (
      match equal_contents_kind_list ops1 ops2 with
      | None -&gt;
          None
      | Some Eq -&gt;
          Some Eq ) )

let equal : type a b. a operation -&gt; b operation -&gt; (a, b) eq option =
 fun op1 op2 -&gt;
  if not (Operation_hash.equal (hash op1) (hash op2)) then None
  else
    equal_contents_kind_list
      op1.protocol_data.contents
      op2.protocol_data.contents
</pre>
  </div>
  <div class="col-md-6">
    <a href="#operation_repr.ml"><code>Operation_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Blinded_public_key_hash.
Require Tezos.Block_header_repr.
Require Tezos.Contract_repr.
Require Tezos.Raw_level_repr.
Require Tezos.Script_repr.
Require Tezos.Seed_repr.
Require Tezos.Tez_repr.
Require Tezos.Vote_repr.
Require Tezos.Voting_period_repr.

Module Kind.
  Inductive seed_nonce_revelation : Set :=
  | Seed_nonce_revelation_kind : seed_nonce_revelation.
  
  Inductive double_endorsement_evidence : Set :=
  | Double_endorsement_evidence_kind : double_endorsement_evidence.
  
  Inductive double_baking_evidence : Set :=
  | Double_baking_evidence_kind : double_baking_evidence.
  
  Inductive activate_account : Set :=
  | Activate_account_kind : activate_account.
  
  Inductive endorsement : Set :=
  | Endorsement_kind : endorsement.
  
  Inductive proposals : Set :=
  | Proposals_kind : proposals.
  
  Inductive ballot : Set :=
  | Ballot_kind : ballot.
  
  Inductive reveal : Set :=
  | Reveal_kind : reveal.
  
  Inductive transaction : Set :=
  | Transaction_kind : transaction.
  
  Inductive origination : Set :=
  | Origination_kind : origination.
  
  Inductive delegation : Set :=
  | Delegation_kind : delegation.
  
  Inductive manager : Set :=
  | Reveal_manager_kind : manager
  | Transaction_manager_kind : manager
  | Origination_manager_kind : manager
  | Delegation_manager_kind : manager.
End Kind.

Definition raw : Set := Operation.t.

Definition raw_encoding : Data_encoding.t Operation.t := Operation.encoding.

Module ConstructorRecords_contents_list_contents_manager_operation.
  Module contents.
    Module Endorsement.
      Record record {level : Set} : Set := Build {
        level : level }.
      Arguments record : clear implicits.
      Definition with_level {t_level} level (r : record t_level) :=
        Build t_level level.
    End Endorsement.
    Definition Endorsement_skeleton := Endorsement.record.
    
    Module Seed_nonce_revelation.
      Record record {level nonce : Set} : Set := Build {
        level : level;
        nonce : nonce }.
      Arguments record : clear implicits.
      Definition with_level {t_level t_nonce} level
        (r : record t_level t_nonce) :=
        Build t_level t_nonce level r.(nonce).
      Definition with_nonce {t_level t_nonce} nonce
        (r : record t_level t_nonce) :=
        Build t_level t_nonce r.(level) nonce.
    End Seed_nonce_revelation.
    Definition Seed_nonce_revelation_skeleton := Seed_nonce_revelation.record.
    
    Module Double_endorsement_evidence.
      Record record {op1 op2 : Set} : Set := Build {
        op1 : op1;
        op2 : op2 }.
      Arguments record : clear implicits.
      Definition with_op1 {t_op1 t_op2} op1 (r : record t_op1 t_op2) :=
        Build t_op1 t_op2 op1 r.(op2).
      Definition with_op2 {t_op1 t_op2} op2 (r : record t_op1 t_op2) :=
        Build t_op1 t_op2 r.(op1) op2.
    End Double_endorsement_evidence.
    Definition Double_endorsement_evidence_skeleton :=
      Double_endorsement_evidence.record.
    
    Module Double_baking_evidence.
      Record record {bh1 bh2 : Set} : Set := Build {
        bh1 : bh1;
        bh2 : bh2 }.
      Arguments record : clear implicits.
      Definition with_bh1 {t_bh1 t_bh2} bh1 (r : record t_bh1 t_bh2) :=
        Build t_bh1 t_bh2 bh1 r.(bh2).
      Definition with_bh2 {t_bh1 t_bh2} bh2 (r : record t_bh1 t_bh2) :=
        Build t_bh1 t_bh2 r.(bh1) bh2.
    End Double_baking_evidence.
    Definition Double_baking_evidence_skeleton := Double_baking_evidence.record.
    
    Module Activate_account.
      Record record {id activation_code : Set} : Set := Build {
        id : id;
        activation_code : activation_code }.
      Arguments record : clear implicits.
      Definition with_id {t_id t_activation_code} id
        (r : record t_id t_activation_code) :=
        Build t_id t_activation_code id r.(activation_code).
      Definition with_activation_code {t_id t_activation_code} activation_code
        (r : record t_id t_activation_code) :=
        Build t_id t_activation_code r.(id) activation_code.
    End Activate_account.
    Definition Activate_account_skeleton := Activate_account.record.
    
    Module Proposals.
      Record record {source period proposals : Set} : Set := Build {
        source : source;
        period : period;
        proposals : proposals }.
      Arguments record : clear implicits.
      Definition with_source {t_source t_period t_proposals} source
        (r : record t_source t_period t_proposals) :=
        Build t_source t_period t_proposals source r.(period) r.(proposals).
      Definition with_period {t_source t_period t_proposals} period
        (r : record t_source t_period t_proposals) :=
        Build t_source t_period t_proposals r.(source) period r.(proposals).
      Definition with_proposals {t_source t_period t_proposals} proposals
        (r : record t_source t_period t_proposals) :=
        Build t_source t_period t_proposals r.(source) r.(period) proposals.
    End Proposals.
    Definition Proposals_skeleton := Proposals.record.
    
    Module Ballot.
      Record record {source period proposal ballot : Set} : Set := Build {
        source : source;
        period : period;
        proposal : proposal;
        ballot : ballot }.
      Arguments record : clear implicits.
      Definition with_source {t_source t_period t_proposal t_ballot} source
        (r : record t_source t_period t_proposal t_ballot) :=
        Build t_source t_period t_proposal t_ballot source r.(period)
          r.(proposal) r.(ballot).
      Definition with_period {t_source t_period t_proposal t_ballot} period
        (r : record t_source t_period t_proposal t_ballot) :=
        Build t_source t_period t_proposal t_ballot r.(source) period
          r.(proposal) r.(ballot).
      Definition with_proposal {t_source t_period t_proposal t_ballot} proposal
        (r : record t_source t_period t_proposal t_ballot) :=
        Build t_source t_period t_proposal t_ballot r.(source) r.(period)
          proposal r.(ballot).
      Definition with_ballot {t_source t_period t_proposal t_ballot} ballot
        (r : record t_source t_period t_proposal t_ballot) :=
        Build t_source t_period t_proposal t_ballot r.(source) r.(period)
          r.(proposal) ballot.
    End Ballot.
    Definition Ballot_skeleton := Ballot.record.
    
    Module Manager_operation.
      Record record {source fee counter operation gas_limit storage_limit : Set} :
        Set := Build {
        source : source;
        fee : fee;
        counter : counter;
        operation : operation;
        gas_limit : gas_limit;
        storage_limit : storage_limit }.
      Arguments record : clear implicits.
      Definition with_source
        {t_source t_fee t_counter t_operation t_gas_limit t_storage_limit}
        source
        (r :
          record t_source t_fee t_counter t_operation t_gas_limit
            t_storage_limit) :=
        Build t_source t_fee t_counter t_operation t_gas_limit t_storage_limit
          source r.(fee) r.(counter) r.(operation) r.(gas_limit)
          r.(storage_limit).
      Definition with_fee
        {t_source t_fee t_counter t_operation t_gas_limit t_storage_limit} fee
        (r :
          record t_source t_fee t_counter t_operation t_gas_limit
            t_storage_limit) :=
        Build t_source t_fee t_counter t_operation t_gas_limit t_storage_limit
          r.(source) fee r.(counter) r.(operation) r.(gas_limit)
          r.(storage_limit).
      Definition with_counter
        {t_source t_fee t_counter t_operation t_gas_limit t_storage_limit}
        counter
        (r :
          record t_source t_fee t_counter t_operation t_gas_limit
            t_storage_limit) :=
        Build t_source t_fee t_counter t_operation t_gas_limit t_storage_limit
          r.(source) r.(fee) counter r.(operation) r.(gas_limit)
          r.(storage_limit).
      Definition with_operation
        {t_source t_fee t_counter t_operation t_gas_limit t_storage_limit}
        operation
        (r :
          record t_source t_fee t_counter t_operation t_gas_limit
            t_storage_limit) :=
        Build t_source t_fee t_counter t_operation t_gas_limit t_storage_limit
          r.(source) r.(fee) r.(counter) operation r.(gas_limit)
          r.(storage_limit).
      Definition with_gas_limit
        {t_source t_fee t_counter t_operation t_gas_limit t_storage_limit}
        gas_limit
        (r :
          record t_source t_fee t_counter t_operation t_gas_limit
            t_storage_limit) :=
        Build t_source t_fee t_counter t_operation t_gas_limit t_storage_limit
          r.(source) r.(fee) r.(counter) r.(operation) gas_limit
          r.(storage_limit).
      Definition with_storage_limit
        {t_source t_fee t_counter t_operation t_gas_limit t_storage_limit}
        storage_limit
        (r :
          record t_source t_fee t_counter t_operation t_gas_limit
            t_storage_limit) :=
        Build t_source t_fee t_counter t_operation t_gas_limit t_storage_limit
          r.(source) r.(fee) r.(counter) r.(operation) r.(gas_limit)
          storage_limit.
    End Manager_operation.
    Definition Manager_operation_skeleton := Manager_operation.record.
  End contents.
  Module manager_operation.
    Module Transaction.
      Record record {amount parameters entrypoint destination : Set} : Set := Build {
        amount : amount;
        parameters : parameters;
        entrypoint : entrypoint;
        destination : destination }.
      Arguments record : clear implicits.
      Definition with_amount {t_amount t_parameters t_entrypoint t_destination}
        amount (r : record t_amount t_parameters t_entrypoint t_destination) :=
        Build t_amount t_parameters t_entrypoint t_destination amount
          r.(parameters) r.(entrypoint) r.(destination).
      Definition with_parameters
        {t_amount t_parameters t_entrypoint t_destination} parameters
        (r : record t_amount t_parameters t_entrypoint t_destination) :=
        Build t_amount t_parameters t_entrypoint t_destination r.(amount)
          parameters r.(entrypoint) r.(destination).
      Definition with_entrypoint
        {t_amount t_parameters t_entrypoint t_destination} entrypoint
        (r : record t_amount t_parameters t_entrypoint t_destination) :=
        Build t_amount t_parameters t_entrypoint t_destination r.(amount)
          r.(parameters) entrypoint r.(destination).
      Definition with_destination
        {t_amount t_parameters t_entrypoint t_destination} destination
        (r : record t_amount t_parameters t_entrypoint t_destination) :=
        Build t_amount t_parameters t_entrypoint t_destination r.(amount)
          r.(parameters) r.(entrypoint) destination.
    End Transaction.
    Definition Transaction_skeleton := Transaction.record.
    
    Module Origination.
      Record record {delegate script credit preorigination : Set} : Set := Build {
        delegate : delegate;
        script : script;
        credit : credit;
        preorigination : preorigination }.
      Arguments record : clear implicits.
      Definition with_delegate {t_delegate t_script t_credit t_preorigination}
        delegate (r : record t_delegate t_script t_credit t_preorigination) :=
        Build t_delegate t_script t_credit t_preorigination delegate r.(script)
          r.(credit) r.(preorigination).
      Definition with_script {t_delegate t_script t_credit t_preorigination}
        script (r : record t_delegate t_script t_credit t_preorigination) :=
        Build t_delegate t_script t_credit t_preorigination r.(delegate) script
          r.(credit) r.(preorigination).
      Definition with_credit {t_delegate t_script t_credit t_preorigination}
        credit (r : record t_delegate t_script t_credit t_preorigination) :=
        Build t_delegate t_script t_credit t_preorigination r.(delegate)
          r.(script) credit r.(preorigination).
      Definition with_preorigination
        {t_delegate t_script t_credit t_preorigination} preorigination
        (r : record t_delegate t_script t_credit t_preorigination) :=
        Build t_delegate t_script t_credit t_preorigination r.(delegate)
          r.(script) r.(credit) preorigination.
    End Origination.
    Definition Origination_skeleton := Origination.record.
  End manager_operation.
End ConstructorRecords_contents_list_contents_manager_operation.
Import ConstructorRecords_contents_list_contents_manager_operation.

Module operation.
  Record record {shell protocol_data : Set} : Set := Build {
    shell : shell;
    protocol_data : protocol_data }.
  Arguments record : clear implicits.
  Definition with_shell {t_shell t_protocol_data} shell
    (r : record t_shell t_protocol_data) :=
    Build t_shell t_protocol_data shell r.(protocol_data).
  Definition with_protocol_data {t_shell t_protocol_data} protocol_data
    (r : record t_shell t_protocol_data) :=
    Build t_shell t_protocol_data r.(shell) protocol_data.
End operation.
Definition operation_skeleton := operation.record.

Module protocol_data.
  Record record {contents signature : Set} : Set := Build {
    contents : contents;
    signature : signature }.
  Arguments record : clear implicits.
  Definition with_contents {t_contents t_signature} contents
    (r : record t_contents t_signature) :=
    Build t_contents t_signature contents r.(signature).
  Definition with_signature {t_contents t_signature} signature
    (r : record t_contents t_signature) :=
    Build t_contents t_signature r.(contents) signature.
End protocol_data.
Definition protocol_data_skeleton := protocol_data.record.

Reserved Notation &quot;'contents.Endorsement&quot;.
Reserved Notation &quot;'contents.Seed_nonce_revelation&quot;.
Reserved Notation &quot;'contents.Double_endorsement_evidence&quot;.
Reserved Notation &quot;'contents.Double_baking_evidence&quot;.
Reserved Notation &quot;'contents.Activate_account&quot;.
Reserved Notation &quot;'contents.Proposals&quot;.
Reserved Notation &quot;'contents.Ballot&quot;.
Reserved Notation &quot;'contents.Manager_operation&quot;.
Reserved Notation &quot;'manager_operation.Transaction&quot;.
Reserved Notation &quot;'manager_operation.Origination&quot;.
Reserved Notation &quot;'protocol_data&quot;.
Reserved Notation &quot;'operation&quot;.
Reserved Notation &quot;'counter&quot;.

Inductive contents_list : Set :=
| Single : contents -&gt; contents_list
| Cons : contents -&gt; contents_list -&gt; contents_list

with contents : Set :=
| Endorsement : 'contents.Endorsement -&gt; contents
| Seed_nonce_revelation : 'contents.Seed_nonce_revelation -&gt; contents
| Double_endorsement_evidence :
  'contents.Double_endorsement_evidence -&gt; contents
| Double_baking_evidence : 'contents.Double_baking_evidence -&gt; contents
| Activate_account : 'contents.Activate_account -&gt; contents
| Proposals : 'contents.Proposals -&gt; contents
| Ballot : 'contents.Ballot -&gt; contents
| Manager_operation : 'contents.Manager_operation -&gt; contents

with manager_operation : Set :=
| Reveal : (|Signature.Public_key|).(S.SPublic_key.t) -&gt; manager_operation
| Transaction : 'manager_operation.Transaction -&gt; manager_operation
| Origination : 'manager_operation.Origination -&gt; manager_operation
| Delegation :
  option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  manager_operation

where &quot;'protocol_data&quot; :=
  (protocol_data_skeleton contents_list (option Signature.t))
and &quot;'operation&quot; := (operation_skeleton Operation.shell_header 'protocol_data)
and &quot;'counter&quot; := (Z.t)
and &quot;'contents.Endorsement&quot; := (contents.Endorsement_skeleton Raw_level_repr.t)
and &quot;'contents.Seed_nonce_revelation&quot; :=
  (contents.Seed_nonce_revelation_skeleton Raw_level_repr.t Seed_repr.nonce)
and &quot;'contents.Double_endorsement_evidence&quot; :=
  (contents.Double_endorsement_evidence_skeleton 'operation 'operation)
and &quot;'contents.Double_baking_evidence&quot; :=
  (contents.Double_baking_evidence_skeleton Block_header_repr.block_header
    Block_header_repr.block_header)
and &quot;'contents.Activate_account&quot; :=
  (contents.Activate_account_skeleton
    (|Ed25519|).(S.SIGNATURE.Public_key_hash).(S.SPublic_key_hash.t)
    Blinded_public_key_hash.activation_code)
and &quot;'contents.Proposals&quot; :=
  (contents.Proposals_skeleton
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) Voting_period_repr.t
    (list (|Protocol_hash|).(S.HASH.t)))
and &quot;'contents.Ballot&quot; :=
  (contents.Ballot_skeleton (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)
    Voting_period_repr.t (|Protocol_hash|).(S.HASH.t) Vote_repr.ballot)
and &quot;'contents.Manager_operation&quot; :=
  (contents.Manager_operation_skeleton
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) Tez_repr.tez 'counter
    manager_operation Z.t Z.t)
and &quot;'manager_operation.Transaction&quot; :=
  (manager_operation.Transaction_skeleton Tez_repr.tez Script_repr.lazy_expr
    string Contract_repr.contract)
and &quot;'manager_operation.Origination&quot; :=
  (manager_operation.Origination_skeleton
    (option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) Script_repr.t
    Tez_repr.tez (option Contract_repr.t)).

Module contents.
  Include ConstructorRecords_contents_list_contents_manager_operation.contents.
  Definition Endorsement := 'contents.Endorsement.
  Definition Seed_nonce_revelation := 'contents.Seed_nonce_revelation.
  Definition Double_endorsement_evidence :=
    'contents.Double_endorsement_evidence.
  Definition Double_baking_evidence := 'contents.Double_baking_evidence.
  Definition Activate_account := 'contents.Activate_account.
  Definition Proposals := 'contents.Proposals.
  Definition Ballot := 'contents.Ballot.
  Definition Manager_operation := 'contents.Manager_operation.
End contents.
Module manager_operation.
  Include ConstructorRecords_contents_list_contents_manager_operation.manager_operation.
  Definition Transaction := 'manager_operation.Transaction.
  Definition Origination := 'manager_operation.Origination.
End manager_operation.

Definition protocol_data := 'protocol_data.
Definition operation := 'operation.
Definition counter := 'counter.

Definition manager_kind (function_parameter : manager_operation)
  : Kind.manager :=
  match function_parameter with
  | Reveal _ =&gt; Kind.Reveal_manager_kind
  | Transaction _ =&gt; Kind.Transaction_manager_kind
  | Origination _ =&gt; Kind.Origination_manager_kind
  | Delegation _ =&gt; Kind.Delegation_manager_kind
  end.

Module internal_operation.
  Record record : Set := Build {
    source : Contract_repr.contract;
    operation : manager_operation;
    nonce : int }.
  Definition with_source source (r : record) :=
    Build source r.(operation) r.(nonce).
  Definition with_operation operation (r : record) :=
    Build r.(source) operation r.(nonce).
  Definition with_nonce nonce (r : record) :=
    Build r.(source) r.(operation) nonce.
End internal_operation.
Definition internal_operation := internal_operation.record.

Inductive packed_manager_operation : Set :=
| Manager : manager_operation -&gt; packed_manager_operation.

Inductive packed_contents : Set :=
| Contents : contents -&gt; packed_contents.

Inductive packed_contents_list : Set :=
| Contents_list : contents_list -&gt; packed_contents_list.

Inductive packed_protocol_data : Set :=
| Operation_data : protocol_data -&gt; packed_protocol_data.

Module packed_operation.
  Record record : Set := Build {
    shell : Operation.shell_header;
    protocol_data : packed_protocol_data }.
  Definition with_shell shell (r : record) :=
    Build shell r.(protocol_data).
  Definition with_protocol_data protocol_data (r : record) :=
    Build r.(shell) protocol_data.
End packed_operation.
Definition packed_operation := packed_operation.record.

Definition __pack (function_parameter : operation) : packed_operation :=
  let '{|
    operation.shell := shell; operation.protocol_data := protocol_data |} :=
    function_parameter in
  {| packed_operation.shell := shell;
    packed_operation.protocol_data := Operation_data protocol_data |}.

Inductive packed_internal_operation : Set :=
| Internal_operation : internal_operation -&gt; packed_internal_operation.

Fixpoint to_list (function_parameter : packed_contents_list)
  {struct function_parameter} : list packed_contents :=
  let 'Contents_list content := function_parameter in
  match content with
  | Single o =&gt; [ Contents o ]
  | Cons o os =&gt; cons (Contents o) (to_list (Contents_list os))
  end.

Fixpoint of_list (function_parameter : list packed_contents)
  {struct function_parameter} : packed_contents_list :=
  match function_parameter with
  | [] =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert packed_contents_list false
  | cons (Contents o) [] =&gt; Contents_list (Single o)
  | cons (Contents o) os =&gt;
    let 'Contents_list os := of_list os in
    match (o, os) with
    | (Manager_operation _, Single (Manager_operation _)) =&gt;
      Contents_list (Cons o os)
    | (Manager_operation _, Cons _ _) =&gt; Contents_list (Cons o os)
    | _ =&gt;
      Pervasives.failwith
        &quot;Operation list of length &gt; 1 should only contains manager operations.&quot;
    end
  end.

Module Encoding.
  Import Data_encoding.
  
  Definition __case_value {A B : Set}
    (tag : Data_encoding.case_tag) (name : string)
    (args : Data_encoding.encoding A) (proj : B -&gt; option A) (inj : A -&gt; B)
    : Data_encoding.case B :=
    Data_encoding.__case_value (String.capitalize_ascii name) None tag
      (Data_encoding.merge_objs
        (Data_encoding.obj1
          (Data_encoding.req None None &quot;kind&quot; (Data_encoding.constant name)))
        args)
      (fun x =&gt;
        match proj x with
        | None =&gt; None
        | Some x =&gt; Some (tt, x)
        end)
      (fun function_parameter =&gt;
        let '(_, x) := function_parameter in
        inj x).
  
  Module Manager_operations.
    Module ConstructorRecords_case.
      Module case.
        Module MCase.
          Record record {tag name encoding select proj inj : Set} : Set := Build {
            tag : tag;
            name : name;
            encoding : encoding;
            select : select;
            proj : proj;
            inj : inj }.
          Arguments record : clear implicits.
          Definition with_tag {t_tag t_name t_encoding t_select t_proj t_inj}
            tag (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
            Build t_tag t_name t_encoding t_select t_proj t_inj tag r.(name)
              r.(encoding) r.(select) r.(proj) r.(inj).
          Definition with_name {t_tag t_name t_encoding t_select t_proj t_inj}
            name (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
            Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) name
              r.(encoding) r.(select) r.(proj) r.(inj).
          Definition with_encoding
            {t_tag t_name t_encoding t_select t_proj t_inj} encoding
            (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
            Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) r.(name)
              encoding r.(select) r.(proj) r.(inj).
          Definition with_select {t_tag t_name t_encoding t_select t_proj t_inj}
            select (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
            Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) r.(name)
              r.(encoding) select r.(proj) r.(inj).
          Definition with_proj {t_tag t_name t_encoding t_select t_proj t_inj}
            proj (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
            Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) r.(name)
              r.(encoding) r.(select) proj r.(inj).
          Definition with_inj {t_tag t_name t_encoding t_select t_proj t_inj}
            inj (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
            Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) r.(name)
              r.(encoding) r.(select) r.(proj) inj.
        End MCase.
        Definition MCase_skeleton := MCase.record.
      End case.
    End ConstructorRecords_case.
    Import ConstructorRecords_case.
    
    Reserved Notation &quot;'case.MCase&quot;.
    
    Inductive case : Set :=
    | MCase : forall {a : Set}, 'case.MCase a -&gt; case
    
    where &quot;'case.MCase&quot; := (fun (t_a : Set) =&gt;
      case.MCase_skeleton int string (Data_encoding.t t_a)
        (packed_manager_operation -&gt; option manager_operation)
        (manager_operation -&gt; t_a) (t_a -&gt; manager_operation)).
    
    Module case.
      Include ConstructorRecords_case.case.
      Definition MCase := 'case.MCase.
    End case.
    
    Definition reveal_case : case :=
      MCase
        {| case.MCase.tag := 0; case.MCase.name := &quot;reveal&quot;;
          case.MCase.encoding :=
            Data_encoding.obj1
              (Data_encoding.req None None &quot;public_key&quot;
                (|Signature.Public_key|).(S.SPublic_key.encoding));
          case.MCase.select :=
            fun function_parameter =&gt;
              match function_parameter with
              | Manager ((Reveal _) as op) =&gt; Some op
              | _ =&gt; None
              end;
          case.MCase.proj :=
            fun function_parameter =&gt;
              match function_parameter with
              | Reveal pkh =&gt; pkh
              | _ =&gt; unreachable_gadt_branch
              end; case.MCase.inj := fun pkh =&gt; Reveal pkh |}.
    
    Definition entrypoint_encoding
      : Data_encoding.encoding (|Compare.String|).(Compare.S.t) :=
      (Data_encoding.def &quot;entrypoint&quot; (Some &quot;entrypoint&quot;)
        (Some &quot;Named entrypoint to a Michelson smart contract&quot;))
        (let builtin_case (tag : int) (name : (|Compare.String|).(Compare.S.t))
          : Data_encoding.case (|Compare.String|).(Compare.S.t) :=
          Data_encoding.__case_value name None (Data_encoding.Tag tag)
            (Data_encoding.constant name)
            (fun n =&gt;
              if (|Compare.String|).(Compare.S.op_eq) n name then
                Some tt
              else
                None)
            (fun function_parameter =&gt;
              let '_ := function_parameter in
              name) in
        Data_encoding.union None
          [
            builtin_case 0 &quot;default&quot;;
            builtin_case 1 &quot;root&quot;;
            builtin_case 2 &quot;do&quot;;
            builtin_case 3 &quot;set_delegate&quot;;
            builtin_case 4 &quot;remove_delegate&quot;;
            Data_encoding.__case_value &quot;named&quot; None (Data_encoding.Tag 255)
              (Data_encoding.Bounded.__string_value 31)
              (fun s =&gt; Some s) (fun s =&gt; s)
          ]).
    
    Definition transaction_case : case :=
      MCase
        {| case.MCase.tag := 1; case.MCase.name := &quot;transaction&quot;;
          case.MCase.encoding :=
            Data_encoding.obj3
              (Data_encoding.req None None &quot;amount&quot; Tez_repr.encoding)
              (Data_encoding.req None None &quot;destination&quot; Contract_repr.encoding)
              (Data_encoding.opt None None &quot;parameters&quot;
                (Data_encoding.obj2
                  (Data_encoding.req None None &quot;entrypoint&quot; entrypoint_encoding)
                  (Data_encoding.req None None &quot;value&quot;
                    Script_repr.lazy_expr_encoding)));
          case.MCase.select :=
            fun function_parameter =&gt;
              match function_parameter with
              | Manager ((Transaction _) as op) =&gt; Some op
              | _ =&gt; None
              end;
          case.MCase.proj :=
            fun function_parameter =&gt;
              match function_parameter with
              |
                Transaction {|
                  manager_operation.Transaction.amount := amount;
                    manager_operation.Transaction.parameters := parameters;
                    manager_operation.Transaction.entrypoint := entrypoint;
                    manager_operation.Transaction.destination := destination
                    |} =&gt;
                let parameters :=
                  if
                    Pervasives.op_andand
                      (Script_repr.is_unit_parameter parameters)
                      ((|Compare.String|).(Compare.S.op_eq) entrypoint &quot;default&quot;)
                    then
                    None
                  else
                    Some (entrypoint, parameters) in
                (amount, destination, parameters)
              | _ =&gt; unreachable_gadt_branch
              end;
          case.MCase.inj :=
            fun function_parameter =&gt;
              let '(amount, destination, parameters) := function_parameter in
              let '(entrypoint, parameters) :=
                match parameters with
                | None =&gt; (&quot;default&quot;, Script_repr.unit_parameter)
                | Some (entrypoint, value) =&gt; (entrypoint, value)
                end in
              Transaction
                {| manager_operation.Transaction.amount := amount;
                  manager_operation.Transaction.parameters := parameters;
                  manager_operation.Transaction.entrypoint := entrypoint;
                  manager_operation.Transaction.destination := destination |} |}.
    
    Definition origination_case : case :=
      MCase
        {| case.MCase.tag := 2; case.MCase.name := &quot;origination&quot;;
          case.MCase.encoding :=
            Data_encoding.obj3
              (Data_encoding.req None None &quot;balance&quot; Tez_repr.encoding)
              (Data_encoding.opt None None &quot;delegate&quot;
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding))
              (Data_encoding.req None None &quot;script&quot; Script_repr.encoding);
          case.MCase.select :=
            fun function_parameter =&gt;
              match function_parameter with
              | Manager ((Origination _) as op) =&gt; Some op
              | _ =&gt; None
              end;
          case.MCase.proj :=
            fun function_parameter =&gt;
              match function_parameter with
              |
                Origination {|
                  manager_operation.Origination.delegate := delegate;
                    manager_operation.Origination.script := script;
                    manager_operation.Origination.credit := credit;
                    manager_operation.Origination.preorigination := _
                    |} =&gt; (credit, delegate, script)
              | _ =&gt; unreachable_gadt_branch
              end;
          case.MCase.inj :=
            fun function_parameter =&gt;
              let '(credit, delegate, script) := function_parameter in
              Origination
                {| manager_operation.Origination.delegate := delegate;
                  manager_operation.Origination.script := script;
                  manager_operation.Origination.credit := credit;
                  manager_operation.Origination.preorigination := None |} |}.
    
    Definition delegation_case : case :=
      MCase
        {| case.MCase.tag := 3; case.MCase.name := &quot;delegation&quot;;
          case.MCase.encoding :=
            Data_encoding.obj1
              (Data_encoding.opt None None &quot;delegate&quot;
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding));
          case.MCase.select :=
            fun function_parameter =&gt;
              match function_parameter with
              | Manager ((Delegation _) as op) =&gt; Some op
              | _ =&gt; None
              end;
          case.MCase.proj :=
            fun function_parameter =&gt;
              match function_parameter with
              | Delegation __key_value =&gt; __key_value
              | _ =&gt; unreachable_gadt_branch
              end; case.MCase.inj := fun __key_value =&gt; Delegation __key_value
          |}.
    
    Definition encoding : Data_encoding.encoding packed_manager_operation :=
      let make (function_parameter : case)
        : Data_encoding.case packed_manager_operation :=
        let
          'MCase {|
            case.MCase.tag := tag;
              case.MCase.name := name;
              case.MCase.encoding := encoding;
              case.MCase.select := select;
              case.MCase.proj := proj;
              case.MCase.inj := inj
              |} := function_parameter in
        let 'existT _ __MCase_'a [tag, name, encoding, select, proj, inj] :=
          existT (A := Set)
            (fun __MCase_'a =&gt;
              [int ** string ** Data_encoding.t __MCase_'a **
                packed_manager_operation -&gt; option manager_operation **
                manager_operation -&gt; __MCase_'a **
                __MCase_'a -&gt; manager_operation]) _
            [tag, name, encoding, select, proj, inj] in
        __case_value (Data_encoding.Tag tag) name encoding
          (fun o =&gt;
            match select o with
            | None =&gt; None
            | Some o =&gt; Some (proj o)
            end) (fun x =&gt; Manager (inj x)) in
      Data_encoding.union (Some Data_encoding.Uint8)
        [
          make reveal_case;
          make transaction_case;
          make origination_case;
          make delegation_case
        ].
  End Manager_operations.
  
  Module ConstructorRecords_case.
    Module case.
      Module Case.
        Record record {tag name encoding select proj inj : Set} : Set := Build {
          tag : tag;
          name : name;
          encoding : encoding;
          select : select;
          proj : proj;
          inj : inj }.
        Arguments record : clear implicits.
        Definition with_tag {t_tag t_name t_encoding t_select t_proj t_inj} tag
          (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
          Build t_tag t_name t_encoding t_select t_proj t_inj tag r.(name)
            r.(encoding) r.(select) r.(proj) r.(inj).
        Definition with_name {t_tag t_name t_encoding t_select t_proj t_inj}
          name (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
          Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) name
            r.(encoding) r.(select) r.(proj) r.(inj).
        Definition with_encoding {t_tag t_name t_encoding t_select t_proj t_inj}
          encoding (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
          Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) r.(name)
            encoding r.(select) r.(proj) r.(inj).
        Definition with_select {t_tag t_name t_encoding t_select t_proj t_inj}
          select (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
          Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) r.(name)
            r.(encoding) select r.(proj) r.(inj).
        Definition with_proj {t_tag t_name t_encoding t_select t_proj t_inj}
          proj (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
          Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) r.(name)
            r.(encoding) r.(select) proj r.(inj).
        Definition with_inj {t_tag t_name t_encoding t_select t_proj t_inj} inj
          (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
          Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) r.(name)
            r.(encoding) r.(select) r.(proj) inj.
      End Case.
      Definition Case_skeleton := Case.record.
    End case.
  End ConstructorRecords_case.
  Import ConstructorRecords_case.
  
  Reserved Notation &quot;'case.Case&quot;.
  
  Inductive case : Set :=
  | Case : forall {a : Set}, 'case.Case a -&gt; case
  
  where &quot;'case.Case&quot; := (fun (t_a : Set) =&gt;
    case.Case_skeleton int string (Data_encoding.t t_a)
      (packed_contents -&gt; option contents) (contents -&gt; t_a) (t_a -&gt; contents)).
  
  Module case.
    Include ConstructorRecords_case.case.
    Definition Case := 'case.Case.
  End case.
  
  Definition raw_endorsement_encoding
    : Data_encoding.encoding Raw_level_repr.raw_level :=
    Data_encoding.obj1
      (Data_encoding.req None None &quot;level&quot; Raw_level_repr.encoding).
  
  Definition endorsement_case : case :=
    Case
      {| case.Case.tag := 0; case.Case.name := &quot;endorsement&quot;;
        case.Case.encoding := raw_endorsement_encoding;
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents ((Endorsement _) as op) =&gt; Some op
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            match function_parameter with
            | Endorsement {| contents.Endorsement.level := level |} =&gt; level
            | _ =&gt; unreachable_gadt_branch
            end;
        case.Case.inj :=
          fun level =&gt; Endorsement {| contents.Endorsement.level := level |} |}.
  
  Definition endorsement_encoding : Data_encoding.encoding operation :=
    let make (function_parameter : case) : Data_encoding.case contents :=
      let
        'Case {|
          case.Case.tag := tag;
            case.Case.name := name;
            case.Case.encoding := encoding;
            case.Case.select := _;
            case.Case.proj := proj;
            case.Case.inj := inj
            |} := function_parameter in
      let 'existT _ __Case_'a [tag, name, encoding, proj, inj] :=
        existT (A := Set)
          (fun __Case_'a =&gt;
            [int ** string ** Data_encoding.t __Case_'a ** contents -&gt; __Case_'a
              ** __Case_'a -&gt; contents]) _ [tag, name, encoding, proj, inj] in
      __case_value (Data_encoding.Tag tag) name encoding
        (fun o =&gt; Some (proj o)) (fun x =&gt; inj x) in
    let to_list (function_parameter : contents_list) : contents :=
      match function_parameter with
      | Single o =&gt; o
      | _ =&gt; unreachable_gadt_branch
      end in
    let of_list (o : contents) : contents_list :=
      Single o in
    (let arg := Data_encoding.def &quot;inlined.endorsement&quot; in
    fun eta =&gt; arg None None eta)
      (Data_encoding.conv
        (fun function_parameter =&gt;
          let '{|
            operation.shell := shell;
              operation.protocol_data := {|
                protocol_data.contents := contents;
                  protocol_data.signature := signature
                  |}
              |} := function_parameter in
          (shell, (contents, signature)))
        (fun function_parameter =&gt;
          let '(shell, (contents, signature)) := function_parameter in
          {| operation.shell := shell;
            operation.protocol_data :=
              {| protocol_data.contents := contents;
                protocol_data.signature := signature |} |}) None
        (Data_encoding.merge_objs Operation.shell_header_encoding
          (Data_encoding.obj2
            (Data_encoding.req None None &quot;operations&quot;
              ((let arg := Data_encoding.conv to_list of_list in
              fun eta =&gt; arg None eta)
                ((let arg := Data_encoding.def &quot;inlined.endorsement.contents&quot; in
                fun eta =&gt; arg None None eta)
                  (Data_encoding.union None [ make endorsement_case ]))))
            (Data_encoding.varopt None None &quot;signature&quot; Signature.encoding)))).
  
  Definition seed_nonce_revelation_case : case :=
    Case
      {| case.Case.tag := 1; case.Case.name := &quot;seed_nonce_revelation&quot;;
        case.Case.encoding :=
          Data_encoding.obj2
            (Data_encoding.req None None &quot;level&quot; Raw_level_repr.encoding)
            (Data_encoding.req None None &quot;nonce&quot; Seed_repr.nonce_encoding);
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents ((Seed_nonce_revelation _) as op) =&gt; Some op
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            match function_parameter with
            |
              Seed_nonce_revelation {|
                contents.Seed_nonce_revelation.level := level;
                  contents.Seed_nonce_revelation.nonce := __nonce_value
                  |} =&gt; (level, __nonce_value)
            | _ =&gt; unreachable_gadt_branch
            end;
        case.Case.inj :=
          fun function_parameter =&gt;
            let '(level, __nonce_value) := function_parameter in
            Seed_nonce_revelation
              {| contents.Seed_nonce_revelation.level := level;
                contents.Seed_nonce_revelation.nonce := __nonce_value |} |}.
  
  Definition double_endorsement_evidence_case : case :=
    Case
      {| case.Case.tag := 2; case.Case.name := &quot;double_endorsement_evidence&quot;;
        case.Case.encoding :=
          Data_encoding.obj2
            (Data_encoding.req None None &quot;op1&quot;
              (Data_encoding.dynamic_size None endorsement_encoding))
            (Data_encoding.req None None &quot;op2&quot;
              (Data_encoding.dynamic_size None endorsement_encoding));
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents ((Double_endorsement_evidence _) as op) =&gt; Some op
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            match function_parameter with
            |
              Double_endorsement_evidence {|
                contents.Double_endorsement_evidence.op1 := op1;
                  contents.Double_endorsement_evidence.op2 := op2
                  |} =&gt; (op1, op2)
            | _ =&gt; unreachable_gadt_branch
            end;
        case.Case.inj :=
          fun function_parameter =&gt;
            let '(op1, op2) := function_parameter in
            Double_endorsement_evidence
              {| contents.Double_endorsement_evidence.op1 := op1;
                contents.Double_endorsement_evidence.op2 := op2 |} |}.
  
  Definition double_baking_evidence_case : case :=
    Case
      {| case.Case.tag := 3; case.Case.name := &quot;double_baking_evidence&quot;;
        case.Case.encoding :=
          Data_encoding.obj2
            (Data_encoding.req None None &quot;bh1&quot;
              (Data_encoding.dynamic_size None Block_header_repr.encoding))
            (Data_encoding.req None None &quot;bh2&quot;
              (Data_encoding.dynamic_size None Block_header_repr.encoding));
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents ((Double_baking_evidence _) as op) =&gt; Some op
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            match function_parameter with
            |
              Double_baking_evidence {|
                contents.Double_baking_evidence.bh1 := bh1;
                  contents.Double_baking_evidence.bh2 := bh2
                  |} =&gt; (bh1, bh2)
            | _ =&gt; unreachable_gadt_branch
            end;
        case.Case.inj :=
          fun function_parameter =&gt;
            let '(bh1, bh2) := function_parameter in
            Double_baking_evidence
              {| contents.Double_baking_evidence.bh1 := bh1;
                contents.Double_baking_evidence.bh2 := bh2 |} |}.
  
  Definition activate_account_case : case :=
    Case
      {| case.Case.tag := 4; case.Case.name := &quot;activate_account&quot;;
        case.Case.encoding :=
          Data_encoding.obj2
            (Data_encoding.req None None &quot;pkh&quot;
              (|Ed25519|).(S.SIGNATURE.Public_key_hash).(S.SPublic_key_hash.encoding))
            (Data_encoding.req None None &quot;secret&quot;
              Blinded_public_key_hash.activation_code_encoding);
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents ((Activate_account _) as op) =&gt; Some op
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            match function_parameter with
            |
              Activate_account {|
                contents.Activate_account.id := id;
                  contents.Activate_account.activation_code := activation_code
                  |} =&gt; (id, activation_code)
            | _ =&gt; unreachable_gadt_branch
            end;
        case.Case.inj :=
          fun function_parameter =&gt;
            let '(id, activation_code) := function_parameter in
            Activate_account
              {| contents.Activate_account.id := id;
                contents.Activate_account.activation_code := activation_code |}
        |}.
  
  Definition proposals_case : case :=
    Case
      {| case.Case.tag := 5; case.Case.name := &quot;proposals&quot;;
        case.Case.encoding :=
          Data_encoding.obj3
            (Data_encoding.req None None &quot;source&quot;
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding))
            (Data_encoding.req None None &quot;period&quot; Voting_period_repr.encoding)
            (Data_encoding.req None None &quot;proposals&quot;
              (Data_encoding.__list_value None
                (|Protocol_hash|).(S.HASH.encoding)));
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents ((Proposals _) as op) =&gt; Some op
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            match function_parameter with
            |
              Proposals {|
                contents.Proposals.source := source;
                  contents.Proposals.period := period;
                  contents.Proposals.proposals := proposals
                  |} =&gt; (source, period, proposals)
            | _ =&gt; unreachable_gadt_branch
            end;
        case.Case.inj :=
          fun function_parameter =&gt;
            let '(source, period, proposals) := function_parameter in
            Proposals
              {| contents.Proposals.source := source;
                contents.Proposals.period := period;
                contents.Proposals.proposals := proposals |} |}.
  
  Definition ballot_case : case :=
    Case
      {| case.Case.tag := 6; case.Case.name := &quot;ballot&quot;;
        case.Case.encoding :=
          Data_encoding.obj4
            (Data_encoding.req None None &quot;source&quot;
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding))
            (Data_encoding.req None None &quot;period&quot; Voting_period_repr.encoding)
            (Data_encoding.req None None &quot;proposal&quot;
              (|Protocol_hash|).(S.HASH.encoding))
            (Data_encoding.req None None &quot;ballot&quot; Vote_repr.ballot_encoding);
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            | Contents ((Ballot _) as op) =&gt; Some op
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            match function_parameter with
            |
              Ballot {|
                contents.Ballot.source := source;
                  contents.Ballot.period := period;
                  contents.Ballot.proposal := proposal;
                  contents.Ballot.ballot := ballot
                  |} =&gt; (source, period, proposal, ballot)
            | _ =&gt; unreachable_gadt_branch
            end;
        case.Case.inj :=
          fun function_parameter =&gt;
            let '(source, period, proposal, ballot) := function_parameter in
            Ballot
              {| contents.Ballot.source := source;
                contents.Ballot.period := period;
                contents.Ballot.proposal := proposal;
                contents.Ballot.ballot := ballot |} |}.
  
  Definition manager_encoding
    : Data_encoding.encoding
      ((|Signature.Public_key_hash|).(S.SPublic_key_hash.t) * Tez_repr.t * Z.t *
        Z.t * Z.t) :=
    Data_encoding.obj5
      (Data_encoding.req None None &quot;source&quot;
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding))
      (Data_encoding.req None None &quot;fee&quot; Tez_repr.encoding)
      (Data_encoding.req None None &quot;counter&quot;
        (Data_encoding.check_size 10 Data_encoding.n))
      (Data_encoding.req None None &quot;gas_limit&quot;
        (Data_encoding.check_size 10 Data_encoding.n))
      (Data_encoding.req None None &quot;storage_limit&quot;
        (Data_encoding.check_size 10 Data_encoding.n)).
  
  Definition extract (function_parameter : contents)
    : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) * Tez_repr.tez *
      counter * Z.t * Z.t :=
    match function_parameter with
    |
      Manager_operation {|
        contents.Manager_operation.source := source;
          contents.Manager_operation.fee := fee;
          contents.Manager_operation.counter := counter;
          contents.Manager_operation.operation := _;
          contents.Manager_operation.gas_limit := gas_limit;
          contents.Manager_operation.storage_limit := storage_limit
          |} =&gt; (source, fee, counter, gas_limit, storage_limit)
    | _ =&gt; unreachable_gadt_branch
    end.
  
  Definition rebuild
    (function_parameter :
      (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) * Tez_repr.tez *
        counter * Z.t * Z.t) : manager_operation -&gt; contents :=
    let '(source, fee, counter, gas_limit, storage_limit) := function_parameter
      in
    fun operation =&gt;
      Manager_operation
        {| contents.Manager_operation.source := source;
          contents.Manager_operation.fee := fee;
          contents.Manager_operation.counter := counter;
          contents.Manager_operation.operation := operation;
          contents.Manager_operation.gas_limit := gas_limit;
          contents.Manager_operation.storage_limit := storage_limit |}.
  
  Definition make_manager_case
    (tag : int) (function_parameter : Manager_operations.case) : case :=
    let 'Manager_operations.MCase mcase := function_parameter in
    let 'existT _ __MCase_'a mcase :=
      existT (A := Set)
        (fun __MCase_'a =&gt; Manager_operations.case.MCase __MCase_'a) _ mcase in
    Case
      {| case.Case.tag := tag;
        case.Case.name := mcase.(Manager_operations.case.MCase.name);
        case.Case.encoding :=
          Data_encoding.merge_objs manager_encoding
            mcase.(Manager_operations.case.MCase.encoding);
        case.Case.select :=
          fun function_parameter =&gt;
            match function_parameter with
            |
              Contents
                (Manager_operation
                  ({| contents.Manager_operation.operation := operation |} as op))
              =&gt;
              match
                mcase.(Manager_operations.case.MCase.select) (Manager operation)
                with
              | None =&gt; None
              | Some operation =&gt;
                Some
                  (Manager_operation
                    (contents.Manager_operation.with_operation operation op))
              end
            | _ =&gt; None
            end;
        case.Case.proj :=
          fun function_parameter =&gt;
            match function_parameter with
            |
              (Manager_operation {|
                contents.Manager_operation.operation := operation |}) as op
              =&gt;
              ((extract op),
                (mcase.(Manager_operations.case.MCase.proj) operation))
            | _ =&gt; unreachable_gadt_branch
            end;
        case.Case.inj :=
          fun function_parameter =&gt;
            let '(op, contents) := function_parameter in
            rebuild op (mcase.(Manager_operations.case.MCase.inj) contents) |}.
  
  Definition reveal_case : case :=
    make_manager_case 107 Manager_operations.reveal_case.
  
  Definition transaction_case : case :=
    make_manager_case 108 Manager_operations.transaction_case.
  
  Definition origination_case : case :=
    make_manager_case 109 Manager_operations.origination_case.
  
  Definition delegation_case : case :=
    make_manager_case 110 Manager_operations.delegation_case.
  
  Definition contents_encoding : Data_encoding.encoding packed_contents :=
    let make (function_parameter : case) : Data_encoding.case packed_contents :=
      let
        'Case {|
          case.Case.tag := tag;
            case.Case.name := name;
            case.Case.encoding := encoding;
            case.Case.select := select;
            case.Case.proj := proj;
            case.Case.inj := inj
            |} := function_parameter in
      let 'existT _ __Case_'a [tag, name, encoding, select, proj, inj] :=
        existT (A := Set)
          (fun __Case_'a =&gt;
            [int ** string ** Data_encoding.t __Case_'a **
              packed_contents -&gt; option contents ** contents -&gt; __Case_'a **
              __Case_'a -&gt; contents]) _ [tag, name, encoding, select, proj, inj]
        in
      __case_value (Data_encoding.Tag tag) name encoding
        (fun o =&gt;
          match select o with
          | None =&gt; None
          | Some o =&gt; Some (proj o)
          end) (fun x =&gt; Contents (inj x)) in
    (let arg := Data_encoding.def &quot;operation.alpha.contents&quot; in
    fun eta =&gt; arg None None eta)
      (Data_encoding.union None
        [
          make endorsement_case;
          make seed_nonce_revelation_case;
          make double_endorsement_evidence_case;
          make double_baking_evidence_case;
          make activate_account_case;
          make proposals_case;
          make ballot_case;
          make reveal_case;
          make transaction_case;
          make origination_case;
          make delegation_case
        ]).
  
  Definition contents_list_encoding
    : Data_encoding.encoding packed_contents_list :=
    Data_encoding.conv to_list of_list None
      (Data_encoding.__Variable.__list_value None contents_encoding).
  
  Definition optional_signature_encoding
    : Data_encoding.encoding (option Signature.t) :=
    Data_encoding.conv
      (fun function_parameter =&gt;
        match function_parameter with
        | Some s =&gt; s
        | None =&gt; Signature.zero
        end)
      (fun s =&gt;
        if Signature.equal s Signature.zero then
          None
        else
          Some s) None Signature.encoding.
  
  Definition protocol_data_encoding
    : Data_encoding.encoding packed_protocol_data :=
    (let arg := Data_encoding.def &quot;operation.alpha.contents_and_signature&quot; in
    fun eta =&gt; arg None None eta)
      (Data_encoding.conv
        (fun function_parameter =&gt;
          let
            'Operation_data {|
              protocol_data.contents := contents;
                protocol_data.signature := signature
                |} := function_parameter in
          ((Contents_list contents), signature))
        (fun function_parameter =&gt;
          let '(Contents_list contents, signature) := function_parameter in
          Operation_data
            {| protocol_data.contents := contents;
              protocol_data.signature := signature |}) None
        (Data_encoding.obj2
          (Data_encoding.req None None &quot;contents&quot; contents_list_encoding)
          (Data_encoding.req None None &quot;signature&quot; optional_signature_encoding))).
  
  Definition operation_encoding : Data_encoding.encoding packed_operation :=
    Data_encoding.conv
      (fun function_parameter =&gt;
        let '{|
          packed_operation.shell := shell;
            packed_operation.protocol_data := protocol_data
            |} := function_parameter in
        (shell, protocol_data))
      (fun function_parameter =&gt;
        let '(shell, protocol_data) := function_parameter in
        {| packed_operation.shell := shell;
          packed_operation.protocol_data := protocol_data |}) None
      (Data_encoding.merge_objs Operation.shell_header_encoding
        protocol_data_encoding).
  
  Definition unsigned_operation_encoding
    : Data_encoding.encoding (Operation.shell_header * packed_contents_list) :=
    (let arg := Data_encoding.def &quot;operation.alpha.unsigned_operation&quot; in
    fun eta =&gt; arg None None eta)
      (Data_encoding.merge_objs Operation.shell_header_encoding
        (Data_encoding.obj1
          (Data_encoding.req None None &quot;contents&quot; contents_list_encoding))).
  
  Definition internal_operation_encoding
    : Data_encoding.encoding packed_internal_operation :=
    (let arg := Data_encoding.def &quot;operation.alpha.internal_operation&quot; in
    fun eta =&gt; arg None None eta)
      (Data_encoding.conv
        (fun function_parameter =&gt;
          let
            'Internal_operation {|
              internal_operation.source := source;
                internal_operation.operation := operation;
                internal_operation.nonce := __nonce_value
                |} := function_parameter in
          ((source, __nonce_value), (Manager operation)))
        (fun function_parameter =&gt;
          let '((source, __nonce_value), Manager operation) :=
            function_parameter in
          Internal_operation
            {| internal_operation.source := source;
              internal_operation.operation := operation;
              internal_operation.nonce := __nonce_value |}) None
        (Data_encoding.merge_objs
          (Data_encoding.obj2
            (Data_encoding.req None None &quot;source&quot; Contract_repr.encoding)
            (Data_encoding.req None None &quot;nonce&quot; Data_encoding.uint16))
          Manager_operations.encoding)).
End Encoding.

Definition encoding : Data_encoding.encoding packed_operation :=
  Encoding.operation_encoding.

Definition contents_encoding : Data_encoding.encoding packed_contents :=
  Encoding.contents_encoding.

Definition contents_list_encoding
  : Data_encoding.encoding packed_contents_list :=
  Encoding.contents_list_encoding.

Definition protocol_data_encoding
  : Data_encoding.encoding packed_protocol_data :=
  Encoding.protocol_data_encoding.

Definition unsigned_operation_encoding
  : Data_encoding.encoding (Operation.shell_header * packed_contents_list) :=
  Encoding.unsigned_operation_encoding.

Definition internal_operation_encoding
  : Data_encoding.encoding packed_internal_operation :=
  Encoding.internal_operation_encoding.

Definition __raw_value (function_parameter : operation) : Operation.t :=
  let '{|
    operation.shell := shell; operation.protocol_data := protocol_data |} :=
    function_parameter in
  let proto :=
    Data_encoding.Binary.to_bytes_exn protocol_data_encoding
      (Operation_data protocol_data) in
  {| Operation.t.shell := shell; Operation.t.proto := proto |}.

Definition acceptable_passes (op : packed_operation) : list int :=
  let 'Operation_data protocol_data := op.(packed_operation.protocol_data) in
  match protocol_data.(protocol_data.contents) with
  | Single (Endorsement _) =&gt; [ 0 ]
  | Single (Proposals _) =&gt; [ 1 ]
  | Single (Ballot _) =&gt; [ 1 ]
  | Single (Seed_nonce_revelation _) =&gt; [ 2 ]
  | Single (Double_endorsement_evidence _) =&gt; [ 2 ]
  | Single (Double_baking_evidence _) =&gt; [ 2 ]
  | Single (Activate_account _) =&gt; [ 2 ]
  | Single (Manager_operation _) =&gt; [ 3 ]
  | Cons _ _ =&gt; [ 3 ]
  end.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition check_signature_sync
  (__key_value : (|Signature.Public_key|).(S.SPublic_key.t))
  (chain_id : (|Chain_id|).(S.HASH.t)) (function_parameter : operation)
  : Error_monad.tzresult unit :=
  let '{|
    operation.shell := shell; operation.protocol_data := protocol_data |} :=
    function_parameter in
  let check
    (watermark : Signature.watermark) (contents : packed_contents_list)
    (signature : Signature.t)
    : Pervasives.result unit (list Error_monad.__error) :=
    let unsigned_operation :=
      Data_encoding.Binary.to_bytes_exn unsigned_operation_encoding
        (shell, contents) in
    if Signature.check (Some watermark) __key_value signature unsigned_operation
      then
      Pervasives.Ok tt
    else
      Error_monad.__error_value extensible_type_value in
  match
    (protocol_data.(protocol_data.contents),
      protocol_data.(protocol_data.signature)) with
  | (Single _, None) =&gt; Error_monad.__error_value extensible_type_value
  | (Cons _ _, None) =&gt; Error_monad.__error_value extensible_type_value
  | ((Single (Endorsement _)) as contents, Some signature) =&gt;
    check (Signature.Endorsement chain_id) (Contents_list contents) signature
  | ((Single _) as contents, Some signature) =&gt;
    check Signature.Generic_operation (Contents_list contents) signature
  | ((Cons _ _) as contents, Some signature) =&gt;
    check Signature.Generic_operation (Contents_list contents) signature
  end.

Definition check_signature
  (pk : (|Signature.Public_key|).(S.SPublic_key.t))
  (chain_id : (|Chain_id|).(S.HASH.t)) (op : operation)
  : Lwt.t (Error_monad.tzresult unit) :=
  Lwt.__return (check_signature_sync pk chain_id op).

Definition hash_raw : Operation.t -&gt; (|Operation_hash|).(S.HASH.t) :=
  Operation.__hash_value.

Definition __hash_value (o : operation) : (|Operation_hash|).(S.HASH.t) :=
  let proto :=
    Data_encoding.Binary.to_bytes_exn protocol_data_encoding
      (Operation_data o.(operation.protocol_data)) in
  Operation.__hash_value
    {| Operation.t.shell := o.(operation.shell); Operation.t.proto := proto |}.

Definition hash_packed (o : packed_operation) : (|Operation_hash|).(S.HASH.t) :=
  let proto :=
    Data_encoding.Binary.to_bytes_exn protocol_data_encoding
      o.(packed_operation.protocol_data) in
  Operation.__hash_value
    {| Operation.t.shell := o.(packed_operation.shell);
      Operation.t.proto := proto |}.

Inductive eq : Set :=
| Eq : eq.

Definition equal_manager_operation_kind
  (op1 : manager_operation) (op2 : manager_operation) : option eq :=
  match (op1, op2) with
  | (Reveal _, Reveal _) =&gt; Some Eq
  | (Reveal _, _) =&gt; None
  | (Transaction _, Transaction _) =&gt; Some Eq
  | (Transaction _, _) =&gt; None
  | (Origination _, Origination _) =&gt; Some Eq
  | (Origination _, _) =&gt; None
  | (Delegation _, Delegation _) =&gt; Some Eq
  | (Delegation _, _) =&gt; None
  end.

Definition equal_contents_kind (op1 : contents) (op2 : contents) : option eq :=
  match (op1, op2) with
  | (Endorsement _, Endorsement _) =&gt; Some Eq
  | (Endorsement _, _) =&gt; None
  | (Seed_nonce_revelation _, Seed_nonce_revelation _) =&gt; Some Eq
  | (Seed_nonce_revelation _, _) =&gt; None
  | (Double_endorsement_evidence _, Double_endorsement_evidence _) =&gt; Some Eq
  | (Double_endorsement_evidence _, _) =&gt; None
  | (Double_baking_evidence _, Double_baking_evidence _) =&gt; Some Eq
  | (Double_baking_evidence _, _) =&gt; None
  | (Activate_account _, Activate_account _) =&gt; Some Eq
  | (Activate_account _, _) =&gt; None
  | (Proposals _, Proposals _) =&gt; Some Eq
  | (Proposals _, _) =&gt; None
  | (Ballot _, Ballot _) =&gt; Some Eq
  | (Ballot _, _) =&gt; None
  | (Manager_operation op1, Manager_operation op2) =&gt;
    match
      equal_manager_operation_kind op1.(contents.Manager_operation.operation)
        op2.(contents.Manager_operation.operation) with
    | None =&gt; None
    | Some Eq =&gt; Some Eq
    end
  | (Manager_operation _, _) =&gt; None
  end.

Fixpoint equal_contents_kind_list (op1 : contents_list) (op2 : contents_list)
  {struct op1} : option eq :=
  match (op1, op2) with
  | (Single op1, Single op2) =&gt; equal_contents_kind op1 op2
  | (Single _, Cons _ _) =&gt; None
  | (Cons _ _, Single _) =&gt; None
  | (Cons op1 ops1, Cons op2 ops2) =&gt;
    match equal_contents_kind op1 op2 with
    | None =&gt; None
    | Some Eq =&gt;
      match equal_contents_kind_list ops1 ops2 with
      | None =&gt; None
      | Some Eq =&gt; Some Eq
      end
    end
  end.

Definition equal (op1 : operation) (op2 : operation) : option eq :=
  if
    Pervasives.not
      ((|Operation_hash|).(S.HASH.equal) (__hash_value op1) (__hash_value op2))
    then
    None
  else
    equal_contents_kind_list
      op1.(operation.protocol_data).(protocol_data.contents)
      op2.(operation.protocol_data).(protocol_data.contents).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="operation_repr.mli">
  <div style="margin: 20px;">
    <h3>Operation_repr_mli</h3>
    <ul>
      <li>OCaml size: 271 lines</li>
      <li>Coq size: 656 lines (+142% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#operation_repr.mli"><code>operation_repr.mli</code></a>&nbsp;<span class="label label-warning">2 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(* Tezos Protocol Implementation - Low level Repr. of Operations *)

module Kind : sig
  type seed_nonce_revelation = Seed_nonce_revelation_kind

  type double_endorsement_evidence = Double_endorsement_evidence_kind

  type double_baking_evidence = Double_baking_evidence_kind

  type activate_account = Activate_account_kind

  type endorsement = Endorsement_kind

  type proposals = Proposals_kind

  type ballot = Ballot_kind

  type reveal = Reveal_kind

  type transaction = Transaction_kind

  type origination = Origination_kind

  type delegation = Delegation_kind

  type 'a manager =
    | Reveal_manager_kind : reveal manager
    | Transaction_manager_kind : transaction manager
    | Origination_manager_kind : origination manager
    | Delegation_manager_kind : delegation manager
end

type raw = Operation.t

val raw_encoding : raw Data_encoding.t

type _ contents_list =
  | Single : 'kind contents -&gt; 'kind contents_list
  | Cons :
      'kind Kind.manager contents * 'rest Kind.manager contents_list
      -&gt; ('kind * 'rest) Kind.manager contents_list

and 'kind protocol_data = {
  contents : 'kind contents_list;
  signature : Signature.t option;
}

and 'kind operation = {
  shell : Operation.shell_header;
  protocol_data : 'kind protocol_data;
}

and _ contents =
  | Endorsement : {level : Raw_level_repr.t} -&gt; Kind.endorsement contents
  | Seed_nonce_revelation : {
      level : Raw_level_repr.t;
      nonce : Seed_repr.nonce;
    }
      -&gt; Kind.seed_nonce_revelation contents
  | Double_endorsement_evidence : {
      op1 : Kind.endorsement operation;
      op2 : Kind.endorsement operation;
    }
      -&gt; Kind.double_endorsement_evidence contents
  | Double_baking_evidence : {
      bh1 : Block_header_repr.block_header;
      bh2 : Block_header_repr.block_header;
    }
      -&gt; Kind.double_baking_evidence contents
  | Activate_account : {
      id : Ed25519.Public_key_hash.t;
      activation_code : Blinded_public_key_hash.activation_code;
    }
      -&gt; Kind.activate_account contents
  | Proposals : {
      source : Signature.Public_key_hash.t;
      period : Voting_period_repr.t;
      proposals : Protocol_hash.t list;
    }
      -&gt; Kind.proposals contents
  | Ballot : {
      source : Signature.Public_key_hash.t;
      period : Voting_period_repr.t;
      proposal : Protocol_hash.t;
      ballot : Vote_repr.ballot;
    }
      -&gt; Kind.ballot contents
  | Manager_operation : {
      source : Signature.Public_key_hash.t;
      fee : Tez_repr.tez;
      counter : counter;
      operation : 'kind manager_operation;
      gas_limit : Z.t;
      storage_limit : Z.t;
    }
      -&gt; 'kind Kind.manager contents

and _ manager_operation =
  | Reveal : Signature.Public_key.t -&gt; Kind.reveal manager_operation
  | Transaction : {
      amount : Tez_repr.tez;
      parameters : Script_repr.lazy_expr;
      entrypoint : string;
      destination : Contract_repr.contract;
    }
      -&gt; Kind.transaction manager_operation
  | Origination : {
      delegate : Signature.Public_key_hash.t option;
      script : Script_repr.t;
      credit : Tez_repr.tez;
      preorigination : Contract_repr.t option;
    }
      -&gt; Kind.origination manager_operation
  | Delegation :
      Signature.Public_key_hash.t option
      -&gt; Kind.delegation manager_operation

and counter = Z.t

type 'kind internal_operation = {
  source : Contract_repr.contract;
  operation : 'kind manager_operation;
  nonce : int;
}

type packed_manager_operation =
  | Manager : 'kind manager_operation -&gt; packed_manager_operation

type packed_contents = Contents : 'kind contents -&gt; packed_contents

type packed_contents_list =
  | Contents_list : 'kind contents_list -&gt; packed_contents_list

val of_list : packed_contents list -&gt; packed_contents_list

val to_list : packed_contents_list -&gt; packed_contents list

type packed_protocol_data =
  | Operation_data : 'kind protocol_data -&gt; packed_protocol_data

type packed_operation = {
  shell : Operation.shell_header;
  protocol_data : packed_protocol_data;
}

val pack : 'kind operation -&gt; packed_operation

type packed_internal_operation =
  | Internal_operation : 'kind internal_operation -&gt; packed_internal_operation

val manager_kind : 'kind manager_operation -&gt; 'kind Kind.manager

val encoding : packed_operation Data_encoding.t

val contents_encoding : packed_contents Data_encoding.t

val contents_list_encoding : packed_contents_list Data_encoding.t

val protocol_data_encoding : packed_protocol_data Data_encoding.t

val unsigned_operation_encoding :
  (Operation.shell_header * packed_contents_list) Data_encoding.t

val raw : _ operation -&gt; raw

val hash_raw : raw -&gt; Operation_hash.t

val hash : _ operation -&gt; Operation_hash.t

val hash_packed : packed_operation -&gt; Operation_hash.t

val acceptable_passes : packed_operation -&gt; int list

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Missing_signature</abbr> (* `Permanent *)

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Invalid_signature</abbr> (* `Permanent *)

val check_signature :
  Signature.Public_key.t -&gt; Chain_id.t -&gt; _ operation -&gt; unit tzresult Lwt.t

val check_signature_sync :
  Signature.Public_key.t -&gt; Chain_id.t -&gt; _ operation -&gt; unit tzresult

val internal_operation_encoding : packed_internal_operation Data_encoding.t

type ('a, 'b) eq = Eq : ('a, 'a) eq

val equal : 'a operation -&gt; 'b operation -&gt; ('a, 'b) eq option

module Encoding : sig
  type 'b case =
    | Case : {
        tag : int;
        name : string;
        encoding : 'a Data_encoding.t;
        select : packed_contents -&gt; 'b contents option;
        proj : 'b contents -&gt; 'a;
        inj : 'a -&gt; 'b contents;
      }
        -&gt; 'b case
  [@@coq_force_gadt]

  val endorsement_case : Kind.endorsement case

  val seed_nonce_revelation_case : Kind.seed_nonce_revelation case

  val double_endorsement_evidence_case : Kind.double_endorsement_evidence case

  val double_baking_evidence_case : Kind.double_baking_evidence case

  val activate_account_case : Kind.activate_account case

  val proposals_case : Kind.proposals case

  val ballot_case : Kind.ballot case

  val reveal_case : Kind.reveal Kind.manager case

  val transaction_case : Kind.transaction Kind.manager case

  val origination_case : Kind.origination Kind.manager case

  val delegation_case : Kind.delegation Kind.manager case

  module Manager_operations : sig
    type 'b case =
      | MCase : {
          tag : int;
          name : string;
          encoding : 'a Data_encoding.t;
          select : packed_manager_operation -&gt; 'kind manager_operation option;
          proj : 'kind manager_operation -&gt; 'a;
          inj : 'a -&gt; 'kind manager_operation;
        }
          -&gt; 'kind case
    [@@coq_force_gadt]

    val reveal_case : Kind.reveal case

    val transaction_case : Kind.transaction case

    val origination_case : Kind.origination case

    val delegation_case : Kind.delegation case
  end
end
</pre>
  </div>
  <div class="col-md-6">
    <a href="#operation_repr.mli"><code>Operation_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Blinded_public_key_hash.
Require Tezos.Block_header_repr.
Require Tezos.Contract_repr.
Require Tezos.Raw_level_repr.
Require Tezos.Script_repr.
Require Tezos.Seed_repr.
Require Tezos.Tez_repr.
Require Tezos.Vote_repr.
Require Tezos.Voting_period_repr.

Module Kind.
  Inductive seed_nonce_revelation : Set :=
  | Seed_nonce_revelation_kind : seed_nonce_revelation.
  
  Inductive double_endorsement_evidence : Set :=
  | Double_endorsement_evidence_kind : double_endorsement_evidence.
  
  Inductive double_baking_evidence : Set :=
  | Double_baking_evidence_kind : double_baking_evidence.
  
  Inductive activate_account : Set :=
  | Activate_account_kind : activate_account.
  
  Inductive endorsement : Set :=
  | Endorsement_kind : endorsement.
  
  Inductive proposals : Set :=
  | Proposals_kind : proposals.
  
  Inductive ballot : Set :=
  | Ballot_kind : ballot.
  
  Inductive reveal : Set :=
  | Reveal_kind : reveal.
  
  Inductive transaction : Set :=
  | Transaction_kind : transaction.
  
  Inductive origination : Set :=
  | Origination_kind : origination.
  
  Inductive delegation : Set :=
  | Delegation_kind : delegation.
  
  Inductive manager : Set :=
  | Reveal_manager_kind : manager
  | Transaction_manager_kind : manager
  | Origination_manager_kind : manager
  | Delegation_manager_kind : manager.
End Kind.

Definition raw : Set := Operation.t.

Parameter raw_encoding : Data_encoding.t raw.

Module ConstructorRecords_contents_list_contents_manager_operation.
  Module contents.
    Module Endorsement.
      Record record {level : Set} : Set := Build {
        level : level }.
      Arguments record : clear implicits.
      Definition with_level {t_level} level (r : record t_level) :=
        Build t_level level.
    End Endorsement.
    Definition Endorsement_skeleton := Endorsement.record.
    
    Module Seed_nonce_revelation.
      Record record {level nonce : Set} : Set := Build {
        level : level;
        nonce : nonce }.
      Arguments record : clear implicits.
      Definition with_level {t_level t_nonce} level
        (r : record t_level t_nonce) :=
        Build t_level t_nonce level r.(nonce).
      Definition with_nonce {t_level t_nonce} nonce
        (r : record t_level t_nonce) :=
        Build t_level t_nonce r.(level) nonce.
    End Seed_nonce_revelation.
    Definition Seed_nonce_revelation_skeleton := Seed_nonce_revelation.record.
    
    Module Double_endorsement_evidence.
      Record record {op1 op2 : Set} : Set := Build {
        op1 : op1;
        op2 : op2 }.
      Arguments record : clear implicits.
      Definition with_op1 {t_op1 t_op2} op1 (r : record t_op1 t_op2) :=
        Build t_op1 t_op2 op1 r.(op2).
      Definition with_op2 {t_op1 t_op2} op2 (r : record t_op1 t_op2) :=
        Build t_op1 t_op2 r.(op1) op2.
    End Double_endorsement_evidence.
    Definition Double_endorsement_evidence_skeleton :=
      Double_endorsement_evidence.record.
    
    Module Double_baking_evidence.
      Record record {bh1 bh2 : Set} : Set := Build {
        bh1 : bh1;
        bh2 : bh2 }.
      Arguments record : clear implicits.
      Definition with_bh1 {t_bh1 t_bh2} bh1 (r : record t_bh1 t_bh2) :=
        Build t_bh1 t_bh2 bh1 r.(bh2).
      Definition with_bh2 {t_bh1 t_bh2} bh2 (r : record t_bh1 t_bh2) :=
        Build t_bh1 t_bh2 r.(bh1) bh2.
    End Double_baking_evidence.
    Definition Double_baking_evidence_skeleton := Double_baking_evidence.record.
    
    Module Activate_account.
      Record record {id activation_code : Set} : Set := Build {
        id : id;
        activation_code : activation_code }.
      Arguments record : clear implicits.
      Definition with_id {t_id t_activation_code} id
        (r : record t_id t_activation_code) :=
        Build t_id t_activation_code id r.(activation_code).
      Definition with_activation_code {t_id t_activation_code} activation_code
        (r : record t_id t_activation_code) :=
        Build t_id t_activation_code r.(id) activation_code.
    End Activate_account.
    Definition Activate_account_skeleton := Activate_account.record.
    
    Module Proposals.
      Record record {source period proposals : Set} : Set := Build {
        source : source;
        period : period;
        proposals : proposals }.
      Arguments record : clear implicits.
      Definition with_source {t_source t_period t_proposals} source
        (r : record t_source t_period t_proposals) :=
        Build t_source t_period t_proposals source r.(period) r.(proposals).
      Definition with_period {t_source t_period t_proposals} period
        (r : record t_source t_period t_proposals) :=
        Build t_source t_period t_proposals r.(source) period r.(proposals).
      Definition with_proposals {t_source t_period t_proposals} proposals
        (r : record t_source t_period t_proposals) :=
        Build t_source t_period t_proposals r.(source) r.(period) proposals.
    End Proposals.
    Definition Proposals_skeleton := Proposals.record.
    
    Module Ballot.
      Record record {source period proposal ballot : Set} : Set := Build {
        source : source;
        period : period;
        proposal : proposal;
        ballot : ballot }.
      Arguments record : clear implicits.
      Definition with_source {t_source t_period t_proposal t_ballot} source
        (r : record t_source t_period t_proposal t_ballot) :=
        Build t_source t_period t_proposal t_ballot source r.(period)
          r.(proposal) r.(ballot).
      Definition with_period {t_source t_period t_proposal t_ballot} period
        (r : record t_source t_period t_proposal t_ballot) :=
        Build t_source t_period t_proposal t_ballot r.(source) period
          r.(proposal) r.(ballot).
      Definition with_proposal {t_source t_period t_proposal t_ballot} proposal
        (r : record t_source t_period t_proposal t_ballot) :=
        Build t_source t_period t_proposal t_ballot r.(source) r.(period)
          proposal r.(ballot).
      Definition with_ballot {t_source t_period t_proposal t_ballot} ballot
        (r : record t_source t_period t_proposal t_ballot) :=
        Build t_source t_period t_proposal t_ballot r.(source) r.(period)
          r.(proposal) ballot.
    End Ballot.
    Definition Ballot_skeleton := Ballot.record.
    
    Module Manager_operation.
      Record record {source fee counter operation gas_limit storage_limit : Set} :
        Set := Build {
        source : source;
        fee : fee;
        counter : counter;
        operation : operation;
        gas_limit : gas_limit;
        storage_limit : storage_limit }.
      Arguments record : clear implicits.
      Definition with_source
        {t_source t_fee t_counter t_operation t_gas_limit t_storage_limit}
        source
        (r :
          record t_source t_fee t_counter t_operation t_gas_limit
            t_storage_limit) :=
        Build t_source t_fee t_counter t_operation t_gas_limit t_storage_limit
          source r.(fee) r.(counter) r.(operation) r.(gas_limit)
          r.(storage_limit).
      Definition with_fee
        {t_source t_fee t_counter t_operation t_gas_limit t_storage_limit} fee
        (r :
          record t_source t_fee t_counter t_operation t_gas_limit
            t_storage_limit) :=
        Build t_source t_fee t_counter t_operation t_gas_limit t_storage_limit
          r.(source) fee r.(counter) r.(operation) r.(gas_limit)
          r.(storage_limit).
      Definition with_counter
        {t_source t_fee t_counter t_operation t_gas_limit t_storage_limit}
        counter
        (r :
          record t_source t_fee t_counter t_operation t_gas_limit
            t_storage_limit) :=
        Build t_source t_fee t_counter t_operation t_gas_limit t_storage_limit
          r.(source) r.(fee) counter r.(operation) r.(gas_limit)
          r.(storage_limit).
      Definition with_operation
        {t_source t_fee t_counter t_operation t_gas_limit t_storage_limit}
        operation
        (r :
          record t_source t_fee t_counter t_operation t_gas_limit
            t_storage_limit) :=
        Build t_source t_fee t_counter t_operation t_gas_limit t_storage_limit
          r.(source) r.(fee) r.(counter) operation r.(gas_limit)
          r.(storage_limit).
      Definition with_gas_limit
        {t_source t_fee t_counter t_operation t_gas_limit t_storage_limit}
        gas_limit
        (r :
          record t_source t_fee t_counter t_operation t_gas_limit
            t_storage_limit) :=
        Build t_source t_fee t_counter t_operation t_gas_limit t_storage_limit
          r.(source) r.(fee) r.(counter) r.(operation) gas_limit
          r.(storage_limit).
      Definition with_storage_limit
        {t_source t_fee t_counter t_operation t_gas_limit t_storage_limit}
        storage_limit
        (r :
          record t_source t_fee t_counter t_operation t_gas_limit
            t_storage_limit) :=
        Build t_source t_fee t_counter t_operation t_gas_limit t_storage_limit
          r.(source) r.(fee) r.(counter) r.(operation) r.(gas_limit)
          storage_limit.
    End Manager_operation.
    Definition Manager_operation_skeleton := Manager_operation.record.
  End contents.
  Module manager_operation.
    Module Transaction.
      Record record {amount parameters entrypoint destination : Set} : Set := Build {
        amount : amount;
        parameters : parameters;
        entrypoint : entrypoint;
        destination : destination }.
      Arguments record : clear implicits.
      Definition with_amount {t_amount t_parameters t_entrypoint t_destination}
        amount (r : record t_amount t_parameters t_entrypoint t_destination) :=
        Build t_amount t_parameters t_entrypoint t_destination amount
          r.(parameters) r.(entrypoint) r.(destination).
      Definition with_parameters
        {t_amount t_parameters t_entrypoint t_destination} parameters
        (r : record t_amount t_parameters t_entrypoint t_destination) :=
        Build t_amount t_parameters t_entrypoint t_destination r.(amount)
          parameters r.(entrypoint) r.(destination).
      Definition with_entrypoint
        {t_amount t_parameters t_entrypoint t_destination} entrypoint
        (r : record t_amount t_parameters t_entrypoint t_destination) :=
        Build t_amount t_parameters t_entrypoint t_destination r.(amount)
          r.(parameters) entrypoint r.(destination).
      Definition with_destination
        {t_amount t_parameters t_entrypoint t_destination} destination
        (r : record t_amount t_parameters t_entrypoint t_destination) :=
        Build t_amount t_parameters t_entrypoint t_destination r.(amount)
          r.(parameters) r.(entrypoint) destination.
    End Transaction.
    Definition Transaction_skeleton := Transaction.record.
    
    Module Origination.
      Record record {delegate script credit preorigination : Set} : Set := Build {
        delegate : delegate;
        script : script;
        credit : credit;
        preorigination : preorigination }.
      Arguments record : clear implicits.
      Definition with_delegate {t_delegate t_script t_credit t_preorigination}
        delegate (r : record t_delegate t_script t_credit t_preorigination) :=
        Build t_delegate t_script t_credit t_preorigination delegate r.(script)
          r.(credit) r.(preorigination).
      Definition with_script {t_delegate t_script t_credit t_preorigination}
        script (r : record t_delegate t_script t_credit t_preorigination) :=
        Build t_delegate t_script t_credit t_preorigination r.(delegate) script
          r.(credit) r.(preorigination).
      Definition with_credit {t_delegate t_script t_credit t_preorigination}
        credit (r : record t_delegate t_script t_credit t_preorigination) :=
        Build t_delegate t_script t_credit t_preorigination r.(delegate)
          r.(script) credit r.(preorigination).
      Definition with_preorigination
        {t_delegate t_script t_credit t_preorigination} preorigination
        (r : record t_delegate t_script t_credit t_preorigination) :=
        Build t_delegate t_script t_credit t_preorigination r.(delegate)
          r.(script) r.(credit) preorigination.
    End Origination.
    Definition Origination_skeleton := Origination.record.
  End manager_operation.
End ConstructorRecords_contents_list_contents_manager_operation.
Import ConstructorRecords_contents_list_contents_manager_operation.

Module operation.
  Record record {shell protocol_data : Set} : Set := Build {
    shell : shell;
    protocol_data : protocol_data }.
  Arguments record : clear implicits.
  Definition with_shell {t_shell t_protocol_data} shell
    (r : record t_shell t_protocol_data) :=
    Build t_shell t_protocol_data shell r.(protocol_data).
  Definition with_protocol_data {t_shell t_protocol_data} protocol_data
    (r : record t_shell t_protocol_data) :=
    Build t_shell t_protocol_data r.(shell) protocol_data.
End operation.
Definition operation_skeleton := operation.record.

Module protocol_data.
  Record record {contents signature : Set} : Set := Build {
    contents : contents;
    signature : signature }.
  Arguments record : clear implicits.
  Definition with_contents {t_contents t_signature} contents
    (r : record t_contents t_signature) :=
    Build t_contents t_signature contents r.(signature).
  Definition with_signature {t_contents t_signature} signature
    (r : record t_contents t_signature) :=
    Build t_contents t_signature r.(contents) signature.
End protocol_data.
Definition protocol_data_skeleton := protocol_data.record.

Reserved Notation &quot;'contents.Endorsement&quot;.
Reserved Notation &quot;'contents.Seed_nonce_revelation&quot;.
Reserved Notation &quot;'contents.Double_endorsement_evidence&quot;.
Reserved Notation &quot;'contents.Double_baking_evidence&quot;.
Reserved Notation &quot;'contents.Activate_account&quot;.
Reserved Notation &quot;'contents.Proposals&quot;.
Reserved Notation &quot;'contents.Ballot&quot;.
Reserved Notation &quot;'contents.Manager_operation&quot;.
Reserved Notation &quot;'manager_operation.Transaction&quot;.
Reserved Notation &quot;'manager_operation.Origination&quot;.
Reserved Notation &quot;'protocol_data&quot;.
Reserved Notation &quot;'operation&quot;.
Reserved Notation &quot;'counter&quot;.

Inductive contents_list : Set :=
| Single : contents -&gt; contents_list
| Cons : contents -&gt; contents_list -&gt; contents_list

with contents : Set :=
| Endorsement : 'contents.Endorsement -&gt; contents
| Seed_nonce_revelation : 'contents.Seed_nonce_revelation -&gt; contents
| Double_endorsement_evidence :
  'contents.Double_endorsement_evidence -&gt; contents
| Double_baking_evidence : 'contents.Double_baking_evidence -&gt; contents
| Activate_account : 'contents.Activate_account -&gt; contents
| Proposals : 'contents.Proposals -&gt; contents
| Ballot : 'contents.Ballot -&gt; contents
| Manager_operation : 'contents.Manager_operation -&gt; contents

with manager_operation : Set :=
| Reveal : (|Signature.Public_key|).(S.SPublic_key.t) -&gt; manager_operation
| Transaction : 'manager_operation.Transaction -&gt; manager_operation
| Origination : 'manager_operation.Origination -&gt; manager_operation
| Delegation :
  option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  manager_operation

where &quot;'protocol_data&quot; :=
  (protocol_data_skeleton contents_list (option Signature.t))
and &quot;'operation&quot; := (operation_skeleton Operation.shell_header 'protocol_data)
and &quot;'counter&quot; := (Z.t)
and &quot;'contents.Endorsement&quot; := (contents.Endorsement_skeleton Raw_level_repr.t)
and &quot;'contents.Seed_nonce_revelation&quot; :=
  (contents.Seed_nonce_revelation_skeleton Raw_level_repr.t Seed_repr.nonce)
and &quot;'contents.Double_endorsement_evidence&quot; :=
  (contents.Double_endorsement_evidence_skeleton 'operation 'operation)
and &quot;'contents.Double_baking_evidence&quot; :=
  (contents.Double_baking_evidence_skeleton Block_header_repr.block_header
    Block_header_repr.block_header)
and &quot;'contents.Activate_account&quot; :=
  (contents.Activate_account_skeleton
    (|Ed25519|).(S.SIGNATURE.Public_key_hash).(S.SPublic_key_hash.t)
    Blinded_public_key_hash.activation_code)
and &quot;'contents.Proposals&quot; :=
  (contents.Proposals_skeleton
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) Voting_period_repr.t
    (list (|Protocol_hash|).(S.HASH.t)))
and &quot;'contents.Ballot&quot; :=
  (contents.Ballot_skeleton (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)
    Voting_period_repr.t (|Protocol_hash|).(S.HASH.t) Vote_repr.ballot)
and &quot;'contents.Manager_operation&quot; :=
  (contents.Manager_operation_skeleton
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) Tez_repr.tez 'counter
    manager_operation Z.t Z.t)
and &quot;'manager_operation.Transaction&quot; :=
  (manager_operation.Transaction_skeleton Tez_repr.tez Script_repr.lazy_expr
    string Contract_repr.contract)
and &quot;'manager_operation.Origination&quot; :=
  (manager_operation.Origination_skeleton
    (option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)) Script_repr.t
    Tez_repr.tez (option Contract_repr.t)).

Module contents.
  Include ConstructorRecords_contents_list_contents_manager_operation.contents.
  Definition Endorsement := 'contents.Endorsement.
  Definition Seed_nonce_revelation := 'contents.Seed_nonce_revelation.
  Definition Double_endorsement_evidence :=
    'contents.Double_endorsement_evidence.
  Definition Double_baking_evidence := 'contents.Double_baking_evidence.
  Definition Activate_account := 'contents.Activate_account.
  Definition Proposals := 'contents.Proposals.
  Definition Ballot := 'contents.Ballot.
  Definition Manager_operation := 'contents.Manager_operation.
End contents.
Module manager_operation.
  Include ConstructorRecords_contents_list_contents_manager_operation.manager_operation.
  Definition Transaction := 'manager_operation.Transaction.
  Definition Origination := 'manager_operation.Origination.
End manager_operation.

Definition protocol_data := 'protocol_data.
Definition operation := 'operation.
Definition counter := 'counter.

Module internal_operation.
  Record record : Set := Build {
    source : Contract_repr.contract;
    operation : manager_operation;
    nonce : int }.
  Definition with_source source (r : record) :=
    Build source r.(operation) r.(nonce).
  Definition with_operation operation (r : record) :=
    Build r.(source) operation r.(nonce).
  Definition with_nonce nonce (r : record) :=
    Build r.(source) r.(operation) nonce.
End internal_operation.
Definition internal_operation := internal_operation.record.

Inductive packed_manager_operation : Set :=
| Manager : manager_operation -&gt; packed_manager_operation.

Inductive packed_contents : Set :=
| Contents : contents -&gt; packed_contents.

Inductive packed_contents_list : Set :=
| Contents_list : contents_list -&gt; packed_contents_list.

Parameter of_list : list packed_contents -&gt; packed_contents_list.

Parameter to_list : packed_contents_list -&gt; list packed_contents.

Inductive packed_protocol_data : Set :=
| Operation_data : protocol_data -&gt; packed_protocol_data.

Module packed_operation.
  Record record : Set := Build {
    shell : Operation.shell_header;
    protocol_data : packed_protocol_data }.
  Definition with_shell shell (r : record) :=
    Build shell r.(protocol_data).
  Definition with_protocol_data protocol_data (r : record) :=
    Build r.(shell) protocol_data.
End packed_operation.
Definition packed_operation := packed_operation.record.

Parameter __pack : operation -&gt; packed_operation.

Inductive packed_internal_operation : Set :=
| Internal_operation : internal_operation -&gt; packed_internal_operation.

Parameter manager_kind : manager_operation -&gt; Kind.manager.

Parameter encoding : Data_encoding.t packed_operation.

Parameter contents_encoding : Data_encoding.t packed_contents.

Parameter contents_list_encoding : Data_encoding.t packed_contents_list.

Parameter protocol_data_encoding : Data_encoding.t packed_protocol_data.

Parameter unsigned_operation_encoding :
  Data_encoding.t (Operation.shell_header * packed_contents_list).

Parameter __raw_value : operation -&gt; raw.

Parameter hash_raw : raw -&gt; (|Operation_hash|).(S.HASH.t).

Parameter __hash_value : operation -&gt; (|Operation_hash|).(S.HASH.t).

Parameter hash_packed : packed_operation -&gt; (|Operation_hash|).(S.HASH.t).

Parameter acceptable_passes : packed_operation -&gt; list int.

(* extensible_type_definition `error` *)

(* extensible_type_definition `error` *)

Parameter check_signature :
  (|Signature.Public_key|).(S.SPublic_key.t) -&gt; (|Chain_id|).(S.HASH.t) -&gt;
  operation -&gt; Lwt.t (Error_monad.tzresult unit).

Parameter check_signature_sync :
  (|Signature.Public_key|).(S.SPublic_key.t) -&gt; (|Chain_id|).(S.HASH.t) -&gt;
  operation -&gt; Error_monad.tzresult unit.

Parameter internal_operation_encoding :
  Data_encoding.t packed_internal_operation.

Inductive eq : Set :=
| Eq : eq.

Parameter equal : operation -&gt; operation -&gt; option eq.

Module Encoding.
  Module ConstructorRecords_case.
    Module case.
      Module Case.
        Record record {tag name encoding select proj inj : Set} : Set := Build {
          tag : tag;
          name : name;
          encoding : encoding;
          select : select;
          proj : proj;
          inj : inj }.
        Arguments record : clear implicits.
        Definition with_tag {t_tag t_name t_encoding t_select t_proj t_inj} tag
          (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
          Build t_tag t_name t_encoding t_select t_proj t_inj tag r.(name)
            r.(encoding) r.(select) r.(proj) r.(inj).
        Definition with_name {t_tag t_name t_encoding t_select t_proj t_inj}
          name (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
          Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) name
            r.(encoding) r.(select) r.(proj) r.(inj).
        Definition with_encoding {t_tag t_name t_encoding t_select t_proj t_inj}
          encoding (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
          Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) r.(name)
            encoding r.(select) r.(proj) r.(inj).
        Definition with_select {t_tag t_name t_encoding t_select t_proj t_inj}
          select (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
          Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) r.(name)
            r.(encoding) select r.(proj) r.(inj).
        Definition with_proj {t_tag t_name t_encoding t_select t_proj t_inj}
          proj (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
          Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) r.(name)
            r.(encoding) r.(select) proj r.(inj).
        Definition with_inj {t_tag t_name t_encoding t_select t_proj t_inj} inj
          (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
          Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) r.(name)
            r.(encoding) r.(select) r.(proj) inj.
      End Case.
      Definition Case_skeleton := Case.record.
    End case.
  End ConstructorRecords_case.
  Import ConstructorRecords_case.
  
  Reserved Notation &quot;'case.Case&quot;.
  
  Inductive case : Set :=
  | Case : forall {a : Set}, 'case.Case a -&gt; case
  
  where &quot;'case.Case&quot; := (fun (t_a : Set) =&gt;
    case.Case_skeleton int string (Data_encoding.t t_a)
      (packed_contents -&gt; option contents) (contents -&gt; t_a) (t_a -&gt; contents)).
  
  Module case.
    Include ConstructorRecords_case.case.
    Definition Case := 'case.Case.
  End case.
  
  Parameter endorsement_case : case.
  
  Parameter seed_nonce_revelation_case : case.
  
  Parameter double_endorsement_evidence_case : case.
  
  Parameter double_baking_evidence_case : case.
  
  Parameter activate_account_case : case.
  
  Parameter proposals_case : case.
  
  Parameter ballot_case : case.
  
  Parameter reveal_case : case.
  
  Parameter transaction_case : case.
  
  Parameter origination_case : case.
  
  Parameter delegation_case : case.
  
  Module Manager_operations.
    Module ConstructorRecords_case.
      Module case.
        Module MCase.
          Record record {tag name encoding select proj inj : Set} : Set := Build {
            tag : tag;
            name : name;
            encoding : encoding;
            select : select;
            proj : proj;
            inj : inj }.
          Arguments record : clear implicits.
          Definition with_tag {t_tag t_name t_encoding t_select t_proj t_inj}
            tag (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
            Build t_tag t_name t_encoding t_select t_proj t_inj tag r.(name)
              r.(encoding) r.(select) r.(proj) r.(inj).
          Definition with_name {t_tag t_name t_encoding t_select t_proj t_inj}
            name (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
            Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) name
              r.(encoding) r.(select) r.(proj) r.(inj).
          Definition with_encoding
            {t_tag t_name t_encoding t_select t_proj t_inj} encoding
            (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
            Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) r.(name)
              encoding r.(select) r.(proj) r.(inj).
          Definition with_select {t_tag t_name t_encoding t_select t_proj t_inj}
            select (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
            Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) r.(name)
              r.(encoding) select r.(proj) r.(inj).
          Definition with_proj {t_tag t_name t_encoding t_select t_proj t_inj}
            proj (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
            Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) r.(name)
              r.(encoding) r.(select) proj r.(inj).
          Definition with_inj {t_tag t_name t_encoding t_select t_proj t_inj}
            inj (r : record t_tag t_name t_encoding t_select t_proj t_inj) :=
            Build t_tag t_name t_encoding t_select t_proj t_inj r.(tag) r.(name)
              r.(encoding) r.(select) r.(proj) inj.
        End MCase.
        Definition MCase_skeleton := MCase.record.
      End case.
    End ConstructorRecords_case.
    Import ConstructorRecords_case.
    
    Reserved Notation &quot;'case.MCase&quot;.
    
    Inductive case : Set :=
    | MCase : forall {a : Set}, 'case.MCase a -&gt; case
    
    where &quot;'case.MCase&quot; := (fun (t_a : Set) =&gt;
      case.MCase_skeleton int string (Data_encoding.t t_a)
        (packed_manager_operation -&gt; option manager_operation)
        (manager_operation -&gt; t_a) (t_a -&gt; manager_operation)).
    
    Module case.
      Include ConstructorRecords_case.case.
      Definition MCase := 'case.MCase.
    End case.
    
    Parameter reveal_case : case.
    
    Parameter transaction_case : case.
    
    Parameter origination_case : case.
    
    Parameter delegation_case : case.
  End Manager_operations.
End Encoding.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="parameters_repr.ml">
  <div style="margin: 20px;">
    <h3>Parameters_repr</h3>
    <ul>
      <li>OCaml size: 127 lines</li>
      <li>Coq size: 177 lines (+39% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#parameters_repr.ml"><code>parameters_repr.ml</code></a>&nbsp;<span class="label label-warning">1 warning</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type bootstrap_account = {
  public_key_hash : Signature.Public_key_hash.t;
  public_key : Signature.Public_key.t option;
  amount : Tez_repr.t;
}

type bootstrap_contract = {
  delegate : Signature.Public_key_hash.t;
  amount : Tez_repr.t;
  script : Script_repr.t;
}

type t = {
  bootstrap_accounts : bootstrap_account list;
  bootstrap_contracts : bootstrap_contract list;
  commitments : Commitment_repr.t list;
  constants : Constants_repr.parametric;
  security_deposit_ramp_up_cycles : int option;
  no_reward_cycles : int option;
}

let bootstrap_account_encoding =
  let open Data_encoding in
  union
    [ case
        (Tag 0)
        ~title:&quot;Public_key_known&quot;
        (tup2 Signature.Public_key.encoding Tez_repr.encoding)
        (function
          | {public_key_hash; public_key = Some public_key; amount} -&gt;
              <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (
                Signature.Public_key_hash.equal
                  (Signature.Public_key.hash public_key)
                  public_key_hash )</abbr> ;
              Some (public_key, amount)
          | {public_key = None} -&gt;
              None)
        (fun (public_key, amount) -&gt;
          {
            public_key = Some public_key;
            public_key_hash = Signature.Public_key.hash public_key;
            amount;
          });
      case
        (Tag 1)
        ~title:&quot;Public_key_unknown&quot;
        (tup2 Signature.Public_key_hash.encoding Tez_repr.encoding)
        (function
          | {public_key_hash; public_key = None; amount} -&gt;
              Some (public_key_hash, amount)
          | {public_key = Some _} -&gt;
              None)
        (fun (public_key_hash, amount) -&gt;
          {public_key = None; public_key_hash; amount}) ]

let bootstrap_contract_encoding =
  let open Data_encoding in
  conv
    (fun {delegate; amount; script} -&gt; (delegate, amount, script))
    (fun (delegate, amount, script) -&gt; {delegate; amount; script})
    (obj3
       (req &quot;delegate&quot; Signature.Public_key_hash.encoding)
       (req &quot;amount&quot; Tez_repr.encoding)
       (req &quot;script&quot; Script_repr.encoding))

let encoding =
  let open Data_encoding in
  conv
    (fun { bootstrap_accounts;
           bootstrap_contracts;
           commitments;
           constants;
           security_deposit_ramp_up_cycles;
           no_reward_cycles } -&gt;
      ( ( bootstrap_accounts,
          bootstrap_contracts,
          commitments,
          security_deposit_ramp_up_cycles,
          no_reward_cycles ),
        constants ))
    (fun ( ( bootstrap_accounts,
             bootstrap_contracts,
             commitments,
             security_deposit_ramp_up_cycles,
             no_reward_cycles ),
           constants ) -&gt;
      {
        bootstrap_accounts;
        bootstrap_contracts;
        commitments;
        constants;
        security_deposit_ramp_up_cycles;
        no_reward_cycles;
      })
    (merge_objs
       (obj5
          (req &quot;bootstrap_accounts&quot; (list bootstrap_account_encoding))
          (dft &quot;bootstrap_contracts&quot; (list bootstrap_contract_encoding) [])
          (dft &quot;commitments&quot; (list Commitment_repr.encoding) [])
          (opt &quot;security_deposit_ramp_up_cycles&quot; int31)
          (opt &quot;no_reward_cycles&quot; int31))
       Constants_repr.parametric_encoding)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#parameters_repr.ml"><code>Parameters_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Commitment_repr.
Require Tezos.Constants_repr.
Require Tezos.Script_repr.
Require Tezos.Tez_repr.

Module bootstrap_account.
  Record record : Set := Build {
    public_key_hash : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t);
    public_key : option (|Signature.Public_key|).(S.SPublic_key.t);
    amount : Tez_repr.t }.
  Definition with_public_key_hash public_key_hash (r : record) :=
    Build public_key_hash r.(public_key) r.(amount).
  Definition with_public_key public_key (r : record) :=
    Build r.(public_key_hash) public_key r.(amount).
  Definition with_amount amount (r : record) :=
    Build r.(public_key_hash) r.(public_key) amount.
End bootstrap_account.
Definition bootstrap_account := bootstrap_account.record.

Module bootstrap_contract.
  Record record : Set := Build {
    delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t);
    amount : Tez_repr.t;
    script : Script_repr.t }.
  Definition with_delegate delegate (r : record) :=
    Build delegate r.(amount) r.(script).
  Definition with_amount amount (r : record) :=
    Build r.(delegate) amount r.(script).
  Definition with_script script (r : record) :=
    Build r.(delegate) r.(amount) script.
End bootstrap_contract.
Definition bootstrap_contract := bootstrap_contract.record.

Module t.
  Record record : Set := Build {
    bootstrap_accounts : list bootstrap_account;
    bootstrap_contracts : list bootstrap_contract;
    commitments : list Commitment_repr.t;
    constants : Constants_repr.parametric;
    security_deposit_ramp_up_cycles : option int;
    no_reward_cycles : option int }.
  Definition with_bootstrap_accounts bootstrap_accounts (r : record) :=
    Build bootstrap_accounts r.(bootstrap_contracts) r.(commitments)
      r.(constants) r.(security_deposit_ramp_up_cycles) r.(no_reward_cycles).
  Definition with_bootstrap_contracts bootstrap_contracts (r : record) :=
    Build r.(bootstrap_accounts) bootstrap_contracts r.(commitments)
      r.(constants) r.(security_deposit_ramp_up_cycles) r.(no_reward_cycles).
  Definition with_commitments commitments (r : record) :=
    Build r.(bootstrap_accounts) r.(bootstrap_contracts) commitments
      r.(constants) r.(security_deposit_ramp_up_cycles) r.(no_reward_cycles).
  Definition with_constants constants (r : record) :=
    Build r.(bootstrap_accounts) r.(bootstrap_contracts) r.(commitments)
      constants r.(security_deposit_ramp_up_cycles) r.(no_reward_cycles).
  Definition with_security_deposit_ramp_up_cycles
    security_deposit_ramp_up_cycles (r : record) :=
    Build r.(bootstrap_accounts) r.(bootstrap_contracts) r.(commitments)
      r.(constants) security_deposit_ramp_up_cycles r.(no_reward_cycles).
  Definition with_no_reward_cycles no_reward_cycles (r : record) :=
    Build r.(bootstrap_accounts) r.(bootstrap_contracts) r.(commitments)
      r.(constants) r.(security_deposit_ramp_up_cycles) no_reward_cycles.
End t.
Definition t := t.record.

Definition bootstrap_account_encoding
  : Data_encoding.encoding bootstrap_account :=
  Data_encoding.union None
    [
      Data_encoding.__case_value &quot;Public_key_known&quot; None (Data_encoding.Tag 0)
        (Data_encoding.tup2 (|Signature.Public_key|).(S.SPublic_key.encoding)
          Tez_repr.encoding)
        (fun function_parameter =&gt;
          match function_parameter with
          | {|
            bootstrap_account.public_key_hash := public_key_hash;
              bootstrap_account.public_key := Some public_key;
              bootstrap_account.amount := amount
              |} =&gt;
            (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
            (* ‚ùå instruction_sequence &quot;;&quot; *)
            Some (public_key, amount)
          | {| bootstrap_account.public_key := None |} =&gt; None
          end)
        (fun function_parameter =&gt;
          let '(public_key, amount) := function_parameter in
          {|
            bootstrap_account.public_key_hash :=
              (|Signature.Public_key|).(S.SPublic_key.__hash_value)
                public_key;
            bootstrap_account.public_key := Some public_key;
            bootstrap_account.amount := amount |});
      Data_encoding.__case_value &quot;Public_key_unknown&quot; None (Data_encoding.Tag 1)
        (Data_encoding.tup2
          (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding)
          Tez_repr.encoding)
        (fun function_parameter =&gt;
          match function_parameter with
          | {|
            bootstrap_account.public_key_hash := public_key_hash;
              bootstrap_account.public_key := None;
              bootstrap_account.amount := amount
              |} =&gt; Some (public_key_hash, amount)
          | {| bootstrap_account.public_key := Some _ |} =&gt; None
          end)
        (fun function_parameter =&gt;
          let '(public_key_hash, amount) := function_parameter in
          {| bootstrap_account.public_key_hash := public_key_hash;
            bootstrap_account.public_key := None;
            bootstrap_account.amount := amount |})
    ].

Definition bootstrap_contract_encoding
  : Data_encoding.encoding bootstrap_contract :=
  Data_encoding.conv
    (fun function_parameter =&gt;
      let '{|
        bootstrap_contract.delegate := delegate;
          bootstrap_contract.amount := amount;
          bootstrap_contract.script := script
          |} := function_parameter in
      (delegate, amount, script))
    (fun function_parameter =&gt;
      let '(delegate, amount, script) := function_parameter in
      {| bootstrap_contract.delegate := delegate;
        bootstrap_contract.amount := amount; bootstrap_contract.script := script
        |}) None
    (Data_encoding.obj3
      (Data_encoding.req None None &quot;delegate&quot;
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding))
      (Data_encoding.req None None &quot;amount&quot; Tez_repr.encoding)
      (Data_encoding.req None None &quot;script&quot; Script_repr.encoding)).

Definition encoding : Data_encoding.encoding t :=
  Data_encoding.conv
    (fun function_parameter =&gt;
      let '{|
        t.bootstrap_accounts := bootstrap_accounts;
          t.bootstrap_contracts := bootstrap_contracts;
          t.commitments := commitments;
          t.constants := constants;
          t.security_deposit_ramp_up_cycles := security_deposit_ramp_up_cycles;
          t.no_reward_cycles := no_reward_cycles
          |} := function_parameter in
      ((bootstrap_accounts, bootstrap_contracts, commitments,
        security_deposit_ramp_up_cycles, no_reward_cycles), constants))
    (fun function_parameter =&gt;
      let
        '((bootstrap_accounts, bootstrap_contracts, commitments,
          security_deposit_ramp_up_cycles, no_reward_cycles), constants) :=
        function_parameter in
      {| t.bootstrap_accounts := bootstrap_accounts;
        t.bootstrap_contracts := bootstrap_contracts;
        t.commitments := commitments; t.constants := constants;
        t.security_deposit_ramp_up_cycles := security_deposit_ramp_up_cycles;
        t.no_reward_cycles := no_reward_cycles |}) None
    (Data_encoding.merge_objs
      (Data_encoding.obj5
        (Data_encoding.req None None &quot;bootstrap_accounts&quot;
          (Data_encoding.__list_value None bootstrap_account_encoding))
        (Data_encoding.dft None None &quot;bootstrap_contracts&quot;
          (Data_encoding.__list_value None bootstrap_contract_encoding) nil)
        (Data_encoding.dft None None &quot;commitments&quot;
          (Data_encoding.__list_value None Commitment_repr.encoding) nil)
        (Data_encoding.opt None None &quot;security_deposit_ramp_up_cycles&quot;
          Data_encoding.int31)
        (Data_encoding.opt None None &quot;no_reward_cycles&quot; Data_encoding.int31))
      Constants_repr.parametric_encoding).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="parameters_repr.mli">
  <div style="margin: 20px;">
    <h3>Parameters_repr_mli</h3>
    <ul>
      <li>OCaml size: 47 lines</li>
      <li>Coq size: 75 lines (+59% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#parameters_repr.mli"><code>parameters_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type bootstrap_account = {
  public_key_hash : Signature.Public_key_hash.t;
  public_key : Signature.Public_key.t option;
  amount : Tez_repr.t;
}

type bootstrap_contract = {
  delegate : Signature.Public_key_hash.t;
  amount : Tez_repr.t;
  script : Script_repr.t;
}

type t = {
  bootstrap_accounts : bootstrap_account list;
  bootstrap_contracts : bootstrap_contract list;
  commitments : Commitment_repr.t list;
  constants : Constants_repr.parametric;
  security_deposit_ramp_up_cycles : int option;
  no_reward_cycles : int option;
}

val encoding : t Data_encoding.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#parameters_repr.mli"><code>Parameters_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Commitment_repr.
Require Tezos.Constants_repr.
Require Tezos.Script_repr.
Require Tezos.Tez_repr.

Module bootstrap_account.
  Record record : Set := Build {
    public_key_hash : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t);
    public_key : option (|Signature.Public_key|).(S.SPublic_key.t);
    amount : Tez_repr.t }.
  Definition with_public_key_hash public_key_hash (r : record) :=
    Build public_key_hash r.(public_key) r.(amount).
  Definition with_public_key public_key (r : record) :=
    Build r.(public_key_hash) public_key r.(amount).
  Definition with_amount amount (r : record) :=
    Build r.(public_key_hash) r.(public_key) amount.
End bootstrap_account.
Definition bootstrap_account := bootstrap_account.record.

Module bootstrap_contract.
  Record record : Set := Build {
    delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t);
    amount : Tez_repr.t;
    script : Script_repr.t }.
  Definition with_delegate delegate (r : record) :=
    Build delegate r.(amount) r.(script).
  Definition with_amount amount (r : record) :=
    Build r.(delegate) amount r.(script).
  Definition with_script script (r : record) :=
    Build r.(delegate) r.(amount) script.
End bootstrap_contract.
Definition bootstrap_contract := bootstrap_contract.record.

Module t.
  Record record : Set := Build {
    bootstrap_accounts : list bootstrap_account;
    bootstrap_contracts : list bootstrap_contract;
    commitments : list Commitment_repr.t;
    constants : Constants_repr.parametric;
    security_deposit_ramp_up_cycles : option int;
    no_reward_cycles : option int }.
  Definition with_bootstrap_accounts bootstrap_accounts (r : record) :=
    Build bootstrap_accounts r.(bootstrap_contracts) r.(commitments)
      r.(constants) r.(security_deposit_ramp_up_cycles) r.(no_reward_cycles).
  Definition with_bootstrap_contracts bootstrap_contracts (r : record) :=
    Build r.(bootstrap_accounts) bootstrap_contracts r.(commitments)
      r.(constants) r.(security_deposit_ramp_up_cycles) r.(no_reward_cycles).
  Definition with_commitments commitments (r : record) :=
    Build r.(bootstrap_accounts) r.(bootstrap_contracts) commitments
      r.(constants) r.(security_deposit_ramp_up_cycles) r.(no_reward_cycles).
  Definition with_constants constants (r : record) :=
    Build r.(bootstrap_accounts) r.(bootstrap_contracts) r.(commitments)
      constants r.(security_deposit_ramp_up_cycles) r.(no_reward_cycles).
  Definition with_security_deposit_ramp_up_cycles
    security_deposit_ramp_up_cycles (r : record) :=
    Build r.(bootstrap_accounts) r.(bootstrap_contracts) r.(commitments)
      r.(constants) security_deposit_ramp_up_cycles r.(no_reward_cycles).
  Definition with_no_reward_cycles no_reward_cycles (r : record) :=
    Build r.(bootstrap_accounts) r.(bootstrap_contracts) r.(commitments)
      r.(constants) r.(security_deposit_ramp_up_cycles) no_reward_cycles.
End t.
Definition t := t.record.

Parameter encoding : Data_encoding.t t.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="period_repr.ml">
  <div style="margin: 20px;">
    <h3>Period_repr</h3>
    <ul>
      <li>OCaml size: 87 lines</li>
      <li>Coq size: 103 lines (+18% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#period_repr.ml"><code>period_repr.ml</code></a>&nbsp;<span class="label label-warning">4 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = Int64.t

type period = t

include (Compare.Int64 : Compare.S with type t := t)

let encoding = Data_encoding.int64

let rpc_arg = RPC_arg.int64

let pp ppf v = Format.fprintf ppf &quot;%Ld&quot; v

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += (* `Permanent *)
                Malformed_period | Invalid_arg</abbr>

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  let open Data_encoding in
  (* Malformed period *)
  register_error_kind
    `Permanent
    ~id:&quot;malformed_period&quot;
    ~title:&quot;Malformed period&quot;
    ~description:&quot;Period is negative.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Malformed period&quot;)
    empty
    (function Malformed_period -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Malformed_period) ;
  (* Invalid arg *)
  register_error_kind
    `Permanent
    ~id:&quot;invalid_arg&quot;
    ~title:&quot;Invalid arg&quot;
    ~description:&quot;Negative multiple of periods are not allowed.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Invalid arg&quot;)
    empty
    (function Invalid_arg -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Invalid_arg)</abbr>

let of_seconds t =
  if Compare.Int64.(t &gt;= 0L) then ok t else error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Malformed_period</abbr>

let to_seconds t = t

let of_seconds_exn t =
  match of_seconds t with
  | Ok t -&gt;
      t
  | _ -&gt;
      invalid_arg &quot;Period.of_seconds_exn&quot;

let mult i p =
  (* TODO check overflow *)
  if Compare.Int32.(i &lt; 0l) then error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_arg</abbr>
  else ok (Int64.mul (Int64.of_int32 i) p)

let zero = of_seconds_exn 0L

let one_second = of_seconds_exn 1L

let one_minute = of_seconds_exn 60L

let one_hour = of_seconds_exn 3600L
</pre>
  </div>
  <div class="col-md-6">
    <a href="#period_repr.ml"><code>Period_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.

Definition t : Set := Int64.t.

Definition period : Set := t.

Definition op_eq := (|Compare.Int64|).(Compare.S.op_eq).

Definition op_ltgt := (|Compare.Int64|).(Compare.S.op_ltgt).

Definition op_lt := (|Compare.Int64|).(Compare.S.op_lt).

Definition op_lteq := (|Compare.Int64|).(Compare.S.op_lteq).

Definition op_gteq := (|Compare.Int64|).(Compare.S.op_gteq).

Definition op_gt := (|Compare.Int64|).(Compare.S.op_gt).

Definition compare := (|Compare.Int64|).(Compare.S.compare).

Definition equal := (|Compare.Int64|).(Compare.S.equal).

Definition max := (|Compare.Int64|).(Compare.S.max).

Definition min := (|Compare.Int64|).(Compare.S.min).

Definition encoding : Data_encoding.encoding int64 :=
  Data_encoding.__int64_value.

Definition rpc_arg : RPC_arg.arg int64 := RPC_arg.__int64_value.

Definition pp (ppf : Format.formatter) (v : int64) : unit :=
  Format.fprintf ppf
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.Int64 CamlinternalFormatBasics.Int_d
        CamlinternalFormatBasics.No_padding
        CamlinternalFormatBasics.No_precision
        CamlinternalFormatBasics.End_of_format) &quot;%Ld&quot;) v.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition of_seconds (__t_value : (|Compare.Int64|).(Compare.S.t))
  : Error_monad.tzresult (|Compare.Int64|).(Compare.S.t) :=
  if
    (|Compare.Int64|).(Compare.S.op_gteq) __t_value
      (* ‚ùå Constant of type int64 is converted to int *)
      0 then
    Error_monad.ok __t_value
  else
    Error_monad.__error_value extensible_type_value.

Definition to_seconds {A : Set} (__t_value : A) : A := __t_value.

Definition of_seconds_exn (__t_value : (|Compare.Int64|).(Compare.S.t))
  : (|Compare.Int64|).(Compare.S.t) :=
  match of_seconds __t_value with
  | Pervasives.Ok __t_value =&gt; __t_value
  | _ =&gt; Pervasives.invalid_arg &quot;Period.of_seconds_exn&quot;
  end.

Definition mult (i : (|Compare.Int32|).(Compare.S.t)) (__p_value : int64)
  : Error_monad.tzresult int64 :=
  if
    (|Compare.Int32|).(Compare.S.op_lt) i
      (* ‚ùå Constant of type int32 is converted to int *)
      0 then
    Error_monad.__error_value extensible_type_value
  else
    Error_monad.ok (Int64.mul (Int64.of_int32 i) __p_value).

Definition zero : (|Compare.Int64|).(Compare.S.t) :=
  of_seconds_exn
    (* ‚ùå Constant of type int64 is converted to int *)
    0.

Definition one_second : (|Compare.Int64|).(Compare.S.t) :=
  of_seconds_exn
    (* ‚ùå Constant of type int64 is converted to int *)
    1.

Definition one_minute : (|Compare.Int64|).(Compare.S.t) :=
  of_seconds_exn
    (* ‚ùå Constant of type int64 is converted to int *)
    60.

Definition one_hour : (|Compare.Int64|).(Compare.S.t) :=
  of_seconds_exn
    (* ‚ùå Constant of type int64 is converted to int *)
    3600.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="period_repr.mli">
  <div style="margin: 20px;">
    <h3>Period_repr_mli</h3>
    <ul>
      <li>OCaml size: 55 lines</li>
      <li>Coq size: 59 lines (+7% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#period_repr.mli"><code>period_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t

type period = t

include Compare.S with type t := t

val encoding : period Data_encoding.t

val rpc_arg : period RPC_arg.t

val pp : Format.formatter -&gt; period -&gt; unit

val to_seconds : period -&gt; int64

(** [of_second period] fails if period is not positive *)
val of_seconds : int64 -&gt; period tzresult

(** [of_second period] fails if period is not positive.
    It should only be used at toplevel for constants. *)
val of_seconds_exn : int64 -&gt; period

val mult : int32 -&gt; period -&gt; period tzresult

val zero : period

val one_second : period

val one_minute : period

val one_hour : period
</pre>
  </div>
  <div class="col-md-6">
    <a href="#period_repr.mli"><code>Period_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.

Parameter t : Set.

Definition period : Set := t.

Parameter Included_S : {_ : unit &amp; Compare.S.signature (t := t)}.

Definition op_eq : t -&gt; t -&gt; bool := (|Included_S|).(Compare.S.op_eq).

Definition op_ltgt : t -&gt; t -&gt; bool := (|Included_S|).(Compare.S.op_ltgt).

Definition op_lt : t -&gt; t -&gt; bool := (|Included_S|).(Compare.S.op_lt).

Definition op_lteq : t -&gt; t -&gt; bool := (|Included_S|).(Compare.S.op_lteq).

Definition op_gteq : t -&gt; t -&gt; bool := (|Included_S|).(Compare.S.op_gteq).

Definition op_gt : t -&gt; t -&gt; bool := (|Included_S|).(Compare.S.op_gt).

Definition compare : t -&gt; t -&gt; int := (|Included_S|).(Compare.S.compare).

Definition equal : t -&gt; t -&gt; bool := (|Included_S|).(Compare.S.equal).

Definition max : t -&gt; t -&gt; t := (|Included_S|).(Compare.S.max).

Definition min : t -&gt; t -&gt; t := (|Included_S|).(Compare.S.min).

Parameter encoding : Data_encoding.t period.

Parameter rpc_arg : RPC_arg.t period.

Parameter pp : Format.formatter -&gt; period -&gt; unit.

Parameter to_seconds : period -&gt; int64.

Parameter of_seconds : int64 -&gt; Error_monad.tzresult period.

Parameter of_seconds_exn : int64 -&gt; period.

Parameter mult : int32 -&gt; period -&gt; Error_monad.tzresult period.

Parameter zero : period.

Parameter one_second : period.

Parameter one_minute : period.

Parameter one_hour : period.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="qty_repr.ml">
  <div style="margin: 20px;">
    <h3>Qty_repr</h3>
    <ul>
      <li>OCaml size: 337 lines</li>
      <li>Coq size: 376 lines (+11% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#qty_repr.ml"><code>qty_repr.ml</code></a>&nbsp;<span class="label label-warning">11 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

module type QTY = sig
  val id : string
end

module type S = sig
  type qty

  <abbr class="mark-warning" title="Extensible types are not handled.">type error +=
    | Addition_overflow of qty * qty (* `Temporary *)
    | Subtraction_underflow of qty * qty (* `Temporary *)
    | Multiplication_overflow of qty * int64 (* `Temporary *)
    | Negative_multiplicator of qty * int64 (* `Temporary *)
    | Invalid_divisor of qty * int64</abbr>

  (* `Temporary *)

  val id : string

  val zero : qty

  val one_mutez : qty

  val one_cent : qty

  val fifty_cents : qty

  val one : qty

  val ( -? ) : qty -&gt; qty -&gt; qty tzresult

  val ( +? ) : qty -&gt; qty -&gt; qty tzresult

  val ( *? ) : qty -&gt; int64 -&gt; qty tzresult

  val ( /? ) : qty -&gt; int64 -&gt; qty tzresult

  val to_mutez : qty -&gt; int64

  (** [of_mutez n] (micro tez) is None if n is negative *)
  val of_mutez : int64 -&gt; qty option

  (** [of_mutez_exn n] fails if n is negative.
      It should only be used at toplevel for constants. *)
  val of_mutez_exn : int64 -&gt; qty

  (** It should only be used at toplevel for constants. *)
  val add_exn : qty -&gt; qty -&gt; qty

  (** It should only be used at toplevel for constants. *)
  val mul_exn : qty -&gt; int -&gt; qty

  val qty_encoding : qty Data_encoding.t

  val to_int64 : qty -&gt; int64

  include Compare.S with type t := qty

  val pp : Format.formatter -&gt; qty -&gt; unit

  val of_string : string -&gt; qty option

  val to_string : qty -&gt; string
end

module Make (T : QTY) : S = struct
  type qty = int64 (* invariant: positive *)

  <abbr class="mark-warning" title="Type extension not handled">type error +=
    | Addition_overflow of qty * qty (* `Temporary *)
    | Subtraction_underflow of qty * qty (* `Temporary *)
    | Multiplication_overflow of qty * int64 (* `Temporary *)
    | Negative_multiplicator of qty * int64 (* `Temporary *)
    | Invalid_divisor of qty * int64</abbr>

  (* `Temporary *)

  include Compare.Int64

  let zero = 0L

  (* all other constant are defined from the value of one micro tez *)
  let one_mutez = 1L

  let one_cent = Int64.mul one_mutez 10_000L

  let fifty_cents = Int64.mul one_cent 50L

  (* 1 tez = 100 cents = 1_000_000 mutez *)
  let one = Int64.mul one_cent 100L

  let id = T.id

  let of_string s =
    let triplets = function
      | hd :: tl -&gt;
          let len = String.length hd in
          Compare.Int.(
            len &lt;= 3 &amp;&amp; len &gt; 0
            &amp;&amp; List.for_all (fun s -&gt; String.length s = 3) tl)
      | [] -&gt;
          false
    in
    let integers s = triplets (String.split_on_char ',' s) in
    let decimals s =
      let l = String.split_on_char ',' s in
      if Compare.Int.(List.length l &gt; 2) then false else triplets (List.rev l)
    in
    let parse left right =
      let remove_commas s = String.concat &quot;&quot; (String.split_on_char ',' s) in
      let pad_to_six s =
        let len = String.length s in
        String.init 6 (fun i -&gt; if Compare.Int.(i &lt; len) then s.[i] else '0')
      in
      <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
        Some
          (Int64.of_string
             (remove_commas left ^ pad_to_six (remove_commas right)))
      with _ -&gt; None</abbr>
    in
    match String.split_on_char '.' s with
    | [left; right] -&gt;
        if String.contains s ',' then
          if integers left &amp;&amp; decimals right then parse left right else None
        else if
          Compare.Int.(String.length right &gt; 0)
          &amp;&amp; Compare.Int.(String.length right &lt;= 6)
        then parse left right
        else None
    | [left] -&gt;
        if (not (String.contains s ',')) || integers left then parse left &quot;&quot;
        else None
    | _ -&gt;
        None

  let pp ppf amount =
    let mult_int = 1_000_000L in
    let rec left ppf amount =
      let (d, r) = (Int64.(div amount 1000L), Int64.(rem amount 1000L)) in
      if d &gt; 0L then Format.fprintf ppf &quot;%a%03Ld&quot; left d r
      else Format.fprintf ppf &quot;%Ld&quot; r
    in
    let right ppf amount =
      let triplet ppf v =
        if Compare.Int.(v mod 10 &gt; 0) then Format.fprintf ppf &quot;%03d&quot; v
        else if Compare.Int.(v mod 100 &gt; 0) then
          Format.fprintf ppf &quot;%02d&quot; (v / 10)
        else Format.fprintf ppf &quot;%d&quot; (v / 100)
      in
      let (hi, lo) = (amount / 1000, amount mod 1000) in
      if Compare.Int.(lo = 0) then Format.fprintf ppf &quot;%a&quot; triplet hi
      else Format.fprintf ppf &quot;%03d%a&quot; hi triplet lo
    in
    let (ints, decs) =
      (Int64.(div amount mult_int), Int64.(to_int (rem amount mult_int)))
    in
    <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">Format.fprintf ppf &quot;%a&quot; left ints</abbr> ;
    if Compare.Int.(decs &gt; 0) then Format.fprintf ppf &quot;.%a&quot; right decs

  let to_string t = Format.asprintf &quot;%a&quot; pp t

  let ( - ) t1 t2 = if t2 &lt;= t1 then Some (Int64.sub t1 t2) else None

  let ( -? ) t1 t2 =
    match t1 - t2 with
    | None -&gt;
        error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Subtraction_underflow (t1, t2))</abbr>
    | Some v -&gt;
        ok v

  let ( +? ) t1 t2 =
    let t = Int64.add t1 t2 in
    if t &lt; t1 then error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Addition_overflow (t1, t2))</abbr> else ok t

  let ( *? ) t m =
    let open Compare.Int64 in
    let open Int64 in
    let rec step cur pow acc =
      if cur = 0L then ok acc
      else
        pow +? pow
        &gt;&gt;? fun npow -&gt;
        if logand cur 1L = 1L then
          acc +? pow &gt;&gt;? fun nacc -&gt; step (shift_right_logical cur 1) npow nacc
        else step (shift_right_logical cur 1) npow acc
    in
    if m &lt; 0L then error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Negative_multiplicator (t, m))</abbr>
    else
      match step m t 0L with
      | Ok res -&gt;
          Ok res
      | Error ([<abbr class="mark-warning" title="Patterns of extensible types are not handled">Addition_overflow _</abbr>] as errs) -&gt;
          Error (<abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Multiplication_overflow (t, m)</abbr> :: errs)
      | Error errs -&gt;
          Error errs

  let ( /? ) t d =
    if d &lt;= 0L then error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_divisor (t, d))</abbr> else ok (Int64.div t d)

  let add_exn t1 t2 =
    let t = Int64.add t1 t2 in
    if t &lt;= 0L then invalid_arg &quot;add_exn&quot; else t

  let mul_exn t m =
    match t *? Int64.(of_int m) with
    | Ok v -&gt;
        v
    | Error _ -&gt;
        invalid_arg &quot;mul_exn&quot;

  let of_mutez t = if t &lt; 0L then None else Some t

  let of_mutez_exn x =
    match of_mutez x with None -&gt; invalid_arg &quot;Qty.of_mutez&quot; | Some v -&gt; v

  let to_int64 t = t

  let to_mutez t = t

  let qty_encoding =
    let open Data_encoding in
    check_size 10 (conv Z.of_int64 (Json.wrap_error Z.to_int64) n)

  <abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
    let open Data_encoding in
    register_error_kind
      `Temporary
      ~id:(T.id ^ &quot;.addition_overflow&quot;)
      ~title:(&quot;Overflowing &quot; ^ T.id ^ &quot; addition&quot;)
      ~pp:(fun ppf (opa, opb) -&gt;
        Format.fprintf
          ppf
          &quot;Overflowing addition of %a %s and %a %s&quot;
          pp
          opa
          T.id
          pp
          opb
          T.id)
      ~description:(&quot;An addition of two &quot; ^ T.id ^ &quot; amounts overflowed&quot;)
      (obj1 (req &quot;amounts&quot; (tup2 qty_encoding qty_encoding)))
      (function Addition_overflow (a, b) -&gt; Some (a, b) | _ -&gt; None)
      (fun (a, b) -&gt; Addition_overflow (a, b)) ;
    register_error_kind
      `Temporary
      ~id:(T.id ^ &quot;.subtraction_underflow&quot;)
      ~title:(&quot;Underflowing &quot; ^ T.id ^ &quot; subtraction&quot;)
      ~pp:(fun ppf (opa, opb) -&gt;
        Format.fprintf
          ppf
          &quot;Underflowing subtraction of %a %s and %a %s&quot;
          pp
          opa
          T.id
          pp
          opb
          T.id)
      ~description:(&quot;An subtraction of two &quot; ^ T.id ^ &quot; amounts underflowed&quot;)
      (obj1 (req &quot;amounts&quot; (tup2 qty_encoding qty_encoding)))
      (function Subtraction_underflow (a, b) -&gt; Some (a, b) | _ -&gt; None)
      (fun (a, b) -&gt; Subtraction_underflow (a, b)) ;
    register_error_kind
      `Temporary
      ~id:(T.id ^ &quot;.multiplication_overflow&quot;)
      ~title:(&quot;Overflowing &quot; ^ T.id ^ &quot; multiplication&quot;)
      ~pp:(fun ppf (opa, opb) -&gt;
        Format.fprintf
          ppf
          &quot;Overflowing multiplication of %a %s and %Ld&quot;
          pp
          opa
          T.id
          opb)
      ~description:
        (&quot;A multiplication of a &quot; ^ T.id ^ &quot; amount by an integer overflowed&quot;)
      (obj2 (req &quot;amount&quot; qty_encoding) (req &quot;multiplicator&quot; int64))
      (function Multiplication_overflow (a, b) -&gt; Some (a, b) | _ -&gt; None)
      (fun (a, b) -&gt; Multiplication_overflow (a, b)) ;
    register_error_kind
      `Temporary
      ~id:(T.id ^ &quot;.negative_multiplicator&quot;)
      ~title:(&quot;Negative &quot; ^ T.id ^ &quot; multiplicator&quot;)
      ~pp:(fun ppf (opa, opb) -&gt;
        Format.fprintf
          ppf
          &quot;Multiplication of %a %s by negative integer %Ld&quot;
          pp
          opa
          T.id
          opb)
      ~description:
        (&quot;Multiplication of a &quot; ^ T.id ^ &quot; amount by a negative integer&quot;)
      (obj2 (req &quot;amount&quot; qty_encoding) (req &quot;multiplicator&quot; int64))
      (function Negative_multiplicator (a, b) -&gt; Some (a, b) | _ -&gt; None)
      (fun (a, b) -&gt; Negative_multiplicator (a, b)) ;
    register_error_kind
      `Temporary
      ~id:(T.id ^ &quot;.invalid_divisor&quot;)
      ~title:(&quot;Invalid &quot; ^ T.id ^ &quot; divisor&quot;)
      ~pp:(fun ppf (opa, opb) -&gt;
        Format.fprintf
          ppf
          &quot;Division of %a %s by non positive integer %Ld&quot;
          pp
          opa
          T.id
          opb)
      ~description:
        (&quot;Multiplication of a &quot; ^ T.id ^ &quot; amount by a non positive integer&quot;)
      (obj2 (req &quot;amount&quot; qty_encoding) (req &quot;divisor&quot; int64))
      (function Invalid_divisor (a, b) -&gt; Some (a, b) | _ -&gt; None)
      (fun (a, b) -&gt; Invalid_divisor (a, b))</abbr>
end
</pre>
  </div>
  <div class="col-md-6">
    <a href="#qty_repr.ml"><code>Qty_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.

Module QTY.
  Record signature : Set := {
    id : string;
  }.
End QTY.

Module S.
  Record signature {qty : Set} : Set := {
    qty := qty;
    (* extensible_type error *)
    id : string;
    zero : qty;
    one_mutez : qty;
    one_cent : qty;
    fifty_cents : qty;
    one : qty;
    op_minusquestion : qty -&gt; qty -&gt; Error_monad.tzresult qty;
    op_plusquestion : qty -&gt; qty -&gt; Error_monad.tzresult qty;
    op_starquestion : qty -&gt; int64 -&gt; Error_monad.tzresult qty;
    op_divquestion : qty -&gt; int64 -&gt; Error_monad.tzresult qty;
    to_mutez : qty -&gt; int64;
    of_mutez : int64 -&gt; option qty;
    of_mutez_exn : int64 -&gt; qty;
    add_exn : qty -&gt; qty -&gt; qty;
    mul_exn : qty -&gt; int -&gt; qty;
    qty_encoding : Data_encoding.t qty;
    to_int64 : qty -&gt; int64;
    op_eq : qty -&gt; qty -&gt; bool;
    op_ltgt : qty -&gt; qty -&gt; bool;
    op_lt : qty -&gt; qty -&gt; bool;
    op_lteq : qty -&gt; qty -&gt; bool;
    op_gteq : qty -&gt; qty -&gt; bool;
    op_gt : qty -&gt; qty -&gt; bool;
    compare : qty -&gt; qty -&gt; int;
    equal : qty -&gt; qty -&gt; bool;
    max : qty -&gt; qty -&gt; qty;
    min : qty -&gt; qty -&gt; qty;
    pp : Format.formatter -&gt; qty -&gt; unit;
    of_string : string -&gt; option qty;
    to_string : qty -&gt; string;
  }.
End S.

Definition Make :=
  fun (T : {_ : unit &amp; QTY.signature}) =&gt;
    ((let qty : Set := int64 in
    (* ‚ùå type_extension *)
    let t := (|Compare.Int64|).(Compare.S.t) in
    let op_eq := (|Compare.Int64|).(Compare.S.op_eq) in
    let op_ltgt := (|Compare.Int64|).(Compare.S.op_ltgt) in
    let op_lt := (|Compare.Int64|).(Compare.S.op_lt) in
    let op_lteq := (|Compare.Int64|).(Compare.S.op_lteq) in
    let op_gteq := (|Compare.Int64|).(Compare.S.op_gteq) in
    let op_gt := (|Compare.Int64|).(Compare.S.op_gt) in
    let compare := (|Compare.Int64|).(Compare.S.compare) in
    let equal := (|Compare.Int64|).(Compare.S.equal) in
    let max := (|Compare.Int64|).(Compare.S.max) in
    let min := (|Compare.Int64|).(Compare.S.min) in
    let zero :=
      (* ‚ùå Constant of type int64 is converted to int *)
      0 in
    let one_mutez :=
      (* ‚ùå Constant of type int64 is converted to int *)
      1 in
    let one_cent :=
      Int64.mul one_mutez
        (* ‚ùå Constant of type int64 is converted to int *)
        10000 in
    let fifty_cents :=
      Int64.mul one_cent
        (* ‚ùå Constant of type int64 is converted to int *)
        50 in
    let one :=
      Int64.mul one_cent
        (* ‚ùå Constant of type int64 is converted to int *)
        100 in
    let id := (|T|).(QTY.id) in
    let of_string (s : string) : option int64 :=
      let triplets (function_parameter : list string) : bool :=
        match function_parameter with
        | cons hd tl =&gt;
          let len := String.length hd in
          Pervasives.op_andand ((|Compare.Int|).(Compare.S.op_lteq) len 3)
            (Pervasives.op_andand ((|Compare.Int|).(Compare.S.op_gt) len 0)
              (List.for_all
                (fun s =&gt; (|Compare.Int|).(Compare.S.op_eq) (String.length s) 3)
                tl))
        | [] =&gt; false
        end in
      let integers (s : string) : bool :=
        triplets (String.split_on_char &quot;,&quot; % char s) in
      let decimals (s : string) : bool :=
        let l := String.split_on_char &quot;,&quot; % char s in
        if (|Compare.Int|).(Compare.S.op_gt) (List.length l) 2 then
          false
        else
          triplets (List.rev l) in
      let parse (__left : string) (__right : string) : option int64 :=
        let remove_commas (s : string) : string :=
          String.concat &quot;&quot; (String.split_on_char &quot;,&quot; % char s) in
        let pad_to_six (s : string) : string :=
          let len := String.length s in
          String.init 6
            (fun i =&gt;
              if (|Compare.Int|).(Compare.S.op_lt) i len then
                String.get s i
              else
                &quot;0&quot; % char) in
        (* ‚ùå Try-with are not handled *)
        try
          (Some
            (Int64.of_string
              (Pervasives.op_caret (remove_commas __left)
                (pad_to_six (remove_commas __right))))) in
      match String.split_on_char &quot;.&quot; % char s with
      | cons __left (cons __right []) =&gt;
        if String.contains s &quot;,&quot; % char then
          if Pervasives.op_andand (integers __left) (decimals __right) then
            parse __left __right
          else
            None
        else
          if
            Pervasives.op_andand
              ((|Compare.Int|).(Compare.S.op_gt) (String.length __right) 0)
              ((|Compare.Int|).(Compare.S.op_lteq) (String.length __right) 6)
            then
            parse __left __right
          else
            None
      | cons __left [] =&gt;
        if
          Pervasives.op_pipepipe (Pervasives.not (String.contains s &quot;,&quot; % char))
            (integers __left) then
          parse __left &quot;&quot;
        else
          None
      | _ =&gt; None
      end in
    let pp (ppf : Format.formatter) (amount : int64) : unit :=
      let mult_int :=
        (* ‚ùå Constant of type int64 is converted to int *)
        1000000 in
      let fix __left (ppf : Format.formatter) (amount : int64) {struct ppf}
        : unit :=
        let '(d, __r_value) :=
          ((Int64.div amount
            (* ‚ùå Constant of type int64 is converted to int *)
            1000),
            (Int64.rem amount
              (* ‚ùå Constant of type int64 is converted to int *)
              1000)) in
        if
          op_gt d
            (* ‚ùå Constant of type int64 is converted to int *)
            0 then
          Format.fprintf ppf
            (CamlinternalFormatBasics.Format
              (CamlinternalFormatBasics.Alpha
                (CamlinternalFormatBasics.Int64 CamlinternalFormatBasics.Int_d
                  (CamlinternalFormatBasics.Lit_padding
                    CamlinternalFormatBasics.Zeros 3)
                  CamlinternalFormatBasics.No_precision
                  CamlinternalFormatBasics.End_of_format)) &quot;%a%03Ld&quot;) __left d
            __r_value
        else
          Format.fprintf ppf
            (CamlinternalFormatBasics.Format
              (CamlinternalFormatBasics.Int64 CamlinternalFormatBasics.Int_d
                CamlinternalFormatBasics.No_padding
                CamlinternalFormatBasics.No_precision
                CamlinternalFormatBasics.End_of_format) &quot;%Ld&quot;) __r_value in
      let __right (ppf : Format.formatter) (amount : int) : unit :=
        let triplet (ppf : Format.formatter) (v : int) : unit :=
          if (|Compare.Int|).(Compare.S.op_gt) (Pervasives.__mod v 10) 0 then
            Format.fprintf ppf
              (CamlinternalFormatBasics.Format
                (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_d
                  (CamlinternalFormatBasics.Lit_padding
                    CamlinternalFormatBasics.Zeros 3)
                  CamlinternalFormatBasics.No_precision
                  CamlinternalFormatBasics.End_of_format) &quot;%03d&quot;) v
          else
            if (|Compare.Int|).(Compare.S.op_gt) (Pervasives.__mod v 100) 0 then
              Format.fprintf ppf
                (CamlinternalFormatBasics.Format
                  (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_d
                    (CamlinternalFormatBasics.Lit_padding
                      CamlinternalFormatBasics.Zeros 2)
                    CamlinternalFormatBasics.No_precision
                    CamlinternalFormatBasics.End_of_format) &quot;%02d&quot;)
                (Pervasives.op_div v 10)
            else
              Format.fprintf ppf
                (CamlinternalFormatBasics.Format
                  (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_d
                    CamlinternalFormatBasics.No_padding
                    CamlinternalFormatBasics.No_precision
                    CamlinternalFormatBasics.End_of_format) &quot;%d&quot;)
                (Pervasives.op_div v 100) in
        let '(hi, lo) :=
          ((Pervasives.op_div amount 1000), (Pervasives.__mod amount 1000)) in
        if (|Compare.Int|).(Compare.S.op_eq) lo 0 then
          Format.fprintf ppf
            (CamlinternalFormatBasics.Format
              (CamlinternalFormatBasics.Alpha
                CamlinternalFormatBasics.End_of_format) &quot;%a&quot;) triplet hi
        else
          Format.fprintf ppf
            (CamlinternalFormatBasics.Format
              (CamlinternalFormatBasics.Int CamlinternalFormatBasics.Int_d
                (CamlinternalFormatBasics.Lit_padding
                  CamlinternalFormatBasics.Zeros 3)
                CamlinternalFormatBasics.No_precision
                (CamlinternalFormatBasics.Alpha
                  CamlinternalFormatBasics.End_of_format)) &quot;%03d%a&quot;) hi triplet
            lo in
      let '(ints, decs) :=
        ((Int64.div amount mult_int), (Int64.to_int (Int64.rem amount mult_int)))
        in
      (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
      (* ‚ùå instruction_sequence &quot;;&quot; *)
      if (|Compare.Int|).(Compare.S.op_gt) decs 0 then
        Format.fprintf ppf
          (CamlinternalFormatBasics.Format
            (CamlinternalFormatBasics.Char_literal &quot;.&quot; % char
              (CamlinternalFormatBasics.Alpha
                CamlinternalFormatBasics.End_of_format)) &quot;.%a&quot;) __right decs
      else
        tt in
    let to_string (__t_value : int64) : string :=
      Format.asprintf
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Alpha CamlinternalFormatBasics.End_of_format)
          &quot;%a&quot;) pp __t_value in
    let op_minus (t1 : t) (t2 : t) : option int64 :=
      if op_lteq t2 t1 then
        Some (Int64.sub t1 t2)
      else
        None in
    let op_minusquestion (t1 : t) (t2 : t) : Error_monad.tzresult int64 :=
      match op_minus t1 t2 with
      | None =&gt; Error_monad.__error_value extensible_type_value
      | Some v =&gt; Error_monad.ok v
      end in
    let op_plusquestion (t1 : t) (t2 : qty) : Error_monad.tzresult int64 :=
      let __t_value := Int64.add t1 t2 in
      if op_lt __t_value t1 then
        Error_monad.__error_value extensible_type_value
      else
        Error_monad.ok __t_value in
    let op_starquestion (__t_value : qty) (m : (|Compare.Int64|).(Compare.S.t))
      : Error_monad.tzresult t :=
      let fix step (cur : (|Compare.Int64|).(Compare.S.t)) (pow : t) (acc : t)
        {struct cur} : Error_monad.tzresult t :=
        if
          (|Compare.Int64|).(Compare.S.op_eq) cur
            (* ‚ùå Constant of type int64 is converted to int *)
            0 then
          Error_monad.ok acc
        else
          let? npow := op_plusquestion pow pow in
          if
            (|Compare.Int64|).(Compare.S.op_eq)
              (Int64.logand cur
                (* ‚ùå Constant of type int64 is converted to int *)
                1)
              (* ‚ùå Constant of type int64 is converted to int *)
              1 then
            let? nacc := op_plusquestion acc pow in
            step (Int64.shift_right_logical cur 1) npow nacc
          else
            step (Int64.shift_right_logical cur 1) npow acc in
      if
        (|Compare.Int64|).(Compare.S.op_lt) m
          (* ‚ùå Constant of type int64 is converted to int *)
          0 then
        Error_monad.__error_value extensible_type_value
      else
        match
          step m __t_value
            (* ‚ùå Constant of type int64 is converted to int *)
            0 with
        | Pervasives.Ok res =&gt; Pervasives.Ok res
        | Pervasives.Error errs =&gt; Pervasives.Error errs
        end in
    let op_divquestion (__t_value : qty) (d : t) : Error_monad.tzresult int64 :=
      if
        op_lteq d
          (* ‚ùå Constant of type int64 is converted to int *)
          0 then
        Error_monad.__error_value extensible_type_value
      else
        Error_monad.ok (Int64.div __t_value d) in
    let add_exn (t1 : int64) (t2 : int64) : int64 :=
      let __t_value := Int64.add t1 t2 in
      if
        op_lteq __t_value
          (* ‚ùå Constant of type int64 is converted to int *)
          0 then
        Pervasives.invalid_arg &quot;add_exn&quot;
      else
        __t_value in
    let mul_exn (__t_value : qty) (m : int) : t :=
      match op_starquestion __t_value (Int64.of_int m) with
      | Pervasives.Ok v =&gt; v
      | Pervasives.Error _ =&gt; Pervasives.invalid_arg &quot;mul_exn&quot;
      end in
    let of_mutez (__t_value : t) : option t :=
      if
        op_lt __t_value
          (* ‚ùå Constant of type int64 is converted to int *)
          0 then
        None
      else
        Some __t_value in
    let of_mutez_exn (x : t) : t :=
      match of_mutez x with
      | None =&gt; Pervasives.invalid_arg &quot;Qty.of_mutez&quot;
      | Some v =&gt; v
      end in
    let to_int64 {A : Set} (__t_value : A) : A :=
      __t_value in
    let to_mutez {A : Set} (__t_value : A) : A :=
      __t_value in
    let qty_encoding :=
      Data_encoding.check_size 10
        (Data_encoding.conv Z.of_int64
          (Data_encoding.Json.wrap_error Z.to_int64) None Data_encoding.n) in
    (* ‚ùå top_level_evaluation *)
    existT (A := Set) _ _
      {|
        S.id := id;
        S.zero := zero;
        S.one_mutez := one_mutez;
        S.one_cent := one_cent;
        S.fifty_cents := fifty_cents;
        S.one := one;
        S.op_minusquestion := op_minusquestion;
        S.op_plusquestion := op_plusquestion;
        S.op_starquestion := op_starquestion;
        S.op_divquestion := op_divquestion;
        S.to_mutez := to_mutez;
        S.of_mutez := of_mutez;
        S.of_mutez_exn := of_mutez_exn;
        S.add_exn := add_exn;
        S.mul_exn := mul_exn;
        S.qty_encoding := qty_encoding;
        S.to_int64 := to_int64;
        S.op_eq := op_eq;
        S.op_ltgt := op_ltgt;
        S.op_lt := op_lt;
        S.op_lteq := op_lteq;
        S.op_gteq := op_gteq;
        S.op_gt := op_gt;
        S.compare := compare;
        S.equal := equal;
        S.max := max;
        S.min := min;
        S.pp := pp;
        S.of_string := of_string;
        S.to_string := to_string
      |}) : {qty : Set &amp; S.signature (qty := qty)}).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="raw_context.ml">
  <div style="margin: 20px;">
    <h3>Raw_context</h3>
    <ul>
      <li>OCaml size: 754 lines</li>
      <li>Coq size: 946 lines (+25% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#raw_context.ml"><code>raw_context.ml</code></a>&nbsp;<span class="label label-warning">42 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

module Int_set = Set.Make (Compare.Int)

type t = {
  context : Context.t;
  constants : Constants_repr.parametric;
  first_level : Raw_level_repr.t;
  level : Level_repr.t;
  predecessor_timestamp : Time.t;
  timestamp : Time.t;
  fitness : Int64.t;
  deposits : Tez_repr.t Signature.Public_key_hash.Map.t;
  included_endorsements : int;
  allowed_endorsements :
    (Signature.Public_key.t * int list * bool) Signature.Public_key_hash.Map.t;
  fees : Tez_repr.t;
  rewards : Tez_repr.t;
  block_gas : Z.t;
  operation_gas : Gas_limit_repr.t;
  internal_gas : Gas_limit_repr.internal_gas;
  storage_space_to_pay : Z.t option;
  allocated_contracts : int option;
  origination_nonce : Contract_repr.origination_nonce option;
  temporary_big_map : Z.t;
  internal_nonce : int;
  internal_nonces_used : Int_set.t;
}

type context = t

type root_context = t

let current_level ctxt = ctxt.level

let predecessor_timestamp ctxt = ctxt.predecessor_timestamp

let current_timestamp ctxt = ctxt.timestamp

let current_fitness ctxt = ctxt.fitness

let first_level ctxt = ctxt.first_level

let constants ctxt = ctxt.constants

let recover ctxt = ctxt.context

let record_endorsement ctxt k =
  match Signature.Public_key_hash.Map.find_opt k ctxt.allowed_endorsements with
  | None -&gt;
      <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
  | Some (_, _, true) -&gt;
      <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr> (* right already used *)
  | Some (d, s, false) -&gt;
      {
        ctxt with
        included_endorsements = ctxt.included_endorsements + List.length s;
        allowed_endorsements =
          Signature.Public_key_hash.Map.add
            k
            (d, s, true)
            ctxt.allowed_endorsements;
      }

let init_endorsements ctxt allowed_endorsements =
  if Signature.Public_key_hash.Map.is_empty allowed_endorsements then
    <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr> (* can't initialize to empty *)
  else if Signature.Public_key_hash.Map.is_empty ctxt.allowed_endorsements then
    {ctxt with allowed_endorsements}
  else <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>

(* can't initialize twice *)

let allowed_endorsements ctxt = ctxt.allowed_endorsements

let included_endorsements ctxt = ctxt.included_endorsements

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Too_many_internal_operations</abbr> (* `Permanent *)

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  let open Data_encoding in
  register_error_kind
    `Permanent
    ~id:&quot;too_many_internal_operations&quot;
    ~title:&quot;Too many internal operations&quot;
    ~description:
      &quot;A transaction exceeded the hard limit of internal operations it can emit&quot;
    empty
    (function Too_many_internal_operations -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Too_many_internal_operations)</abbr>

let fresh_internal_nonce ctxt =
  if Compare.Int.(ctxt.internal_nonce &gt;= 65_535) then
    error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Too_many_internal_operations</abbr>
  else
    ok
      ( {ctxt with internal_nonce = ctxt.internal_nonce + 1},
        ctxt.internal_nonce )

let reset_internal_nonce ctxt =
  {ctxt with internal_nonces_used = Int_set.empty; internal_nonce = 0}

let record_internal_nonce ctxt k =
  {ctxt with internal_nonces_used = Int_set.add k ctxt.internal_nonces_used}

let internal_nonce_already_recorded ctxt k =
  Int_set.mem k ctxt.internal_nonces_used

let set_current_fitness ctxt fitness = {ctxt with fitness}

let add_fees ctxt fees =
  Lwt.return Tez_repr.(ctxt.fees +? fees)
  &gt;&gt;=? fun fees -&gt; return {ctxt with fees}

let add_rewards ctxt rewards =
  Lwt.return Tez_repr.(ctxt.rewards +? rewards)
  &gt;&gt;=? fun rewards -&gt; return {ctxt with rewards}

let add_deposit ctxt delegate deposit =
  let previous =
    match Signature.Public_key_hash.Map.find_opt delegate ctxt.deposits with
    | Some tz -&gt;
        tz
    | None -&gt;
        Tez_repr.zero
  in
  Lwt.return Tez_repr.(previous +? deposit)
  &gt;&gt;=? fun deposit -&gt;
  let deposits =
    Signature.Public_key_hash.Map.add delegate deposit ctxt.deposits
  in
  return {ctxt with deposits}

let get_deposits ctxt = ctxt.deposits

let get_rewards ctxt = ctxt.rewards

let get_fees ctxt = ctxt.fees

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Undefined_operation_nonce</abbr> (* `Permanent *)

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  let open Data_encoding in
  register_error_kind
    `Permanent
    ~id:&quot;undefined_operation_nonce&quot;
    ~title:&quot;Ill timed access to the origination nonce&quot;
    ~description:
      &quot;An origination was attemped out of the scope of a manager operation&quot;
    empty
    (function Undefined_operation_nonce -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Undefined_operation_nonce)</abbr>

let init_origination_nonce ctxt operation_hash =
  let origination_nonce =
    Some (Contract_repr.initial_origination_nonce operation_hash)
  in
  {ctxt with origination_nonce}

let origination_nonce ctxt =
  match ctxt.origination_nonce with
  | None -&gt;
      error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Undefined_operation_nonce</abbr>
  | Some origination_nonce -&gt;
      ok origination_nonce

let increment_origination_nonce ctxt =
  match ctxt.origination_nonce with
  | None -&gt;
      error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Undefined_operation_nonce</abbr>
  | Some cur_origination_nonce -&gt;
      let origination_nonce =
        Some (Contract_repr.incr_origination_nonce cur_origination_nonce)
      in
      ok ({ctxt with origination_nonce}, cur_origination_nonce)

let unset_origination_nonce ctxt = {ctxt with origination_nonce = None}

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Gas_limit_too_high</abbr> (* `Permanent *)

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  let open Data_encoding in
  register_error_kind
    `Permanent
    ~id:&quot;gas_limit_too_high&quot;
    ~title:&quot;Gas limit out of protocol hard bounds&quot;
    ~description:&quot;A transaction tried to exceed the hard limit on gas&quot;
    empty
    (function Gas_limit_too_high -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Gas_limit_too_high)</abbr>

let check_gas_limit ctxt remaining =
  if
    Compare.Z.(remaining &gt; ctxt.constants.hard_gas_limit_per_operation)
    || Compare.Z.(remaining &lt; Z.zero)
  then error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Gas_limit_too_high</abbr>
  else ok ()

let set_gas_limit ctxt remaining =
  {
    ctxt with
    operation_gas = Limited {remaining};
    internal_gas = Gas_limit_repr.internal_gas_zero;
  }

let set_gas_unlimited ctxt = {ctxt with operation_gas = Unaccounted}

let consume_gas ctxt cost =
  Gas_limit_repr.consume_raw
    ctxt.block_gas
    ctxt.operation_gas
    ctxt.internal_gas
    cost
  &gt;&gt;? fun (block_gas, operation_gas, internal_gas) -&gt;
  ok {ctxt with block_gas; operation_gas; internal_gas}

let check_enough_gas ctxt cost =
  Gas_limit_repr.check_enough_raw
    ctxt.block_gas
    ctxt.operation_gas
    ctxt.internal_gas
    cost

let gas_level ctxt = ctxt.operation_gas

let block_gas_level ctxt = ctxt.block_gas

let gas_consumed ~since ~until =
  match (gas_level since, gas_level until) with
  | (Limited {remaining = before}, Limited {remaining = after}) -&gt;
      Z.sub before after
  | (_, _) -&gt;
      Z.zero

let init_storage_space_to_pay ctxt =
  match ctxt.storage_space_to_pay with
  | Some _ -&gt;
      <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
  | None -&gt;
      {
        ctxt with
        storage_space_to_pay = Some Z.zero;
        allocated_contracts = Some 0;
      }

let update_storage_space_to_pay ctxt n =
  match ctxt.storage_space_to_pay with
  | None -&gt;
      <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
  | Some storage_space_to_pay -&gt;
      {ctxt with storage_space_to_pay = Some (Z.add n storage_space_to_pay)}

let update_allocated_contracts_count ctxt =
  match ctxt.allocated_contracts with
  | None -&gt;
      <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
  | Some allocated_contracts -&gt;
      {ctxt with allocated_contracts = Some (succ allocated_contracts)}

let clear_storage_space_to_pay ctxt =
  match (ctxt.storage_space_to_pay, ctxt.allocated_contracts) with
  | (None, _) | (_, None) -&gt;
      <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
  | (Some storage_space_to_pay, Some allocated_contracts) -&gt;
      ( {ctxt with storage_space_to_pay = None; allocated_contracts = None},
        storage_space_to_pay,
        allocated_contracts )

<abbr class="mark-warning" title="Polymorphic variant types are defined as standard algebraic types">type missing_key_kind = [`Get | `Set | `Del | `Copy]</abbr>

type storage_error =
  | Incompatible_protocol_version of string
  | Missing_key of string list * missing_key_kind
  | Existing_key of string list
  | Corrupted_data of string list

let storage_error_encoding =
  let open Data_encoding in
  union
    [ case
        (Tag 0)
        ~title:&quot;Incompatible_protocol_version&quot;
        (obj1 (req &quot;incompatible_protocol_version&quot; string))
        (function Incompatible_protocol_version arg -&gt; Some arg | _ -&gt; None)
        (fun arg -&gt; Incompatible_protocol_version arg);
      case
        (Tag 1)
        ~title:&quot;Missing_key&quot;
        (obj2
           (req &quot;missing_key&quot; (list string))
           (req
              &quot;function&quot;
              (string_enum
                 [(&quot;get&quot;, <abbr class="mark-warning" title="Constructor of the variant `Get unknown">`Get</abbr>); (&quot;set&quot;, <abbr class="mark-warning" title="Constructor of the variant `Set unknown">`Set</abbr>); (&quot;del&quot;, <abbr class="mark-warning" title="Constructor of the variant `Del unknown">`Del</abbr>); (&quot;copy&quot;, <abbr class="mark-warning" title="Constructor of the variant `Copy unknown">`Copy</abbr>)])))
        (function <abbr class="mark-warning" title="No type known for the following variants: `Get, `Set, `Del, `Copy">Missing_key (key, f)</abbr> -&gt; Some (key, f) | <abbr class="mark-warning" title="No type known for the following variants: `Get, `Set, `Del, `Copy">_</abbr> -&gt; None)
        (fun (key, f) -&gt; Missing_key (key, f));
      case
        (Tag 2)
        ~title:&quot;Existing_key&quot;
        (obj1 (req &quot;existing_key&quot; (list string)))
        (function Existing_key key -&gt; Some key | _ -&gt; None)
        (fun key -&gt; Existing_key key);
      case
        (Tag 3)
        ~title:&quot;Corrupted_data&quot;
        (obj1 (req &quot;corrupted_data&quot; (list string)))
        (function Corrupted_data key -&gt; Some key | _ -&gt; None)
        (fun key -&gt; Corrupted_data key) ]

let pp_storage_error ppf = function
  | Incompatible_protocol_version version -&gt;
      Format.fprintf
        ppf
        &quot;Found a context with an unexpected version '%s'.&quot;
        version
  | Missing_key (key, <abbr class="mark-warning" title="Constructor of the variant `Get unknown">`Get</abbr>) -&gt;
      Format.fprintf ppf &quot;Missing key '%s'.&quot; (String.concat &quot;/&quot; key)
  | Missing_key (key, <abbr class="mark-warning" title="Constructor of the variant `Set unknown">`Set</abbr>) -&gt;
      Format.fprintf
        ppf
        &quot;Cannot set undefined key '%s'.&quot;
        (String.concat &quot;/&quot; key)
  | Missing_key (key, <abbr class="mark-warning" title="Constructor of the variant `Del unknown">`Del</abbr>) -&gt;
      Format.fprintf
        ppf
        &quot;Cannot delete undefined key '%s'.&quot;
        (String.concat &quot;/&quot; key)
  | Missing_key (key, <abbr class="mark-warning" title="Constructor of the variant `Copy unknown">`Copy</abbr>) -&gt;
      Format.fprintf
        ppf
        &quot;Cannot copy undefined key '%s'.&quot;
        (String.concat &quot;/&quot; key)
  | Existing_key key -&gt;
      Format.fprintf
        ppf
        &quot;Cannot initialize defined key '%s'.&quot;
        (String.concat &quot;/&quot; key)
  | Corrupted_data key -&gt;
      Format.fprintf
        ppf
        &quot;Failed to parse the data at '%s'.&quot;
        (String.concat &quot;/&quot; key)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Storage_error of storage_error</abbr>

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  register_error_kind
    `Permanent
    ~id:&quot;context.storage_error&quot;
    ~title:&quot;Storage error (fatal internal error)&quot;
    ~description:
      &quot;An error that should never happen unless something has been deleted or \
       corrupted in the database.&quot;
    ~pp:(fun ppf err -&gt;
      Format.fprintf ppf &quot;@[&lt;v 2&gt;Storage error:@ %a@]&quot; pp_storage_error err)
    storage_error_encoding
    (function Storage_error err -&gt; Some err | _ -&gt; None)
    (fun err -&gt; Storage_error err)</abbr>

let storage_error err = fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Storage_error err)</abbr>

(* Initialization *********************************************************)

(* This key should always be populated for every version of the
   protocol.  It's absence meaning that the context is empty. *)
let version_key = [&quot;version&quot;]

let version_value = &quot;alpha_current&quot;

let version = &quot;v1&quot;

let first_level_key = [version; &quot;first_level&quot;]

let constants_key = [version; &quot;constants&quot;]

let protocol_param_key = [&quot;protocol_parameters&quot;]

let get_first_level ctxt =
  Context.get ctxt first_level_key
  &gt;&gt;= function
  | None -&gt;
      storage_error (Missing_key (first_level_key, <abbr class="mark-warning" title="Constructor of the variant `Get unknown">`Get</abbr>))
  | Some bytes -&gt; (
    match Data_encoding.Binary.of_bytes Raw_level_repr.encoding bytes with
    | None -&gt;
        storage_error (Corrupted_data first_level_key)
    | Some level -&gt;
        return level )

let set_first_level ctxt level =
  let bytes =
    Data_encoding.Binary.to_bytes_exn Raw_level_repr.encoding level
  in
  Context.set ctxt first_level_key bytes &gt;&gt;= fun ctxt -&gt; return ctxt

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Failed_to_parse_parameter of MBytes.t</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Failed_to_decode_parameter of Data_encoding.json * string</abbr>

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  register_error_kind
    `Temporary
    ~id:&quot;context.failed_to_parse_parameter&quot;
    ~title:&quot;Failed to parse parameter&quot;
    ~description:&quot;The protocol parameters are not valid JSON.&quot;
    ~pp:(fun ppf bytes -&gt;
      Format.fprintf
        ppf
        &quot;@[&lt;v 2&gt;Cannot parse the protocol parameter:@ %s@]&quot;
        (MBytes.to_string bytes))
    Data_encoding.(obj1 (req &quot;contents&quot; bytes))
    (function Failed_to_parse_parameter data -&gt; Some data | _ -&gt; None)
    (fun data -&gt; Failed_to_parse_parameter data) ;
  register_error_kind
    `Temporary
    ~id:&quot;context.failed_to_decode_parameter&quot;
    ~title:&quot;Failed to decode parameter&quot;
    ~description:&quot;Unexpected JSON object.&quot;
    ~pp:(fun ppf (json, msg) -&gt;
      Format.fprintf
        ppf
        &quot;@[&lt;v 2&gt;Cannot decode the protocol parameter:@ %s@ %a@]&quot;
        msg
        Data_encoding.Json.pp
        json)
    Data_encoding.(obj2 (req &quot;contents&quot; json) (req &quot;error&quot; string))
    (function
      | Failed_to_decode_parameter (json, msg) -&gt; Some (json, msg) | _ -&gt; None)
    (fun (json, msg) -&gt; Failed_to_decode_parameter (json, msg))</abbr>

let get_proto_param ctxt =
  Context.get ctxt protocol_param_key
  &gt;&gt;= function
  | None -&gt;
      failwith &quot;Missing protocol parameters.&quot;
  | Some bytes -&gt; (
    match Data_encoding.Binary.of_bytes Data_encoding.json bytes with
    | None -&gt;
        fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Failed_to_parse_parameter bytes)</abbr>
    | Some json -&gt; (
        Context.del ctxt protocol_param_key
        &gt;&gt;= fun ctxt -&gt;
        match Data_encoding.Json.destruct Parameters_repr.encoding json with
        | exception <abbr class="mark-warning" title="We do not support pattern-matching on exceptions">(Data_encoding.Json.Cannot_destruct _ as exn)</abbr> -&gt;
            Format.kasprintf
              failwith
              &quot;Invalid protocol_parameters: %a %a&quot;
              (fun ppf -&gt; Data_encoding.Json.print_error ppf)
              exn
              Data_encoding.Json.pp
              json
        | param -&gt;
            return (param, ctxt) ) )

let set_constants ctxt constants =
  let bytes =
    Data_encoding.Binary.to_bytes_exn
      Constants_repr.parametric_encoding
      constants
  in
  Context.set ctxt constants_key bytes

let get_constants ctxt =
  Context.get ctxt constants_key
  &gt;&gt;= function
  | None -&gt;
      failwith &quot;Internal error: cannot read constants in context.&quot;
  | Some bytes -&gt; (
    match
      Data_encoding.Binary.of_bytes Constants_repr.parametric_encoding bytes
    with
    | None -&gt;
        failwith &quot;Internal error: cannot parse constants in context.&quot;
    | Some constants -&gt;
        return constants )

let patch_constants ctxt f =
  let constants = f ctxt.constants in
  set_constants ctxt.context constants
  &gt;&gt;= fun context -&gt; Lwt.return {ctxt with context; constants}

let check_inited ctxt =
  Context.get ctxt version_key
  &gt;&gt;= function
  | None -&gt;
      failwith &quot;Internal error: un-initialized context.&quot;
  | Some bytes -&gt;
      let s = MBytes.to_string bytes in
      if Compare.String.(s = version_value) then return_unit
      else storage_error (Incompatible_protocol_version s)

let prepare ~level ~predecessor_timestamp ~timestamp ~fitness ctxt =
  Lwt.return (Raw_level_repr.of_int32 level)
  &gt;&gt;=? fun level -&gt;
  Lwt.return (Fitness_repr.to_int64 fitness)
  &gt;&gt;=? fun fitness -&gt;
  check_inited ctxt
  &gt;&gt;=? fun () -&gt;
  get_constants ctxt
  &gt;&gt;=? fun constants -&gt;
  get_first_level ctxt
  &gt;&gt;=? fun first_level -&gt;
  let level =
    Level_repr.from_raw_level
      ~first_level
      ~blocks_per_cycle:constants.Constants_repr.blocks_per_cycle
      ~blocks_per_voting_period:
        constants.Constants_repr.blocks_per_voting_period
      ~blocks_per_commitment:constants.Constants_repr.blocks_per_commitment
      level
  in
  return
    {
      context = ctxt;
      constants;
      level;
      predecessor_timestamp;
      timestamp;
      fitness;
      first_level;
      allowed_endorsements = Signature.Public_key_hash.Map.empty;
      included_endorsements = 0;
      fees = Tez_repr.zero;
      rewards = Tez_repr.zero;
      deposits = Signature.Public_key_hash.Map.empty;
      operation_gas = Unaccounted;
      internal_gas = Gas_limit_repr.internal_gas_zero;
      storage_space_to_pay = None;
      allocated_contracts = None;
      block_gas = constants.Constants_repr.hard_gas_limit_per_block;
      origination_nonce = None;
      temporary_big_map = Z.sub Z.zero Z.one;
      internal_nonce = 0;
      internal_nonces_used = Int_set.empty;
    }

type previous_protocol = Genesis of Parameters_repr.t | Alpha_previous

let check_and_update_protocol_version ctxt =
  Context.get ctxt version_key
  &gt;&gt;= (function
        | None -&gt;
            failwith
              &quot;Internal error: un-initialized context in check_first_block.&quot;
        | Some bytes -&gt;
            let s = MBytes.to_string bytes in
            if Compare.String.(s = version_value) then
              failwith &quot;Internal error: previously initialized context.&quot;
            else if Compare.String.(s = &quot;genesis&quot;) then
              get_proto_param ctxt
              &gt;&gt;=? fun (param, ctxt) -&gt; return (Genesis param, ctxt)
            else if Compare.String.(s = &quot;alpha_previous&quot;) then
              return (Alpha_previous, ctxt)
            else storage_error (Incompatible_protocol_version s))
  &gt;&gt;=? fun (previous_proto, ctxt) -&gt;
  Context.set ctxt version_key (MBytes.of_string version_value)
  &gt;&gt;= fun ctxt -&gt; return (previous_proto, ctxt)

let prepare_first_block ~level ~timestamp ~fitness ctxt =
  check_and_update_protocol_version ctxt
  &gt;&gt;=? fun (previous_proto, ctxt) -&gt;
  ( match previous_proto with
  | Genesis param -&gt;
      Lwt.return (Raw_level_repr.of_int32 level)
      &gt;&gt;=? fun first_level -&gt;
      set_first_level ctxt first_level
      &gt;&gt;=? fun ctxt -&gt;
      set_constants ctxt param.constants &gt;&gt;= fun ctxt -&gt; return ctxt
  | Alpha_previous -&gt;
      return ctxt )
  &gt;&gt;=? fun ctxt -&gt;
  prepare ctxt ~level ~predecessor_timestamp:timestamp ~timestamp ~fitness
  &gt;&gt;=? fun ctxt -&gt; return (previous_proto, ctxt)

let activate ({context = c; _} as s) h =
  Updater.activate c h &gt;&gt;= fun c -&gt; Lwt.return {s with context = c}

let fork_test_chain ({context = c; _} as s) protocol expiration =
  Updater.fork_test_chain c ~protocol ~expiration
  &gt;&gt;= fun c -&gt; Lwt.return {s with context = c}

(* Generic context ********************************************************)

type key = string list

type value = MBytes.t

module type T = sig
  type t

  type context = t

  val mem : context -&gt; key -&gt; bool Lwt.t

  val dir_mem : context -&gt; key -&gt; bool Lwt.t

  val get : context -&gt; key -&gt; value tzresult Lwt.t

  val get_option : context -&gt; key -&gt; value option Lwt.t

  val init : context -&gt; key -&gt; value -&gt; context tzresult Lwt.t

  val set : context -&gt; key -&gt; value -&gt; context tzresult Lwt.t

  val init_set : context -&gt; key -&gt; value -&gt; context Lwt.t

  val set_option : context -&gt; key -&gt; value option -&gt; context Lwt.t

  val delete : context -&gt; key -&gt; context tzresult Lwt.t

  val remove : context -&gt; key -&gt; context Lwt.t

  val remove_rec : context -&gt; key -&gt; context Lwt.t

  val copy : context -&gt; from:key -&gt; to_:key -&gt; context tzresult Lwt.t

  val fold :
    context -&gt;
    key -&gt;
    init:'a -&gt;
    f:([`Key of key | `Dir of key] -&gt; 'a -&gt; 'a Lwt.t) -&gt;
    'a Lwt.t

  val keys : context -&gt; key -&gt; key list Lwt.t

  val fold_keys :
    context -&gt; key -&gt; init:'a -&gt; f:(key -&gt; 'a -&gt; 'a Lwt.t) -&gt; 'a Lwt.t

  val project : context -&gt; root_context

  val absolute_key : context -&gt; key -&gt; key

  val consume_gas : context -&gt; Gas_limit_repr.cost -&gt; context tzresult

  val check_enough_gas : context -&gt; Gas_limit_repr.cost -&gt; unit tzresult

  val description : context Storage_description.t
end

let mem ctxt k = Context.mem ctxt.context k

let dir_mem ctxt k = Context.dir_mem ctxt.context k

let get ctxt k =
  Context.get ctxt.context k
  &gt;&gt;= function
  | None -&gt; storage_error (Missing_key (k, <abbr class="mark-warning" title="Constructor of the variant `Get unknown">`Get</abbr>)) | Some v -&gt; return v

let get_option ctxt k = Context.get ctxt.context k

(* Verify that the k is present before modifying *)
let set ctxt k v =
  Context.mem ctxt.context k
  &gt;&gt;= function
  | false -&gt;
      storage_error (Missing_key (k, <abbr class="mark-warning" title="Constructor of the variant `Set unknown">`Set</abbr>))
  | true -&gt;
      Context.set ctxt.context k v
      &gt;&gt;= fun context -&gt; return {ctxt with context}

(* Verify that the k is not present before inserting *)
let init ctxt k v =
  Context.mem ctxt.context k
  &gt;&gt;= function
  | true -&gt;
      storage_error (Existing_key k)
  | false -&gt;
      Context.set ctxt.context k v
      &gt;&gt;= fun context -&gt; return {ctxt with context}

(* Does not verify that the key is present or not *)
let init_set ctxt k v =
  Context.set ctxt.context k v
  &gt;&gt;= fun context -&gt; Lwt.return {ctxt with context}

(* Verify that the key is present before deleting *)
let delete ctxt k =
  Context.mem ctxt.context k
  &gt;&gt;= function
  | false -&gt;
      storage_error (Missing_key (k, <abbr class="mark-warning" title="Constructor of the variant `Del unknown">`Del</abbr>))
  | true -&gt;
      Context.del ctxt.context k &gt;&gt;= fun context -&gt; return {ctxt with context}

(* Do not verify before deleting *)
let remove ctxt k =
  Context.del ctxt.context k &gt;&gt;= fun context -&gt; Lwt.return {ctxt with context}

let set_option ctxt k = function
  | None -&gt;
      remove ctxt k
  | Some v -&gt;
      init_set ctxt k v

let remove_rec ctxt k =
  Context.remove_rec ctxt.context k
  &gt;&gt;= fun context -&gt; Lwt.return {ctxt with context}

let copy ctxt ~from ~to_ =
  Context.copy ctxt.context ~from ~to_
  &gt;&gt;= function
  | None -&gt;
      storage_error (Missing_key (from, <abbr class="mark-warning" title="Constructor of the variant `Copy unknown">`Copy</abbr>))
  | Some context -&gt;
      return {ctxt with context}

let fold ctxt k ~init ~f = Context.fold ctxt.context k ~init ~f

let keys ctxt k = Context.keys ctxt.context k

let fold_keys ctxt k ~init ~f = Context.fold_keys ctxt.context k ~init ~f

let project x = x

let absolute_key _ k = k

let description = Storage_description.create ()

let fresh_temporary_big_map ctxt =
  ( {ctxt with temporary_big_map = Z.sub ctxt.temporary_big_map Z.one},
    ctxt.temporary_big_map )

let reset_temporary_big_map ctxt =
  {ctxt with temporary_big_map = Z.sub Z.zero Z.one}

let temporary_big_maps ctxt f acc =
  let rec iter acc id =
    if Z.equal id ctxt.temporary_big_map then Lwt.return acc
    else f acc id &gt;&gt;= fun acc -&gt; iter acc (Z.sub id Z.one)
  in
  iter acc (Z.sub Z.zero Z.one)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#raw_context.ml"><code>Raw_context.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Constants_repr.
Require Tezos.Contract_repr.
Require Tezos.Fitness_repr.
Require Tezos.Gas_limit_repr.
Require Tezos.Level_repr.
Require Tezos.Parameters_repr.
Require Tezos.Raw_level_repr.
Require Tezos.Storage_description.
Require Tezos.Tez_repr.

Definition Int_set :=
  __Set.Make
    (existT (A := Set) _ _
      {|
        Compare.COMPARABLE.compare := (|Compare.Int|).(Compare.S.compare)
      |}).

Module t.
  Record record : Set := Build {
    context : Context.t;
    constants : Constants_repr.parametric;
    first_level : Raw_level_repr.t;
    level : Level_repr.t;
    predecessor_timestamp : Time.t;
    timestamp : Time.t;
    fitness : Int64.t;
    deposits :
      (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t)
        Tez_repr.t;
    included_endorsements : int;
    allowed_endorsements :
      (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t)
        ((|Signature.Public_key|).(S.SPublic_key.t) * list int * bool);
    fees : Tez_repr.t;
    rewards : Tez_repr.t;
    block_gas : Z.t;
    operation_gas : Gas_limit_repr.t;
    internal_gas : Gas_limit_repr.internal_gas;
    storage_space_to_pay : option Z.t;
    allocated_contracts : option int;
    origination_nonce : option Contract_repr.origination_nonce;
    temporary_big_map : Z.t;
    internal_nonce : int;
    internal_nonces_used : (|Int_set|).(S.SET.t) }.
  Definition with_context context (r : record) :=
    Build context r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_constants constants (r : record) :=
    Build r.(context) constants r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_first_level first_level (r : record) :=
    Build r.(context) r.(constants) first_level r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_level level (r : record) :=
    Build r.(context) r.(constants) r.(first_level) level
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_predecessor_timestamp predecessor_timestamp (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      predecessor_timestamp r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_timestamp timestamp (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) timestamp r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_fitness fitness (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) fitness r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_deposits deposits (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) deposits
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_included_endorsements included_endorsements (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      included_endorsements r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_allowed_endorsements allowed_endorsements (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) allowed_endorsements r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_fees fees (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) fees r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_rewards rewards (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) rewards
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_block_gas block_gas (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      block_gas r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_operation_gas operation_gas (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) operation_gas r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_internal_gas internal_gas (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) internal_gas r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_storage_space_to_pay storage_space_to_pay (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) storage_space_to_pay
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_allocated_contracts allocated_contracts (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      allocated_contracts r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_origination_nonce origination_nonce (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) origination_nonce r.(temporary_big_map)
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_temporary_big_map temporary_big_map (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) temporary_big_map
      r.(internal_nonce) r.(internal_nonces_used).
  Definition with_internal_nonce internal_nonce (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      internal_nonce r.(internal_nonces_used).
  Definition with_internal_nonces_used internal_nonces_used (r : record) :=
    Build r.(context) r.(constants) r.(first_level) r.(level)
      r.(predecessor_timestamp) r.(timestamp) r.(fitness) r.(deposits)
      r.(included_endorsements) r.(allowed_endorsements) r.(fees) r.(rewards)
      r.(block_gas) r.(operation_gas) r.(internal_gas) r.(storage_space_to_pay)
      r.(allocated_contracts) r.(origination_nonce) r.(temporary_big_map)
      r.(internal_nonce) internal_nonces_used.
End t.
Definition t := t.record.

Definition context : Set := t.

Definition root_context : Set := t.

Definition current_level (ctxt : t) : Level_repr.t := ctxt.(t.level).

Definition predecessor_timestamp (ctxt : t) : Time.t :=
  ctxt.(t.predecessor_timestamp).

Definition current_timestamp (ctxt : t) : Time.t := ctxt.(t.timestamp).

Definition current_fitness (ctxt : t) : Int64.t := ctxt.(t.fitness).

Definition first_level (ctxt : t) : Raw_level_repr.t := ctxt.(t.first_level).

Definition constants (ctxt : t) : Constants_repr.parametric :=
  ctxt.(t.constants).

Definition recover (ctxt : t) : Context.t := ctxt.(t.context).

Definition record_endorsement
  (ctxt : t)
  (k :
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.key))
  : t :=
  match
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.find_opt)
      k ctxt.(t.allowed_endorsements) with
  | None =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert t false
  | Some (_, _, true) =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert t false
  | Some (d, s, false) =&gt;
    t.with_allowed_endorsements
      ((|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.add)
        k (d, s, true) ctxt.(t.allowed_endorsements))
      (t.with_included_endorsements
        (Pervasives.op_plus ctxt.(t.included_endorsements) (List.length s)) ctxt)
  end.

Definition init_endorsements
  (ctxt : t)
  (allowed_endorsements :
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t)
      ((|Signature.Public_key|).(S.SPublic_key.t) * list int * bool)) : t :=
  if
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.is_empty)
      allowed_endorsements then
    (* ‚ùå Assert instruction is not handled. *)
    assert t false
  else
    if
      (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.is_empty)
        ctxt.(t.allowed_endorsements) then
      t.with_allowed_endorsements allowed_endorsements ctxt
    else
      (* ‚ùå Assert instruction is not handled. *)
      assert t false.

Definition allowed_endorsements (ctxt : t)
  : (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t)
    ((|Signature.Public_key|).(S.SPublic_key.t) * list int * bool) :=
  ctxt.(t.allowed_endorsements).

Definition included_endorsements (ctxt : t) : int :=
  ctxt.(t.included_endorsements).

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition fresh_internal_nonce (ctxt : t) : Error_monad.tzresult (t * int) :=
  if (|Compare.Int|).(Compare.S.op_gteq) ctxt.(t.internal_nonce) 65535 then
    Error_monad.__error_value extensible_type_value
  else
    Error_monad.ok
      ((t.with_internal_nonce (Pervasives.op_plus ctxt.(t.internal_nonce) 1)
        ctxt), ctxt.(t.internal_nonce)).

Definition reset_internal_nonce (ctxt : t) : t :=
  t.with_internal_nonces_used (|Int_set|).(S.SET.empty)
    (t.with_internal_nonce 0 ctxt).

Definition record_internal_nonce (ctxt : t) (k : (|Int_set|).(S.SET.elt)) : t :=
  t.with_internal_nonces_used
    ((|Int_set|).(S.SET.add) k ctxt.(t.internal_nonces_used)) ctxt.

Definition internal_nonce_already_recorded
  (ctxt : t) (k : (|Int_set|).(S.SET.elt)) : bool :=
  (|Int_set|).(S.SET.mem) k ctxt.(t.internal_nonces_used).

Definition set_current_fitness (ctxt : t) (fitness : Int64.t) : t :=
  t.with_fitness fitness ctxt.

Definition add_fees (ctxt : t) (fees : Tez_repr.t)
  : Lwt.t (Error_monad.tzresult t) :=
  let=? fees := Lwt.__return (Tez_repr.op_plusquestion ctxt.(t.fees) fees) in
  Error_monad.__return (t.with_fees fees ctxt).

Definition add_rewards (ctxt : t) (rewards : Tez_repr.t)
  : Lwt.t (Error_monad.tzresult t) :=
  let=? rewards :=
    Lwt.__return (Tez_repr.op_plusquestion ctxt.(t.rewards) rewards) in
  Error_monad.__return (t.with_rewards rewards ctxt).

Definition add_deposit
  (ctxt : t)
  (delegate :
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.key))
  (deposit : Tez_repr.t) : Lwt.t (Error_monad.tzresult t) :=
  let previous :=
    match
      (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.find_opt)
        delegate ctxt.(t.deposits) with
    | Some tz =&gt; tz
    | None =&gt; Tez_repr.zero
    end in
  let=? deposit := Lwt.__return (Tez_repr.op_plusquestion previous deposit) in
  let deposits :=
    (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.add)
      delegate deposit ctxt.(t.deposits) in
  Error_monad.__return (t.with_deposits deposits ctxt).

Definition get_deposits (ctxt : t)
  : (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t)
    Tez_repr.t := ctxt.(t.deposits).

Definition get_rewards (ctxt : t) : Tez_repr.t := ctxt.(t.rewards).

Definition get_fees (ctxt : t) : Tez_repr.t := ctxt.(t.fees).

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition init_origination_nonce
  (ctxt : t) (operation_hash : (|Operation_hash|).(S.HASH.t)) : t :=
  let origination_nonce :=
    Some (Contract_repr.initial_origination_nonce operation_hash) in
  t.with_origination_nonce origination_nonce ctxt.

Definition origination_nonce (ctxt : t)
  : Error_monad.tzresult Contract_repr.origination_nonce :=
  match ctxt.(t.origination_nonce) with
  | None =&gt; Error_monad.__error_value extensible_type_value
  | Some origination_nonce =&gt; Error_monad.ok origination_nonce
  end.

Definition increment_origination_nonce (ctxt : t)
  : Error_monad.tzresult (t * Contract_repr.origination_nonce) :=
  match ctxt.(t.origination_nonce) with
  | None =&gt; Error_monad.__error_value extensible_type_value
  | Some cur_origination_nonce =&gt;
    let origination_nonce :=
      Some (Contract_repr.incr_origination_nonce cur_origination_nonce) in
    Error_monad.ok
      ((t.with_origination_nonce origination_nonce ctxt), cur_origination_nonce)
  end.

Definition unset_origination_nonce (ctxt : t) : t :=
  t.with_origination_nonce None ctxt.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition check_gas_limit (ctxt : t) (remaining : (|Compare.Z|).(Compare.S.t))
  : Error_monad.tzresult unit :=
  if
    Pervasives.op_pipepipe
      ((|Compare.Z|).(Compare.S.op_gt) remaining
        ctxt.(t.constants).(Constants_repr.parametric.hard_gas_limit_per_operation))
      ((|Compare.Z|).(Compare.S.op_lt) remaining Z.zero) then
    Error_monad.__error_value extensible_type_value
  else
    Error_monad.ok tt.

Definition set_gas_limit (ctxt : t) (remaining : Z.t) : t :=
  t.with_internal_gas Gas_limit_repr.internal_gas_zero
    (t.with_operation_gas
      (Gas_limit_repr.Limited
        {| Gas_limit_repr.t.Limited.remaining := remaining |}) ctxt).

Definition set_gas_unlimited (ctxt : t) : t :=
  t.with_operation_gas Gas_limit_repr.Unaccounted ctxt.

Definition consume_gas (ctxt : t) (cost : Gas_limit_repr.cost)
  : Error_monad.tzresult t :=
  let? '(block_gas, operation_gas, __internal_gas_value) :=
    Gas_limit_repr.consume_raw ctxt.(t.block_gas) ctxt.(t.operation_gas)
      ctxt.(t.internal_gas) cost in
  Error_monad.ok
    (t.with_internal_gas __internal_gas_value
      (t.with_operation_gas operation_gas (t.with_block_gas block_gas ctxt))).

Definition check_enough_gas (ctxt : t) (cost : Gas_limit_repr.cost)
  : Error_monad.tzresult unit :=
  Gas_limit_repr.check_enough_raw ctxt.(t.block_gas) ctxt.(t.operation_gas)
    ctxt.(t.internal_gas) cost.

Definition gas_level (ctxt : t) : Gas_limit_repr.t := ctxt.(t.operation_gas).

Definition block_gas_level (ctxt : t) : Z.t := ctxt.(t.block_gas).

Definition gas_consumed (since : t) (until : t) : Z.t :=
  match ((gas_level since), (gas_level until)) with
  |
    (Gas_limit_repr.Limited {| Gas_limit_repr.t.Limited.remaining := before |},
      Gas_limit_repr.Limited {| Gas_limit_repr.t.Limited.remaining := after |})
    =&gt; Z.sub before after
  | (_, _) =&gt; Z.zero
  end.

Definition init_storage_space_to_pay (ctxt : t) : t :=
  match ctxt.(t.storage_space_to_pay) with
  | Some _ =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert t false
  | None =&gt;
    t.with_allocated_contracts (Some 0)
      (t.with_storage_space_to_pay (Some Z.zero) ctxt)
  end.

Definition update_storage_space_to_pay (ctxt : t) (n : Z.t) : t :=
  match ctxt.(t.storage_space_to_pay) with
  | None =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert t false
  | Some storage_space_to_pay =&gt;
    t.with_storage_space_to_pay (Some (Z.add n storage_space_to_pay)) ctxt
  end.

Definition update_allocated_contracts_count (ctxt : t) : t :=
  match ctxt.(t.allocated_contracts) with
  | None =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert t false
  | Some allocated_contracts =&gt;
    t.with_allocated_contracts (Some (Pervasives.succ allocated_contracts)) ctxt
  end.

Definition clear_storage_space_to_pay (ctxt : t) : t * Z.t * int :=
  match (ctxt.(t.storage_space_to_pay), ctxt.(t.allocated_contracts)) with
  | ((None, _) | (_, None)) =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert (t * Z.t * int) false
  | (Some storage_space_to_pay, Some allocated_contracts) =&gt;
    ((t.with_allocated_contracts None (t.with_storage_space_to_pay None ctxt)),
      storage_space_to_pay, allocated_contracts)
  end.

Inductive missing_key_kind : Set :=
| Del : missing_key_kind
| Copy : missing_key_kind
| Get : missing_key_kind
| __Set : missing_key_kind.

Inductive storage_error : Set :=
| Incompatible_protocol_version : string -&gt; storage_error
| Missing_key : list string -&gt; missing_key_kind -&gt; storage_error
| Existing_key : list string -&gt; storage_error
| Corrupted_data : list string -&gt; storage_error.

Definition storage_error_encoding : Data_encoding.encoding storage_error :=
  Data_encoding.union None
    [
      Data_encoding.__case_value &quot;Incompatible_protocol_version&quot; None
        (Data_encoding.Tag 0)
        (Data_encoding.obj1
          (Data_encoding.req None None &quot;incompatible_protocol_version&quot;
            Data_encoding.__string_value))
        (fun function_parameter =&gt;
          match function_parameter with
          | Incompatible_protocol_version arg =&gt; Some arg
          | _ =&gt; None
          end) (fun arg =&gt; Incompatible_protocol_version arg);
      Data_encoding.__case_value &quot;Missing_key&quot; None (Data_encoding.Tag 1)
        (Data_encoding.obj2
          (Data_encoding.req None None &quot;missing_key&quot;
            (Data_encoding.__list_value None Data_encoding.__string_value))
          (Data_encoding.req None None &quot;function&quot;
            (Data_encoding.string_enum
              [
                (&quot;get&quot;, Get);
                (&quot;set&quot;, __Set);
                (&quot;del&quot;, Del);
                (&quot;copy&quot;, Copy)
              ])))
        (fun function_parameter =&gt;
          match function_parameter with
          | Missing_key __key_value f =&gt; Some (__key_value, f)
          | _ =&gt; None
          end)
        (fun function_parameter =&gt;
          let '(__key_value, f) := function_parameter in
          Missing_key __key_value f);
      Data_encoding.__case_value &quot;Existing_key&quot; None (Data_encoding.Tag 2)
        (Data_encoding.obj1
          (Data_encoding.req None None &quot;existing_key&quot;
            (Data_encoding.__list_value None Data_encoding.__string_value)))
        (fun function_parameter =&gt;
          match function_parameter with
          | Existing_key __key_value =&gt; Some __key_value
          | _ =&gt; None
          end) (fun __key_value =&gt; Existing_key __key_value);
      Data_encoding.__case_value &quot;Corrupted_data&quot; None (Data_encoding.Tag 3)
        (Data_encoding.obj1
          (Data_encoding.req None None &quot;corrupted_data&quot;
            (Data_encoding.__list_value None Data_encoding.__string_value)))
        (fun function_parameter =&gt;
          match function_parameter with
          | Corrupted_data __key_value =&gt; Some __key_value
          | _ =&gt; None
          end) (fun __key_value =&gt; Corrupted_data __key_value)
    ].

Definition pp_storage_error
  (ppf : Format.formatter) (function_parameter : storage_error) : unit :=
  match function_parameter with
  | Incompatible_protocol_version version =&gt;
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal
          &quot;Found a context with an unexpected version '&quot;
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.String_literal &quot;'.&quot;
              CamlinternalFormatBasics.End_of_format)))
        &quot;Found a context with an unexpected version '%s'.&quot;) version
  | Missing_key __key_value Get =&gt;
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;Missing key '&quot;
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.String_literal &quot;'.&quot;
              CamlinternalFormatBasics.End_of_format))) &quot;Missing key '%s'.&quot;)
      (String.concat &quot;/&quot; __key_value)
  | Missing_key __key_value __Set =&gt;
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;Cannot set undefined key '&quot;
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.String_literal &quot;'.&quot;
              CamlinternalFormatBasics.End_of_format)))
        &quot;Cannot set undefined key '%s'.&quot;) (String.concat &quot;/&quot; __key_value)
  | Missing_key __key_value Del =&gt;
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;Cannot delete undefined key '&quot;
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.String_literal &quot;'.&quot;
              CamlinternalFormatBasics.End_of_format)))
        &quot;Cannot delete undefined key '%s'.&quot;) (String.concat &quot;/&quot; __key_value)
  | Missing_key __key_value Copy =&gt;
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;Cannot copy undefined key '&quot;
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.String_literal &quot;'.&quot;
              CamlinternalFormatBasics.End_of_format)))
        &quot;Cannot copy undefined key '%s'.&quot;) (String.concat &quot;/&quot; __key_value)
  | Existing_key __key_value =&gt;
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal
          &quot;Cannot initialize defined key '&quot;
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.String_literal &quot;'.&quot;
              CamlinternalFormatBasics.End_of_format)))
        &quot;Cannot initialize defined key '%s'.&quot;) (String.concat &quot;/&quot; __key_value)
  | Corrupted_data __key_value =&gt;
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;Failed to parse the data at '&quot;
          (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
            (CamlinternalFormatBasics.String_literal &quot;'.&quot;
              CamlinternalFormatBasics.End_of_format)))
        &quot;Failed to parse the data at '%s'.&quot;) (String.concat &quot;/&quot; __key_value)
  end.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition __storage_error_value {A : Set} (err : storage_error)
  : Lwt.t (Error_monad.tzresult A) := Error_monad.fail extensible_type_value.

Definition version_key : list string := [ &quot;version&quot; ].

Definition version_value : string := &quot;alpha_current&quot;.

Definition version : string := &quot;v1&quot;.

Definition first_level_key : list string := [ version; &quot;first_level&quot; ].

Definition constants_key : list string := [ version; &quot;constants&quot; ].

Definition protocol_param_key : list string := [ &quot;protocol_parameters&quot; ].

Definition get_first_level (ctxt : Context.t)
  : Lwt.t (Error_monad.tzresult Raw_level_repr.raw_level) :=
  let= function_parameter := Context.get ctxt first_level_key in
  match function_parameter with
  | None =&gt; __storage_error_value (Missing_key first_level_key Get)
  | Some __bytes_value =&gt;
    match Data_encoding.Binary.of_bytes Raw_level_repr.encoding __bytes_value
      with
    | None =&gt; __storage_error_value (Corrupted_data first_level_key)
    | Some level =&gt; Error_monad.__return level
    end
  end.

Definition set_first_level (ctxt : Context.t) (level : Raw_level_repr.raw_level)
  : Lwt.t (Error_monad.tzresult Context.t) :=
  let __bytes_value :=
    Data_encoding.Binary.to_bytes_exn Raw_level_repr.encoding level in
  let= ctxt := Context.set ctxt first_level_key __bytes_value in
  Error_monad.__return ctxt.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition get_proto_param (ctxt : Context.t)
  : Lwt.t (Error_monad.tzresult (Parameters_repr.t * Context.t)) :=
  let= function_parameter := Context.get ctxt protocol_param_key in
  match function_parameter with
  | None =&gt; Pervasives.failwith &quot;Missing protocol parameters.&quot;
  | Some __bytes_value =&gt;
    match Data_encoding.Binary.of_bytes Data_encoding.__json_value __bytes_value
      with
    | None =&gt; Error_monad.fail extensible_type_value
    | Some __json_value =&gt;
      let= ctxt := Context.del ctxt protocol_param_key in
      let 'param :=
        Data_encoding.Json.destruct Parameters_repr.encoding __json_value in
      Error_monad.__return (param, ctxt)
    end
  end.

Definition set_constants
  (ctxt : Context.t) (constants : Constants_repr.parametric)
  : Lwt.t Context.t :=
  let __bytes_value :=
    Data_encoding.Binary.to_bytes_exn Constants_repr.parametric_encoding
      constants in
  Context.set ctxt constants_key __bytes_value.

Definition get_constants (ctxt : Context.t)
  : Lwt.t (Error_monad.tzresult Constants_repr.parametric) :=
  let= function_parameter := Context.get ctxt constants_key in
  match function_parameter with
  | None =&gt;
    Pervasives.failwith &quot;Internal error: cannot read constants in context.&quot;
  | Some __bytes_value =&gt;
    match
      Data_encoding.Binary.of_bytes Constants_repr.parametric_encoding
        __bytes_value with
    | None =&gt;
      Pervasives.failwith &quot;Internal error: cannot parse constants in context.&quot;
    | Some constants =&gt; Error_monad.__return constants
    end
  end.

Definition patch_constants
  (ctxt : t) (f : Constants_repr.parametric -&gt; Constants_repr.parametric)
  : Lwt.t t :=
  let constants := f ctxt.(t.constants) in
  let= context := set_constants ctxt.(t.context) constants in
  Lwt.__return (t.with_constants constants (t.with_context context ctxt)).

Definition check_inited (ctxt : Context.t)
  : Lwt.t (Error_monad.tzresult unit) :=
  let= function_parameter := Context.get ctxt version_key in
  match function_parameter with
  | None =&gt; Pervasives.failwith &quot;Internal error: un-initialized context.&quot;
  | Some __bytes_value =&gt;
    let s := MBytes.to_string __bytes_value in
    if (|Compare.String|).(Compare.S.op_eq) s version_value then
      Error_monad.return_unit
    else
      __storage_error_value (Incompatible_protocol_version s)
  end.

Definition prepare
  (level : int32) (predecessor_timestamp : Time.t) (timestamp : Time.t)
  (fitness : list MBytes.t) (ctxt : Context.t)
  : Lwt.t (Error_monad.tzresult t) :=
  let=? level := Lwt.__return (Raw_level_repr.of_int32 level) in
  let=? fitness := Lwt.__return (Fitness_repr.to_int64 fitness) in
  let=? '_ := check_inited ctxt in
  let=? constants := get_constants ctxt in
  let=? first_level := get_first_level ctxt in
  let level :=
    Level_repr.from_raw_level first_level
      constants.(Constants_repr.parametric.blocks_per_cycle)
      constants.(Constants_repr.parametric.blocks_per_voting_period)
      constants.(Constants_repr.parametric.blocks_per_commitment) level in
  Error_monad.__return
    {| t.context := ctxt; t.constants := constants;
      t.first_level := first_level; t.level := level;
      t.predecessor_timestamp := predecessor_timestamp;
      t.timestamp := timestamp; t.fitness := fitness;
      t.deposits :=
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.empty);
      t.included_endorsements := 0;
      t.allowed_endorsements :=
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.empty);
      t.fees := Tez_repr.zero; t.rewards := Tez_repr.zero;
      t.block_gas :=
        constants.(Constants_repr.parametric.hard_gas_limit_per_block);
      t.operation_gas := Gas_limit_repr.Unaccounted;
      t.internal_gas := Gas_limit_repr.internal_gas_zero;
      t.storage_space_to_pay := None; t.allocated_contracts := None;
      t.origination_nonce := None; t.temporary_big_map := Z.sub Z.zero Z.one;
      t.internal_nonce := 0; t.internal_nonces_used := (|Int_set|).(S.SET.empty)
      |}.

Inductive previous_protocol : Set :=
| Genesis : Parameters_repr.t -&gt; previous_protocol
| Alpha_previous : previous_protocol.

Definition check_and_update_protocol_version (ctxt : Context.t)
  : Lwt.t (Error_monad.tzresult (previous_protocol * Context.t)) :=
  let=? '(previous_proto, ctxt) :=
    let= function_parameter := Context.get ctxt version_key in
    match function_parameter with
    | None =&gt;
      Pervasives.failwith
        &quot;Internal error: un-initialized context in check_first_block.&quot;
    | Some __bytes_value =&gt;
      let s := MBytes.to_string __bytes_value in
      if (|Compare.String|).(Compare.S.op_eq) s version_value then
        Pervasives.failwith &quot;Internal error: previously initialized context.&quot;
      else
        if (|Compare.String|).(Compare.S.op_eq) s &quot;genesis&quot; then
          let=? '(param, ctxt) := get_proto_param ctxt in
          Error_monad.__return ((Genesis param), ctxt)
        else
          if (|Compare.String|).(Compare.S.op_eq) s &quot;alpha_previous&quot; then
            Error_monad.__return (Alpha_previous, ctxt)
          else
            __storage_error_value (Incompatible_protocol_version s)
    end in
  let= ctxt := Context.set ctxt version_key (MBytes.of_string version_value) in
  Error_monad.__return (previous_proto, ctxt).

Definition prepare_first_block
  (level : int32) (timestamp : Time.t) (fitness : list MBytes.t)
  (ctxt : Context.t) : Lwt.t (Error_monad.tzresult (previous_protocol * t)) :=
  let=? '(previous_proto, ctxt) := check_and_update_protocol_version ctxt in
  let=? ctxt :=
    match previous_proto with
    | Genesis param =&gt;
      let=? first_level := Lwt.__return (Raw_level_repr.of_int32 level) in
      let=? ctxt := set_first_level ctxt first_level in
      let= ctxt := set_constants ctxt param.(Parameters_repr.t.constants) in
      Error_monad.__return ctxt
    | Alpha_previous =&gt; Error_monad.__return ctxt
    end in
  let=? ctxt := prepare level timestamp timestamp fitness ctxt in
  Error_monad.__return (previous_proto, ctxt).

Definition activate (function_parameter : t)
  : (|Protocol_hash|).(S.HASH.t) -&gt; Lwt.t t :=
  let '{| t.context := c |} as s := function_parameter in
  fun h =&gt;
    let= c := Updater.activate c h in
    Lwt.__return (t.with_context c s).

Definition fork_test_chain (function_parameter : t)
  : (|Protocol_hash|).(S.HASH.t) -&gt; Time.t -&gt; Lwt.t t :=
  let '{| t.context := c |} as s := function_parameter in
  fun protocol =&gt;
    fun expiration =&gt;
      let= c := Updater.fork_test_chain c protocol expiration in
      Lwt.__return (t.with_context c s).

Definition key : Set := list string.

Definition value : Set := MBytes.t.

Module T.
  Record signature {t : Set} : Set := {
    t := t;
    context := t;
    mem : context -&gt; key -&gt; Lwt.t bool;
    dir_mem : context -&gt; key -&gt; Lwt.t bool;
    get : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult value);
    get_option : context -&gt; key -&gt; Lwt.t (option value);
    init : context -&gt; key -&gt; value -&gt; Lwt.t (Error_monad.tzresult context);
    set : context -&gt; key -&gt; value -&gt; Lwt.t (Error_monad.tzresult context);
    init_set : context -&gt; key -&gt; value -&gt; Lwt.t context;
    set_option : context -&gt; key -&gt; option value -&gt; Lwt.t context;
    delete : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult context);
    remove : context -&gt; key -&gt; Lwt.t context;
    remove_rec : context -&gt; key -&gt; Lwt.t context;
    copy : context -&gt; key -&gt; key -&gt; Lwt.t (Error_monad.tzresult context);
    fold : forall {a : Set},
      context -&gt; key -&gt; a -&gt; (Context.dir_or_key -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a;
    keys : context -&gt; key -&gt; Lwt.t (list key);
    fold_keys : forall {a : Set},
      context -&gt; key -&gt; a -&gt; (key -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a;
    project : context -&gt; root_context;
    absolute_key : context -&gt; key -&gt; key;
    consume_gas :
      context -&gt; Gas_limit_repr.cost -&gt; Error_monad.tzresult context;
    check_enough_gas :
      context -&gt; Gas_limit_repr.cost -&gt; Error_monad.tzresult unit;
    description : Storage_description.t context;
  }.
End T.

Definition mem (ctxt : t) (k : Context.key) : Lwt.t bool :=
  Context.mem ctxt.(t.context) k.

Definition dir_mem (ctxt : t) (k : Context.key) : Lwt.t bool :=
  Context.dir_mem ctxt.(t.context) k.

Definition get (ctxt : t) (k : Context.key)
  : Lwt.t (Error_monad.tzresult Context.value) :=
  let= function_parameter := Context.get ctxt.(t.context) k in
  match function_parameter with
  | None =&gt; __storage_error_value (Missing_key k Get)
  | Some v =&gt; Error_monad.__return v
  end.

Definition get_option (ctxt : t) (k : Context.key)
  : Lwt.t (option Context.value) := Context.get ctxt.(t.context) k.

Definition set (ctxt : t) (k : Context.key) (v : Context.value)
  : Lwt.t (Error_monad.tzresult t) :=
  let= function_parameter := Context.mem ctxt.(t.context) k in
  match function_parameter with
  | false =&gt; __storage_error_value (Missing_key k __Set)
  | true =&gt;
    let= context := Context.set ctxt.(t.context) k v in
    Error_monad.__return (t.with_context context ctxt)
  end.

Definition init (ctxt : t) (k : Context.key) (v : Context.value)
  : Lwt.t (Error_monad.tzresult t) :=
  let= function_parameter := Context.mem ctxt.(t.context) k in
  match function_parameter with
  | true =&gt; __storage_error_value (Existing_key k)
  | false =&gt;
    let= context := Context.set ctxt.(t.context) k v in
    Error_monad.__return (t.with_context context ctxt)
  end.

Definition init_set (ctxt : t) (k : Context.key) (v : Context.value)
  : Lwt.t t :=
  let= context := Context.set ctxt.(t.context) k v in
  Lwt.__return (t.with_context context ctxt).

Definition delete (ctxt : t) (k : Context.key)
  : Lwt.t (Error_monad.tzresult t) :=
  let= function_parameter := Context.mem ctxt.(t.context) k in
  match function_parameter with
  | false =&gt; __storage_error_value (Missing_key k Del)
  | true =&gt;
    let= context := Context.del ctxt.(t.context) k in
    Error_monad.__return (t.with_context context ctxt)
  end.

Definition remove (ctxt : t) (k : Context.key) : Lwt.t t :=
  let= context := Context.del ctxt.(t.context) k in
  Lwt.__return (t.with_context context ctxt).

Definition set_option
  (ctxt : t) (k : Context.key) (function_parameter : option Context.value)
  : Lwt.t t :=
  match function_parameter with
  | None =&gt; remove ctxt k
  | Some v =&gt; init_set ctxt k v
  end.

Definition remove_rec (ctxt : t) (k : Context.key) : Lwt.t t :=
  let= context := Context.remove_rec ctxt.(t.context) k in
  Lwt.__return (t.with_context context ctxt).

Definition copy (ctxt : t) (from : Context.key) (to_ : Context.key)
  : Lwt.t (Error_monad.tzresult t) :=
  let= function_parameter := Context.copy ctxt.(t.context) from to_ in
  match function_parameter with
  | None =&gt; __storage_error_value (Missing_key from Copy)
  | Some context =&gt; Error_monad.__return (t.with_context context ctxt)
  end.

Definition fold {A : Set}
  (ctxt : t) (k : Context.key) (init : A)
  (f : Context.dir_or_key -&gt; A -&gt; Lwt.t A) : Lwt.t A :=
  Context.fold ctxt.(t.context) k init f.

Definition keys (ctxt : t) (k : Context.key) : Lwt.t (list Context.key) :=
  Context.keys ctxt.(t.context) k.

Definition fold_keys {A : Set}
  (ctxt : t) (k : Context.key) (init : A) (f : Context.key -&gt; A -&gt; Lwt.t A)
  : Lwt.t A := Context.fold_keys ctxt.(t.context) k init f.

Definition project {A : Set} (x : A) : A := x.

Definition absolute_key {A B : Set} (function_parameter : A) : B -&gt; B :=
  let '_ := function_parameter in
  fun k =&gt; k.

Definition description {A : Set} : Storage_description.t A :=
  Storage_description.create tt.

Definition fresh_temporary_big_map (ctxt : t) : t * Z.t :=
  ((t.with_temporary_big_map (Z.sub ctxt.(t.temporary_big_map) Z.one) ctxt),
    ctxt.(t.temporary_big_map)).

Definition reset_temporary_big_map (ctxt : t) : t :=
  t.with_temporary_big_map (Z.sub Z.zero Z.one) ctxt.

Definition temporary_big_maps {A : Set}
  (ctxt : t) (f : A -&gt; Z.t -&gt; Lwt.t A) (acc : A) : Lwt.t A :=
  let fix iter (acc : A) (id : Z.t) {struct acc} : Lwt.t A :=
    if Z.equal id ctxt.(t.temporary_big_map) then
      Lwt.__return acc
    else
      let= acc := f acc id in
      iter acc (Z.sub id Z.one) in
  iter acc (Z.sub Z.zero Z.one).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="raw_context.mli">
  <div style="margin: 20px;">
    <h3>Raw_context_mli</h3>
    <ul>
      <li>OCaml size: 293 lines</li>
      <li>Coq size: 267 lines (-9% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#raw_context.mli"><code>raw_context.mli</code></a>&nbsp;<span class="label label-warning">7 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** {1 Errors} *)

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Too_many_internal_operations</abbr> (* `Permanent *)

<abbr class="mark-warning" title="Polymorphic variant types are defined as standard algebraic types">type missing_key_kind = [`Get | `Set | `Del | `Copy]</abbr>

(** An internal storage error that should not happen *)
type storage_error =
  | Incompatible_protocol_version of string
  | Missing_key of string list * missing_key_kind
  | Existing_key of string list
  | Corrupted_data of string list

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Storage_error of storage_error</abbr>

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Failed_to_parse_parameter of MBytes.t</abbr>

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Failed_to_decode_parameter of Data_encoding.json * string</abbr>

val storage_error : storage_error -&gt; 'a tzresult Lwt.t

(** {1 Abstract Context} *)

(** Abstract view of the context.
    Includes a handle to the functional key-value database
    ({!Context.t}) along with some in-memory values (gas, etc.). *)
type t

type context = t

type root_context = t

(** Retrieves the state of the database and gives its abstract view.
    It also returns wether this is the first block validated
    with this version of the protocol. *)
val prepare :
  level:Int32.t -&gt;
  predecessor_timestamp:Time.t -&gt;
  timestamp:Time.t -&gt;
  fitness:Fitness.t -&gt;
  Context.t -&gt;
  context tzresult Lwt.t

type previous_protocol = Genesis of Parameters_repr.t | Alpha_previous

val prepare_first_block :
  level:int32 -&gt;
  timestamp:Time.t -&gt;
  fitness:Fitness.t -&gt;
  Context.t -&gt;
  (previous_protocol * context) tzresult Lwt.t

val activate : context -&gt; Protocol_hash.t -&gt; t Lwt.t

val fork_test_chain : context -&gt; Protocol_hash.t -&gt; Time.t -&gt; t Lwt.t

(** Returns the state of the database resulting of operations on its
    abstract view *)
val recover : context -&gt; Context.t

val current_level : context -&gt; Level_repr.t

val predecessor_timestamp : context -&gt; Time.t

val current_timestamp : context -&gt; Time.t

val current_fitness : context -&gt; Int64.t

val set_current_fitness : context -&gt; Int64.t -&gt; t

val constants : context -&gt; Constants_repr.parametric

val patch_constants :
  context -&gt;
  (Constants_repr.parametric -&gt; Constants_repr.parametric) -&gt;
  context Lwt.t

val first_level : context -&gt; Raw_level_repr.t

(** Increment the current block fee stash that will be credited to baker's
    frozen_fees account at finalize_application *)
val add_fees : context -&gt; Tez_repr.t -&gt; context tzresult Lwt.t

(** Increment the current block reward stash that will be credited to baker's
    frozen_fees account at finalize_application *)
val add_rewards : context -&gt; Tez_repr.t -&gt; context tzresult Lwt.t

(** Increment the current block deposit stash for a specific delegate. All the
    delegates' frozen_deposit accounts are credited at finalize_application *)
val add_deposit :
  context -&gt;
  Signature.Public_key_hash.t -&gt;
  Tez_repr.t -&gt;
  context tzresult Lwt.t

val get_fees : context -&gt; Tez_repr.t

val get_rewards : context -&gt; Tez_repr.t

val get_deposits : context -&gt; Tez_repr.t Signature.Public_key_hash.Map.t

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Gas_limit_too_high</abbr> (* `Permanent *)

val check_gas_limit : t -&gt; Z.t -&gt; unit tzresult

val set_gas_limit : t -&gt; Z.t -&gt; t

val set_gas_unlimited : t -&gt; t

val gas_level : t -&gt; Gas_limit_repr.t

val gas_consumed : since:t -&gt; until:t -&gt; Z.t

val block_gas_level : t -&gt; Z.t

val init_storage_space_to_pay : t -&gt; t

val update_storage_space_to_pay : t -&gt; Z.t -&gt; t

val update_allocated_contracts_count : t -&gt; t

val clear_storage_space_to_pay : t -&gt; t * Z.t * int

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Undefined_operation_nonce</abbr> (* `Permanent *)

val init_origination_nonce : t -&gt; Operation_hash.t -&gt; t

val origination_nonce : t -&gt; Contract_repr.origination_nonce tzresult

val increment_origination_nonce :
  t -&gt; (t * Contract_repr.origination_nonce) tzresult

val unset_origination_nonce : t -&gt; t

(** {1 Generic accessors} *)

type key = string list

type value = MBytes.t

(** All context manipulation functions. This signature is included
    as-is for direct context accesses, and used in {!Storage_functors}
    to provide restricted views to the context. *)
module type T = sig
  type t

  type context = t

  (** Tells if the key is already defined as a value. *)
  val mem : context -&gt; key -&gt; bool Lwt.t

  (** Tells if the key is already defined as a directory. *)
  val dir_mem : context -&gt; key -&gt; bool Lwt.t

  (** Retrieve the value from the storage bucket ; returns a
      {!Storage_error Missing_key} if the key is not set. *)
  val get : context -&gt; key -&gt; value tzresult Lwt.t

  (** Retrieves the value from the storage bucket ; returns [None] if
      the data is not initialized. *)
  val get_option : context -&gt; key -&gt; value option Lwt.t

  (** Allocates the storage bucket and initializes it ; returns a
      {!Storage_error Existing_key} if the bucket exists. *)
  val init : context -&gt; key -&gt; value -&gt; context tzresult Lwt.t

  (** Updates the content of the bucket ; returns a {!Storage_error
      Missing_key} if the value does not exists. *)
  val set : context -&gt; key -&gt; value -&gt; context tzresult Lwt.t

  (** Allocates the data and initializes it with a value ; just
      updates it if the bucket exists. *)
  val init_set : context -&gt; key -&gt; value -&gt; context Lwt.t

  (** When the value is [Some v], allocates the data and initializes
      it with [v] ; just updates it if the bucket exists. When the
      valus is [None], delete the storage bucket when the value ; does
      nothing if the bucket does not exists. *)
  val set_option : context -&gt; key -&gt; value option -&gt; context Lwt.t

  (** Delete the storage bucket ; returns a {!Storage_error
      Missing_key} if the bucket does not exists. *)
  val delete : context -&gt; key -&gt; context tzresult Lwt.t

  (** Removes the storage bucket and its contents ; does nothing if the
      bucket does not exists. *)
  val remove : context -&gt; key -&gt; context Lwt.t

  (** Recursively removes all the storage buckets and contents ; does
      nothing if no bucket exists. *)
  val remove_rec : context -&gt; key -&gt; context Lwt.t

  val copy : context -&gt; from:key -&gt; to_:key -&gt; context tzresult Lwt.t

  (** Iterator on all the items of a given directory. *)
  val fold :
    context -&gt;
    key -&gt;
    init:'a -&gt;
    f:([`Key of key | `Dir of key] -&gt; 'a -&gt; 'a Lwt.t) -&gt;
    'a Lwt.t

  (** Recursively list all subkeys of a given key. *)
  val keys : context -&gt; key -&gt; key list Lwt.t

  (** Recursive iterator on all the subkeys of a given key. *)
  val fold_keys :
    context -&gt; key -&gt; init:'a -&gt; f:(key -&gt; 'a -&gt; 'a Lwt.t) -&gt; 'a Lwt.t

  (** Internally used in {!Storage_functors} to escape from a view. *)
  val project : context -&gt; root_context

  (** Internally used in {!Storage_functors} to retrieve a full key
      from partial key relative a view. *)
  val absolute_key : context -&gt; key -&gt; key

  (** Internally used in {!Storage_functors} to consume gas from
      within a view. *)
  val consume_gas : context -&gt; Gas_limit_repr.cost -&gt; context tzresult

  (** Check if consume_gas will fail *)
  val check_enough_gas : context -&gt; Gas_limit_repr.cost -&gt; unit tzresult

  val description : context Storage_description.t
end

include T with type t := t and type context := context

(** Initialize the local nonce used for preventing a script to
    duplicate an internal operation to replay it. *)
val reset_internal_nonce : context -&gt; context

(** Increments the internal operation nonce. *)
val fresh_internal_nonce : context -&gt; (context * int) tzresult

(** Mark an internal operation nonce as taken. *)
val record_internal_nonce : context -&gt; int -&gt; context

(** Check is the internal operation nonce has been taken. *)
val internal_nonce_already_recorded : context -&gt; int -&gt; bool

(** Returns a map where to each endorser's pkh is associated the list of its
    endorsing slots (in decreasing order) for a given level. *)
val allowed_endorsements :
  context -&gt;
  (Signature.Public_key.t * int list * bool) Signature.Public_key_hash.Map.t

(** Keep track of the number of endorsements that are included in a block *)
val included_endorsements : context -&gt; int

(** Initializes the map of allowed endorsements, this function must only be
    called once. *)
val init_endorsements :
  context -&gt;
  (Signature.Public_key.t * int list * bool) Signature.Public_key_hash.Map.t -&gt;
  context

(** Marks an endorsment in the map as used. *)
val record_endorsement : context -&gt; Signature.Public_key_hash.t -&gt; context

(** Provide a fresh identifier for a temporary big map (negative index). *)
val fresh_temporary_big_map : context -&gt; context * Z.t

(** Reset the temporary big_map identifier generator to [-1]. *)
val reset_temporary_big_map : context -&gt; context

(** Iterate over all created temporary big maps since the last {!reset_temporary_big_map}. *)
val temporary_big_maps : context -&gt; ('a -&gt; Z.t -&gt; 'a Lwt.t) -&gt; 'a -&gt; 'a Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#raw_context.mli"><code>Raw_context_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Constants_repr.
Require Tezos.Contract_repr.
Require Tezos.Gas_limit_repr.
Require Tezos.Level_repr.
Require Tezos.Parameters_repr.
Require Tezos.Raw_level_repr.
Require Tezos.Storage_description.
Require Tezos.Tez_repr.

(* extensible_type_definition `error` *)

Inductive missing_key_kind : Set :=
| Del : missing_key_kind
| Copy : missing_key_kind
| Get : missing_key_kind
| __Set : missing_key_kind.

Inductive storage_error : Set :=
| Incompatible_protocol_version : string -&gt; storage_error
| Missing_key : list string -&gt; missing_key_kind -&gt; storage_error
| Existing_key : list string -&gt; storage_error
| Corrupted_data : list string -&gt; storage_error.

(* extensible_type_definition `error` *)

(* extensible_type_definition `error` *)

(* extensible_type_definition `error` *)

Parameter __storage_error_value : forall {a : Set},
  storage_error -&gt; Lwt.t (Error_monad.tzresult a).

Parameter t : Set.

Definition context : Set := t.

Definition root_context : Set := t.

Parameter prepare :
  Int32.t -&gt; Time.t -&gt; Time.t -&gt; (|Fitness|).(S.T.t) -&gt; Context.t -&gt;
  Lwt.t (Error_monad.tzresult context).

Inductive previous_protocol : Set :=
| Genesis : Parameters_repr.t -&gt; previous_protocol
| Alpha_previous : previous_protocol.

Parameter prepare_first_block :
  int32 -&gt; Time.t -&gt; (|Fitness|).(S.T.t) -&gt; Context.t -&gt;
  Lwt.t (Error_monad.tzresult (previous_protocol * context)).

Parameter activate : context -&gt; (|Protocol_hash|).(S.HASH.t) -&gt; Lwt.t t.

Parameter fork_test_chain :
  context -&gt; (|Protocol_hash|).(S.HASH.t) -&gt; Time.t -&gt; Lwt.t t.

Parameter recover : context -&gt; Context.t.

Parameter current_level : context -&gt; Level_repr.t.

Parameter predecessor_timestamp : context -&gt; Time.t.

Parameter current_timestamp : context -&gt; Time.t.

Parameter current_fitness : context -&gt; Int64.t.

Parameter set_current_fitness : context -&gt; Int64.t -&gt; t.

Parameter constants : context -&gt; Constants_repr.parametric.

Parameter patch_constants :
  context -&gt; (Constants_repr.parametric -&gt; Constants_repr.parametric) -&gt;
  Lwt.t context.

Parameter first_level : context -&gt; Raw_level_repr.t.

Parameter add_fees :
  context -&gt; Tez_repr.t -&gt; Lwt.t (Error_monad.tzresult context).

Parameter add_rewards :
  context -&gt; Tez_repr.t -&gt; Lwt.t (Error_monad.tzresult context).

Parameter add_deposit :
  context -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Tez_repr.t -&gt; Lwt.t (Error_monad.tzresult context).

Parameter get_fees : context -&gt; Tez_repr.t.

Parameter get_rewards : context -&gt; Tez_repr.t.

Parameter get_deposits :
  context -&gt;
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t)
    Tez_repr.t.

(* extensible_type_definition `error` *)

Parameter check_gas_limit : t -&gt; Z.t -&gt; Error_monad.tzresult unit.

Parameter set_gas_limit : t -&gt; Z.t -&gt; t.

Parameter set_gas_unlimited : t -&gt; t.

Parameter gas_level : t -&gt; Gas_limit_repr.t.

Parameter gas_consumed : t -&gt; t -&gt; Z.t.

Parameter block_gas_level : t -&gt; Z.t.

Parameter init_storage_space_to_pay : t -&gt; t.

Parameter update_storage_space_to_pay : t -&gt; Z.t -&gt; t.

Parameter update_allocated_contracts_count : t -&gt; t.

Parameter clear_storage_space_to_pay : t -&gt; t * Z.t * int.

(* extensible_type_definition `error` *)

Parameter init_origination_nonce : t -&gt; (|Operation_hash|).(S.HASH.t) -&gt; t.

Parameter origination_nonce :
  t -&gt; Error_monad.tzresult Contract_repr.origination_nonce.

Parameter increment_origination_nonce :
  t -&gt; Error_monad.tzresult (t * Contract_repr.origination_nonce).

Parameter unset_origination_nonce : t -&gt; t.

Definition key : Set := list string.

Definition value : Set := MBytes.t.

Module T.
  Record signature {t : Set} : Set := {
    t := t;
    context := t;
    mem : context -&gt; key -&gt; Lwt.t bool;
    dir_mem : context -&gt; key -&gt; Lwt.t bool;
    get : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult value);
    get_option : context -&gt; key -&gt; Lwt.t (option value);
    init : context -&gt; key -&gt; value -&gt; Lwt.t (Error_monad.tzresult context);
    set : context -&gt; key -&gt; value -&gt; Lwt.t (Error_monad.tzresult context);
    init_set : context -&gt; key -&gt; value -&gt; Lwt.t context;
    set_option : context -&gt; key -&gt; option value -&gt; Lwt.t context;
    delete : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult context);
    remove : context -&gt; key -&gt; Lwt.t context;
    remove_rec : context -&gt; key -&gt; Lwt.t context;
    copy : context -&gt; key -&gt; key -&gt; Lwt.t (Error_monad.tzresult context);
    fold : forall {a : Set},
      context -&gt; key -&gt; a -&gt; (Context.dir_or_key -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a;
    keys : context -&gt; key -&gt; Lwt.t (list key);
    fold_keys : forall {a : Set},
      context -&gt; key -&gt; a -&gt; (key -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a;
    project : context -&gt; root_context;
    absolute_key : context -&gt; key -&gt; key;
    consume_gas :
      context -&gt; Gas_limit_repr.cost -&gt; Error_monad.tzresult context;
    check_enough_gas :
      context -&gt; Gas_limit_repr.cost -&gt; Error_monad.tzresult unit;
    description : Storage_description.t context;
  }.
End T.

Parameter Included_T : {_ : unit &amp; T.signature (t := t)}.

Definition mem : context -&gt; key -&gt; Lwt.t bool := (|Included_T|).(T.mem).

Definition dir_mem : context -&gt; key -&gt; Lwt.t bool := (|Included_T|).(T.dir_mem).

Definition get : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult value) :=
  (|Included_T|).(T.get).

Definition get_option : context -&gt; key -&gt; Lwt.t (option value) :=
  (|Included_T|).(T.get_option).

Definition init :
  context -&gt; key -&gt; value -&gt; Lwt.t (Error_monad.tzresult context) :=
  (|Included_T|).(T.init).

Definition set : context -&gt; key -&gt; value -&gt; Lwt.t (Error_monad.tzresult context)
  := (|Included_T|).(T.set).

Definition init_set : context -&gt; key -&gt; value -&gt; Lwt.t context :=
  (|Included_T|).(T.init_set).

Definition set_option : context -&gt; key -&gt; option value -&gt; Lwt.t context :=
  (|Included_T|).(T.set_option).

Definition delete : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult context) :=
  (|Included_T|).(T.delete).

Definition remove : context -&gt; key -&gt; Lwt.t context :=
  (|Included_T|).(T.remove).

Definition remove_rec : context -&gt; key -&gt; Lwt.t context :=
  (|Included_T|).(T.remove_rec).

Definition copy : context -&gt; key -&gt; key -&gt; Lwt.t (Error_monad.tzresult context)
  := (|Included_T|).(T.copy).

Definition fold {a : Set} :
  context -&gt; key -&gt; a -&gt; (Context.dir_or_key -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a :=
  (|Included_T|).(T.fold).

Definition keys : context -&gt; key -&gt; Lwt.t (list key) := (|Included_T|).(T.keys).

Definition fold_keys {a : Set} :
  context -&gt; key -&gt; a -&gt; (key -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a :=
  (|Included_T|).(T.fold_keys).

Definition project : context -&gt; root_context := (|Included_T|).(T.project).

Definition absolute_key : context -&gt; key -&gt; key :=
  (|Included_T|).(T.absolute_key).

Definition consume_gas :
  context -&gt; Gas_limit_repr.cost -&gt; Error_monad.tzresult context :=
  (|Included_T|).(T.consume_gas).

Definition check_enough_gas :
  context -&gt; Gas_limit_repr.cost -&gt; Error_monad.tzresult unit :=
  (|Included_T|).(T.check_enough_gas).

Definition description : Storage_description.t context :=
  (|Included_T|).(T.description).

Parameter reset_internal_nonce : context -&gt; context.

Parameter fresh_internal_nonce :
  context -&gt; Error_monad.tzresult (context * int).

Parameter record_internal_nonce : context -&gt; int -&gt; context.

Parameter internal_nonce_already_recorded : context -&gt; int -&gt; bool.

Parameter allowed_endorsements :
  context -&gt;
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t)
    ((|Signature.Public_key|).(S.SPublic_key.t) * list int * bool).

Parameter included_endorsements : context -&gt; int.

Parameter init_endorsements :
  context -&gt;
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.Map).(S.INDEXES_Map.t)
    ((|Signature.Public_key|).(S.SPublic_key.t) * list int * bool) -&gt; context.

Parameter record_endorsement :
  context -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt; context.

Parameter fresh_temporary_big_map : context -&gt; context * Z.t.

Parameter reset_temporary_big_map : context -&gt; context.

Parameter temporary_big_maps : forall {a : Set},
  context -&gt; (a -&gt; Z.t -&gt; Lwt.t a) -&gt; a -&gt; Lwt.t a.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="raw_level_repr.ml">
  <div style="margin: 20px;">
    <h3>Raw_level_repr</h3>
    <ul>
      <li>OCaml size: 102 lines</li>
      <li>Coq size: 117 lines (+14% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#raw_level_repr.ml"><code>raw_level_repr.ml</code></a>&nbsp;<span class="label label-warning">5 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = int32

type raw_level = t

include (Compare.Int32 : Compare.S with type t := t)

let encoding = Data_encoding.int32

let pp ppf level = Format.fprintf ppf &quot;%ld&quot; level

let rpc_arg =
  let construct raw_level = Int32.to_string raw_level in
  let destruct str =
    match Int32.of_string str with
    | exception <abbr class="mark-warning" title="We do not support pattern-matching on exceptions">_</abbr> -&gt;
        Error &quot;Cannot parse level&quot;
    | raw_level -&gt;
        Ok raw_level
  in
  RPC_arg.make
    ~descr:&quot;A level integer&quot;
    ~name:&quot;block_level&quot;
    ~construct
    ~destruct
    ()

let root = 0l

let succ = Int32.succ

let pred l = if l = 0l then None else Some (Int32.pred l)

let diff = Int32.sub

let to_int32 l = l

let of_int32_exn l =
  if Compare.Int32.(l &gt;= 0l) then l else invalid_arg &quot;Level_repr.of_int32&quot;

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Unexpected_level of Int32.t</abbr> (* `Permanent *)

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  register_error_kind
    `Permanent
    ~id:&quot;unexpected_level&quot;
    ~title:&quot;Unexpected level&quot;
    ~description:&quot;Level must be non-negative.&quot;
    ~pp:(fun ppf l -&gt;
      Format.fprintf
        ppf
        &quot;The level is %s but should be non-negative.&quot;
        (Int32.to_string l))
    Data_encoding.(obj1 (req &quot;level&quot; int32))
    (function Unexpected_level l -&gt; Some l | _ -&gt; None)
    (fun l -&gt; Unexpected_level l)</abbr>

let of_int32 l = <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Ok (of_int32_exn l) with _ -&gt; error (Unexpected_level l)</abbr>

module Index = struct
  type t = raw_level

  let path_length = 1

  let to_path level l = Int32.to_string level :: l

  let of_path = function
    | [s] -&gt; <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(
      try Some (Int32.of_string s) with _ -&gt; None )</abbr>
    | _ -&gt;
        None

  let rpc_arg = rpc_arg

  let encoding = encoding

  let compare = compare
end
</pre>
  </div>
  <div class="col-md-6">
    <a href="#raw_level_repr.ml"><code>Raw_level_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Storage_description.

Definition t : Set := int32.

Definition raw_level : Set := t.

Definition op_eq := (|Compare.Int32|).(Compare.S.op_eq).

Definition op_ltgt := (|Compare.Int32|).(Compare.S.op_ltgt).

Definition op_lt := (|Compare.Int32|).(Compare.S.op_lt).

Definition op_lteq := (|Compare.Int32|).(Compare.S.op_lteq).

Definition op_gteq := (|Compare.Int32|).(Compare.S.op_gteq).

Definition op_gt := (|Compare.Int32|).(Compare.S.op_gt).

Definition compare := (|Compare.Int32|).(Compare.S.compare).

Definition equal := (|Compare.Int32|).(Compare.S.equal).

Definition max := (|Compare.Int32|).(Compare.S.max).

Definition min := (|Compare.Int32|).(Compare.S.min).

Definition encoding : Data_encoding.encoding int32 :=
  Data_encoding.__int32_value.

Definition pp (ppf : Format.formatter) (level : int32) : unit :=
  Format.fprintf ppf
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.Int32 CamlinternalFormatBasics.Int_d
        CamlinternalFormatBasics.No_padding
        CamlinternalFormatBasics.No_precision
        CamlinternalFormatBasics.End_of_format) &quot;%ld&quot;) level.

Definition rpc_arg : RPC_arg.arg int32 :=
  let construct (raw_level : int32) : string :=
    Int32.to_string raw_level in
  let destruct (str : string) : Pervasives.result int32 string :=
    let 'raw_level := Int32.of_string str in
    Pervasives.Ok raw_level in
  RPC_arg.make (Some &quot;A level integer&quot;) &quot;block_level&quot; destruct construct tt.

Definition root : int32 :=
  (* ‚ùå Constant of type int32 is converted to int *)
  0.

Definition succ : int32 -&gt; int32 := Int32.succ.

Definition pred (l : t) : option int32 :=
  if
    op_eq l
      (* ‚ùå Constant of type int32 is converted to int *)
      0 then
    None
  else
    Some (Int32.pred l).

Definition diff : int32 -&gt; int32 -&gt; int32 := Int32.sub.

Definition to_int32 {A : Set} (l : A) : A := l.

Definition of_int32_exn (l : (|Compare.Int32|).(Compare.S.t))
  : (|Compare.Int32|).(Compare.S.t) :=
  if
    (|Compare.Int32|).(Compare.S.op_gteq) l
      (* ‚ùå Constant of type int32 is converted to int *)
      0 then
    l
  else
    Pervasives.invalid_arg &quot;Level_repr.of_int32&quot;.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition of_int32 (l : (|Compare.Int32|).(Compare.S.t))
  : Pervasives.result (|Compare.Int32|).(Compare.S.t) (list Error_monad.__error) :=
  (* ‚ùå Try-with are not handled *)
  try (Pervasives.Ok (of_int32_exn l)).

Definition Index :=
  let t : Set := raw_level in
  let path_length := 1 in
  let to_path (level : int32) (l : list string) : list string :=
    cons (Int32.to_string level) l in
  let of_path (function_parameter : list string) : option int32 :=
    match function_parameter with
    | cons s [] =&gt;
      (* ‚ùå Try-with are not handled *)
      try (Some (Int32.of_string s))
    | _ =&gt; None
    end in
  existT (A := unit) (fun _ =&gt; _) tt
    {|
      Storage_description.INDEX.path_length := path_length;
      Storage_description.INDEX.to_path := to_path;
      Storage_description.INDEX.of_path := of_path;
      Storage_description.INDEX.rpc_arg := rpc_arg;
      Storage_description.INDEX.encoding := encoding;
      Storage_description.INDEX.compare := compare
    |}.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="raw_level_repr.mli">
  <div style="margin: 20px;">
    <h3>Raw_level_repr_mli</h3>
    <ul>
      <li>OCaml size: 55 lines</li>
      <li>Coq size: 71 lines (+29% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#raw_level_repr.mli"><code>raw_level_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** The shell's notion of a level: an integer indicating the number of blocks
    since genesis: genesis is 0, all other blocks have increasing levels from
    there. *)
type t

type raw_level = t

val encoding : raw_level Data_encoding.t

val rpc_arg : raw_level RPC_arg.arg

val pp : Format.formatter -&gt; raw_level -&gt; unit

include Compare.S with type t := raw_level

val to_int32 : raw_level -&gt; int32

val of_int32_exn : int32 -&gt; raw_level

val of_int32 : int32 -&gt; raw_level tzresult

val diff : raw_level -&gt; raw_level -&gt; int32

val root : raw_level

val succ : raw_level -&gt; raw_level

val pred : raw_level -&gt; raw_level option

module Index : Storage_description.INDEX with type t = raw_level
</pre>
  </div>
  <div class="col-md-6">
    <a href="#raw_level_repr.mli"><code>Raw_level_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Storage_description.

Parameter t : Set.

Definition raw_level : Set := t.

Parameter encoding : Data_encoding.t raw_level.

Parameter rpc_arg : RPC_arg.arg raw_level.

Parameter pp : Format.formatter -&gt; raw_level -&gt; unit.

Parameter Included_S : {_ : unit &amp; Compare.S.signature (t := raw_level)}.

Definition op_eq : raw_level -&gt; raw_level -&gt; bool :=
  (|Included_S|).(Compare.S.op_eq).

Definition op_ltgt : raw_level -&gt; raw_level -&gt; bool :=
  (|Included_S|).(Compare.S.op_ltgt).

Definition op_lt : raw_level -&gt; raw_level -&gt; bool :=
  (|Included_S|).(Compare.S.op_lt).

Definition op_lteq : raw_level -&gt; raw_level -&gt; bool :=
  (|Included_S|).(Compare.S.op_lteq).

Definition op_gteq : raw_level -&gt; raw_level -&gt; bool :=
  (|Included_S|).(Compare.S.op_gteq).

Definition op_gt : raw_level -&gt; raw_level -&gt; bool :=
  (|Included_S|).(Compare.S.op_gt).

Definition compare : raw_level -&gt; raw_level -&gt; int :=
  (|Included_S|).(Compare.S.compare).

Definition equal : raw_level -&gt; raw_level -&gt; bool :=
  (|Included_S|).(Compare.S.equal).

Definition max : raw_level -&gt; raw_level -&gt; raw_level :=
  (|Included_S|).(Compare.S.max).

Definition min : raw_level -&gt; raw_level -&gt; raw_level :=
  (|Included_S|).(Compare.S.min).

Parameter to_int32 : raw_level -&gt; int32.

Parameter of_int32_exn : int32 -&gt; raw_level.

Parameter of_int32 : int32 -&gt; Error_monad.tzresult raw_level.

Parameter diff : raw_level -&gt; raw_level -&gt; int32.

Parameter root : raw_level.

Parameter succ : raw_level -&gt; raw_level.

Parameter pred : raw_level -&gt; option raw_level.

Parameter Index :
  {_ : unit &amp; Storage_description.INDEX.signature (t := raw_level)}.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="roll_repr.ml">
  <div style="margin: 20px;">
    <h3>Roll_repr</h3>
    <ul>
      <li>OCaml size: 65 lines</li>
      <li>Coq size: 80 lines (+23% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#roll_repr.ml"><code>roll_repr.ml</code></a>&nbsp;<span class="label label-warning">1 warning</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

include Compare.Int32

type roll = t

let encoding = Data_encoding.int32

let first = 0l

let succ i = Int32.succ i

let random sequence ~bound = Seed_repr.take_int32 sequence bound

let rpc_arg = RPC_arg.like RPC_arg.int32 &quot;roll&quot;

let to_int32 v = v

module Index = struct
  type t = roll

  let path_length = 3

  let to_path roll l =
    (Int32.to_string @@ Int32.logand roll (Int32.of_int 0xff))
    :: ( Int32.to_string
       @@ Int32.logand (Int32.shift_right_logical roll 8) (Int32.of_int 0xff)
       )
    :: Int32.to_string roll :: l

  let of_path = function
    | _ :: _ :: s :: _ -&gt; <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(
      try Some (Int32.of_string s) with _ -&gt; None )</abbr>
    | _ -&gt;
        None

  let rpc_arg = rpc_arg

  let encoding = encoding

  let compare = compare
end
</pre>
  </div>
  <div class="col-md-6">
    <a href="#roll_repr.ml"><code>Roll_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Seed_repr.
Require Tezos.Storage_description.

Definition t := (|Compare.Int32|).(Compare.S.t).

Definition op_eq := (|Compare.Int32|).(Compare.S.op_eq).

Definition op_ltgt := (|Compare.Int32|).(Compare.S.op_ltgt).

Definition op_lt := (|Compare.Int32|).(Compare.S.op_lt).

Definition op_lteq := (|Compare.Int32|).(Compare.S.op_lteq).

Definition op_gteq := (|Compare.Int32|).(Compare.S.op_gteq).

Definition op_gt := (|Compare.Int32|).(Compare.S.op_gt).

Definition compare := (|Compare.Int32|).(Compare.S.compare).

Definition equal := (|Compare.Int32|).(Compare.S.equal).

Definition max := (|Compare.Int32|).(Compare.S.max).

Definition min := (|Compare.Int32|).(Compare.S.min).

Definition roll : Set := t.

Definition encoding : Data_encoding.encoding int32 :=
  Data_encoding.__int32_value.

Definition first : int32 :=
  (* ‚ùå Constant of type int32 is converted to int *)
  0.

Definition succ (i : int32) : int32 := Int32.succ i.

Definition random (__sequence_value : Seed_repr.sequence) (bound : int32)
  : int32 * Seed_repr.sequence := Seed_repr.take_int32 __sequence_value bound.

Definition rpc_arg : RPC_arg.arg int32 :=
  RPC_arg.like RPC_arg.__int32_value None &quot;roll&quot;.

Definition to_int32 {A : Set} (v : A) : A := v.

Definition Index :=
  let t : Set := roll in
  let path_length := 3 in
  let to_path (roll : int32) (l : list string) : list string :=
    cons (Int32.to_string (Int32.logand roll (Int32.of_int 255)))
      (cons
        (Int32.to_string
          (Int32.logand (Int32.shift_right_logical roll 8) (Int32.of_int 255)))
        (cons (Int32.to_string roll) l)) in
  let of_path (function_parameter : list string) : option int32 :=
    match function_parameter with
    | cons _ (cons _ (cons s _)) =&gt;
      (* ‚ùå Try-with are not handled *)
      try (Some (Int32.of_string s))
    | _ =&gt; None
    end in
  existT (A := unit) (fun _ =&gt; _) tt
    {|
      Storage_description.INDEX.path_length := path_length;
      Storage_description.INDEX.to_path := to_path;
      Storage_description.INDEX.of_path := of_path;
      Storage_description.INDEX.rpc_arg := rpc_arg;
      Storage_description.INDEX.encoding := encoding;
      Storage_description.INDEX.compare := compare
    |}.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="roll_repr.mli">
  <div style="margin: 20px;">
    <h3>Roll_repr_mli</h3>
    <ul>
      <li>OCaml size: 44 lines</li>
      <li>Coq size: 33 lines (-25% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#roll_repr.mli"><code>roll_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = private int32

type roll = t

val encoding : roll Data_encoding.t

val rpc_arg : roll RPC_arg.t

val random : Seed_repr.sequence -&gt; bound:roll -&gt; roll * Seed_repr.sequence

val first : roll

val succ : roll -&gt; roll

val to_int32 : roll -&gt; Int32.t

val ( = ) : roll -&gt; roll -&gt; bool

module Index : Storage_description.INDEX with type t = roll
</pre>
  </div>
  <div class="col-md-6">
    <a href="#roll_repr.mli"><code>Roll_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Seed_repr.
Require Tezos.Storage_description.

Definition t : Set := int32.

Definition roll : Set := t.

Parameter encoding : Data_encoding.t roll.

Parameter rpc_arg : RPC_arg.t roll.

Parameter random : Seed_repr.sequence -&gt; roll -&gt; roll * Seed_repr.sequence.

Parameter first : roll.

Parameter succ : roll -&gt; roll.

Parameter to_int32 : roll -&gt; Int32.t.

Parameter op_eq : roll -&gt; roll -&gt; bool.

Parameter Index : {_ : unit &amp; Storage_description.INDEX.signature (t := roll)}.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="roll_storage.ml">
  <div style="margin: 20px;">
    <h3>Roll_storage</h3>
    <ul>
      <li>OCaml size: 604 lines</li>
      <li>Coq size: 796 lines (+31% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#roll_storage.ml"><code>roll_storage.ml</code></a>&nbsp;<span class="label label-warning">7 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Misc

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | Consume_roll_change (* `Permanent *)
  | No_roll_for_delegate (* `Permanent *)
  | No_roll_snapshot_for_cycle of Cycle_repr.t (* `Permanent *)
  | Unregistered_delegate of Signature.Public_key_hash.t</abbr>

(* `Permanent *)

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  let open Data_encoding in
  (* Consume roll change *)
  register_error_kind
    `Permanent
    ~id:&quot;contract.manager.consume_roll_change&quot;
    ~title:&quot;Consume roll change&quot;
    ~description:&quot;Change is not enough to consume a roll.&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf ppf &quot;Not enough change to consume a roll.&quot;)
    empty
    (function Consume_roll_change -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Consume_roll_change) ;
  (* No roll for delegate *)
  register_error_kind
    `Permanent
    ~id:&quot;contract.manager.no_roll_for_delegate&quot;
    ~title:&quot;No roll for delegate&quot;
    ~description:&quot;Delegate has no roll.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Delegate has no roll.&quot;)
    empty
    (function No_roll_for_delegate -&gt; Some () | _ -&gt; None)
    (fun () -&gt; No_roll_for_delegate) ;
  (* No roll snapshot for cycle *)
  register_error_kind
    `Permanent
    ~id:&quot;contract.manager.no_roll_snapshot_for_cycle&quot;
    ~title:&quot;No roll snapshot for cycle&quot;
    ~description:
      &quot;A snapshot of the rolls distribution does not exist for this cycle.&quot;
    ~pp:(fun ppf c -&gt;
      Format.fprintf
        ppf
        &quot;A snapshot of the rolls distribution does not exist for cycle %a&quot;
        Cycle_repr.pp
        c)
    (obj1 (req &quot;cycle&quot; Cycle_repr.encoding))
    (function No_roll_snapshot_for_cycle c -&gt; Some c | _ -&gt; None)
    (fun c -&gt; No_roll_snapshot_for_cycle c) ;
  (* Unregistered delegate *)
  register_error_kind
    `Permanent
    ~id:&quot;contract.manager.unregistered_delegate&quot;
    ~title:&quot;Unregistered delegate&quot;
    ~description:&quot;A contract cannot be delegated to an unregistered delegate&quot;
    ~pp:(fun ppf k -&gt;
      Format.fprintf
        ppf
        &quot;The provided public key (with hash %a) is  not registered as valid \
         delegate key.&quot;
        Signature.Public_key_hash.pp
        k)
    (obj1 (req &quot;hash&quot; Signature.Public_key_hash.encoding))
    (function Unregistered_delegate k -&gt; Some k | _ -&gt; None)
    (fun k -&gt; Unregistered_delegate k)</abbr>

let get_contract_delegate c contract =
  Storage.Contract.Delegate.get_option c contract

let delegate_pubkey ctxt delegate =
  Storage.Contract.Manager.get_option
    ctxt
    (Contract_repr.implicit_contract delegate)
  &gt;&gt;=? function
  | None | Some (Manager_repr.Hash _) -&gt;
      fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Unregistered_delegate delegate)</abbr>
  | Some (Manager_repr.Public_key pk) -&gt;
      return pk

let clear_cycle c cycle =
  Storage.Roll.Snapshot_for_cycle.get c cycle
  &gt;&gt;=? fun index -&gt;
  Storage.Roll.Snapshot_for_cycle.delete c cycle
  &gt;&gt;=? fun c -&gt;
  Storage.Roll.Last_for_snapshot.delete (c, cycle) index
  &gt;&gt;=? fun c -&gt;
  Storage.Roll.Owner.delete_snapshot c (cycle, index) &gt;&gt;= fun c -&gt; return c

let fold ctxt ~f init =
  Storage.Roll.Next.get ctxt
  &gt;&gt;=? fun last -&gt;
  let rec loop ctxt roll acc =
    acc
    &gt;&gt;=? fun acc -&gt;
    if Roll_repr.(roll = last) then return acc
    else
      Storage.Roll.Owner.get_option ctxt roll
      &gt;&gt;=? function
      | None -&gt;
          loop ctxt (Roll_repr.succ roll) (return acc)
      | Some delegate -&gt;
          loop ctxt (Roll_repr.succ roll) (f roll delegate acc)
  in
  loop ctxt Roll_repr.first (return init)

let snapshot_rolls_for_cycle ctxt cycle =
  Storage.Roll.Snapshot_for_cycle.get ctxt cycle
  &gt;&gt;=? fun index -&gt;
  Storage.Roll.Snapshot_for_cycle.set ctxt cycle (index + 1)
  &gt;&gt;=? fun ctxt -&gt;
  Storage.Roll.Owner.snapshot ctxt (cycle, index)
  &gt;&gt;=? fun ctxt -&gt;
  Storage.Roll.Next.get ctxt
  &gt;&gt;=? fun last -&gt;
  Storage.Roll.Last_for_snapshot.init (ctxt, cycle) index last
  &gt;&gt;=? fun ctxt -&gt; return ctxt

let freeze_rolls_for_cycle ctxt cycle =
  Storage.Roll.Snapshot_for_cycle.get ctxt cycle
  &gt;&gt;=? fun max_index -&gt;
  Storage.Seed.For_cycle.get ctxt cycle
  &gt;&gt;=? fun seed -&gt;
  let rd = Seed_repr.initialize_new seed [MBytes.of_string &quot;roll_snapshot&quot;] in
  let seq = Seed_repr.sequence rd 0l in
  let selected_index =
    Seed_repr.take_int32 seq (Int32.of_int max_index) |&gt; fst |&gt; Int32.to_int
  in
  Storage.Roll.Snapshot_for_cycle.set ctxt cycle selected_index
  &gt;&gt;=? fun ctxt -&gt;
  fold_left_s
    (fun ctxt index -&gt;
      if Compare.Int.(index = selected_index) then return ctxt
      else
        Storage.Roll.Owner.delete_snapshot ctxt (cycle, index)
        &gt;&gt;= fun ctxt -&gt;
        Storage.Roll.Last_for_snapshot.delete (ctxt, cycle) index
        &gt;&gt;=? fun ctxt -&gt; return ctxt)
    ctxt
    Misc.(0 --&gt; (max_index - 1))
  &gt;&gt;=? fun ctxt -&gt; return ctxt

(* Roll selection *)

module Random = struct
  let int32_to_bytes i =
    let b = MBytes.create 4 in
    <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">MBytes.set_int32 b 0 i</abbr> ; b

  let level_random seed use level =
    let position = level.Level_repr.cycle_position in
    Seed_repr.initialize_new
      seed
      [MBytes.of_string (&quot;level &quot; ^ use ^ &quot;:&quot;); int32_to_bytes position]

  let owner c kind level offset =
    let cycle = level.Level_repr.cycle in
    Seed_storage.for_cycle c cycle
    &gt;&gt;=? fun random_seed -&gt;
    let rd = level_random random_seed kind level in
    let sequence = Seed_repr.sequence rd (Int32.of_int offset) in
    Storage.Roll.Snapshot_for_cycle.get c cycle
    &gt;&gt;=? fun index -&gt;
    Storage.Roll.Last_for_snapshot.get (c, cycle) index
    &gt;&gt;=? fun bound -&gt;
    let rec loop sequence =
      let (roll, sequence) = Roll_repr.random sequence ~bound in
      Storage.Roll.Owner.Snapshot.get_option c ((cycle, index), roll)
      &gt;&gt;=? function None -&gt; loop sequence | Some delegate -&gt; return delegate
    in
    Storage.Roll.Owner.snapshot_exists c (cycle, index)
    &gt;&gt;= fun snapshot_exists -&gt;
    fail_unless snapshot_exists <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(No_roll_snapshot_for_cycle cycle)</abbr>
    &gt;&gt;=? fun () -&gt; loop sequence
end

let baking_rights_owner c level ~priority =
  Random.owner c &quot;baking&quot; level priority

let endorsement_rights_owner c level ~slot =
  Random.owner c &quot;endorsement&quot; level slot

let traverse_rolls ctxt head =
  let rec loop acc roll =
    Storage.Roll.Successor.get_option ctxt roll
    &gt;&gt;=? function
    | None -&gt; return (List.rev acc) | Some next -&gt; loop (next :: acc) next
  in
  loop [head] head

let get_rolls ctxt delegate =
  Storage.Roll.Delegate_roll_list.get_option ctxt delegate
  &gt;&gt;=? function
  | None -&gt; return_nil | Some head_roll -&gt; traverse_rolls ctxt head_roll

let count_rolls ctxt delegate =
  Storage.Roll.Delegate_roll_list.get_option ctxt delegate
  &gt;&gt;=? function
  | None -&gt;
      return 0
  | Some head_roll -&gt;
      let rec loop acc roll =
        Storage.Roll.Successor.get_option ctxt roll
        &gt;&gt;=? function None -&gt; return acc | Some next -&gt; loop (succ acc) next
      in
      loop 1 head_roll

let get_change c delegate =
  Storage.Roll.Delegate_change.get_option c delegate
  &gt;&gt;=? function None -&gt; return Tez_repr.zero | Some change -&gt; return change

module Delegate = struct
  let fresh_roll c =
    Storage.Roll.Next.get c
    &gt;&gt;=? fun roll -&gt;
    Storage.Roll.Next.set c (Roll_repr.succ roll) &gt;&gt;=? fun c -&gt; return (roll, c)

  let get_limbo_roll c =
    Storage.Roll.Limbo.get_option c
    &gt;&gt;=? function
    | None -&gt;
        fresh_roll c
        &gt;&gt;=? fun (roll, c) -&gt;
        Storage.Roll.Limbo.init c roll &gt;&gt;=? fun c -&gt; return (roll, c)
    | Some roll -&gt;
        return (roll, c)

  let consume_roll_change c delegate =
    let tokens_per_roll = Constants_storage.tokens_per_roll c in
    Storage.Roll.Delegate_change.get c delegate
    &gt;&gt;=? fun change -&gt;
    trace <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Consume_roll_change</abbr> (Lwt.return Tez_repr.(change -? tokens_per_roll))
    &gt;&gt;=? fun new_change -&gt;
    Storage.Roll.Delegate_change.set c delegate new_change

  let recover_roll_change c delegate =
    let tokens_per_roll = Constants_storage.tokens_per_roll c in
    Storage.Roll.Delegate_change.get c delegate
    &gt;&gt;=? fun change -&gt;
    Lwt.return Tez_repr.(change +? tokens_per_roll)
    &gt;&gt;=? fun new_change -&gt;
    Storage.Roll.Delegate_change.set c delegate new_change

  let pop_roll_from_delegate c delegate =
    recover_roll_change c delegate
    &gt;&gt;=? fun c -&gt;
    (* beginning:
       delegate : roll -&gt; successor_roll -&gt; ...
       limbo : limbo_head -&gt; ...
    *)
    Storage.Roll.Limbo.get_option c
    &gt;&gt;=? fun limbo_head -&gt;
    Storage.Roll.Delegate_roll_list.get_option c delegate
    &gt;&gt;=? function
    | None -&gt;
        fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">No_roll_for_delegate</abbr>
    | Some roll -&gt;
        Storage.Roll.Owner.delete c roll
        &gt;&gt;=? fun c -&gt;
        Storage.Roll.Successor.get_option c roll
        &gt;&gt;=? fun successor_roll -&gt;
        Storage.Roll.Delegate_roll_list.set_option c delegate successor_roll
        &gt;&gt;= fun c -&gt;
        (* delegate : successor_roll -&gt; ...
           roll ------^
           limbo : limbo_head -&gt; ... *)
        Storage.Roll.Successor.set_option c roll limbo_head
        &gt;&gt;= fun c -&gt;
        (* delegate : successor_roll -&gt; ...
           roll ------v
           limbo : limbo_head -&gt; ... *)
        Storage.Roll.Limbo.init_set c roll
        &gt;&gt;= fun c -&gt;
        (* delegate : successor_roll -&gt; ...
           limbo : roll -&gt; limbo_head -&gt; ... *)
        return (roll, c)

  let create_roll_in_delegate c delegate delegate_pk =
    consume_roll_change c delegate
    &gt;&gt;=? fun c -&gt;
    (* beginning:
       delegate : delegate_head -&gt; ...
       limbo : roll -&gt; limbo_successor -&gt; ...
    *)
    Storage.Roll.Delegate_roll_list.get_option c delegate
    &gt;&gt;=? fun delegate_head -&gt;
    get_limbo_roll c
    &gt;&gt;=? fun (roll, c) -&gt;
    Storage.Roll.Owner.init c roll delegate_pk
    &gt;&gt;=? fun c -&gt;
    Storage.Roll.Successor.get_option c roll
    &gt;&gt;=? fun limbo_successor -&gt;
    Storage.Roll.Limbo.set_option c limbo_successor
    &gt;&gt;= fun c -&gt;
    (* delegate : delegate_head -&gt; ...
       roll ------v
       limbo : limbo_successor -&gt; ... *)
    Storage.Roll.Successor.set_option c roll delegate_head
    &gt;&gt;= fun c -&gt;
    (* delegate : delegate_head -&gt; ...
       roll ------^
       limbo : limbo_successor -&gt; ... *)
    Storage.Roll.Delegate_roll_list.init_set c delegate roll
    &gt;&gt;= fun c -&gt;
    (* delegate : roll -&gt; delegate_head -&gt; ...
       limbo : limbo_successor -&gt; ... *)
    return c

  let ensure_inited c delegate =
    Storage.Roll.Delegate_change.mem c delegate
    &gt;&gt;= function
    | true -&gt;
        return c
    | false -&gt;
        Storage.Roll.Delegate_change.init c delegate Tez_repr.zero

  let is_inactive c delegate =
    Storage.Contract.Inactive_delegate.mem
      c
      (Contract_repr.implicit_contract delegate)
    &gt;&gt;= fun inactive -&gt;
    if inactive then return inactive
    else
      Storage.Contract.Delegate_desactivation.get_option
        c
        (Contract_repr.implicit_contract delegate)
      &gt;&gt;=? function
      | Some last_active_cycle -&gt;
          let {Level_repr.cycle = current_cycle} =
            Raw_context.current_level c
          in
          return Cycle_repr.(last_active_cycle &lt; current_cycle)
      | None -&gt;
          (* This case is only when called from `set_active`, when creating
             a contract. *)
          return_false

  let add_amount c delegate amount =
    ensure_inited c delegate
    &gt;&gt;=? fun c -&gt;
    let tokens_per_roll = Constants_storage.tokens_per_roll c in
    Storage.Roll.Delegate_change.get c delegate
    &gt;&gt;=? fun change -&gt;
    Lwt.return Tez_repr.(amount +? change)
    &gt;&gt;=? fun change -&gt;
    Storage.Roll.Delegate_change.set c delegate change
    &gt;&gt;=? fun c -&gt;
    delegate_pubkey c delegate
    &gt;&gt;=? fun delegate_pk -&gt;
    let rec loop c change =
      if Tez_repr.(change &lt; tokens_per_roll) then return c
      else
        Lwt.return Tez_repr.(change -? tokens_per_roll)
        &gt;&gt;=? fun change -&gt;
        create_roll_in_delegate c delegate delegate_pk
        &gt;&gt;=? fun c -&gt; loop c change
    in
    is_inactive c delegate
    &gt;&gt;=? fun inactive -&gt;
    if inactive then return c
    else
      loop c change
      &gt;&gt;=? fun c -&gt;
      Storage.Roll.Delegate_roll_list.get_option c delegate
      &gt;&gt;=? fun rolls -&gt;
      match rolls with
      | None -&gt;
          return c
      | Some _ -&gt;
          Storage.Active_delegates_with_rolls.add c delegate
          &gt;&gt;= fun c -&gt; return c

  let remove_amount c delegate amount =
    let tokens_per_roll = Constants_storage.tokens_per_roll c in
    let rec loop c change =
      if Tez_repr.(amount &lt;= change) then return (c, change)
      else
        pop_roll_from_delegate c delegate
        &gt;&gt;=? fun (_, c) -&gt;
        Lwt.return Tez_repr.(change +? tokens_per_roll)
        &gt;&gt;=? fun change -&gt; loop c change
    in
    Storage.Roll.Delegate_change.get c delegate
    &gt;&gt;=? fun change -&gt;
    is_inactive c delegate
    &gt;&gt;=? fun inactive -&gt;
    ( if inactive then return (c, change)
    else
      loop c change
      &gt;&gt;=? fun (c, change) -&gt;
      Storage.Roll.Delegate_roll_list.get_option c delegate
      &gt;&gt;=? fun rolls -&gt;
      match rolls with
      | None -&gt;
          Storage.Active_delegates_with_rolls.del c delegate
          &gt;&gt;= fun c -&gt; return (c, change)
      | Some _ -&gt;
          return (c, change) )
    &gt;&gt;=? fun (c, change) -&gt;
    Lwt.return Tez_repr.(change -? amount)
    &gt;&gt;=? fun change -&gt; Storage.Roll.Delegate_change.set c delegate change

  let set_inactive ctxt delegate =
    ensure_inited ctxt delegate
    &gt;&gt;=? fun ctxt -&gt;
    let tokens_per_roll = Constants_storage.tokens_per_roll ctxt in
    Storage.Roll.Delegate_change.get ctxt delegate
    &gt;&gt;=? fun change -&gt;
    Storage.Contract.Inactive_delegate.add
      ctxt
      (Contract_repr.implicit_contract delegate)
    &gt;&gt;= fun ctxt -&gt;
    Storage.Active_delegates_with_rolls.del ctxt delegate
    &gt;&gt;= fun ctxt -&gt;
    let rec loop ctxt change =
      Storage.Roll.Delegate_roll_list.get_option ctxt delegate
      &gt;&gt;=? function
      | None -&gt;
          return (ctxt, change)
      | Some _roll -&gt;
          pop_roll_from_delegate ctxt delegate
          &gt;&gt;=? fun (_, ctxt) -&gt;
          Lwt.return Tez_repr.(change +? tokens_per_roll)
          &gt;&gt;=? fun change -&gt; loop ctxt change
    in
    loop ctxt change
    &gt;&gt;=? fun (ctxt, change) -&gt;
    Storage.Roll.Delegate_change.set ctxt delegate change
    &gt;&gt;=? fun ctxt -&gt; return ctxt

  let set_active ctxt delegate =
    is_inactive ctxt delegate
    &gt;&gt;=? fun inactive -&gt;
    let current_cycle = (Raw_context.current_level ctxt).cycle in
    let preserved_cycles = Constants_storage.preserved_cycles ctxt in
    (* When the delegate is new or inactive, she will become active in
       `1+preserved_cycles`, and we allow `preserved_cycles` for the
       delegate to start baking. When the delegate is active, we only
       give her at least `preserved_cycles` after the current cycle
       before to be deactivated.  *)
    Storage.Contract.Delegate_desactivation.get_option
      ctxt
      (Contract_repr.implicit_contract delegate)
    &gt;&gt;=? fun current_expiration -&gt;
    let expiration =
      match current_expiration with
      | None -&gt;
          Cycle_repr.add current_cycle (1 + (2 * preserved_cycles))
      | Some current_expiration -&gt;
          let delay =
            if inactive then 1 + (2 * preserved_cycles)
            else 1 + preserved_cycles
          in
          let updated = Cycle_repr.add current_cycle delay in
          Cycle_repr.max current_expiration updated
    in
    Storage.Contract.Delegate_desactivation.init_set
      ctxt
      (Contract_repr.implicit_contract delegate)
      expiration
    &gt;&gt;= fun ctxt -&gt;
    if not inactive then return ctxt
    else
      ensure_inited ctxt delegate
      &gt;&gt;=? fun ctxt -&gt;
      let tokens_per_roll = Constants_storage.tokens_per_roll ctxt in
      Storage.Roll.Delegate_change.get ctxt delegate
      &gt;&gt;=? fun change -&gt;
      Storage.Contract.Inactive_delegate.del
        ctxt
        (Contract_repr.implicit_contract delegate)
      &gt;&gt;= fun ctxt -&gt;
      delegate_pubkey ctxt delegate
      &gt;&gt;=? fun delegate_pk -&gt;
      let rec loop ctxt change =
        if Tez_repr.(change &lt; tokens_per_roll) then return ctxt
        else
          Lwt.return Tez_repr.(change -? tokens_per_roll)
          &gt;&gt;=? fun change -&gt;
          create_roll_in_delegate ctxt delegate delegate_pk
          &gt;&gt;=? fun ctxt -&gt; loop ctxt change
      in
      loop ctxt change
      &gt;&gt;=? fun ctxt -&gt;
      Storage.Roll.Delegate_roll_list.get_option ctxt delegate
      &gt;&gt;=? fun rolls -&gt;
      match rolls with
      | None -&gt;
          return ctxt
      | Some _ -&gt;
          Storage.Active_delegates_with_rolls.add ctxt delegate
          &gt;&gt;= fun ctxt -&gt; return ctxt
end

module Contract = struct
  let add_amount c contract amount =
    get_contract_delegate c contract
    &gt;&gt;=? function
    | None -&gt; return c | Some delegate -&gt; Delegate.add_amount c delegate amount

  let remove_amount c contract amount =
    get_contract_delegate c contract
    &gt;&gt;=? function
    | None -&gt;
        return c
    | Some delegate -&gt;
        Delegate.remove_amount c delegate amount
end

let init ctxt = Storage.Roll.Next.init ctxt Roll_repr.first

let init_first_cycles ctxt =
  let preserved = Constants_storage.preserved_cycles ctxt in
  (* Precompute rolls for cycle (0 --&gt; preserved_cycles) *)
  List.fold_left
    (fun ctxt c -&gt;
      ctxt
      &gt;&gt;=? fun ctxt -&gt;
      let cycle = Cycle_repr.of_int32_exn (Int32.of_int c) in
      Storage.Roll.Snapshot_for_cycle.init ctxt cycle 0
      &gt;&gt;=? fun ctxt -&gt;
      snapshot_rolls_for_cycle ctxt cycle
      &gt;&gt;=? fun ctxt -&gt; freeze_rolls_for_cycle ctxt cycle)
    (return ctxt)
    (0 --&gt; preserved)
  &gt;&gt;=? fun ctxt -&gt;
  let cycle = Cycle_repr.of_int32_exn (Int32.of_int (preserved + 1)) in
  (* Precomputed a snapshot for cycle (preserved_cycles + 1) *)
  Storage.Roll.Snapshot_for_cycle.init ctxt cycle 0
  &gt;&gt;=? fun ctxt -&gt;
  snapshot_rolls_for_cycle ctxt cycle
  &gt;&gt;=? fun ctxt -&gt;
  (* Prepare storage for storing snapshots for cycle (preserved_cycles+2) *)
  let cycle = Cycle_repr.of_int32_exn (Int32.of_int (preserved + 2)) in
  Storage.Roll.Snapshot_for_cycle.init ctxt cycle 0
  &gt;&gt;=? fun ctxt -&gt; return ctxt

let snapshot_rolls ctxt =
  let current_level = Raw_context.current_level ctxt in
  let preserved = Constants_storage.preserved_cycles ctxt in
  let cycle = Cycle_repr.add current_level.cycle (preserved + 2) in
  snapshot_rolls_for_cycle ctxt cycle

let cycle_end ctxt last_cycle =
  let preserved = Constants_storage.preserved_cycles ctxt in
  ( match Cycle_repr.sub last_cycle preserved with
  | None -&gt;
      return ctxt
  | Some cleared_cycle -&gt;
      clear_cycle ctxt cleared_cycle )
  &gt;&gt;=? fun ctxt -&gt;
  let frozen_roll_cycle = Cycle_repr.add last_cycle (preserved + 1) in
  freeze_rolls_for_cycle ctxt frozen_roll_cycle
  &gt;&gt;=? fun ctxt -&gt;
  Storage.Roll.Snapshot_for_cycle.init
    ctxt
    (Cycle_repr.succ (Cycle_repr.succ frozen_roll_cycle))
    0
  &gt;&gt;=? fun ctxt -&gt; return ctxt

let update_tokens_per_roll ctxt new_tokens_per_roll =
  let constants = Raw_context.constants ctxt in
  let old_tokens_per_roll = constants.tokens_per_roll in
  Raw_context.patch_constants ctxt (fun constants -&gt;
      {constants with Constants_repr.tokens_per_roll = new_tokens_per_roll})
  &gt;&gt;= fun ctxt -&gt;
  let decrease = Tez_repr.(new_tokens_per_roll &lt; old_tokens_per_roll) in
  ( if decrease then
    Lwt.return Tez_repr.(old_tokens_per_roll -? new_tokens_per_roll)
  else Lwt.return Tez_repr.(new_tokens_per_roll -? old_tokens_per_roll) )
  &gt;&gt;=? fun abs_diff -&gt;
  Storage.Delegates.fold ctxt (Ok ctxt) (fun pkh ctxt -&gt;
      Lwt.return ctxt
      &gt;&gt;=? fun ctxt -&gt;
      count_rolls ctxt pkh
      &gt;&gt;=? fun rolls -&gt;
      Lwt.return Tez_repr.(abs_diff *? Int64.of_int rolls)
      &gt;&gt;=? fun amount -&gt;
      if decrease then Delegate.add_amount ctxt pkh amount
      else Delegate.remove_amount ctxt pkh amount)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#roll_storage.ml"><code>Roll_storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Constants_repr.
Require Tezos.Constants_storage.
Require Tezos.Contract_repr.
Require Tezos.Cycle_repr.
Require Tezos.Level_repr.
Require Tezos.Manager_repr.
Require Tezos.Misc.
Require Tezos.Raw_context.
Require Tezos.Roll_repr.
Require Tezos.Seed_repr.
Require Tezos.Seed_storage.
Require Tezos.Storage_mli. Module Storage := Storage_mli.
Require Tezos.Storage_sigs.
Require Tezos.Tez_repr.

Import Misc.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition get_contract_delegate
  (c : (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.context))
  (contract :
    (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t
    (Error_monad.tzresult
      (option
        (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.value))) :=
  (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.get_option) c
    contract.

Definition delegate_pubkey
  (ctxt :
    (|Storage.Contract.Manager|).(Storage_sigs.Indexed_data_storage.context))
  (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
  : Lwt.t (Error_monad.tzresult (|Signature.Public_key|).(S.SPublic_key.t)) :=
  let=? function_parameter :=
    (|Storage.Contract.Manager|).(Storage_sigs.Indexed_data_storage.get_option)
      ctxt (Contract_repr.implicit_contract delegate) in
  match function_parameter with
  | (None | Some (Manager_repr.Hash _)) =&gt;
    Error_monad.fail extensible_type_value
  | Some (Manager_repr.Public_key pk) =&gt; Error_monad.__return pk
  end.

Definition clear_cycle
  (c :
    (|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.context))
  (cycle :
    (|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let=? index :=
    (|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.get)
      c cycle in
  let=? c :=
    (|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.delete)
      c cycle in
  let=? c :=
    (|Storage.Roll.Last_for_snapshot|).(Storage_sigs.Indexed_data_storage.delete)
      (c, cycle) index in
  let= c :=
    (|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.delete_snapshot)
      c (cycle, index) in
  Error_monad.__return c.

Definition fold {A : Set}
  (ctxt : (|Storage.Roll.Next|).(Storage_sigs.Single_data_storage.context))
  (f :
    Roll_repr.roll -&gt;
    (|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.value)
    -&gt; A -&gt; Lwt.t (Error_monad.tzresult A)) (init : A)
  : Lwt.t (Error_monad.tzresult A) :=
  let=? last :=
    (|Storage.Roll.Next|).(Storage_sigs.Single_data_storage.get) ctxt in
  let fix loop
    (ctxt :
      (|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.context))
    (roll : Roll_repr.roll) (acc : Lwt.t (Error_monad.tzresult A)) {struct ctxt}
    : Lwt.t (Error_monad.tzresult A) :=
    let=? acc := acc in
    if Roll_repr.op_eq roll last then
      Error_monad.__return acc
    else
      let=? function_parameter :=
        (|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.get_option)
          ctxt roll in
      match function_parameter with
      | None =&gt; loop ctxt (Roll_repr.succ roll) (Error_monad.__return acc)
      | Some delegate =&gt; loop ctxt (Roll_repr.succ roll) (f roll delegate acc)
      end in
  loop ctxt Roll_repr.first (Error_monad.__return init).

Definition snapshot_rolls_for_cycle
  (ctxt :
    (|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.context))
  (cycle :
    (|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let=? index :=
    (|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.get)
      ctxt cycle in
  let=? ctxt :=
    (|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.set)
      ctxt cycle (Pervasives.op_plus index 1) in
  let=? ctxt :=
    (|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.__snapshot_value)
      ctxt (cycle, index) in
  let=? last :=
    (|Storage.Roll.Next|).(Storage_sigs.Single_data_storage.get) ctxt in
  let=? ctxt :=
    (|Storage.Roll.Last_for_snapshot|).(Storage_sigs.Indexed_data_storage.init)
      (ctxt, cycle) index last in
  Error_monad.__return ctxt.

Definition freeze_rolls_for_cycle
  (ctxt :
    (|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.context))
  (cycle :
    (|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t
    (Error_monad.tzresult
      (|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.context)) :=
  let=? max_index :=
    (|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.get)
      ctxt cycle in
  let=? __seed_value :=
    (|Storage.Seed.For_cycle|).(Storage.For_cycle_sig.get) ctxt cycle in
  let rd :=
    Seed_repr.initialize_new __seed_value [ MBytes.of_string &quot;roll_snapshot&quot; ]
    in
  let seq :=
    Seed_repr.__sequence_value rd
      (* ‚ùå Constant of type int32 is converted to int *)
      0 in
  let selected_index :=
    Int32.to_int
      (Pervasives.fst (Seed_repr.take_int32 seq (Int32.of_int max_index))) in
  let=? ctxt :=
    (|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.set)
      ctxt cycle selected_index in
  let=? ctxt :=
    Error_monad.fold_left_s
      (fun ctxt =&gt;
        fun index =&gt;
          if (|Compare.Int|).(Compare.S.op_eq) index selected_index then
            Error_monad.__return ctxt
          else
            let= ctxt :=
              (|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.delete_snapshot)
                ctxt (cycle, index) in
            let=? ctxt :=
              (|Storage.Roll.Last_for_snapshot|).(Storage_sigs.Indexed_data_storage.delete)
                (ctxt, cycle) index in
            Error_monad.__return ctxt) ctxt
      (Misc.op_minusminusgt 0 (Pervasives.op_minus max_index 1)) in
  Error_monad.__return ctxt.

Module Random.
  Definition int32_to_bytes (i : int32) : MBytes.t :=
    let __b_value := MBytes.create 4 in
    (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
    (* ‚ùå instruction_sequence &quot;;&quot; *)
    __b_value.
  
  Definition level_random
    (__seed_value : Seed_repr.seed) (use : string) (level : Level_repr.t)
    : Seed_repr.t :=
    let position := level.(Level_repr.t.cycle_position) in
    Seed_repr.initialize_new __seed_value
      [
        MBytes.of_string
          (Pervasives.op_caret &quot;level &quot; (Pervasives.op_caret use &quot;:&quot;));
        int32_to_bytes position
      ].
  
  Definition owner
    (c : Raw_context.t) (kind : string) (level : Level_repr.t) (offset : int)
    : Lwt.t
      (Error_monad.tzresult
        (|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.Snapshot).(Storage_sigs.Indexed_data_storage.value)) :=
    let cycle := level.(Level_repr.t.cycle) in
    let=? random_seed := Seed_storage.for_cycle c cycle in
    let rd := level_random random_seed kind level in
    let __sequence_value := Seed_repr.__sequence_value rd (Int32.of_int offset)
      in
    let=? index :=
      (|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.get)
        c cycle in
    let=? bound :=
      (|Storage.Roll.Last_for_snapshot|).(Storage_sigs.Indexed_data_storage.get)
        (c, cycle) index in
    let fix loop (__sequence_value : Seed_repr.sequence)
      {struct __sequence_value}
      : Lwt.t
        (Error_monad.tzresult
          (|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.Snapshot).(Storage_sigs.Indexed_data_storage.value)) :=
      let '(roll, __sequence_value) := Roll_repr.random __sequence_value bound
        in
      let=? function_parameter :=
        (|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.Snapshot).(Storage_sigs.Indexed_data_storage.get_option)
          c ((cycle, index), roll) in
      match function_parameter with
      | None =&gt; loop __sequence_value
      | Some delegate =&gt; Error_monad.__return delegate
      end in
    let= snapshot_exists :=
      (|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.snapshot_exists)
        c (cycle, index) in
    let=? '_ := Error_monad.fail_unless snapshot_exists extensible_type_value in
    loop __sequence_value.
End Random.

Definition baking_rights_owner
  (c : Raw_context.t) (level : Level_repr.t) (priority : int)
  : Lwt.t
    (Error_monad.tzresult
      (|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.Snapshot).(Storage_sigs.Indexed_data_storage.value)) :=
  Random.owner c &quot;baking&quot; level priority.

Definition endorsement_rights_owner
  (c : Raw_context.t) (level : Level_repr.t) (slot : int)
  : Lwt.t
    (Error_monad.tzresult
      (|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.Snapshot).(Storage_sigs.Indexed_data_storage.value)) :=
  Random.owner c &quot;endorsement&quot; level slot.

Definition traverse_rolls
  (ctxt : (|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.context))
  (head : (|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.value))
  : Lwt.t
    (Error_monad.tzresult
      (list (|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.value))) :=
  let fix loop
    (acc :
      list (|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.value))
    (roll : (|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.key))
    {struct acc}
    : Lwt.t
      (Error_monad.tzresult
        (list
          (|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.value))) :=
    let=? function_parameter :=
      (|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.get_option)
        ctxt roll in
    match function_parameter with
    | None =&gt; Error_monad.__return (List.rev acc)
    | Some next =&gt; loop (cons next acc) next
    end in
  loop [ head ] head.

Definition get_rolls
  (ctxt :
    (|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.context))
  (delegate :
    (|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t
    (Error_monad.tzresult
      (list (|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.value))) :=
  let=? function_parameter :=
    (|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.get_option)
      ctxt delegate in
  match function_parameter with
  | None =&gt; Error_monad.return_nil
  | Some head_roll =&gt; traverse_rolls ctxt head_roll
  end.

Definition count_rolls
  (ctxt :
    (|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.context))
  (delegate :
    (|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t (Error_monad.tzresult int) :=
  let=? function_parameter :=
    (|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.get_option)
      ctxt delegate in
  match function_parameter with
  | None =&gt; Error_monad.__return 0
  | Some head_roll =&gt;
    let fix loop
      (acc : int)
      (roll : (|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.key))
      {struct acc} : Lwt.t (Error_monad.tzresult int) :=
      let=? function_parameter :=
        (|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.get_option)
          ctxt roll in
      match function_parameter with
      | None =&gt; Error_monad.__return acc
      | Some next =&gt; loop (Pervasives.succ acc) next
      end in
    loop 1 head_roll
  end.

Definition get_change
  (c :
    (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.context))
  (delegate :
    (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t (Error_monad.tzresult Tez_repr.t) :=
  let=? function_parameter :=
    (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.get_option)
      c delegate in
  match function_parameter with
  | None =&gt; Error_monad.__return Tez_repr.zero
  | Some change =&gt; Error_monad.__return change
  end.

Module Delegate.
  Definition fresh_roll
    (c : (|Storage.Roll.Next|).(Storage_sigs.Single_data_storage.context))
    : Lwt.t
      (Error_monad.tzresult
        ((|Storage.Roll.Next|).(Storage_sigs.Single_data_storage.value) *
          Raw_context.t)) :=
    let=? roll := (|Storage.Roll.Next|).(Storage_sigs.Single_data_storage.get) c
      in
    let=? c :=
      (|Storage.Roll.Next|).(Storage_sigs.Single_data_storage.set) c
        (Roll_repr.succ roll) in
    Error_monad.__return (roll, c).
  
  Definition get_limbo_roll
    (c : (|Storage.Roll.Limbo|).(Storage_sigs.Single_data_storage.context))
    : Lwt.t
      (Error_monad.tzresult
        ((|Storage.Roll.Next|).(Storage_sigs.Single_data_storage.value) *
          Raw_context.t)) :=
    let=? function_parameter :=
      (|Storage.Roll.Limbo|).(Storage_sigs.Single_data_storage.get_option) c in
    match function_parameter with
    | None =&gt;
      let=? '(roll, c) := fresh_roll c in
      let=? c :=
        (|Storage.Roll.Limbo|).(Storage_sigs.Single_data_storage.init) c roll in
      Error_monad.__return (roll, c)
    | Some roll =&gt; Error_monad.__return (roll, c)
    end.
  
  Definition consume_roll_change
    (c : Raw_context.context)
    (delegate :
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.key))
    : Lwt.t (Error_monad.tzresult Raw_context.t) :=
    let tokens_per_roll := Constants_storage.tokens_per_roll c in
    let=? change :=
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.get) c
        delegate in
    let=? new_change :=
      Error_monad.trace extensible_type_value
        (Lwt.__return (Tez_repr.op_minusquestion change tokens_per_roll)) in
    (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.set) c
      delegate new_change.
  
  Definition recover_roll_change
    (c : Raw_context.context)
    (delegate :
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.key))
    : Lwt.t (Error_monad.tzresult Raw_context.t) :=
    let tokens_per_roll := Constants_storage.tokens_per_roll c in
    let=? change :=
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.get) c
        delegate in
    let=? new_change :=
      Lwt.__return (Tez_repr.op_plusquestion change tokens_per_roll) in
    (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.set) c
      delegate new_change.
  
  Definition pop_roll_from_delegate
    (c : Raw_context.context)
    (delegate :
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.key))
    : Lwt.t
      (Error_monad.tzresult
        ((|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.value)
          * Raw_context.t)) :=
    let=? c := recover_roll_change c delegate in
    let=? limbo_head :=
      (|Storage.Roll.Limbo|).(Storage_sigs.Single_data_storage.get_option) c in
    let=? function_parameter :=
      (|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.get_option)
        c delegate in
    match function_parameter with
    | None =&gt; Error_monad.fail extensible_type_value
    | Some roll =&gt;
      let=? c :=
        (|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.delete)
          c roll in
      let=? successor_roll :=
        (|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.get_option)
          c roll in
      let= c :=
        (|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.set_option)
          c delegate successor_roll in
      let= c :=
        (|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.set_option)
          c roll limbo_head in
      let= c :=
        (|Storage.Roll.Limbo|).(Storage_sigs.Single_data_storage.init_set) c
          roll in
      Error_monad.__return (roll, c)
    end.
  
  Definition create_roll_in_delegate
    (c : Raw_context.context)
    (delegate :
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.key))
    (delegate_pk :
      (|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.value))
    : Lwt.t (Error_monad.tzresult Raw_context.t) :=
    let=? c := consume_roll_change c delegate in
    let=? delegate_head :=
      (|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.get_option)
        c delegate in
    let=? '(roll, c) := get_limbo_roll c in
    let=? c :=
      (|Storage.Roll.Owner|).(Storage_sigs.Indexed_data_snapshotable_storage.init)
        c roll delegate_pk in
    let=? limbo_successor :=
      (|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.get_option)
        c roll in
    let= c :=
      (|Storage.Roll.Limbo|).(Storage_sigs.Single_data_storage.set_option) c
        limbo_successor in
    let= c :=
      (|Storage.Roll.Successor|).(Storage_sigs.Indexed_data_storage.set_option)
        c roll delegate_head in
    let= c :=
      (|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.init_set)
        c delegate roll in
    Error_monad.__return c.
  
  Definition ensure_inited
    (c :
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.context))
    (delegate :
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.key))
    : Lwt.t
      (Error_monad.tzresult
        (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.context)) :=
    let= function_parameter :=
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.mem) c
        delegate in
    match function_parameter with
    | true =&gt; Error_monad.__return c
    | false =&gt;
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.init)
        c delegate Tez_repr.zero
    end.
  
  Definition is_inactive
    (c :
      (|Storage.Contract.Inactive_delegate|).(Storage_sigs.Data_set_storage.context))
    (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
    : Lwt.t (Error_monad.tzresult bool) :=
    let= inactive :=
      (|Storage.Contract.Inactive_delegate|).(Storage_sigs.Data_set_storage.mem)
        c (Contract_repr.implicit_contract delegate) in
    if inactive then
      Error_monad.__return inactive
    else
      let=? function_parameter :=
        (|Storage.Contract.Delegate_desactivation|).(Storage_sigs.Indexed_data_storage.get_option)
          c (Contract_repr.implicit_contract delegate) in
      match function_parameter with
      | Some last_active_cycle =&gt;
        let '{| Level_repr.t.cycle := current_cycle |} :=
          Raw_context.current_level c in
        Error_monad.__return (Cycle_repr.op_lt last_active_cycle current_cycle)
      | None =&gt; Error_monad.return_false
      end.
  
  Definition add_amount
    (c :
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.context))
    (delegate :
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.key))
    (amount : Tez_repr.t) : Lwt.t (Error_monad.tzresult Raw_context.t) :=
    let=? c := ensure_inited c delegate in
    let tokens_per_roll := Constants_storage.tokens_per_roll c in
    let=? change :=
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.get) c
        delegate in
    let=? change := Lwt.__return (Tez_repr.op_plusquestion amount change) in
    let=? c :=
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.set) c
        delegate change in
    let=? delegate_pk := delegate_pubkey c delegate in
    let fix loop (c : Raw_context.context) (change : Tez_repr.t) {struct c}
      : Lwt.t (Error_monad.tzresult Raw_context.context) :=
      if Tez_repr.op_lt change tokens_per_roll then
        Error_monad.__return c
      else
        let=? change :=
          Lwt.__return (Tez_repr.op_minusquestion change tokens_per_roll) in
        let=? c := create_roll_in_delegate c delegate delegate_pk in
        loop c change in
    let=? inactive := is_inactive c delegate in
    if inactive then
      Error_monad.__return c
    else
      let=? c := loop c change in
      let=? rolls :=
        (|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.get_option)
          c delegate in
      match rolls with
      | None =&gt; Error_monad.__return c
      | Some _ =&gt;
        let= c :=
          (|Storage.Active_delegates_with_rolls|).(Storage_sigs.Data_set_storage.add)
            c delegate in
        Error_monad.__return c
      end.
  
  Definition remove_amount
    (c : Raw_context.context)
    (delegate :
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.key))
    (amount : Tez_repr.t) : Lwt.t (Error_monad.tzresult Raw_context.t) :=
    let tokens_per_roll := Constants_storage.tokens_per_roll c in
    let fix loop (c : Raw_context.context) (change : Tez_repr.t) {struct c}
      : Lwt.t (Error_monad.tzresult (Raw_context.context * Tez_repr.t)) :=
      if Tez_repr.op_lteq amount change then
        Error_monad.__return (c, change)
      else
        let=? '(_, c) := pop_roll_from_delegate c delegate in
        let=? change :=
          Lwt.__return (Tez_repr.op_plusquestion change tokens_per_roll) in
        loop c change in
    let=? change :=
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.get) c
        delegate in
    let=? inactive := is_inactive c delegate in
    let=? '(c, change) :=
      if inactive then
        Error_monad.__return (c, change)
      else
        let=? '(c, change) := loop c change in
        let=? rolls :=
          (|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.get_option)
            c delegate in
        match rolls with
        | None =&gt;
          let= c :=
            (|Storage.Active_delegates_with_rolls|).(Storage_sigs.Data_set_storage.del)
              c delegate in
          Error_monad.__return (c, change)
        | Some _ =&gt; Error_monad.__return (c, change)
        end in
    let=? change := Lwt.__return (Tez_repr.op_minusquestion change amount) in
    (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.set) c
      delegate change.
  
  Definition set_inactive
    (ctxt :
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.context))
    (delegate :
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.key))
    : Lwt.t (Error_monad.tzresult Raw_context.t) :=
    let=? ctxt := ensure_inited ctxt delegate in
    let tokens_per_roll := Constants_storage.tokens_per_roll ctxt in
    let=? change :=
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.get)
        ctxt delegate in
    let= ctxt :=
      (|Storage.Contract.Inactive_delegate|).(Storage_sigs.Data_set_storage.add)
        ctxt (Contract_repr.implicit_contract delegate) in
    let= ctxt :=
      (|Storage.Active_delegates_with_rolls|).(Storage_sigs.Data_set_storage.del)
        ctxt delegate in
    let fix loop
      (ctxt :
        (|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.context))
      (change : Tez_repr.t) {struct ctxt}
      : Lwt.t
        (Error_monad.tzresult
          ((|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.context)
            * Tez_repr.t)) :=
      let=? function_parameter :=
        (|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.get_option)
          ctxt delegate in
      match function_parameter with
      | None =&gt; Error_monad.__return (ctxt, change)
      | Some _roll =&gt;
        let=? '(_, ctxt) := pop_roll_from_delegate ctxt delegate in
        let=? change :=
          Lwt.__return (Tez_repr.op_plusquestion change tokens_per_roll) in
        loop ctxt change
      end in
    let=? '(ctxt, change) := loop ctxt change in
    let=? ctxt :=
      (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.set)
        ctxt delegate change in
    Error_monad.__return ctxt.
  
  Definition set_active
    (ctxt :
      (|Storage.Contract.Inactive_delegate|).(Storage_sigs.Data_set_storage.context))
    (delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
    : Lwt.t (Error_monad.tzresult Raw_context.t) :=
    let=? inactive := is_inactive ctxt delegate in
    let current_cycle := (Raw_context.current_level ctxt).(Level_repr.t.cycle)
      in
    let preserved_cycles := Constants_storage.preserved_cycles ctxt in
    let=? current_expiration :=
      (|Storage.Contract.Delegate_desactivation|).(Storage_sigs.Indexed_data_storage.get_option)
        ctxt (Contract_repr.implicit_contract delegate) in
    let expiration :=
      match current_expiration with
      | None =&gt;
        Cycle_repr.add current_cycle
          (Pervasives.op_plus 1 (Pervasives.op_star 2 preserved_cycles))
      | Some current_expiration =&gt;
        let delay :=
          if inactive then
            Pervasives.op_plus 1 (Pervasives.op_star 2 preserved_cycles)
          else
            Pervasives.op_plus 1 preserved_cycles in
        let updated := Cycle_repr.add current_cycle delay in
        Cycle_repr.max current_expiration updated
      end in
    let= ctxt :=
      (|Storage.Contract.Delegate_desactivation|).(Storage_sigs.Indexed_data_storage.init_set)
        ctxt (Contract_repr.implicit_contract delegate) expiration in
    if Pervasives.not inactive then
      Error_monad.__return ctxt
    else
      let=? ctxt := ensure_inited ctxt delegate in
      let tokens_per_roll := Constants_storage.tokens_per_roll ctxt in
      let=? change :=
        (|Storage.Roll.Delegate_change|).(Storage_sigs.Indexed_data_storage.get)
          ctxt delegate in
      let= ctxt :=
        (|Storage.Contract.Inactive_delegate|).(Storage_sigs.Data_set_storage.del)
          ctxt (Contract_repr.implicit_contract delegate) in
      let=? delegate_pk := delegate_pubkey ctxt delegate in
      let fix loop (ctxt : Raw_context.context) (change : Tez_repr.t)
        {struct ctxt} : Lwt.t (Error_monad.tzresult Raw_context.context) :=
        if Tez_repr.op_lt change tokens_per_roll then
          Error_monad.__return ctxt
        else
          let=? change :=
            Lwt.__return (Tez_repr.op_minusquestion change tokens_per_roll) in
          let=? ctxt := create_roll_in_delegate ctxt delegate delegate_pk in
          loop ctxt change in
      let=? ctxt := loop ctxt change in
      let=? rolls :=
        (|Storage.Roll.Delegate_roll_list|).(Storage_sigs.Indexed_data_storage.get_option)
          ctxt delegate in
      match rolls with
      | None =&gt; Error_monad.__return ctxt
      | Some _ =&gt;
        let= ctxt :=
          (|Storage.Active_delegates_with_rolls|).(Storage_sigs.Data_set_storage.add)
            ctxt delegate in
        Error_monad.__return ctxt
      end.
End Delegate.

Module Contract.
  Definition add_amount
    (c :
      (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.context))
    (contract :
      (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.key))
    (amount : Tez_repr.t)
    : Lwt.t
      (Error_monad.tzresult
        (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.context)) :=
    let=? function_parameter := get_contract_delegate c contract in
    match function_parameter with
    | None =&gt; Error_monad.__return c
    | Some delegate =&gt; Delegate.add_amount c delegate amount
    end.
  
  Definition remove_amount
    (c :
      (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.context))
    (contract :
      (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.key))
    (amount : Tez_repr.t)
    : Lwt.t
      (Error_monad.tzresult
        (|Storage.Contract.Delegate|).(Storage_sigs.Indexed_data_storage.context)) :=
    let=? function_parameter := get_contract_delegate c contract in
    match function_parameter with
    | None =&gt; Error_monad.__return c
    | Some delegate =&gt; Delegate.remove_amount c delegate amount
    end.
End Contract.

Definition init
  (ctxt : (|Storage.Roll.Next|).(Storage_sigs.Single_data_storage.context))
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  (|Storage.Roll.Next|).(Storage_sigs.Single_data_storage.init) ctxt
    Roll_repr.first.

Definition init_first_cycles (ctxt : Raw_context.context)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let preserved := Constants_storage.preserved_cycles ctxt in
  let=? ctxt :=
    List.fold_left
      (fun ctxt =&gt;
        fun c =&gt;
          let=? ctxt := ctxt in
          let cycle := Cycle_repr.of_int32_exn (Int32.of_int c) in
          let=? ctxt :=
            (|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.init)
              ctxt cycle 0 in
          let=? ctxt := snapshot_rolls_for_cycle ctxt cycle in
          freeze_rolls_for_cycle ctxt cycle) (Error_monad.__return ctxt)
      (Misc.op_minusminusgt 0 preserved) in
  let cycle :=
    Cycle_repr.of_int32_exn (Int32.of_int (Pervasives.op_plus preserved 1)) in
  let=? ctxt :=
    (|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.init)
      ctxt cycle 0 in
  let=? ctxt := snapshot_rolls_for_cycle ctxt cycle in
  let cycle :=
    Cycle_repr.of_int32_exn (Int32.of_int (Pervasives.op_plus preserved 2)) in
  let=? ctxt :=
    (|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.init)
      ctxt cycle 0 in
  Error_monad.__return ctxt.

Definition snapshot_rolls (ctxt : Raw_context.context)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let current_level := Raw_context.current_level ctxt in
  let preserved := Constants_storage.preserved_cycles ctxt in
  let cycle :=
    Cycle_repr.add current_level.(Level_repr.t.cycle)
      (Pervasives.op_plus preserved 2) in
  snapshot_rolls_for_cycle ctxt cycle.

Definition cycle_end
  (ctxt : Raw_context.context) (last_cycle : Cycle_repr.cycle)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let preserved := Constants_storage.preserved_cycles ctxt in
  let=? ctxt :=
    match Cycle_repr.sub last_cycle preserved with
    | None =&gt; Error_monad.__return ctxt
    | Some cleared_cycle =&gt; clear_cycle ctxt cleared_cycle
    end in
  let frozen_roll_cycle :=
    Cycle_repr.add last_cycle (Pervasives.op_plus preserved 1) in
  let=? ctxt := freeze_rolls_for_cycle ctxt frozen_roll_cycle in
  let=? ctxt :=
    (|Storage.Roll.Snapshot_for_cycle|).(Storage_sigs.Indexed_data_storage.init)
      ctxt (Cycle_repr.succ (Cycle_repr.succ frozen_roll_cycle)) 0 in
  Error_monad.__return ctxt.

Definition update_tokens_per_roll
  (ctxt : Raw_context.context) (new_tokens_per_roll : Tez_repr.t)
  : Lwt.t (Error_monad.tzresult Raw_context.context) :=
  let constants := Raw_context.constants ctxt in
  let old_tokens_per_roll :=
    constants.(Constants_repr.parametric.tokens_per_roll) in
  let= ctxt :=
    Raw_context.patch_constants ctxt
      (fun constants =&gt;
        Constants_repr.parametric.with_tokens_per_roll new_tokens_per_roll
          constants) in
  let decrease := Tez_repr.op_lt new_tokens_per_roll old_tokens_per_roll in
  let=? abs_diff :=
    if decrease then
      Lwt.__return
        (Tez_repr.op_minusquestion old_tokens_per_roll new_tokens_per_roll)
    else
      Lwt.__return
        (Tez_repr.op_minusquestion new_tokens_per_roll old_tokens_per_roll) in
  (|Storage.Delegates|).(Storage_sigs.Data_set_storage.fold) ctxt
    (Pervasives.Ok ctxt)
    (fun pkh =&gt;
      fun ctxt =&gt;
        let=? ctxt := Lwt.__return ctxt in
        let=? rolls := count_rolls ctxt pkh in
        let=? amount :=
          Lwt.__return (Tez_repr.op_starquestion abs_diff (Int64.of_int rolls))
          in
        if decrease then
          Delegate.add_amount ctxt pkh amount
        else
          Delegate.remove_amount ctxt pkh amount).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="roll_storage.mli">
  <div style="margin: 20px;">
    <h3>Roll_storage_mli</h3>
    <ul>
      <li>OCaml size: 132 lines</li>
      <li>Coq size: 96 lines (-28% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#roll_storage.mli"><code>roll_storage.mli</code></a>&nbsp;<span class="label label-warning">1 warning</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(**

   Basic roll manipulation.

   If storage related to roll (a.k.a. `Storage.Roll`) are not used
   outside of this module, this interface enforces the invariant that a
   roll is always either in the limbo list or in a contract list.

*)

<abbr class="mark-warning" title="Extensible types are not handled.">type error +=
  | Consume_roll_change
  | No_roll_for_delegate
  | No_roll_snapshot_for_cycle of Cycle_repr.t
  | Unregistered_delegate of Signature.Public_key_hash.t</abbr>

(* `Permanent *)

val init : Raw_context.t -&gt; Raw_context.t tzresult Lwt.t

val init_first_cycles : Raw_context.t -&gt; Raw_context.t tzresult Lwt.t

val cycle_end : Raw_context.t -&gt; Cycle_repr.t -&gt; Raw_context.t tzresult Lwt.t

val snapshot_rolls : Raw_context.t -&gt; Raw_context.t tzresult Lwt.t

val fold :
  Raw_context.t -&gt;
  f:(Roll_repr.roll -&gt; Signature.Public_key.t -&gt; 'a -&gt; 'a tzresult Lwt.t) -&gt;
  'a -&gt;
  'a tzresult Lwt.t

val baking_rights_owner :
  Raw_context.t -&gt;
  Level_repr.t -&gt;
  priority:int -&gt;
  Signature.Public_key.t tzresult Lwt.t

val endorsement_rights_owner :
  Raw_context.t -&gt;
  Level_repr.t -&gt;
  slot:int -&gt;
  Signature.Public_key.t tzresult Lwt.t

module Delegate : sig
  val is_inactive :
    Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; bool tzresult Lwt.t

  val add_amount :
    Raw_context.t -&gt;
    Signature.Public_key_hash.t -&gt;
    Tez_repr.t -&gt;
    Raw_context.t tzresult Lwt.t

  val remove_amount :
    Raw_context.t -&gt;
    Signature.Public_key_hash.t -&gt;
    Tez_repr.t -&gt;
    Raw_context.t tzresult Lwt.t

  val set_inactive :
    Raw_context.t -&gt;
    Signature.Public_key_hash.t -&gt;
    Raw_context.t tzresult Lwt.t

  val set_active :
    Raw_context.t -&gt;
    Signature.Public_key_hash.t -&gt;
    Raw_context.t tzresult Lwt.t
end

module Contract : sig
  val add_amount :
    Raw_context.t -&gt;
    Contract_repr.t -&gt;
    Tez_repr.t -&gt;
    Raw_context.t tzresult Lwt.t

  val remove_amount :
    Raw_context.t -&gt;
    Contract_repr.t -&gt;
    Tez_repr.t -&gt;
    Raw_context.t tzresult Lwt.t
end

val delegate_pubkey :
  Raw_context.t -&gt;
  Signature.Public_key_hash.t -&gt;
  Signature.Public_key.t tzresult Lwt.t

val get_rolls :
  Raw_context.t -&gt;
  Signature.Public_key_hash.t -&gt;
  Roll_repr.t list tzresult Lwt.t

val get_change :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; Tez_repr.t tzresult Lwt.t

val update_tokens_per_roll :
  Raw_context.t -&gt; Tez_repr.t -&gt; Raw_context.t tzresult Lwt.t

(**/**)

val get_contract_delegate :
  Raw_context.t -&gt;
  Contract_repr.t -&gt;
  Signature.Public_key_hash.t option tzresult Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#roll_storage.mli"><code>Roll_storage_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Contract_repr.
Require Tezos.Cycle_repr.
Require Tezos.Level_repr.
Require Tezos.Raw_context.
Require Tezos.Roll_repr.
Require Tezos.Tez_repr.

(* extensible_type_definition `error` *)

Parameter init : Raw_context.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter init_first_cycles :
  Raw_context.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter cycle_end :
  Raw_context.t -&gt; Cycle_repr.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter snapshot_rolls :
  Raw_context.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter fold : forall {a : Set},
  Raw_context.t -&gt;
  (Roll_repr.roll -&gt; (|Signature.Public_key|).(S.SPublic_key.t) -&gt; a -&gt;
  Lwt.t (Error_monad.tzresult a)) -&gt; a -&gt; Lwt.t (Error_monad.tzresult a).

Parameter baking_rights_owner :
  Raw_context.t -&gt; Level_repr.t -&gt; int -&gt;
  Lwt.t (Error_monad.tzresult (|Signature.Public_key|).(S.SPublic_key.t)).

Parameter endorsement_rights_owner :
  Raw_context.t -&gt; Level_repr.t -&gt; int -&gt;
  Lwt.t (Error_monad.tzresult (|Signature.Public_key|).(S.SPublic_key.t)).

Module Delegate.
  Parameter is_inactive :
    Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
    Lwt.t (Error_monad.tzresult bool).
  
  Parameter add_amount :
    Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
    Tez_repr.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).
  
  Parameter remove_amount :
    Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
    Tez_repr.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).
  
  Parameter set_inactive :
    Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
    Lwt.t (Error_monad.tzresult Raw_context.t).
  
  Parameter set_active :
    Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
    Lwt.t (Error_monad.tzresult Raw_context.t).
End Delegate.

Module Contract.
  Parameter add_amount :
    Raw_context.t -&gt; Contract_repr.t -&gt; Tez_repr.t -&gt;
    Lwt.t (Error_monad.tzresult Raw_context.t).
  
  Parameter remove_amount :
    Raw_context.t -&gt; Contract_repr.t -&gt; Tez_repr.t -&gt;
    Lwt.t (Error_monad.tzresult Raw_context.t).
End Contract.

Parameter delegate_pubkey :
  Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.tzresult (|Signature.Public_key|).(S.SPublic_key.t)).

Parameter get_rolls :
  Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.tzresult (list Roll_repr.t)).

Parameter get_change :
  Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.tzresult Tez_repr.t).

Parameter update_tokens_per_roll :
  Raw_context.t -&gt; Tez_repr.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter get_contract_delegate :
  Raw_context.t -&gt; Contract_repr.t -&gt;
  Lwt.t
    (Error_monad.tzresult
      (option (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_expr_hash.ml">
  <div style="margin: 20px;">
    <h3>Script_expr_hash</h3>
    <ul>
      <li>OCaml size: 43 lines</li>
      <li>Coq size: 103 lines (+139% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#script_expr_hash.ml"><code>script_expr_hash.ml</code></a>&nbsp;<span class="label label-warning">1 warning</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

let script_expr_hash = &quot;\013\044\064\027&quot; (* expr(54) *)

module Blake2BModule =
  Blake2B.Make
    (Base58)
    (struct
      let name = &quot;script_expr&quot;

      let title = &quot;A script expression ID&quot;

      let b58check_prefix = script_expr_hash

      let size = None
    end)

include Blake2BModule

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () = Base58.check_encoded_prefix b58check_encoding &quot;expr&quot; 54</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_expr_hash.ml"><code>Script_expr_hash.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.

Definition script_expr_hash : string := &quot;\r,@\027&quot;.

Definition Blake2BModule :=
  (Blake2B.Make
    (existT (A := unit) (fun _ =&gt; _) tt
      {|
        Blake2B.SRegister.register_encoding {_} := Base58.register_encoding
      |}))
    (let name := &quot;script_expr&quot; in
    let title := &quot;A script expression ID&quot; in
    let b58check_prefix := script_expr_hash in
    let size {A : Set} : option A :=
      None in
    existT (A := unit) (fun _ =&gt; _) tt
      {|
        Blake2B.PrefixedName.name := name;
        Blake2B.PrefixedName.title := title;
        Blake2B.PrefixedName.size := size;
        Blake2B.PrefixedName.b58check_prefix := b58check_prefix
      |}).

Definition t := (|Blake2BModule|).(S.HASH.t).

Definition name := (|Blake2BModule|).(S.HASH.name).

Definition title := (|Blake2BModule|).(S.HASH.title).

Definition pp := (|Blake2BModule|).(S.HASH.pp).

Definition pp_short := (|Blake2BModule|).(S.HASH.pp_short).

Definition op_eq := (|Blake2BModule|).(S.HASH.op_eq).

Definition op_ltgt := (|Blake2BModule|).(S.HASH.op_ltgt).

Definition op_lt := (|Blake2BModule|).(S.HASH.op_lt).

Definition op_lteq := (|Blake2BModule|).(S.HASH.op_lteq).

Definition op_gteq := (|Blake2BModule|).(S.HASH.op_gteq).

Definition op_gt := (|Blake2BModule|).(S.HASH.op_gt).

Definition compare := (|Blake2BModule|).(S.HASH.compare).

Definition equal := (|Blake2BModule|).(S.HASH.equal).

Definition max := (|Blake2BModule|).(S.HASH.max).

Definition min := (|Blake2BModule|).(S.HASH.min).

Definition hash_bytes := (|Blake2BModule|).(S.HASH.hash_bytes).

Definition hash_string := (|Blake2BModule|).(S.HASH.hash_string).

Definition zero := (|Blake2BModule|).(S.HASH.zero).

Definition size := (|Blake2BModule|).(S.HASH.size).

Definition to_bytes := (|Blake2BModule|).(S.HASH.to_bytes).

Definition of_bytes_opt := (|Blake2BModule|).(S.HASH.of_bytes_opt).

Definition of_bytes_exn := (|Blake2BModule|).(S.HASH.of_bytes_exn).

Definition to_b58check := (|Blake2BModule|).(S.HASH.to_b58check).

Definition to_short_b58check := (|Blake2BModule|).(S.HASH.to_short_b58check).

Definition of_b58check_exn := (|Blake2BModule|).(S.HASH.of_b58check_exn).

Definition of_b58check_opt := (|Blake2BModule|).(S.HASH.of_b58check_opt).

Definition b58check_encoding := (|Blake2BModule|).(S.HASH.b58check_encoding).

Definition encoding := (|Blake2BModule|).(S.HASH.encoding).

Definition rpc_arg := (|Blake2BModule|).(S.HASH.rpc_arg).

Definition to_path := (|Blake2BModule|).(S.HASH.to_path).

Definition of_path := (|Blake2BModule|).(S.HASH.of_path).

Definition of_path_exn := (|Blake2BModule|).(S.HASH.of_path_exn).

Definition prefix_path := (|Blake2BModule|).(S.HASH.prefix_path).

Definition path_length := (|Blake2BModule|).(S.HASH.path_length).

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_int_repr.ml">
  <div style="margin: 20px;">
    <h3>Script_int_repr</h3>
    <ul>
      <li>OCaml size: 102 lines</li>
      <li>Coq size: 104 lines (+1% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#script_int_repr.ml"><code>script_int_repr.ml</code></a>&nbsp;<span class="label label-warning">4 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type n = Natural_tag

type z = Integer_tag

type num = Z.t

let compare x y = Z.compare x y

let zero = Z.zero

let zero_n = Z.zero

let to_string x = Z.to_string x

let of_string s = <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Some (Z.of_string s) with _ -&gt; None</abbr>

let to_int64 x = <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Some (Z.to_int64 x) with _ -&gt; None</abbr>

let of_int64 n = Z.of_int64 n

let to_int x = <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Some (Z.to_int x) with _ -&gt; None</abbr>

let of_int n = Z.of_int n

let of_zint x = x

let to_zint x = x

let add x y = Z.add x y

let sub x y = Z.sub x y

let mul x y = Z.mul x y

let ediv x y =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
    let (q, r) = Z.ediv_rem x y in
    Some (q, r)
  with _ -&gt; None</abbr>

let add_n = add

let mul_n = mul

let ediv_n = ediv

let abs x = Z.abs x

let is_nat x = if Compare.Z.(x &lt; Z.zero) then None else Some x

let neg x = Z.neg x

let int x = x

let shift_left x y =
  if Compare.Int.(Z.compare y (Z.of_int 256) &gt; 0) then None
  else
    let y = Z.to_int y in
    Some (Z.shift_left x y)

let shift_right x y =
  if Compare.Int.(Z.compare y (Z.of_int 256) &gt; 0) then None
  else
    let y = Z.to_int y in
    Some (Z.shift_right x y)

let shift_left_n = shift_left

let shift_right_n = shift_right

let logor x y = Z.logor x y

let logxor x y = Z.logxor x y

let logand x y = Z.logand x y

let lognot x = Z.lognot x
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_int_repr.ml"><code>Script_int_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.

Inductive n : Set :=
| Natural_tag : n.

Inductive z : Set :=
| Integer_tag : z.

Definition num : Set := Z.t.

Definition compare (x : Z.t) (y : Z.t) : int := Z.compare x y.

Definition zero : Z.t := Z.zero.

Definition zero_n : Z.t := Z.zero.

Definition to_string (x : Z.t) : string := Z.to_string x.

Definition of_string (s : string) : option Z.t :=
  (* ‚ùå Try-with are not handled *)
  try (Some (Z.of_string s)).

Definition to_int64 (x : Z.t) : option int64 :=
  (* ‚ùå Try-with are not handled *)
  try (Some (Z.to_int64 x)).

Definition of_int64 (n : int64) : Z.t := Z.of_int64 n.

Definition to_int (x : Z.t) : option int :=
  (* ‚ùå Try-with are not handled *)
  try (Some (Z.to_int x)).

Definition of_int (n : int) : Z.t := Z.of_int n.

Definition of_zint {A : Set} (x : A) : A := x.

Definition to_zint {A : Set} (x : A) : A := x.

Definition add (x : Z.t) (y : Z.t) : Z.t := Z.add x y.

Definition sub (x : Z.t) (y : Z.t) : Z.t := Z.sub x y.

Definition mul (x : Z.t) (y : Z.t) : Z.t := Z.mul x y.

Definition ediv (x : Z.t) (y : Z.t) : option (Z.t * Z.t) :=
  (* ‚ùå Try-with are not handled *)
  try
    (let '(q, __r_value) := Z.ediv_rem x y in
    Some (q, __r_value)).

Definition add_n : Z.t -&gt; Z.t -&gt; Z.t := add.

Definition mul_n : Z.t -&gt; Z.t -&gt; Z.t := mul.

Definition ediv_n : Z.t -&gt; Z.t -&gt; option (Z.t * Z.t) := ediv.

Definition abs (x : Z.t) : Z.t := Z.abs x.

Definition is_nat (x : (|Compare.Z|).(Compare.S.t))
  : option (|Compare.Z|).(Compare.S.t) :=
  if (|Compare.Z|).(Compare.S.op_lt) x Z.zero then
    None
  else
    Some x.

Definition neg (x : Z.t) : Z.t := Z.neg x.

Definition __int_value {A : Set} (x : A) : A := x.

Definition shift_left (x : Z.t) (y : Z.t) : option Z.t :=
  if (|Compare.Int|).(Compare.S.op_gt) (Z.compare y (Z.of_int 256)) 0 then
    None
  else
    let y := Z.to_int y in
    Some (Z.shift_left x y).

Definition shift_right (x : Z.t) (y : Z.t) : option Z.t :=
  if (|Compare.Int|).(Compare.S.op_gt) (Z.compare y (Z.of_int 256)) 0 then
    None
  else
    let y := Z.to_int y in
    Some (Z.shift_right x y).

Definition shift_left_n : Z.t -&gt; Z.t -&gt; option Z.t := shift_left.

Definition shift_right_n : Z.t -&gt; Z.t -&gt; option Z.t := shift_right.

Definition logor (x : Z.t) (y : Z.t) : Z.t := Z.logor x y.

Definition logxor (x : Z.t) (y : Z.t) : Z.t := Z.logxor x y.

Definition logand (x : Z.t) (y : Z.t) : Z.t := Z.logand x y.

Definition lognot (x : Z.t) : Z.t := Z.lognot x.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_int_repr.mli">
  <div style="margin: 20px;">
    <h3>Script_int_repr_mli</h3>
    <ul>
      <li>OCaml size: 143 lines</li>
      <li>Coq size: 79 lines (-45% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#script_int_repr.mli"><code>script_int_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** The types for arbitraty precision integers in Michelson.
    The type variable ['t] is always [n] or [z],
    [n num] and [z num] are incompatible.

    This is internally a [Z.t].
    This module mostly adds signedness preservation guarantees. *)
type num

(** Flag for natural numbers. *)
type n = Natural_tag

(** Flag for relative numbers. *)
type z = Integer_tag

(** Natural zero. *)
val zero_n : num

(** Relative zero. *)
val zero : num

(** Compare two numbers as if they were *)
val compare : num -&gt; num -&gt; int

(** Conversion to an OCaml [string] in decimal notation. *)
val to_string : num -&gt; string

(** Conversion from an OCaml [string].
    Returns [None] in case of an invalid notation.
    Supports [+] and [-] sign modifiers, and [0x], [0o] and [0b] base modifiers. *)
val of_string : string -&gt; num option

(** Conversion to an OCaml [int64], returns [None] on overflow. *)
val to_int64 : num -&gt; int64 option

(** Conversion from an OCaml [int]. *)
val of_int64 : int64 -&gt; num

(** Conversion to an OCaml [int], returns [None] on overflow. *)
val to_int : num -&gt; int option

(** Conversion from an OCaml [int64]. *)
val of_int : int -&gt; num

(** Conversion from a Zarith integer ([Z.t]). *)
val of_zint : Z.t -&gt; num

(** Conversion to a Zarith integer ([Z.t]). *)
val to_zint : num -&gt; Z.t

(** Addition between naturals. *)
val add_n : num -&gt; num -&gt; num

(** Multiplication between naturals. *)
val mul_n : num -&gt; num -&gt; num

(** Euclidean division between naturals.
    [ediv_n n d] returns [None] if divisor is zero,
    or [Some (q, r)] where [n = d * q + r] and [[0 &lt;= r &lt; d]] otherwise. *)
val ediv_n : num -&gt; num -&gt; (num * num) option

(** Sign agnostic addition.
    Use {!add_n} when working with naturals to preserve the sign. *)
val add : num -&gt; num -&gt; num

(** Sign agnostic subtraction.
    Use {!sub_n} when working with naturals to preserve the sign. *)
val sub : num -&gt; num -&gt; num

(** Sign agnostic multiplication.
    Use {!mul_n} when working with naturals to preserve the sign. *)
val mul : num -&gt; num -&gt; num

(** Sign agnostic euclidean division.
    [ediv n d] returns [None] if divisor is zero,
    or [Some (q, r)] where [n = d * q + r] and [[0 &lt;= r &lt; |d|]] otherwise.
    Use {!ediv_n} when working with naturals to preserve the sign. *)
val ediv : num -&gt; num -&gt; (num * num) option

(** Compute the absolute value of a relative, turning it into a natural. *)
val abs : num -&gt; num

(** Partial identity over [N]. *)
val is_nat : num -&gt; num option

(** Negates a number. *)
val neg : num -&gt; num

(** Turns a natural into a relative, not changing its value. *)
val int : num -&gt; num

(** Reverses each bit in the representation of the number.
    Also applies to the sign. *)
val lognot : num -&gt; num

(** Shifts the natural to the left of a number of bits between 0 and 256.
    Returns [None] if the amount is too high. *)
val shift_left_n : num -&gt; num -&gt; num option

(** Shifts the natural to the right of a number of bits between 0 and 256.
    Returns [None] if the amount is too high. *)
val shift_right_n : num -&gt; num -&gt; num option

(** Shifts the number to the left of a number of bits between 0 and 256.
    Returns [None] if the amount is too high. *)
val shift_left : num -&gt; num -&gt; num option

(** Shifts the number to the right of a number of bits between 0 and 256.
    Returns [None] if the amount is too high. *)
val shift_right : num -&gt; num -&gt; num option

(** Applies a boolean or operation to each bit. *)
val logor : num -&gt; num -&gt; num

(** Applies a boolean and operation to each bit. *)
val logand : num -&gt; num -&gt; num

(** Applies a boolean xor operation to each bit. *)
val logxor : num -&gt; num -&gt; num
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_int_repr.mli"><code>Script_int_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.

Parameter num : Set.

Inductive n : Set :=
| Natural_tag : n.

Inductive z : Set :=
| Integer_tag : z.

Parameter zero_n : num.

Parameter zero : num.

Parameter compare : num -&gt; num -&gt; int.

Parameter to_string : num -&gt; string.

Parameter of_string : string -&gt; option num.

Parameter to_int64 : num -&gt; option int64.

Parameter of_int64 : int64 -&gt; num.

Parameter to_int : num -&gt; option int.

Parameter of_int : int -&gt; num.

Parameter of_zint : Z.t -&gt; num.

Parameter to_zint : num -&gt; Z.t.

Parameter add_n : num -&gt; num -&gt; num.

Parameter mul_n : num -&gt; num -&gt; num.

Parameter ediv_n : num -&gt; num -&gt; option (num * num).

Parameter add : num -&gt; num -&gt; num.

Parameter sub : num -&gt; num -&gt; num.

Parameter mul : num -&gt; num -&gt; num.

Parameter ediv : num -&gt; num -&gt; option (num * num).

Parameter abs : num -&gt; num.

Parameter is_nat : num -&gt; option num.

Parameter neg : num -&gt; num.

Parameter __int_value : num -&gt; num.

Parameter lognot : num -&gt; num.

Parameter shift_left_n : num -&gt; num -&gt; option num.

Parameter shift_right_n : num -&gt; num -&gt; option num.

Parameter shift_left : num -&gt; num -&gt; option num.

Parameter shift_right : num -&gt; num -&gt; option num.

Parameter logor : num -&gt; num -&gt; num.

Parameter logand : num -&gt; num -&gt; num.

Parameter logxor : num -&gt; num -&gt; num.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_interpreter.ml">
  <div style="margin: 20px;">
    <h3>Script_interpreter</h3>
    <ul>
      <li>OCaml size: 1641 lines</li>
      <li>Coq size: 2096 lines (+27% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#script_interpreter.ml"><code>script_interpreter.ml</code></a>&nbsp;<span class="label label-warning">28 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context
open Script
open Script_typed_ir
open Script_ir_translator

(* ---- Run-time errors -----------------------------------------------------*)

type execution_trace =
  (Script.location * Gas.t * (Script.expr * string option) list) list

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | Reject of Script.location * Script.expr * execution_trace option</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Overflow of Script.location * execution_trace option</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Runtime_contract_error : Contract.t * Script.expr -&gt; error</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Bad_contract_parameter of Contract.t</abbr> (* `Permanent *)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Cannot_serialize_log</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Cannot_serialize_failure</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Cannot_serialize_storage</abbr>

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  let open Data_encoding in
  let trace_encoding =
    list
    @@ obj3
         (req &quot;location&quot; Script.location_encoding)
         (req &quot;gas&quot; Gas.encoding)
         (req
            &quot;stack&quot;
            (list (obj2 (req &quot;item&quot; Script.expr_encoding) (opt &quot;annot&quot; string))))
  in
  (* Reject *)
  register_error_kind
    `Temporary
    ~id:&quot;michelson_v1.script_rejected&quot;
    ~title:&quot;Script failed&quot;
    ~description:&quot;A FAILWITH instruction was reached&quot;
    (obj3
       (req &quot;location&quot; Script.location_encoding)
       (req &quot;with&quot; Script.expr_encoding)
       (opt &quot;trace&quot; trace_encoding))
    (function Reject (loc, v, trace) -&gt; Some (loc, v, trace) | _ -&gt; None)
    (fun (loc, v, trace) -&gt; Reject (loc, v, trace)) ;
  (* Overflow *)
  register_error_kind
    `Temporary
    ~id:&quot;michelson_v1.script_overflow&quot;
    ~title:&quot;Script failed (overflow error)&quot;
    ~description:
      &quot;A FAIL instruction was reached due to the detection of an overflow&quot;
    (obj2
       (req &quot;location&quot; Script.location_encoding)
       (opt &quot;trace&quot; trace_encoding))
    (function Overflow (loc, trace) -&gt; Some (loc, trace) | _ -&gt; None)
    (fun (loc, trace) -&gt; Overflow (loc, trace)) ;
  (* Runtime contract error *)
  register_error_kind
    `Temporary
    ~id:&quot;michelson_v1.runtime_error&quot;
    ~title:&quot;Script runtime error&quot;
    ~description:&quot;Toplevel error for all runtime script errors&quot;
    (obj2
       (req &quot;contract_handle&quot; Contract.encoding)
       (req &quot;contract_code&quot; Script.expr_encoding))
    (function
      | Runtime_contract_error (contract, expr) -&gt;
          Some (contract, expr)
      | _ -&gt;
          None)
    (fun (contract, expr) -&gt; Runtime_contract_error (contract, expr)) ;
  (* Bad contract parameter *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.bad_contract_parameter&quot;
    ~title:&quot;Contract supplied an invalid parameter&quot;
    ~description:
      &quot;Either no parameter was supplied to a contract with a non-unit \
       parameter type, a non-unit parameter was passed to an account, or a \
       parameter was supplied of the wrong type&quot;
    Data_encoding.(obj1 (req &quot;contract&quot; Contract.encoding))
    (function Bad_contract_parameter c -&gt; Some c | _ -&gt; None)
    (fun c -&gt; Bad_contract_parameter c) ;
  (* Cannot serialize log *)
  register_error_kind
    `Temporary
    ~id:&quot;michelson_v1.cannot_serialize_log&quot;
    ~title:&quot;Not enough gas to serialize execution trace&quot;
    ~description:
      &quot;Execution trace with stacks was to big to be serialized with the \
       provided gas&quot;
    Data_encoding.empty
    (function Cannot_serialize_log -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Cannot_serialize_log) ;
  (* Cannot serialize failure *)
  register_error_kind
    `Temporary
    ~id:&quot;michelson_v1.cannot_serialize_failure&quot;
    ~title:&quot;Not enough gas to serialize argument of FAILWITH&quot;
    ~description:
      &quot;Argument of FAILWITH was too big to be serialized with the provided gas&quot;
    Data_encoding.empty
    (function Cannot_serialize_failure -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Cannot_serialize_failure) ;
  (* Cannot serialize storage *)
  register_error_kind
    `Temporary
    ~id:&quot;michelson_v1.cannot_serialize_storage&quot;
    ~title:&quot;Not enough gas to serialize execution storage&quot;
    ~description:
      &quot;The returned storage was too big to be serialized with the provided gas&quot;
    Data_encoding.empty
    (function Cannot_serialize_storage -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Cannot_serialize_storage)</abbr>

(* ---- interpreter ---------------------------------------------------------*)

type 'tys stack =
  | Item : 'ty * 'rest stack -&gt; ('ty * 'rest) stack
  | Empty : end_of_stack stack

let unparse_stack ctxt (stack, stack_ty) =
  (* We drop the gas limit as this function is only used for debugging/errors. *)
  let ctxt = Gas.set_unlimited ctxt in
  let rec unparse_stack :
      type a.
      a stack -&gt;
      a stack_ty -&gt;
      (Script.expr * string option) list tzresult Lwt.t =
   fun s s_ty -&gt;
    match[@coq_match_gadt_with_result] [@coq_match_with_default] (s, s_ty) with
    | (Empty, Empty_t) -&gt; (
        return_nil [@coq_implicit &quot;(a := unit)&quot;] )
    | (Item (v, rest), Item_t (ty, rest_ty, annot)) -&gt;
        unparse_data ctxt Readable ty v
        &gt;&gt;=? fun (data, _ctxt) -&gt;
        unparse_stack rest rest_ty
        &gt;&gt;=? fun rest -&gt;
        let annot =
          match Script_ir_annot.unparse_var_annot annot with
          | [] -&gt;
              None
          | [a] -&gt;
              Some a
          | _ -&gt;
              <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
        in
        let data = Micheline.strip_locations data in
        return ((data, annot) :: rest)
  in
  unparse_stack stack stack_ty

module Interp_costs = Michelson_v1_gas.Cost_of.Interpreter

let[@coq_struct &quot;n&quot;] rec interp_stack_prefix_preserving_operation :
    type fbef bef faft aft result.
    (fbef stack -&gt; (faft stack * result) tzresult Lwt.t) -&gt;
    (fbef, faft, bef, aft) stack_prefix_preservation_witness -&gt;
    bef stack -&gt;
    (aft stack * result) tzresult Lwt.t =
 fun f n stk -&gt;
  match[@coq_match_gadt] [@coq_match_with_default] (n, stk) with
  (* | ( Prefix
        (Prefix
          (Prefix
            (Prefix
              (Prefix
                (Prefix
                  (Prefix
                    (Prefix
                      (Prefix
                        (Prefix
                          (Prefix
                            (Prefix (Prefix (Prefix (Prefix (Prefix n))))))))))))))),
      Item
        ( v0,
          Item
            ( v1,
              Item
                ( v2,
                  Item
                    ( v3,
                      Item
                        ( v4,
                          Item
                            ( v5,
                              Item
                                ( v6,
                                  Item
                                    ( v7,
                                      Item
                                        ( v8,
                                          Item
                                            ( v9,
                                              Item
                                                ( va,
                                                  Item
                                                    ( vb,
                                                      Item
                                                        ( vc,
                                                          Item
                                                            ( vd,
                                                              Item
                                                                ( ve,
                                                                  Item
                                                                    (vf, rest)
                                                                ) ) ) ) ) ) )
                                    ) ) ) ) ) ) ) ) ) -&gt;
      interp_stack_prefix_preserving_operation f n rest
      &gt;&gt;=? fun (rest', result) -&gt;
      return
        ( Item
            ( v0,
              Item
                ( v1,
                  Item
                    ( v2,
                      Item
                        ( v3,
                          Item
                            ( v4,
                              Item
                                ( v5,
                                  Item
                                    ( v6,
                                      Item
                                        ( v7,
                                          Item
                                            ( v8,
                                              Item
                                                ( v9,
                                                  Item
                                                    ( va,
                                                      Item
                                                        ( vb,
                                                          Item
                                                            ( vc,
                                                              Item
                                                                ( vd,
                                                                  Item
                                                                    ( ve,
                                                                      Item
                                                                        ( vf,
                                                                          rest'
                                                                        ) ) )
                                                            ) ) ) ) ) ) ) ) )
                        ) ) ) ),
          result )*)
  | ( Prefix (Prefix (Prefix (Prefix n))),
      Item (v0, Item (v1, Item (v2, Item (v3, rest)))) ) -&gt;
      interp_stack_prefix_preserving_operation f n rest
      &gt;&gt;=? fun (rest', result) -&gt;
      return (Item (v0, Item (v1, Item (v2, Item (v3, rest')))), result)
  | (Prefix n, Item (v, rest)) -&gt;
      interp_stack_prefix_preserving_operation f n rest
      &gt;&gt;=? fun (rest', result) -&gt; return (Item (v, rest'), result)
  | (Rest, v) -&gt;
      f v

type step_constants = {
  source : Contract.t;
  payer : Contract.t;
  self : Contract.t;
  amount : Tez.t;
  chain_id : Chain_id.t;
}

let[@coq_struct &quot;ctxt&quot;] rec step :
    type b a.
    (b, a) instr -&gt;
    Script.location -&gt;
    b stack_ty -&gt;
    a stack_ty -&gt;
    ?log:execution_trace ref -&gt;
    context -&gt;
    step_constants -&gt;
    b stack -&gt;
    (a stack * context) tzresult Lwt.t =
 fun instr loc bef aft ?log ctxt step_constants stack -&gt;
  let descr = {instr; loc; bef; aft} in
  Lwt.return (Gas.consume ctxt Interp_costs.cycle)
  &gt;&gt;=? fun ctxt -&gt;
  let logged_return :
      type a b.
      (b, a) descr -&gt; a stack * context -&gt; (a stack * context) tzresult Lwt.t =
   fun descr (ret, ctxt) -&gt;
    match log with
    | None -&gt;
        return (ret, ctxt)
    | Some log -&gt;
        trace <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Cannot_serialize_log</abbr> (unparse_stack ctxt (ret, descr.aft))
        &gt;&gt;=? fun stack -&gt;
        <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">log := (descr.loc, Gas.level ctxt, stack) :: !log</abbr> ;
        return (ret, ctxt)
  in
  let get_log (log : execution_trace ref option) =
    Option.map ~f:(fun l -&gt; List.rev !l) log
  in
  let consume_gas_terop :
      type ret arg1 arg2 arg3 rest.
      (_ * (_ * (_ * rest)), ret * rest) descr -&gt;
      (arg1 -&gt; arg2 -&gt; arg3 -&gt; ret) * arg1 * arg2 * arg3 -&gt;
      (arg1 -&gt; arg2 -&gt; arg3 -&gt; Gas.cost) -&gt;
      rest stack -&gt;
      ((ret * rest) stack * context) tzresult Lwt.t =
   fun descr (op, x1, x2, x3) cost_func rest -&gt;
    Lwt.return (Gas.consume ctxt (cost_func x1 x2 x3))
    &gt;&gt;=? fun ctxt -&gt; logged_return descr (Item (op x1 x2 x3, rest), ctxt)
  in
  let consume_gas_binop :
      type ret arg1 arg2 rest.
      (_ * (_ * rest), ret * rest) descr -&gt;
      (arg1 -&gt; arg2 -&gt; ret) * arg1 * arg2 -&gt;
      (arg1 -&gt; arg2 -&gt; Gas.cost) -&gt;
      rest stack -&gt;
      context -&gt;
      ((ret * rest) stack * context) tzresult Lwt.t =
   fun descr (op, x1, x2) cost_func rest ctxt -&gt;
    Lwt.return (Gas.consume ctxt (cost_func x1 x2))
    &gt;&gt;=? fun ctxt -&gt; logged_return descr (Item (op x1 x2, rest), ctxt)
  in
  let consume_gas_unop :
      type ret arg rest.
      (_ * rest, ret * rest) descr -&gt;
      (arg -&gt; ret) * arg -&gt;
      (arg -&gt; Gas.cost) -&gt;
      rest stack -&gt;
      context -&gt;
      ((ret * rest) stack * context) tzresult Lwt.t =
   fun descr (op, arg) cost_func rest ctxt -&gt;
    Lwt.return (Gas.consume ctxt (cost_func arg))
    &gt;&gt;=? fun ctxt -&gt; logged_return descr (Item (op arg, rest), ctxt)
  in
  let logged_return : a stack * context -&gt; (a stack * context) tzresult Lwt.t =
    logged_return descr
  in
  match[@coq_match_gadt] [@coq_match_with_default] (instr, stack) with
  (* stack ops *)
  | (Drop, Item (_, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.stack_op)
      &gt;&gt;=? fun ctxt -&gt; logged_return (rest, ctxt)
  | (Dup, Item (v, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.stack_op)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (v, Item (v, rest)), ctxt)
  | (Swap, Item (vi, Item (vo, rest))) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.stack_op)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (vo, Item (vi, rest)), ctxt)
  | (Const v, rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.push)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (v, rest), ctxt)
  (* options *)
  | (Cons_some, Item (v, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.wrap)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (Some v, rest), ctxt)
  | (Cons_none _, rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.variant_no_data)
      &gt;&gt;=? fun ctxt -&gt;
      logged_return (Item ((None [@coq_implicit &quot;(A := unit)&quot;]), rest), ctxt)
  | (If_none (bt, bf), Item (v, rest)) -&gt; (
    match v with
    | None -&gt;
        Lwt.return (Gas.consume ctxt Interp_costs.branch)
        &gt;&gt;=? fun ctxt -&gt; step_descr ?log ctxt step_constants bt rest
    | Some v -&gt;
        Lwt.return (Gas.consume ctxt Interp_costs.branch)
        &gt;&gt;=? fun ctxt -&gt;
        step_descr ?log ctxt step_constants bf (Item (v, rest)) )
  (* pairs *)
  | (Cons_pair, Item (a, Item (b, rest))) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.pair)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item ((a, b), rest), ctxt)
  (*(* Peephole optimization for UNPAIR *)
  | ( Seq
        ( {instr = Dup; _},
          { instr =
              Seq
                ( {instr = Car; _},
                  { instr = Seq ({instr = Dip {instr = Cdr}}, {instr = Nop; _});
                    _ } );
            _ } ),
      Item ((pair : (_, _) pair), rest) ) -&gt;
      let (a, b) = pair in
      Lwt.return (Gas.consume ctxt Interp_costs.pair_access)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (a, Item (b, rest)), ctxt)*)
  | (Car, Item (pair, rest)) -&gt;
      let (a, _) = pair in
      Lwt.return (Gas.consume ctxt Interp_costs.pair_access)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (a, rest), ctxt)
  | (Cdr, Item (pair, rest)) -&gt;
      let (_, b) = pair in
      Lwt.return (Gas.consume ctxt Interp_costs.pair_access)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (b, rest), ctxt)
  (* unions *)
  | (Left, Item (v, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.wrap)
      &gt;&gt;=? fun ctxt -&gt;
      logged_return (Item ((L v [@coq_implicit &quot;(b := unit)&quot;]), rest), ctxt)
  | (Right, Item (v, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.wrap)
      &gt;&gt;=? fun ctxt -&gt;
      logged_return (Item ((R v [@coq_implicit &quot;(a := unit)&quot;]), rest), ctxt)
  | (If_left (bt, bf), Item (v, rest)) -&gt; (
    match v with
    | L v -&gt;
        Lwt.return (Gas.consume ctxt Interp_costs.branch)
        &gt;&gt;=? fun ctxt -&gt;
        step_descr ?log ctxt step_constants bt (Item (v, rest))
    | R v -&gt;
        Lwt.return (Gas.consume ctxt Interp_costs.branch)
        &gt;&gt;=? fun ctxt -&gt;
        step_descr ?log ctxt step_constants bf (Item (v, rest)) )
  (* lists *)
  | (Cons_list, Item (hd, Item (tl, rest))) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.cons)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (hd :: tl, rest), ctxt)
  | (Nil, rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.variant_no_data)
      &gt;&gt;=? fun ctxt -&gt;
      logged_return (Item (([] [@coq_implicit &quot;(A := unit)&quot;]), rest), ctxt)
  | (If_cons (bt, bf), Item (l, rest)) -&gt; (
    match l with
    | [] -&gt;
        Lwt.return (Gas.consume ctxt Interp_costs.branch)
        &gt;&gt;=? fun ctxt -&gt; step_descr ?log ctxt step_constants bf rest
    | hd :: tl -&gt;
        Lwt.return (Gas.consume ctxt Interp_costs.branch)
        &gt;&gt;=? fun ctxt -&gt;
        step_descr ?log ctxt step_constants bt (Item (hd, Item (tl, rest))) )
  | (List_map body, Item (l, rest)) -&gt;
      loop_list_map
        ?log
        step_constants
        body
        rest
        ctxt
        l
        ([] [@coq_implicit &quot;(A := unit)&quot;])
      &gt;&gt;=? fun (res, ctxt) -&gt; logged_return (res, ctxt)
  | (List_size, Item (list, rest)) -&gt;
      Lwt.return
        (List.fold_left
           (fun acc _ -&gt;
             acc
             &gt;&gt;? fun (size, ctxt) -&gt;
             Gas.consume ctxt Interp_costs.loop_size
             &gt;&gt;? fun ctxt -&gt; ok (size + 1 (* FIXME: overflow *), ctxt))
           (ok (0, ctxt))
           list)
      &gt;&gt;=? fun (len, ctxt) -&gt;
      logged_return (Item (Script_int.(abs (of_int len)), rest), ctxt)
  | (List_iter body, Item (l, init)) -&gt;
      let[@coq_struct &quot;l&quot;] rec loop ctxt l stack =
        Lwt.return (Gas.consume ctxt Interp_costs.loop_iter)
        &gt;&gt;=? fun ctxt -&gt;
        match l with
        | [] -&gt;
            return (stack, ctxt)
        | hd :: tl -&gt;
            step_descr ?log ctxt step_constants body (Item (hd, stack))
            &gt;&gt;=? fun (stack, ctxt) -&gt; loop ctxt tl stack
      in
      loop ctxt l init &gt;&gt;=? fun (res, ctxt) -&gt; logged_return (res, ctxt)
  (* sets *)
  | (Empty_set t, rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.empty_set)
      &gt;&gt;=? fun ctxt -&gt;
      logged_return
        (Item ((empty_set [@coq_implicit &quot;(a := unit)&quot;]) t, rest), ctxt)
  | (Set_iter body, Item (set, init)) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.set_to_list set))
      &gt;&gt;=? fun ctxt -&gt;
      let l = List.rev (set_fold (fun e acc -&gt; e :: acc) set []) in
      let[@coq_struct &quot;l&quot;] rec loop ctxt l stack =
        Lwt.return (Gas.consume ctxt Interp_costs.loop_iter)
        &gt;&gt;=? fun ctxt -&gt;
        match l with
        | [] -&gt;
            return (stack, ctxt)
        | hd :: tl -&gt;
            step_descr ?log ctxt step_constants body (Item (hd, stack))
            &gt;&gt;=? fun (stack, ctxt) -&gt; loop ctxt tl stack
      in
      loop ctxt l init &gt;&gt;=? fun (res, ctxt) -&gt; logged_return (res, ctxt)
  | (Set_mem, Item (v, Item (set, rest))) -&gt;
      consume_gas_binop descr (set_mem, v, set) Interp_costs.set_mem rest ctxt
  | (Set_update, Item (v, Item (presence, Item (set, rest)))) -&gt;
      consume_gas_terop
        descr
        (set_update, v, presence, set)
        Interp_costs.set_update
        rest
  | (Set_size, Item (set, rest)) -&gt;
      consume_gas_unop
        descr
        (set_size, set)
        (fun _ -&gt; Interp_costs.set_size)
        rest
        ctxt
  (* maps *)
  | (Empty_map (t, _), rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.empty_map)
      &gt;&gt;=? fun ctxt -&gt;
      logged_return
        ( Item ((empty_map [@coq_implicit &quot;(a := unit) (b := unit)&quot;]) t, rest),
          ctxt )
  | (Map_map body, Item (map, rest)) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.map_to_list map))
      &gt;&gt;=? fun ctxt -&gt;
      let l = List.rev (map_fold (fun k v acc -&gt; (k, v) :: acc) map []) in
      let[@coq_struct &quot;l&quot;] rec loop body rest ctxt l acc =
        Lwt.return (Gas.consume ctxt Interp_costs.loop_map)
        &gt;&gt;=? fun ctxt -&gt;
        match l with
        | [] -&gt;
            return (acc, ctxt)
        | ((k, _) as hd) :: tl -&gt;
            step_descr ?log ctxt step_constants body (Item (hd, rest))
            &gt;&gt;=? fun [@coq_match_gadt] [@coq_match_with_default] ( Item
                                                                     (hd, rest),
                                                                   ctxt ) -&gt;
            loop body rest ctxt tl (map_update k (Some hd) acc)
      in
      loop
        body
        rest
        ctxt
        l
        ((empty_map [@coq_implicit &quot;(b := unit)&quot;]) (map_key_ty map))
      &gt;&gt;=? fun (res, ctxt) -&gt; logged_return (Item (res, rest), ctxt)
  | (Map_iter body, Item (map, init)) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.map_to_list map))
      &gt;&gt;=? fun ctxt -&gt;
      let l = List.rev (map_fold (fun k v acc -&gt; (k, v) :: acc) map []) in
      let[@coq_struct &quot;l&quot;] rec loop ctxt l stack =
        Lwt.return (Gas.consume ctxt Interp_costs.loop_iter)
        &gt;&gt;=? fun ctxt -&gt;
        match l with
        | [] -&gt;
            return (stack, ctxt)
        | hd :: tl -&gt;
            step_descr ?log ctxt step_constants body (Item (hd, stack))
            &gt;&gt;=? fun (stack, ctxt) -&gt; loop ctxt tl stack
      in
      loop ctxt l init &gt;&gt;=? fun (res, ctxt) -&gt; logged_return (res, ctxt)
  | (Map_mem, Item (v, Item (map, rest))) -&gt;
      consume_gas_binop descr (map_mem, v, map) Interp_costs.map_mem rest ctxt
  | (Map_get, Item (v, Item (map, rest))) -&gt;
      consume_gas_binop descr (map_get, v, map) Interp_costs.map_get rest ctxt
  | (Map_update, Item (k, Item (v, Item (map, rest)))) -&gt;
      consume_gas_terop
        descr
        (map_update, k, v, map)
        Interp_costs.map_update
        rest
  | (Map_size, Item (map, rest)) -&gt;
      consume_gas_unop
        descr
        (map_size, map)
        (fun _ -&gt; Interp_costs.map_size)
        rest
        ctxt
  (* Big map operations *)
  | (Empty_big_map (tk, tv), rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.empty_map)
      &gt;&gt;=? fun ctxt -&gt;
      logged_return
        ( Item
            ( (Script_ir_translator.empty_big_map [@coq_implicit
                                                    &quot;(A := unit) (B := unit)&quot;])
                tk
                tv,
              rest ),
          ctxt )
  | (Big_map_mem, Item (key, Item (map, rest))) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.map_mem key map.diff))
      &gt;&gt;=? fun ctxt -&gt;
      Script_ir_translator.big_map_mem ctxt key map
      &gt;&gt;=? fun (res, ctxt) -&gt; logged_return (Item (res, rest), ctxt)
  | (Big_map_get, Item (key, Item (map, rest))) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.map_get key map.diff))
      &gt;&gt;=? fun ctxt -&gt;
      Script_ir_translator.big_map_get ctxt key map
      &gt;&gt;=? fun (res, ctxt) -&gt; logged_return (Item (res, rest), ctxt)
  | (Big_map_update, Item (key, Item (maybe_value, Item (map, rest)))) -&gt;
      consume_gas_terop
        descr
        (Script_ir_translator.big_map_update, key, maybe_value, map)
        (fun k v m -&gt; Interp_costs.map_update k (Some v) m.diff)
        rest
  (* timestamp operations *)
  | (Add_seconds_to_timestamp, Item (n, Item (t, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_timestamp.add_delta, t, n)
        Interp_costs.add_timestamp
        rest
        ctxt
  | (Add_timestamp_to_seconds, Item (t, Item (n, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_timestamp.add_delta, t, n)
        Interp_costs.add_timestamp
        rest
        ctxt
  | (Sub_timestamp_seconds, Item (t, Item (s, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_timestamp.sub_delta, t, s)
        Interp_costs.sub_timestamp
        rest
        ctxt
  | (Diff_timestamps, Item (t1, Item (t2, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_timestamp.diff, t1, t2)
        Interp_costs.diff_timestamps
        rest
        ctxt
  (* string operations *)
  | (Concat_string_pair, Item (x, Item (y, rest))) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.concat_string [x; y]))
      &gt;&gt;=? fun ctxt -&gt;
      let s = String.concat &quot;&quot; [x; y] in
      logged_return (Item (s, rest), ctxt)
  | (Concat_string, Item (ss, rest)) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.concat_string ss))
      &gt;&gt;=? fun ctxt -&gt;
      let s = String.concat &quot;&quot; ss in
      logged_return (Item (s, rest), ctxt)
  | (Slice_string, Item (offset, Item (length, Item (s, rest)))) -&gt;
      let s_length = Z.of_int (String.length s) in
      let offset = Script_int.to_zint offset in
      let length = Script_int.to_zint length in
      if Compare.Z.(offset &lt; s_length &amp;&amp; Z.add offset length &lt;= s_length) then
        Lwt.return
          (Gas.consume ctxt (Interp_costs.slice_string (Z.to_int length)))
        &gt;&gt;=? fun ctxt -&gt;
        logged_return
          ( Item (Some (String.sub s (Z.to_int offset) (Z.to_int length)), rest),
            ctxt )
      else
        Lwt.return (Gas.consume ctxt (Interp_costs.slice_string 0))
        &gt;&gt;=? fun ctxt -&gt;
        logged_return (Item ((None [@coq_implicit &quot;(A := unit)&quot;]), rest), ctxt)
  | (String_size, Item (s, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.push)
      &gt;&gt;=? fun ctxt -&gt;
      logged_return
        (Item (Script_int.(abs (of_int (String.length s))), rest), ctxt)
  (* bytes operations *)
  | (Concat_bytes_pair, Item (x, Item (y, rest))) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.concat_bytes [x; y]))
      &gt;&gt;=? fun ctxt -&gt;
      let s = MBytes.concat &quot;&quot; [x; y] in
      logged_return (Item (s, rest), ctxt)
  | (Concat_bytes, Item (ss, rest)) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.concat_bytes ss))
      &gt;&gt;=? fun ctxt -&gt;
      let s = MBytes.concat &quot;&quot; ss in
      logged_return (Item (s, rest), ctxt)
  | (Slice_bytes, Item (offset, Item (length, Item (s, rest)))) -&gt;
      let s_length = Z.of_int (MBytes.length s) in
      let offset = Script_int.to_zint offset in
      let length = Script_int.to_zint length in
      if Compare.Z.(offset &lt; s_length &amp;&amp; Z.add offset length &lt;= s_length) then
        Lwt.return
          (Gas.consume ctxt (Interp_costs.slice_string (Z.to_int length)))
        &gt;&gt;=? fun ctxt -&gt;
        logged_return
          ( Item (Some (MBytes.sub s (Z.to_int offset) (Z.to_int length)), rest),
            ctxt )
      else
        Lwt.return (Gas.consume ctxt (Interp_costs.slice_string 0))
        &gt;&gt;=? fun ctxt -&gt;
        logged_return (Item ((None [@coq_implicit &quot;(A := unit)&quot;]), rest), ctxt)
  | (Bytes_size, Item (s, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.push)
      &gt;&gt;=? fun ctxt -&gt;
      logged_return
        (Item (Script_int.(abs (of_int (MBytes.length s))), rest), ctxt)
  (* currency operations *)
  | (Add_tez, Item (x, Item (y, rest))) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.int64_op)
      &gt;&gt;=? fun ctxt -&gt;
      Lwt.return Tez.(x +? y)
      &gt;&gt;=? fun res -&gt; logged_return (Item (res, rest), ctxt)
  | (Sub_tez, Item (x, Item (y, rest))) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.int64_op)
      &gt;&gt;=? fun ctxt -&gt;
      Lwt.return Tez.(x -? y)
      &gt;&gt;=? fun res -&gt; logged_return (Item (res, rest), ctxt)
  | (Mul_teznat, Item (x, Item (y, rest))) -&gt; (
      Lwt.return (Gas.consume ctxt Interp_costs.int64_op)
      &gt;&gt;=? fun ctxt -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.z_to_int64)
      &gt;&gt;=? fun ctxt -&gt;
      match Script_int.to_int64 y with
      | None -&gt;
          fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Overflow (loc, get_log log))</abbr>
      | Some y -&gt;
          Lwt.return Tez.(x *? y)
          &gt;&gt;=? fun res -&gt; logged_return (Item (res, rest), ctxt) )
  | (Mul_nattez, Item (y, Item (x, rest))) -&gt; (
      Lwt.return (Gas.consume ctxt Interp_costs.int64_op)
      &gt;&gt;=? fun ctxt -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.z_to_int64)
      &gt;&gt;=? fun ctxt -&gt;
      match Script_int.to_int64 y with
      | None -&gt;
          fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Overflow (loc, get_log log))</abbr>
      | Some y -&gt;
          Lwt.return Tez.(x *? y)
          &gt;&gt;=? fun res -&gt; logged_return (Item (res, rest), ctxt) )
  (* boolean operations *)
  | (Or, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop descr (( || ), x, y) Interp_costs.bool_binop rest ctxt
  | (And, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop descr (( &amp;&amp; ), x, y) Interp_costs.bool_binop rest ctxt
  | (Xor, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop
        descr
        (Compare.Bool.( &lt;&gt; ), x, y)
        Interp_costs.bool_binop
        rest
        ctxt
  | (Not, Item (x, rest)) -&gt;
      consume_gas_unop descr (not, x) Interp_costs.bool_unop rest ctxt
  (* integer operations *)
  | (Is_nat, Item (x, rest)) -&gt;
      consume_gas_unop descr (Script_int.is_nat, x) Interp_costs.abs rest ctxt
  | (Abs_int, Item (x, rest)) -&gt;
      consume_gas_unop descr (Script_int.abs, x) Interp_costs.abs rest ctxt
  | (Int_nat, Item (x, rest)) -&gt;
      consume_gas_unop descr (Script_int.int, x) Interp_costs.int rest ctxt
  | (Neg_int, Item (x, rest)) -&gt;
      consume_gas_unop descr (Script_int.neg, x) Interp_costs.neg rest ctxt
  | (Neg_nat, Item (x, rest)) -&gt;
      consume_gas_unop descr (Script_int.neg, x) Interp_costs.neg rest ctxt
  | (Add_intint, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop descr (Script_int.add, x, y) Interp_costs.add rest ctxt
  | (Add_intnat, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop descr (Script_int.add, x, y) Interp_costs.add rest ctxt
  | (Add_natint, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop descr (Script_int.add, x, y) Interp_costs.add rest ctxt
  | (Add_natnat, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_int.add_n, x, y)
        Interp_costs.add
        rest
        ctxt
  | (Sub_int, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop descr (Script_int.sub, x, y) Interp_costs.sub rest ctxt
  | (Mul_intint, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop descr (Script_int.mul, x, y) Interp_costs.mul rest ctxt
  | (Mul_intnat, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop descr (Script_int.mul, x, y) Interp_costs.mul rest ctxt
  | (Mul_natint, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop descr (Script_int.mul, x, y) Interp_costs.mul rest ctxt
  | (Mul_natnat, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_int.mul_n, x, y)
        Interp_costs.mul
        rest
        ctxt
  | (Ediv_teznat, Item (x, Item (y, rest))) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.int64_to_z)
      &gt;&gt;=? fun ctxt -&gt;
      let x = Script_int.of_int64 (Tez.to_mutez x) in
      let op x y =
        match Script_int.ediv x y with
        | None -&gt;
            None
        | Some (q, r) -&gt; (
          match (Script_int.to_int64 q, Script_int.to_int64 r) with
          | (Some q, Some r) -&gt; (
            match (Tez.of_mutez q, Tez.of_mutez r) with
            | (Some q, Some r) -&gt;
                Some (q, r)
            (* Cannot overflow *)
            | _ -&gt;
                <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr> )
          (* Cannot overflow *)
          | _ -&gt;
              <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr> )
      in
      consume_gas_binop descr (op, x, y) Interp_costs.div rest ctxt
  | (Ediv_tez, Item (x, Item (y, rest))) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.int64_to_z)
      &gt;&gt;=? fun ctxt -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.int64_to_z)
      &gt;&gt;=? fun ctxt -&gt;
      let x = Script_int.abs (Script_int.of_int64 (Tez.to_mutez x)) in
      let y = Script_int.abs (Script_int.of_int64 (Tez.to_mutez y)) in
      let op x y =
        match Script_int.ediv_n x y with
        | None -&gt;
            None
        | Some (q, r) -&gt; (
          match Script_int.to_int64 r with
          | None -&gt;
              <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr> (* Cannot overflow *)
          | Some r -&gt; (
            match Tez.of_mutez r with
            | None -&gt;
                <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr> (* Cannot overflow *)
            | Some r -&gt;
                Some (q, r) ) )
      in
      consume_gas_binop descr (op, x, y) Interp_costs.div rest ctxt
  | (Ediv_intint, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_int.ediv, x, y)
        Interp_costs.div
        rest
        ctxt
  | (Ediv_intnat, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_int.ediv, x, y)
        Interp_costs.div
        rest
        ctxt
  | (Ediv_natint, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_int.ediv, x, y)
        Interp_costs.div
        rest
        ctxt
  | (Ediv_natnat, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_int.ediv_n, x, y)
        Interp_costs.div
        rest
        ctxt
  | (Lsl_nat, Item (x, Item (y, rest))) -&gt; (
      Lwt.return (Gas.consume ctxt (Interp_costs.shift_left x y))
      &gt;&gt;=? fun ctxt -&gt;
      match Script_int.shift_left_n x y with
      | None -&gt;
          fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Overflow (loc, get_log log))</abbr>
      | Some x -&gt;
          logged_return (Item (x, rest), ctxt) )
  | (Lsr_nat, Item (x, Item (y, rest))) -&gt; (
      Lwt.return (Gas.consume ctxt (Interp_costs.shift_right x y))
      &gt;&gt;=? fun ctxt -&gt;
      match Script_int.shift_right_n x y with
      | None -&gt;
          fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Overflow (loc, get_log log))</abbr>
      | Some r -&gt;
          logged_return (Item (r, rest), ctxt) )
  | (Or_nat, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_int.logor, x, y)
        Interp_costs.logor
        rest
        ctxt
  | (And_nat, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_int.logand, x, y)
        Interp_costs.logand
        rest
        ctxt
  | (And_int_nat, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_int.logand, x, y)
        Interp_costs.logand
        rest
        ctxt
  | (Xor_nat, Item (x, Item (y, rest))) -&gt;
      consume_gas_binop
        descr
        (Script_int.logxor, x, y)
        Interp_costs.logxor
        rest
        ctxt
  | (Not_int, Item (x, rest)) -&gt;
      consume_gas_unop
        descr
        (Script_int.lognot, x)
        Interp_costs.lognot
        rest
        ctxt
  | (Not_nat, Item (x, rest)) -&gt;
      consume_gas_unop
        descr
        (Script_int.lognot, x)
        Interp_costs.lognot
        rest
        ctxt
  (* control *)
  | (Seq (hd, tl), stack) -&gt;
      step_descr ?log ctxt step_constants hd stack
      &gt;&gt;=? fun (trans, ctxt) -&gt; step_descr ?log ctxt step_constants tl trans
  | (If (bt, bf), Item (b, rest)) -&gt;
      if b then
        Lwt.return (Gas.consume ctxt Interp_costs.branch)
        &gt;&gt;=? fun ctxt -&gt; step_descr ?log ctxt step_constants bt rest
      else
        Lwt.return (Gas.consume ctxt Interp_costs.branch)
        &gt;&gt;=? fun ctxt -&gt; step_descr ?log ctxt step_constants bf rest
  | (Loop body, Item (b, rest)) -&gt;
      if b then
        Lwt.return (Gas.consume ctxt Interp_costs.loop_cycle)
        &gt;&gt;=? fun ctxt -&gt;
        step_descr ?log ctxt step_constants body rest
        &gt;&gt;=? fun (trans, ctxt) -&gt;
        step_descr ?log ctxt step_constants descr trans
      else logged_return (rest, ctxt)
  | (Loop_left body, Item (v, rest)) -&gt; (
    match v with
    | L v -&gt;
        Lwt.return (Gas.consume ctxt Interp_costs.loop_cycle)
        &gt;&gt;=? fun ctxt -&gt;
        step_descr ?log ctxt step_constants body (Item (v, rest))
        &gt;&gt;=? fun (trans, ctxt) -&gt;
        step_descr ?log ctxt step_constants descr trans
    | R v -&gt;
        Lwt.return (Gas.consume ctxt Interp_costs.loop_cycle)
        &gt;&gt;=? fun ctxt -&gt; logged_return (Item (v, rest), ctxt) )
  | (Dip b, Item (ign, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.stack_op)
      &gt;&gt;=? fun ctxt -&gt;
      step_descr ?log ctxt step_constants b rest
      &gt;&gt;=? fun (res, ctxt) -&gt; logged_return (Item (ign, res), ctxt)
  | (Exec, Item (arg, Item (lam, rest))) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.exec)
      &gt;&gt;=? fun ctxt -&gt;
      interp ?log ctxt step_constants lam arg
      &gt;&gt;=? fun (res, ctxt) -&gt;
      logged_return ((Item (res, rest) [@coq_implicit &quot;(ty := unit)&quot;]), ctxt)
  | (Apply capture_ty, Item (capture, Item (lam, rest))) -&gt; (
      Lwt.return (Gas.consume ctxt Interp_costs.apply)
      &gt;&gt;=? fun ctxt -&gt;
      let {lam = (descr, expr)} = lam in
      let full_arg_ty =
        match[@coq_match_with_default] descr.bef with
        | Item_t (full_arg_ty, _, _) -&gt;
            full_arg_ty
      in
      unparse_data ctxt Optimized capture_ty capture
      &gt;&gt;=? fun (const_expr, ctxt) -&gt;
      unparse_ty ctxt capture_ty
      &gt;&gt;=? fun (ty_expr, ctxt) -&gt;
      match[@coq_match_gadt] full_arg_ty with
      | Pair_t ((capture_ty, _, _), (arg_ty, _, _), _, _) -&gt;
          let arg_stack_ty = Item_t (arg_ty, Empty_t, None) in
          let const_descr =
            ( {
                loc = descr.loc;
                bef = arg_stack_ty;
                aft = Item_t (capture_ty, arg_stack_ty, None);
                instr = Const capture;
              }
              : (_, _) descr )
          in
          let pair_descr =
            ( {
                loc = descr.loc;
                bef = Item_t (capture_ty, arg_stack_ty, None);
                aft = Item_t (full_arg_ty, Empty_t, None);
                instr = Cons_pair;
              }
              : (_, _) descr )
          in
          let seq_descr =
            ( {
                loc = descr.loc;
                bef = arg_stack_ty;
                aft = Item_t (full_arg_ty, Empty_t, None);
                instr = Seq (const_descr, pair_descr);
              }
              : (_, _) descr )
          in
          let full_descr =
            ( {
                loc = descr.loc;
                bef = arg_stack_ty;
                aft = descr.aft;
                instr = Seq (seq_descr, descr);
              }
              : (_, _) descr )
          in
          let full_expr =
            Micheline.Seq
              ( 0,
                [ Prim (0, I_PUSH, [ty_expr; const_expr], []);
                  Prim (0, I_PAIR, [], []);
                  expr ] )
          in
          let lam' = {lam = (full_descr, full_expr)} in
          logged_return (Item (lam', rest), ctxt)
      | _ -&gt;
          <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr> )
  | (Lambda lam, rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.push)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (lam, rest), ctxt)
  | (Failwith tv, Item (v, _)) -&gt;
      trace <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Cannot_serialize_failure</abbr> (unparse_data ctxt Optimized tv v)
      &gt;&gt;=? fun (v, _ctxt) -&gt;
      let v = Micheline.strip_locations v in
      fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Reject (loc, v, get_log log))</abbr>
  | (Nop, stack) -&gt;
      logged_return (stack, ctxt)
  (* comparison *)
  | (Compare ty, Item (a, Item (b, rest))) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.compare ty a b))
      &gt;&gt;=? fun ctxt -&gt;
      logged_return
        ( Item
            ( Script_int.of_int
              @@ Script_ir_translator.compare_comparable ty a b,
              rest ),
          ctxt )
  (* comparators *)
  | (Eq, Item (cmpres, rest)) -&gt;
      let cmpres = Script_int.compare cmpres Script_int.zero in
      let cmpres = Compare.Int.(cmpres = 0) in
      Lwt.return (Gas.consume ctxt Interp_costs.compare_res)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (cmpres, rest), ctxt)
  | (Neq, Item (cmpres, rest)) -&gt;
      let cmpres = Script_int.compare cmpres Script_int.zero in
      let cmpres = Compare.Int.(cmpres &lt;&gt; 0) in
      Lwt.return (Gas.consume ctxt Interp_costs.compare_res)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (cmpres, rest), ctxt)
  | (Lt, Item (cmpres, rest)) -&gt;
      let cmpres = Script_int.compare cmpres Script_int.zero in
      let cmpres = Compare.Int.(cmpres &lt; 0) in
      Lwt.return (Gas.consume ctxt Interp_costs.compare_res)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (cmpres, rest), ctxt)
  | (Le, Item (cmpres, rest)) -&gt;
      let cmpres = Script_int.compare cmpres Script_int.zero in
      let cmpres = Compare.Int.(cmpres &lt;= 0) in
      Lwt.return (Gas.consume ctxt Interp_costs.compare_res)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (cmpres, rest), ctxt)
  | (Gt, Item (cmpres, rest)) -&gt;
      let cmpres = Script_int.compare cmpres Script_int.zero in
      let cmpres = Compare.Int.(cmpres &gt; 0) in
      Lwt.return (Gas.consume ctxt Interp_costs.compare_res)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (cmpres, rest), ctxt)
  | (Ge, Item (cmpres, rest)) -&gt;
      let cmpres = Script_int.compare cmpres Script_int.zero in
      let cmpres = Compare.Int.(cmpres &gt;= 0) in
      Lwt.return (Gas.consume ctxt Interp_costs.compare_res)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (cmpres, rest), ctxt)
  (* packing *)
  | (Pack t, Item (value, rest)) -&gt;
      Script_ir_translator.pack_data ctxt t value
      &gt;&gt;=? fun (bytes, ctxt) -&gt; logged_return (Item (bytes, rest), ctxt)
  | (Unpack t, Item (bytes, rest)) -&gt;
      Lwt.return (Gas.check_enough ctxt (Script.serialized_cost bytes))
      &gt;&gt;=? fun () -&gt;
      if
        Compare.Int.(MBytes.length bytes &gt;= 1)
        &amp;&amp; Compare.Int.(MBytes.get_uint8 bytes 0 = 0x05)
      then
        let bytes = MBytes.sub bytes 1 (MBytes.length bytes - 1) in
        match Data_encoding.Binary.of_bytes Script.expr_encoding bytes with
        | None -&gt;
            Lwt.return (Gas.consume ctxt (Interp_costs.unpack_failed bytes))
            &gt;&gt;=? fun ctxt -&gt;
            logged_return
              (Item ((None [@coq_implicit &quot;(A := unit)&quot;]), rest), ctxt)
        | Some expr -&gt; (
            Lwt.return (Gas.consume ctxt (Script.deserialized_cost expr))
            &gt;&gt;=? fun ctxt -&gt;
            (parse_data [@coq_implicit &quot;(a := unit)&quot;])
              ctxt
              ~legacy:false
              t
              (Micheline.root expr)
            &gt;&gt;= function
            | Ok (value, ctxt) -&gt;
                logged_return (Item (Some value, rest), ctxt)
            | Error _ignored -&gt;
                Lwt.return
                  (Gas.consume ctxt (Interp_costs.unpack_failed bytes))
                &gt;&gt;=? fun ctxt -&gt;
                logged_return
                  (Item ((None [@coq_implicit &quot;(A := unit)&quot;]), rest), ctxt) )
      else
        logged_return (Item ((None [@coq_implicit &quot;(A := unit)&quot;]), rest), ctxt)
  (* protocol *)
  | (Address, Item (pair, rest)) -&gt;
      let (_, address) = pair in
      Lwt.return (Gas.consume ctxt Interp_costs.address)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (address, rest), ctxt)
  | (Contract (t, entrypoint), Item (contract, rest)) -&gt; (
      Lwt.return (Gas.consume ctxt Interp_costs.contract)
      &gt;&gt;=? fun ctxt -&gt;
      let (contract, entrypoint') = contract in
      let entrypoint =
        match (entrypoint, entrypoint') with
        | (&quot;default&quot;, entrypoint) -&gt;
            Some entrypoint
        | (entrypoint, &quot;default&quot;) -&gt;
            Some entrypoint
        | _ -&gt;
            None
      in
      match entrypoint with
      | Some entrypoint -&gt;
          Script_ir_translator.parse_contract_for_script
            ~legacy:false
            ctxt
            loc
            t
            contract
            ~entrypoint
          &gt;&gt;=? fun (ctxt, maybe_contract) -&gt;
          logged_return (Item (maybe_contract, rest), ctxt)
      | _ -&gt;
          logged_return
            (Item ((None [@coq_implicit &quot;(A := unit)&quot;]), rest), ctxt) )
  | (Transfer_tokens, Item (p, Item (amount, Item (triple, rest)))) -&gt;
      let (tp, (destination, entrypoint)) = triple in
      Lwt.return (Gas.consume ctxt Interp_costs.transfer)
      &gt;&gt;=? fun ctxt -&gt;
      collect_big_maps ctxt tp p
      &gt;&gt;=? fun (to_duplicate, ctxt) -&gt;
      let to_update = no_big_map_id in
      extract_big_map_diff
        ctxt
        Optimized
        tp
        p
        ~to_duplicate
        ~to_update
        ~temporary:true
      &gt;&gt;=? fun (p, big_map_diff, ctxt) -&gt;
      unparse_data ctxt Optimized tp p
      &gt;&gt;=? fun (p, ctxt) -&gt;
      let operation =
        Transaction
          {
            amount;
            destination;
            entrypoint;
            parameters = Script.lazy_expr (Micheline.strip_locations p);
          }
      in
      Lwt.return (fresh_internal_nonce ctxt)
      &gt;&gt;=? fun (ctxt, nonce) -&gt;
      logged_return
        ( Item
            ( ( Internal_operation
                  {source = step_constants.self; operation; nonce},
                big_map_diff ),
              rest ),
          ctxt )
  | ( Create_account,
      Item (manager, Item (delegate, Item (_delegatable, Item (credit, rest))))
    ) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.create_account)
      &gt;&gt;=? fun ctxt -&gt;
      Contract.fresh_contract_from_current_nonce ctxt
      &gt;&gt;=? fun (ctxt, contract) -&gt;
      (* store in optimized binary representation - as unparsed with [Optimized]. *)
      let manager_bytes =
        Data_encoding.Binary.to_bytes_exn
          Signature.Public_key_hash.encoding
          manager
      in
      let storage =
        Script_repr.lazy_expr @@ Micheline.strip_locations
        @@ Micheline.Bytes (0, manager_bytes)
      in
      let script = {code = Legacy_support.manager_script_code; storage} in
      let operation =
        Origination {credit; delegate; preorigination = Some contract; script}
      in
      Lwt.return (fresh_internal_nonce ctxt)
      &gt;&gt;=? fun (ctxt, nonce) -&gt;
      logged_return
        ( Item
            ( ( Internal_operation
                  {source = step_constants.self; operation; nonce},
                (None [@coq_implicit &quot;(A := unit)&quot;]) ),
              Item ((contract, &quot;default&quot;), rest) ),
          ctxt )
  | (Implicit_account, Item (key, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.implicit_account)
      &gt;&gt;=? fun ctxt -&gt;
      let contract = Contract.implicit_contract key in
      logged_return (Item ((Unit_t None, (contract, &quot;default&quot;)), rest), ctxt)
  | ( Create_contract (storage_type, param_type, {lam = (_, code)}, root_name),
      Item
        ( manager,
          Item
            ( delegate,
              Item
                ( spendable,
                  Item (delegatable, Item (credit, Item (init, rest))) ) ) ) )
    -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.create_contract)
      &gt;&gt;=? fun ctxt -&gt;
      unparse_ty ctxt param_type
      &gt;&gt;=? fun (unparsed_param_type, ctxt) -&gt;
      let unparsed_param_type =
        Script_ir_translator.add_field_annot
          (Option.map ~f:(fun n -&gt; Field_annot n) root_name)
          None
          unparsed_param_type
      in
      unparse_ty ctxt storage_type
      &gt;&gt;=? fun (unparsed_storage_type, ctxt) -&gt;
      let code =
        Script.lazy_expr
        @@ Micheline.strip_locations
             (Seq
                ( 0,
                  [ Prim (0, K_parameter, [unparsed_param_type], []);
                    Prim (0, K_storage, [unparsed_storage_type], []);
                    Prim (0, K_code, [code], []) ] ))
      in
      collect_big_maps ctxt storage_type init
      &gt;&gt;=? fun (to_duplicate, ctxt) -&gt;
      let to_update = no_big_map_id in
      extract_big_map_diff
        ctxt
        Optimized
        storage_type
        init
        ~to_duplicate
        ~to_update
        ~temporary:true
      &gt;&gt;=? fun (init, big_map_diff, ctxt) -&gt;
      unparse_data ctxt Optimized storage_type init
      &gt;&gt;=? fun (storage, ctxt) -&gt;
      let storage = Script.lazy_expr @@ Micheline.strip_locations storage in
      ( if spendable then
        Legacy_support.add_do
          ~manager_pkh:manager
          ~script_code:code
          ~script_storage:storage
      else if delegatable then
        Legacy_support.add_set_delegate
          ~manager_pkh:manager
          ~script_code:code
          ~script_storage:storage
      else if Legacy_support.has_default_entrypoint code then
        Legacy_support.add_root_entrypoint code
        &gt;&gt;=? fun code -&gt; return (code, storage)
      else return (code, storage) )
      &gt;&gt;=? fun (code, storage) -&gt;
      Contract.fresh_contract_from_current_nonce ctxt
      &gt;&gt;=? fun (ctxt, contract) -&gt;
      let operation =
        Origination
          {
            credit;
            delegate;
            preorigination = Some contract;
            script = {code; storage};
          }
      in
      Lwt.return (fresh_internal_nonce ctxt)
      &gt;&gt;=? fun (ctxt, nonce) -&gt;
      logged_return
        ( Item
            ( ( Internal_operation
                  {source = step_constants.self; operation; nonce},
                big_map_diff ),
              Item ((contract, &quot;default&quot;), rest) ),
          ctxt )
  | ( Create_contract_2 (storage_type, param_type, {lam = (_, code)}, root_name),
      (* Removed the instruction's arguments manager, spendable and delegatable *)
    Item (delegate, Item (credit, Item (init, rest))) ) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.create_contract)
      &gt;&gt;=? fun ctxt -&gt;
      unparse_ty ctxt param_type
      &gt;&gt;=? fun (unparsed_param_type, ctxt) -&gt;
      let unparsed_param_type =
        Script_ir_translator.add_field_annot
          (Option.map ~f:(fun n -&gt; Field_annot n) root_name)
          None
          unparsed_param_type
      in
      unparse_ty ctxt storage_type
      &gt;&gt;=? fun (unparsed_storage_type, ctxt) -&gt;
      let code =
        Micheline.strip_locations
          (Seq
             ( 0,
               [ Prim (0, K_parameter, [unparsed_param_type], []);
                 Prim (0, K_storage, [unparsed_storage_type], []);
                 Prim (0, K_code, [code], []) ] ))
      in
      collect_big_maps ctxt storage_type init
      &gt;&gt;=? fun (to_duplicate, ctxt) -&gt;
      let to_update = no_big_map_id in
      extract_big_map_diff
        ctxt
        Optimized
        storage_type
        init
        ~to_duplicate
        ~to_update
        ~temporary:true
      &gt;&gt;=? fun (init, big_map_diff, ctxt) -&gt;
      unparse_data ctxt Optimized storage_type init
      &gt;&gt;=? fun (storage, ctxt) -&gt;
      let storage = Micheline.strip_locations storage in
      Contract.fresh_contract_from_current_nonce ctxt
      &gt;&gt;=? fun (ctxt, contract) -&gt;
      let operation =
        Origination
          {
            credit;
            delegate;
            preorigination = Some contract;
            script =
              {
                code = Script.lazy_expr code;
                storage = Script.lazy_expr storage;
              };
          }
      in
      Lwt.return (fresh_internal_nonce ctxt)
      &gt;&gt;=? fun (ctxt, nonce) -&gt;
      logged_return
        ( Item
            ( ( Internal_operation
                  {source = step_constants.self; operation; nonce},
                big_map_diff ),
              Item ((contract, &quot;default&quot;), rest) ),
          ctxt )
  | (Set_delegate, Item (delegate, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.create_account)
      &gt;&gt;=? fun ctxt -&gt;
      let operation = Delegation delegate in
      Lwt.return (fresh_internal_nonce ctxt)
      &gt;&gt;=? fun (ctxt, nonce) -&gt;
      logged_return
        ( Item
            ( ( Internal_operation
                  {source = step_constants.self; operation; nonce},
                (None [@coq_implicit &quot;(A := unit)&quot;]) ),
              rest ),
          ctxt )
  | (Balance, rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.balance)
      &gt;&gt;=? fun ctxt -&gt;
      Contract.get_balance ctxt step_constants.self
      &gt;&gt;=? fun balance -&gt; logged_return (Item (balance, rest), ctxt)
  | (Now, rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.now)
      &gt;&gt;=? fun ctxt -&gt;
      let now = Script_timestamp.now ctxt in
      logged_return (Item (now, rest), ctxt)
  | (Check_signature, Item (key, Item (signature, Item (message, rest)))) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.check_signature key message))
      &gt;&gt;=? fun ctxt -&gt;
      let res = Signature.check key signature message in
      logged_return (Item (res, rest), ctxt)
  | (Hash_key, Item (key, rest)) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.hash_key)
      &gt;&gt;=? fun ctxt -&gt;
      logged_return (Item (Signature.Public_key.hash key, rest), ctxt)
  | (Blake2b, Item (bytes, rest)) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.hash_blake2b bytes))
      &gt;&gt;=? fun ctxt -&gt;
      let hash = Raw_hashes.blake2b bytes in
      logged_return (Item (hash, rest), ctxt)
  | (Sha256, Item (bytes, rest)) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.hash_sha256 bytes))
      &gt;&gt;=? fun ctxt -&gt;
      let hash = Raw_hashes.sha256 bytes in
      logged_return (Item (hash, rest), ctxt)
  | (Sha512, Item (bytes, rest)) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.hash_sha512 bytes))
      &gt;&gt;=? fun ctxt -&gt;
      let hash = Raw_hashes.sha512 bytes in
      logged_return (Item (hash, rest), ctxt)
  | (Steps_to_quota, rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.steps_to_quota)
      &gt;&gt;=? fun ctxt -&gt;
      let steps =
        match Gas.level ctxt with
        | Limited {remaining} -&gt;
            remaining
        | Unaccounted -&gt;
            Z.of_string &quot;99999999&quot;
      in
      logged_return (Item (Script_int.(abs (of_zint steps)), rest), ctxt)
  | (Source, rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.source)
      &gt;&gt;=? fun ctxt -&gt;
      logged_return (Item ((step_constants.payer, &quot;default&quot;), rest), ctxt)
  | (Sender, rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.source)
      &gt;&gt;=? fun ctxt -&gt;
      logged_return (Item ((step_constants.source, &quot;default&quot;), rest), ctxt)
  | (Self (t, entrypoint), rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.self)
      &gt;&gt;=? fun ctxt -&gt;
      logged_return (Item ((t, (step_constants.self, entrypoint)), rest), ctxt)
  | (Amount, rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.amount)
      &gt;&gt;=? fun ctxt -&gt; logged_return (Item (step_constants.amount, rest), ctxt)
  | (Dig (n, n'), stack) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.stack_n_op n))
      &gt;&gt;=? fun ctxt -&gt;
      let dig n' =
        interp_stack_prefix_preserving_operation
          (fun [@coq_match_gadt] [@coq_match_with_default] (Item (v, rest)) -&gt;
            return (rest, v))
          n'
          stack
      in
      (dig [@coq_implicit &quot;(A := unit)&quot;]) n'
      &gt;&gt;=? fun (aft, x) -&gt; logged_return (Item (x, aft), ctxt)
  | (Dug (n, n'), Item (v, rest)) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.stack_n_op n))
      &gt;&gt;=? fun ctxt -&gt;
      interp_stack_prefix_preserving_operation
        (fun stk -&gt; return (Item (v, stk), ()))
        n'
        rest
      &gt;&gt;=? fun (aft, ()) -&gt; logged_return (aft, ctxt)
  | (Dipn (n, n', b), stack) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.stack_n_op n))
      &gt;&gt;=? fun ctxt -&gt;
      interp_stack_prefix_preserving_operation
        (fun stk -&gt;
          step_descr ?log ctxt step_constants b stk
          &gt;&gt;=? fun (res, ctxt') -&gt; return (res, ctxt'))
        n'
        stack
      &gt;&gt;=? fun (aft, ctxt') -&gt; logged_return (aft, ctxt')
  | (Dropn (n, n'), stack) -&gt;
      Lwt.return (Gas.consume ctxt (Interp_costs.stack_n_op n))
      &gt;&gt;=? fun ctxt -&gt;
      interp_stack_prefix_preserving_operation
        (fun stk -&gt; return (stk, stk))
        n'
        stack
      &gt;&gt;=? fun (_, rest) -&gt; logged_return (rest, ctxt)
  | (ChainId, rest) -&gt;
      Lwt.return (Gas.consume ctxt Interp_costs.chain_id)
      &gt;&gt;=? fun ctxt -&gt;
      logged_return (Item (step_constants.chain_id, rest), ctxt)

and[@coq_struct &quot;l&quot;] loop_list_map :
    type a b r.
    ?log:execution_trace ref -&gt;
    step_constants -&gt;
    (a * r, b * r) descr -&gt;
    r stack -&gt;
    context -&gt;
    a list -&gt;
    b list -&gt;
    ((b list * r) stack * context) tzresult Lwt.t =
 fun ?log step_constants body rest ctxt l acc -&gt;
  Lwt.return (Gas.consume ctxt Interp_costs.loop_map)
  &gt;&gt;=? fun ctxt -&gt;
  match l with
  | [] -&gt;
      return (Item (List.rev acc, rest), ctxt)
  | hd :: tl -&gt;
      step_descr ?log ctxt step_constants body (Item (hd, rest))
      &gt;&gt;=? fun [@coq_match_gadt] [@coq_match_with_default] ( Item (hd, rest),
                                                             ctxt ) -&gt;
      loop_list_map ?log step_constants body rest ctxt tl (hd :: acc)

and[@coq_struct &quot;__descr_value&quot;] step_descr :
    type b a.
    ?log:execution_trace ref -&gt;
    context -&gt;
    step_constants -&gt;
    (b, a) descr -&gt;
    b stack -&gt;
    (a stack * context) tzresult Lwt.t =
 fun ?log ctxt step_constants descr stack -&gt;
  step descr.instr descr.loc descr.bef descr.aft ?log ctxt step_constants stack

and[@coq_struct &quot;lam&quot;] interp :
    type p r.
    ?log:execution_trace ref -&gt;
    context -&gt;
    step_constants -&gt;
    (p, r) lambda -&gt;
    p -&gt;
    (r * context) tzresult Lwt.t =
 fun ?log ctxt step_constants lam arg -&gt;
  let stack = Item (arg, Empty) in
  match[@coq_match_gadt] lam with
  | {lam = (code, _)} -&gt;
      ( match log with
      | None -&gt;
          return_unit
      | Some log -&gt;
          trace <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Cannot_serialize_log</abbr> (unparse_stack ctxt (stack, code.bef))
          &gt;&gt;=? fun stack -&gt;
          <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">log := (code.loc, Gas.level ctxt, stack) :: !log</abbr> ;
          return_unit )
      &gt;&gt;=? fun () -&gt;
      step_descr ?log ctxt step_constants code stack
      &gt;&gt;=? fun [@coq_match_gadt] [@coq_match_with_default] ( Item (ret, Empty),
                                                             ctxt ) -&gt;
      return (ret, ctxt)

(* ---- contract handling ---------------------------------------------------*)
let execute ?log ctxt mode step_constants ~entrypoint unparsed_script arg :
    ( Script.expr
    * packed_internal_operation list
    * context
    * Contract.big_map_diff option )
    tzresult
    Lwt.t =
  parse_script ctxt unparsed_script ~legacy:true
  &gt;&gt;=? fun [@coq_match_gadt] ( Ex_script
                                 { code;
                                   arg_type;
                                   storage;
                                   storage_type;
                                   root_name },
                               ctxt ) -&gt;
  trace
    <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Bad_contract_parameter step_constants.self)</abbr>
    (Lwt.return (find_entrypoint arg_type ~root_name entrypoint))
  &gt;&gt;=? fun (box, _) -&gt;
  trace
    <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Bad_contract_parameter step_constants.self)</abbr>
    (parse_data ctxt ~legacy:false arg_type (box arg))
  &gt;&gt;=? fun (arg, ctxt) -&gt;
  Script.force_decode_in_context ctxt unparsed_script.code
  &gt;&gt;=? fun (script_code, ctxt) -&gt;
  (Script_ir_translator.collect_big_maps [@coq_implicit &quot;(A := unit)&quot;])
    ctxt
    arg_type
    arg
  &gt;&gt;=? fun (to_duplicate, ctxt) -&gt;
  Script_ir_translator.collect_big_maps ctxt storage_type storage
  &gt;&gt;=? fun (to_update, ctxt) -&gt;
  trace
    <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Runtime_contract_error (step_constants.self, script_code))</abbr>
    ((interp [@coq_implicit &quot;(r := list Script_typed_ir.operation * unit)&quot;])
       ?log
       ctxt
       step_constants
       code
       (arg, storage))
  &gt;&gt;=? fun ((ops, storage), ctxt) -&gt;
  Script_ir_translator.extract_big_map_diff
    ctxt
    mode
    ~temporary:false
    ~to_duplicate
    ~to_update
    storage_type
    storage
  &gt;&gt;=? fun (storage, big_map_diff, ctxt) -&gt;
  trace
    <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Cannot_serialize_storage</abbr>
    ((unparse_data [@coq_implicit &quot;(a := unit)&quot;])
       ctxt
       mode
       storage_type
       storage)
  &gt;&gt;=? fun (storage, ctxt) -&gt;
  let (ops, op_diffs) = List.split ops in
  let big_map_diff =
    match
      List.flatten
        (List.map (Option.unopt ~default:[]) (op_diffs @ [big_map_diff]))
    with
    | [] -&gt;
        None
    | diff -&gt;
        Some diff
  in
  return (Micheline.strip_locations storage, ops, ctxt, big_map_diff)

type execution_result = {
  ctxt : context;
  storage : Script.expr;
  big_map_diff : Contract.big_map_diff option;
  operations : packed_internal_operation list;
}

let trace ctxt mode step_constants ~script ~entrypoint ~parameter =
  let log = ref [] in
  execute
    ~log
    ctxt
    mode
    step_constants
    ~entrypoint
    script
    (Micheline.root parameter)
  &gt;&gt;=? fun (storage, operations, ctxt, big_map_diff) -&gt;
  let trace = List.rev !log in
  return ({ctxt; storage; big_map_diff; operations}, trace)

let execute_wrapper ctxt mode step_constants ~script ~entrypoint ~parameter =
  execute
    ctxt
    mode
    step_constants
    ~entrypoint
    script
    (Micheline.root parameter)
  &gt;&gt;=? fun (storage, operations, ctxt, big_map_diff) -&gt;
  return {ctxt; storage; big_map_diff; operations}
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_interpreter.ml"><code>Script_interpreter.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Michelson_v1_gas.
Require Tezos.Script_ir_annot.
Require Tezos.Script_ir_translator.
Require Tezos.Script_repr.
Require Tezos.Script_typed_ir.

Import Alpha_context.

Import Alpha_context.Script.

Import Script_typed_ir.

Import Script_ir_translator.

Definition execution_trace : Set :=
  list
    (Alpha_context.Script.location * Alpha_context.Gas.t *
      list (Alpha_context.Script.expr * option string)).

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)

Inductive stack : Set :=
| Item : forall {ty : Set}, ty -&gt; stack -&gt; stack
| Empty : stack.

Definition unparse_stack
  (ctxt : Alpha_context.context)
  (function_parameter : stack * Script_typed_ir.stack_ty)
  : Lwt.t
    (Error_monad.tzresult (list (Alpha_context.Script.expr * option string))) :=
  let '(__stack_value, stack_ty) := function_parameter in
  let ctxt := Alpha_context.Gas.set_unlimited ctxt in
  let fix unparse_stack (s : stack) (s_ty : Script_typed_ir.stack_ty) {struct s}
    : Lwt.t
      (Error_monad.tzresult (list (Alpha_context.Script.expr * option string))) :=
    match (s, s_ty) with
    | (Empty, Script_typed_ir.Empty_t) =&gt;
      cast
        (Lwt.t
          (Error_monad.tzresult
            (list (Alpha_context.Script.expr * option string))))
      (Error_monad.return_nil (a := unit))
    | (Item v rest, Script_typed_ir.Item_t ty rest_ty annot) =&gt;
      let 'existT _ __0 [v, rest, ty, rest_ty, annot] :=
        cast_exists (Es := Set)
          (fun __0 =&gt;
            [__0 ** stack ** Script_typed_ir.ty ** Script_typed_ir.stack_ty **
              option Script_typed_ir.var_annot]) [v, rest, ty, rest_ty, annot]
        in
      cast
        (Lwt.t
          (Error_monad.tzresult
            (list (Alpha_context.Script.expr * option string))))
      (let=? '(data, _ctxt) :=
        Script_ir_translator.unparse_data ctxt Script_ir_translator.Readable ty
          v in
      let=? rest := unparse_stack rest rest_ty in
      let annot :=
        match Script_ir_annot.unparse_var_annot annot with
        | [] =&gt; None
        | cons __a_value [] =&gt; Some __a_value
        | _ =&gt;
          (* ‚ùå Assert instruction is not handled. *)
          assert (option string) false
        end in
      let data := Micheline.strip_locations data in
      Error_monad.__return (cons (data, annot) rest))
    | _ =&gt; unreachable_gadt_branch
    end in
  unparse_stack __stack_value stack_ty.

Module Interp_costs := Michelson_v1_gas.Cost_of.Interpreter.

Fixpoint interp_stack_prefix_preserving_operation {result : Set}
  (f : stack -&gt; Lwt.t (Error_monad.tzresult (stack * result)))
  (n : Script_typed_ir.stack_prefix_preservation_witness) (stk : stack)
  {struct n} : Lwt.t (Error_monad.tzresult (stack * result)) :=
  match (n, stk) with
  |
    (Script_typed_ir.Prefix
      (Script_typed_ir.Prefix
        (Script_typed_ir.Prefix (Script_typed_ir.Prefix n))),
      Item v0 (Item v1 (Item v2 (Item v3 rest)))) =&gt;
    let 'existT _ [__0, __3, __6, __9] [n, v0, v1, v2, v3, rest] :=
      cast_exists (Es := [Set ** Set ** Set ** Set])
        (fun '[__0, __3, __6, __9] =&gt;
          [Script_typed_ir.stack_prefix_preservation_witness ** __0 ** __3 **
            __6 ** __9 ** stack]) [n, v0, v1, v2, v3, rest] in
    let=? '(rest', __result_value) :=
      interp_stack_prefix_preserving_operation f n rest in
    Error_monad.__return
      ((Item v0 (Item v1 (Item v2 (Item v3 rest')))), __result_value)
  | (Script_typed_ir.Prefix n, Item v rest) =&gt;
    let 'existT _ __12 [n, v, rest] :=
      cast_exists (Es := Set)
        (fun __12 =&gt;
          [Script_typed_ir.stack_prefix_preservation_witness ** __12 ** stack])
        [n, v, rest] in
    let=? '(rest', __result_value) :=
      interp_stack_prefix_preserving_operation f n rest in
    Error_monad.__return ((Item v rest'), __result_value)
  | (Script_typed_ir.Rest, v) =&gt;
    let v := cast stack v in
    f v
  | _ =&gt; unreachable_gadt_branch
  end.

Module step_constants.
  Record record : Set := Build {
    source : Alpha_context.Contract.t;
    payer : Alpha_context.Contract.t;
    self : Alpha_context.Contract.t;
    amount : Alpha_context.Tez.t;
    chain_id : (|Chain_id|).(S.HASH.t) }.
  Definition with_source source (r : record) :=
    Build source r.(payer) r.(self) r.(amount) r.(chain_id).
  Definition with_payer payer (r : record) :=
    Build r.(source) payer r.(self) r.(amount) r.(chain_id).
  Definition with_self self (r : record) :=
    Build r.(source) r.(payer) self r.(amount) r.(chain_id).
  Definition with_amount amount (r : record) :=
    Build r.(source) r.(payer) r.(self) amount r.(chain_id).
  Definition with_chain_id chain_id (r : record) :=
    Build r.(source) r.(payer) r.(self) r.(amount) chain_id.
End step_constants.
Definition step_constants := step_constants.record.

Fixpoint step
  (instr : Script_typed_ir.instr) (loc : Alpha_context.Script.location)
  (bef : Script_typed_ir.stack_ty) (aft : Script_typed_ir.stack_ty)
  (log : option (Pervasives.ref execution_trace)) (ctxt : Alpha_context.context)
  (step_constants : step_constants) (__stack_value : stack) {struct ctxt}
  : Lwt.t (Error_monad.tzresult (stack * Alpha_context.context)) :=
  let __descr_value :=
    {| Script_typed_ir.descr.loc := loc; Script_typed_ir.descr.bef := bef;
      Script_typed_ir.descr.aft := aft; Script_typed_ir.descr.instr := instr |}
    in
  let=? ctxt := Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.cycle)
    in
  let logged_return
    (__descr_value : Script_typed_ir.descr)
    (function_parameter : stack * Alpha_context.context)
    : Lwt.t (Error_monad.tzresult (stack * Alpha_context.context)) :=
    let '(ret, ctxt) := function_parameter in
    match log with
    | None =&gt; Error_monad.__return (ret, ctxt)
    | Some log =&gt;
      let=? __stack_value :=
        Error_monad.trace extensible_type_value
          (unparse_stack ctxt (ret, __descr_value.(Script_typed_ir.descr.aft)))
        in
      (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
      (* ‚ùå instruction_sequence &quot;;&quot; *)
      Error_monad.__return (ret, ctxt)
    end in
  let get_log (log : option (Pervasives.ref execution_trace))
    : option
      (list
        (Alpha_context.Script.location * Alpha_context.Gas.t *
          list (Alpha_context.Script.expr * option string))) :=
    Option.map (fun l =&gt; List.rev (Pervasives.op_exclamation l)) log in
  let consume_gas_terop {arg1 arg2 arg3 ret : Set}
    (__descr_value : Script_typed_ir.descr)
    (function_parameter : (arg1 -&gt; arg2 -&gt; arg3 -&gt; ret) * arg1 * arg2 * arg3)
    : (arg1 -&gt; arg2 -&gt; arg3 -&gt; Alpha_context.Gas.cost) -&gt; stack -&gt;
    Lwt.t (Error_monad.tzresult (stack * Alpha_context.context)) :=
    let '(op, x1, x2, x3) := function_parameter in
    fun cost_func =&gt;
      fun rest =&gt;
        let=? ctxt :=
          Lwt.__return (Alpha_context.Gas.consume ctxt (cost_func x1 x2 x3)) in
        logged_return __descr_value ((Item (op x1 x2 x3) rest), ctxt) in
  let consume_gas_binop {arg1 arg2 ret : Set}
    (__descr_value : Script_typed_ir.descr)
    (function_parameter : (arg1 -&gt; arg2 -&gt; ret) * arg1 * arg2)
    : (arg1 -&gt; arg2 -&gt; Alpha_context.Gas.cost) -&gt; stack -&gt;
    Alpha_context.context -&gt;
    Lwt.t (Error_monad.tzresult (stack * Alpha_context.context)) :=
    let '(op, x1, x2) := function_parameter in
    fun cost_func =&gt;
      fun rest =&gt;
        fun ctxt =&gt;
          let=? ctxt :=
            Lwt.__return (Alpha_context.Gas.consume ctxt (cost_func x1 x2)) in
          logged_return __descr_value ((Item (op x1 x2) rest), ctxt) in
  let consume_gas_unop {arg ret : Set}
    (__descr_value : Script_typed_ir.descr)
    (function_parameter : (arg -&gt; ret) * arg)
    : (arg -&gt; Alpha_context.Gas.cost) -&gt; stack -&gt; Alpha_context.context -&gt;
    Lwt.t (Error_monad.tzresult (stack * Alpha_context.context)) :=
    let '(op, arg) := function_parameter in
    fun cost_func =&gt;
      fun rest =&gt;
        fun ctxt =&gt;
          let=? ctxt :=
            Lwt.__return (Alpha_context.Gas.consume ctxt (cost_func arg)) in
          logged_return __descr_value ((Item (op arg) rest), ctxt) in
  let logged_return := logged_return __descr_value in
  match (instr, __stack_value) with
  | (Script_typed_ir.Drop, Item _ rest) =&gt;
    let rest := cast stack rest in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.stack_op) in
    logged_return (rest, ctxt)
  
  | (Script_typed_ir.Dup, Item v rest) =&gt;
    let 'existT _ __2 [v, rest] :=
      cast_exists (Es := Set) (fun __2 =&gt; [__2 ** stack]) [v, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.stack_op) in
    logged_return ((Item v (Item v rest)), ctxt)
  
  | (Script_typed_ir.Swap, Item vi (Item vo rest)) =&gt;
    let 'existT _ [__4, __5] [vi, vo, rest] :=
      cast_exists (Es := [Set ** Set])
        (fun '[__4, __5] =&gt; [__4 ** __5 ** stack]) [vi, vo, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.stack_op) in
    logged_return ((Item vo (Item vi rest)), ctxt)
  
  | (Script_typed_ir.Const v, rest) =&gt;
    let 'existT _ __7 [v, rest] :=
      cast_exists (Es := Set) (fun __7 =&gt; [__7 ** stack]) [v, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.push) in
    logged_return ((Item v rest), ctxt)
  
  | (Script_typed_ir.Cons_some, Item v rest) =&gt;
    let 'existT _ __8 [v, rest] :=
      cast_exists (Es := Set) (fun __8 =&gt; [__8 ** stack]) [v, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.wrap) in
    logged_return ((Item (Some v) rest), ctxt)
  
  | (Script_typed_ir.Cons_none _, rest) =&gt;
    let rest := cast stack rest in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.variant_no_data)
      in
    logged_return ((Item (None (A := unit)) rest), ctxt)
  
  | (Script_typed_ir.If_none bt bf, Item v rest) =&gt;
    let 'existT _ __11 [bt, bf, v, rest] :=
      cast_exists (Es := Set)
        (fun __11 =&gt;
          [Script_typed_ir.descr ** Script_typed_ir.descr ** option __11 **
            stack]) [bt, bf, v, rest] in
    match v with
    | None =&gt;
      let=? ctxt :=
        Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.branch) in
      step_descr log ctxt step_constants bt rest
    | Some v =&gt;
      let=? ctxt :=
        Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.branch) in
      step_descr log ctxt step_constants bf (Item v rest)
    end
  
  | (Script_typed_ir.Cons_pair, Item __a_value (Item __b_value rest)) =&gt;
    let 'existT _ [__13, __14] [__a_value, __b_value, rest] :=
      cast_exists (Es := [Set ** Set])
        (fun '[__13, __14] =&gt; [__13 ** __14 ** stack])
        [__a_value, __b_value, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.pair) in
    logged_return ((Item (__a_value, __b_value) rest), ctxt)
  
  | (Script_typed_ir.Car, Item pair rest) =&gt;
    let 'existT _ [__16, __17] [pair, rest] :=
      cast_exists (Es := [Set ** Set])
        (fun '[__16, __17] =&gt; [Script_typed_ir.pair __16 __17 ** stack])
        [pair, rest] in
    let '(__a_value, _) := pair in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.pair_access) in
    logged_return ((Item __a_value rest), ctxt)
  
  | (Script_typed_ir.Cdr, Item pair rest) =&gt;
    let 'existT _ [__19, __20] [pair, rest] :=
      cast_exists (Es := [Set ** Set])
        (fun '[__19, __20] =&gt; [Script_typed_ir.pair __19 __20 ** stack])
        [pair, rest] in
    let '(_, __b_value) := pair in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.pair_access) in
    logged_return ((Item __b_value rest), ctxt)
  
  | (Script_typed_ir.Left, Item v rest) =&gt;
    let 'existT _ __22 [v, rest] :=
      cast_exists (Es := Set) (fun __22 =&gt; [__22 ** stack]) [v, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.wrap) in
    logged_return ((Item (Script_typed_ir.L (b := unit) v) rest), ctxt)
  
  | (Script_typed_ir.Right, Item v rest) =&gt;
    let 'existT _ __25 [v, rest] :=
      cast_exists (Es := Set) (fun __25 =&gt; [__25 ** stack]) [v, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.wrap) in
    logged_return ((Item (Script_typed_ir.R (a := unit) v) rest), ctxt)
  
  | (Script_typed_ir.If_left bt bf, Item v rest) =&gt;
    let 'existT _ [__28, __29] [bt, bf, v, rest] :=
      cast_exists (Es := [Set ** Set])
        (fun '[__28, __29] =&gt;
          [Script_typed_ir.descr ** Script_typed_ir.descr **
            Script_typed_ir.union __28 __29 ** stack]) [bt, bf, v, rest] in
    match v with
    | Script_typed_ir.L v =&gt;
      let=? ctxt :=
        Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.branch) in
      step_descr log ctxt step_constants bt (Item v rest)
    | Script_typed_ir.R v =&gt;
      let=? ctxt :=
        Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.branch) in
      step_descr log ctxt step_constants bf (Item v rest)
    end
  
  | (Script_typed_ir.Cons_list, Item hd (Item tl rest)) =&gt;
    let 'existT _ __31 [hd, tl, rest] :=
      cast_exists (Es := Set) (fun __31 =&gt; [__31 ** list __31 ** stack])
        [hd, tl, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.__cons_value) in
    logged_return ((Item (cons hd tl) rest), ctxt)
  
  | (Script_typed_ir.Nil, rest) =&gt;
    let rest := cast stack rest in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.variant_no_data)
      in
    logged_return ((Item (nil (A := unit)) rest), ctxt)
  
  | (Script_typed_ir.If_cons bt bf, Item l rest) =&gt;
    let 'existT _ __34 [bt, bf, l, rest] :=
      cast_exists (Es := Set)
        (fun __34 =&gt;
          [Script_typed_ir.descr ** Script_typed_ir.descr ** list __34 ** stack])
        [bt, bf, l, rest] in
    match l with
    | [] =&gt;
      let=? ctxt :=
        Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.branch) in
      step_descr log ctxt step_constants bf rest
    | cons hd tl =&gt;
      let=? ctxt :=
        Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.branch) in
      step_descr log ctxt step_constants bt (Item hd (Item tl rest))
    end
  
  | (Script_typed_ir.List_map body, Item l rest) =&gt;
    let 'existT _ __36 [body, l, rest] :=
      cast_exists (Es := Set)
        (fun __36 =&gt; [Script_typed_ir.descr ** list __36 ** stack])
        [body, l, rest] in
    let=? '(res, ctxt) :=
      loop_list_map log step_constants body rest ctxt l (nil (A := unit)) in
    logged_return (res, ctxt)
  
  | (Script_typed_ir.List_size, Item __list_value rest) =&gt;
    let 'existT _ __39 [__list_value, rest] :=
      cast_exists (Es := Set) (fun __39 =&gt; [list __39 ** stack])
        [__list_value, rest] in
    let=? '(len, ctxt) :=
      Lwt.__return
        (List.fold_left
          (fun acc =&gt;
            fun function_parameter =&gt;
              let '_ := function_parameter in
              let? '(size, ctxt) := acc in
              let? ctxt := Alpha_context.Gas.consume ctxt Interp_costs.loop_size
                in
              Error_monad.ok ((Pervasives.op_plus size 1), ctxt))
          (Error_monad.ok (0, ctxt)) __list_value) in
    logged_return
      ((Item
        (Alpha_context.Script_int.abs (Alpha_context.Script_int.of_int len))
        rest), ctxt)
  
  | (Script_typed_ir.List_iter body, Item l init) =&gt;
    let 'existT _ __41 [body, l, init] :=
      cast_exists (Es := Set)
        (fun __41 =&gt; [Script_typed_ir.descr ** list __41 ** stack])
        [body, l, init] in
    let fix loop
      (ctxt : Alpha_context.context) (l : list __41) (__stack_value : stack)
      {struct l}
      : Lwt.t (Error_monad.tzresult (stack * Alpha_context.context)) :=
      let=? ctxt :=
        Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.loop_iter) in
      match l with
      | [] =&gt; Error_monad.__return (__stack_value, ctxt)
      | cons hd tl =&gt;
        let=? '(__stack_value, ctxt) :=
          step_descr log ctxt step_constants body (Item hd __stack_value) in
        loop ctxt tl __stack_value
      end in
    let=? '(res, ctxt) := loop ctxt l init in
    logged_return (res, ctxt)
  
  | (Script_typed_ir.Empty_set __t_value, rest) =&gt;
    let '[__t_value, rest] :=
      cast [Script_typed_ir.comparable_ty ** stack] [__t_value, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.empty_set) in
    logged_return
      ((Item ((Script_ir_translator.empty_set (a := unit)) __t_value) rest),
        ctxt)
  
  | (Script_typed_ir.Set_iter body, Item set init) =&gt;
    let 'existT _ __44 [body, set, init] :=
      cast_exists (Es := Set)
        (fun __44 =&gt;
          [Script_typed_ir.descr ** Script_typed_ir.set __44 ** stack])
        [body, set, init] in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt (Interp_costs.set_to_list set)) in
    let l :=
      List.rev
        (Script_ir_translator.set_fold (fun e =&gt; fun acc =&gt; cons e acc) set nil)
      in
    let fix loop
      (ctxt : Alpha_context.context) (l : list __44) (__stack_value : stack)
      {struct l}
      : Lwt.t (Error_monad.tzresult (stack * Alpha_context.context)) :=
      let=? ctxt :=
        Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.loop_iter) in
      match l with
      | [] =&gt; Error_monad.__return (__stack_value, ctxt)
      | cons hd tl =&gt;
        let=? '(__stack_value, ctxt) :=
          step_descr log ctxt step_constants body (Item hd __stack_value) in
        loop ctxt tl __stack_value
      end in
    let=? '(res, ctxt) := loop ctxt l init in
    logged_return (res, ctxt)
  
  | (Script_typed_ir.Set_mem, Item v (Item set rest)) =&gt;
    let 'existT _ __46 [v, set, rest] :=
      cast_exists (Es := Set)
        (fun __46 =&gt; [__46 ** Script_typed_ir.set __46 ** stack]) [v, set, rest]
      in
    consume_gas_binop __descr_value (Script_ir_translator.set_mem, v, set)
      Interp_costs.set_mem rest ctxt
  
  | (Script_typed_ir.Set_update, Item v (Item presence (Item set rest))) =&gt;
    let 'existT _ __48 [v, presence, set, rest] :=
      cast_exists (Es := Set)
        (fun __48 =&gt; [__48 ** bool ** Script_typed_ir.set __48 ** stack])
        [v, presence, set, rest] in
    consume_gas_terop __descr_value
      (Script_ir_translator.set_update, v, presence, set)
      Interp_costs.set_update rest
  
  | (Script_typed_ir.Set_size, Item set rest) =&gt;
    let 'existT _ __50 [set, rest] :=
      cast_exists (Es := Set) (fun __50 =&gt; [Script_typed_ir.set __50 ** stack])
        [set, rest] in
    consume_gas_unop __descr_value (Script_ir_translator.set_size, set)
      (fun function_parameter =&gt;
        let '_ := function_parameter in
        Interp_costs.set_size) rest ctxt
  
  | (Script_typed_ir.Empty_map __t_value _, rest) =&gt;
    let '[__t_value, rest] :=
      cast [Script_typed_ir.comparable_ty ** stack] [__t_value, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.empty_map) in
    logged_return
      ((Item
        ((Script_ir_translator.empty_map (a := unit) (b := unit)) __t_value)
        rest), ctxt)
  
  | (Script_typed_ir.Map_map body, Item map rest) =&gt;
    let 'existT _ [__54, __55] [body, map, rest] :=
      cast_exists (Es := [Set ** Set])
        (fun '[__54, __55] =&gt;
          [Script_typed_ir.descr ** Script_typed_ir.map __54 __55 ** stack])
        [body, map, rest] in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt (Interp_costs.map_to_list map)) in
    let l :=
      List.rev
        (Script_ir_translator.map_fold
          (fun k =&gt; fun v =&gt; fun acc =&gt; cons (k, v) acc) map nil) in
    let fix loop {A B C : Set}
      (body : Script_typed_ir.descr) (rest : stack)
      (ctxt : Alpha_context.context) (l : list (A * B))
      (acc : Script_typed_ir.map A C) {struct l}
      : Lwt.t
        (Error_monad.tzresult (Script_typed_ir.map A C * Alpha_context.context)) :=
      let=? ctxt :=
        Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.loop_map) in
      match l with
      | [] =&gt; Error_monad.__return (acc, ctxt)
      | cons ((k, _) as hd) tl =&gt;
        let=? function_parameter :=
          step_descr log ctxt step_constants body (Item hd rest) in
        match function_parameter with
        | (Item hd rest, ctxt) =&gt;
          let '[hd, rest, ctxt] :=
            cast [C ** stack ** Alpha_context.context] [hd, rest, ctxt] in
          loop body rest ctxt tl
            (Script_ir_translator.map_update k (Some hd) acc)
        | _ =&gt; unreachable_gadt_branch
        end
      end in
    let=? '(res, ctxt) :=
      loop body rest ctxt l
        ((Script_ir_translator.empty_map (b := unit))
          (Script_ir_translator.map_key_ty map)) in
    logged_return ((Item res rest), ctxt)
  
  | (Script_typed_ir.Map_iter body, Item map init) =&gt;
    let 'existT _ [__58, __59] [body, map, init] :=
      cast_exists (Es := [Set ** Set])
        (fun '[__58, __59] =&gt;
          [Script_typed_ir.descr ** Script_typed_ir.map __58 __59 ** stack])
        [body, map, init] in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt (Interp_costs.map_to_list map)) in
    let l :=
      List.rev
        (Script_ir_translator.map_fold
          (fun k =&gt; fun v =&gt; fun acc =&gt; cons (k, v) acc) map nil) in
    let fix loop
      (ctxt : Alpha_context.context) (l : list (__58 * __59))
      (__stack_value : stack) {struct l}
      : Lwt.t (Error_monad.tzresult (stack * Alpha_context.context)) :=
      let=? ctxt :=
        Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.loop_iter) in
      match l with
      | [] =&gt; Error_monad.__return (__stack_value, ctxt)
      | cons hd tl =&gt;
        let=? '(__stack_value, ctxt) :=
          step_descr log ctxt step_constants body (Item hd __stack_value) in
        loop ctxt tl __stack_value
      end in
    let=? '(res, ctxt) := loop ctxt l init in
    logged_return (res, ctxt)
  
  | (Script_typed_ir.Map_mem, Item v (Item map rest)) =&gt;
    let 'existT _ [__61, __62] [v, map, rest] :=
      cast_exists (Es := [Set ** Set])
        (fun '[__61, __62] =&gt; [__61 ** Script_typed_ir.map __61 __62 ** stack])
        [v, map, rest] in
    consume_gas_binop __descr_value (Script_ir_translator.map_mem, v, map)
      Interp_costs.map_mem rest ctxt
  
  | (Script_typed_ir.Map_get, Item v (Item map rest)) =&gt;
    let 'existT _ [__64, __65] [v, map, rest] :=
      cast_exists (Es := [Set ** Set])
        (fun '[__64, __65] =&gt; [__64 ** Script_typed_ir.map __64 __65 ** stack])
        [v, map, rest] in
    consume_gas_binop __descr_value (Script_ir_translator.map_get, v, map)
      Interp_costs.map_get rest ctxt
  
  | (Script_typed_ir.Map_update, Item k (Item v (Item map rest))) =&gt;
    let 'existT _ [__67, __68] [k, v, map, rest] :=
      cast_exists (Es := [Set ** Set])
        (fun '[__67, __68] =&gt;
          [__67 ** option __68 ** Script_typed_ir.map __67 __68 ** stack])
        [k, v, map, rest] in
    consume_gas_terop __descr_value (Script_ir_translator.map_update, k, v, map)
      Interp_costs.map_update rest
  
  | (Script_typed_ir.Map_size, Item map rest) =&gt;
    let 'existT _ [__70, __71] [map, rest] :=
      cast_exists (Es := [Set ** Set])
        (fun '[__70, __71] =&gt; [Script_typed_ir.map __70 __71 ** stack])
        [map, rest] in
    consume_gas_unop __descr_value (Script_ir_translator.map_size, map)
      (fun function_parameter =&gt;
        let '_ := function_parameter in
        Interp_costs.map_size) rest ctxt
  
  | (Script_typed_ir.Empty_big_map tk tv, rest) =&gt;
    let '[tk, tv, rest] :=
      cast [Script_typed_ir.comparable_ty ** Script_typed_ir.ty ** stack]
        [tk, tv, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.empty_map) in
    logged_return
      ((Item
        ((Script_ir_translator.empty_big_map (A := unit) (B := unit)) tk tv)
        rest), ctxt)
  
  | (Script_typed_ir.Big_map_mem, Item __key_value (Item map rest)) =&gt;
    let 'existT _ [__75, __76] [__key_value, map, rest] :=
      cast_exists (Es := [Set ** Set])
        (fun '[__75, __76] =&gt;
          [__75 ** Script_typed_ir.big_map __75 __76 ** stack])
        [__key_value, map, rest] in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt
          (Interp_costs.map_mem __key_value map.(Script_typed_ir.big_map.diff)))
      in
    let=? '(res, ctxt) := Script_ir_translator.big_map_mem ctxt __key_value map
      in
    logged_return ((Item res rest), ctxt)
  
  | (Script_typed_ir.Big_map_get, Item __key_value (Item map rest)) =&gt;
    let 'existT _ [__78, __79] [__key_value, map, rest] :=
      cast_exists (Es := [Set ** Set])
        (fun '[__78, __79] =&gt;
          [__78 ** Script_typed_ir.big_map __78 __79 ** stack])
        [__key_value, map, rest] in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt
          (Interp_costs.map_get __key_value map.(Script_typed_ir.big_map.diff)))
      in
    let=? '(res, ctxt) := Script_ir_translator.big_map_get ctxt __key_value map
      in
    logged_return ((Item res rest), ctxt)
  
  |
    (Script_typed_ir.Big_map_update,
      Item __key_value (Item maybe_value (Item map rest))) =&gt;
    let 'existT _ [__81, __82] [__key_value, maybe_value, map, rest] :=
      cast_exists (Es := [Set ** Set])
        (fun '[__81, __82] =&gt;
          [__81 ** option __82 ** Script_typed_ir.big_map __81 __82 ** stack])
        [__key_value, maybe_value, map, rest] in
    consume_gas_terop __descr_value
      (Script_ir_translator.big_map_update, __key_value, maybe_value, map)
      (fun k =&gt;
        fun v =&gt;
          fun m =&gt;
            Interp_costs.map_update k (Some v) m.(Script_typed_ir.big_map.diff))
      rest
  
  | (Script_typed_ir.Add_seconds_to_timestamp, Item n (Item __t_value rest)) =&gt;
    let '[n, __t_value, rest] :=
      cast
        [Alpha_context.Script_int.num ** Alpha_context.Script_timestamp.t **
          stack] [n, __t_value, rest] in
    consume_gas_binop __descr_value
      (Alpha_context.Script_timestamp.add_delta, __t_value, n)
      Interp_costs.add_timestamp rest ctxt
  
  | (Script_typed_ir.Add_timestamp_to_seconds, Item __t_value (Item n rest)) =&gt;
    let '[__t_value, n, rest] :=
      cast
        [Alpha_context.Script_timestamp.t ** Alpha_context.Script_int.num **
          stack] [__t_value, n, rest] in
    consume_gas_binop __descr_value
      (Alpha_context.Script_timestamp.add_delta, __t_value, n)
      Interp_costs.add_timestamp rest ctxt
  
  | (Script_typed_ir.Sub_timestamp_seconds, Item __t_value (Item s rest)) =&gt;
    let '[__t_value, s, rest] :=
      cast
        [Alpha_context.Script_timestamp.t ** Alpha_context.Script_int.num **
          stack] [__t_value, s, rest] in
    consume_gas_binop __descr_value
      (Alpha_context.Script_timestamp.sub_delta, __t_value, s)
      Interp_costs.sub_timestamp rest ctxt
  
  | (Script_typed_ir.Diff_timestamps, Item t1 (Item t2 rest)) =&gt;
    let '[t1, t2, rest] :=
      cast
        [Alpha_context.Script_timestamp.t ** Alpha_context.Script_timestamp.t **
          stack] [t1, t2, rest] in
    consume_gas_binop __descr_value
      (Alpha_context.Script_timestamp.diff, t1, t2) Interp_costs.diff_timestamps
      rest ctxt
  
  | (Script_typed_ir.Concat_string_pair, Item x (Item y rest)) =&gt;
    let '[x, y, rest] := cast [string ** string ** stack] [x, y, rest] in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt (Interp_costs.concat_string [ x; y ]))
      in
    let s := String.concat &quot;&quot; [ x; y ] in
    logged_return ((Item s rest), ctxt)
  
  | (Script_typed_ir.Concat_string, Item ss rest) =&gt;
    let '[ss, rest] := cast [list string ** stack] [ss, rest] in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt (Interp_costs.concat_string ss)) in
    let s := String.concat &quot;&quot; ss in
    logged_return ((Item s rest), ctxt)
  
  | (Script_typed_ir.Slice_string, Item offset (Item length (Item s rest))) =&gt;
    let '[offset, length, s, rest] :=
      cast
        [Alpha_context.Script_int.num ** Alpha_context.Script_int.num ** string
          ** stack] [offset, length, s, rest] in
    let s_length := Z.of_int (String.length s) in
    let offset := Alpha_context.Script_int.to_zint offset in
    let length := Alpha_context.Script_int.to_zint length in
    if
      Pervasives.op_andand ((|Compare.Z|).(Compare.S.op_lt) offset s_length)
        ((|Compare.Z|).(Compare.S.op_lteq) (Z.add offset length) s_length) then
      let=? ctxt :=
        Lwt.__return
          (Alpha_context.Gas.consume ctxt
            (Interp_costs.slice_string (Z.to_int length))) in
      logged_return
        ((Item (Some (String.sub s (Z.to_int offset) (Z.to_int length))) rest),
          ctxt)
    else
      let=? ctxt :=
        Lwt.__return
          (Alpha_context.Gas.consume ctxt (Interp_costs.slice_string 0)) in
      logged_return ((Item (None (A := unit)) rest), ctxt)
  
  | (Script_typed_ir.String_size, Item s rest) =&gt;
    let '[s, rest] := cast [string ** stack] [s, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.push) in
    logged_return
      ((Item
        (Alpha_context.Script_int.abs
          (Alpha_context.Script_int.of_int (String.length s))) rest), ctxt)
  
  | (Script_typed_ir.Concat_bytes_pair, Item x (Item y rest)) =&gt;
    let '[x, y, rest] := cast [MBytes.t ** MBytes.t ** stack] [x, y, rest] in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt (Interp_costs.concat_bytes [ x; y ])) in
    let s := MBytes.concat &quot;&quot; [ x; y ] in
    logged_return ((Item s rest), ctxt)
  
  | (Script_typed_ir.Concat_bytes, Item ss rest) =&gt;
    let '[ss, rest] := cast [list MBytes.t ** stack] [ss, rest] in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt (Interp_costs.concat_bytes ss)) in
    let s := MBytes.concat &quot;&quot; ss in
    logged_return ((Item s rest), ctxt)
  
  | (Script_typed_ir.Slice_bytes, Item offset (Item length (Item s rest))) =&gt;
    let '[offset, length, s, rest] :=
      cast
        [Alpha_context.Script_int.num ** Alpha_context.Script_int.num **
          MBytes.t ** stack] [offset, length, s, rest] in
    let s_length := Z.of_int (MBytes.length s) in
    let offset := Alpha_context.Script_int.to_zint offset in
    let length := Alpha_context.Script_int.to_zint length in
    if
      Pervasives.op_andand ((|Compare.Z|).(Compare.S.op_lt) offset s_length)
        ((|Compare.Z|).(Compare.S.op_lteq) (Z.add offset length) s_length) then
      let=? ctxt :=
        Lwt.__return
          (Alpha_context.Gas.consume ctxt
            (Interp_costs.slice_string (Z.to_int length))) in
      logged_return
        ((Item (Some (MBytes.sub s (Z.to_int offset) (Z.to_int length))) rest),
          ctxt)
    else
      let=? ctxt :=
        Lwt.__return
          (Alpha_context.Gas.consume ctxt (Interp_costs.slice_string 0)) in
      logged_return ((Item (None (A := unit)) rest), ctxt)
  
  | (Script_typed_ir.Bytes_size, Item s rest) =&gt;
    let '[s, rest] := cast [MBytes.t ** stack] [s, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.push) in
    logged_return
      ((Item
        (Alpha_context.Script_int.abs
          (Alpha_context.Script_int.of_int (MBytes.length s))) rest), ctxt)
  
  | (Script_typed_ir.Add_tez, Item x (Item y rest)) =&gt;
    let '[x, y, rest] :=
      cast [Alpha_context.Tez.t ** Alpha_context.Tez.t ** stack] [x, y, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.int64_op) in
    let=? res := Lwt.__return (Alpha_context.Tez.op_plusquestion x y) in
    logged_return ((Item res rest), ctxt)
  
  | (Script_typed_ir.Sub_tez, Item x (Item y rest)) =&gt;
    let '[x, y, rest] :=
      cast [Alpha_context.Tez.t ** Alpha_context.Tez.t ** stack] [x, y, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.int64_op) in
    let=? res := Lwt.__return (Alpha_context.Tez.op_minusquestion x y) in
    logged_return ((Item res rest), ctxt)
  
  | (Script_typed_ir.Mul_teznat, Item x (Item y rest)) =&gt;
    let '[x, y, rest] :=
      cast [Alpha_context.Tez.t ** Alpha_context.Script_int.num ** stack]
        [x, y, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.int64_op) in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.z_to_int64) in
    match Alpha_context.Script_int.to_int64 y with
    | None =&gt; Error_monad.fail extensible_type_value
    | Some y =&gt;
      let=? res := Lwt.__return (Alpha_context.Tez.op_starquestion x y) in
      logged_return ((Item res rest), ctxt)
    end
  
  | (Script_typed_ir.Mul_nattez, Item y (Item x rest)) =&gt;
    let '[y, x, rest] :=
      cast [Alpha_context.Script_int.num ** Alpha_context.Tez.t ** stack]
        [y, x, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.int64_op) in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.z_to_int64) in
    match Alpha_context.Script_int.to_int64 y with
    | None =&gt; Error_monad.fail extensible_type_value
    | Some y =&gt;
      let=? res := Lwt.__return (Alpha_context.Tez.op_starquestion x y) in
      logged_return ((Item res rest), ctxt)
    end
  
  | (Script_typed_ir.Or, Item x (Item y rest)) =&gt;
    let '[x, y, rest] := cast [bool ** bool ** stack] [x, y, rest] in
    consume_gas_binop __descr_value (Pervasives.op_pipepipe, x, y)
      Interp_costs.bool_binop rest ctxt
  
  | (Script_typed_ir.And, Item x (Item y rest)) =&gt;
    let '[x, y, rest] := cast [bool ** bool ** stack] [x, y, rest] in
    consume_gas_binop __descr_value (Pervasives.op_andand, x, y)
      Interp_costs.bool_binop rest ctxt
  
  | (Script_typed_ir.Xor, Item x (Item y rest)) =&gt;
    let '[x, y, rest] := cast [bool ** bool ** stack] [x, y, rest] in
    consume_gas_binop __descr_value ((|Compare.Bool|).(Compare.S.op_ltgt), x, y)
      Interp_costs.bool_binop rest ctxt
  
  | (Script_typed_ir.Not, Item x rest) =&gt;
    let '[x, rest] := cast [bool ** stack] [x, rest] in
    consume_gas_unop __descr_value (Pervasives.not, x) Interp_costs.bool_unop
      rest ctxt
  
  | (Script_typed_ir.Is_nat, Item x rest) =&gt;
    let '[x, rest] := cast [Alpha_context.Script_int.num ** stack] [x, rest] in
    consume_gas_unop __descr_value (Alpha_context.Script_int.is_nat, x)
      Interp_costs.abs rest ctxt
  
  | (Script_typed_ir.Abs_int, Item x rest) =&gt;
    let '[x, rest] := cast [Alpha_context.Script_int.num ** stack] [x, rest] in
    consume_gas_unop __descr_value (Alpha_context.Script_int.abs, x)
      Interp_costs.abs rest ctxt
  
  | (Script_typed_ir.Int_nat, Item x rest) =&gt;
    let '[x, rest] := cast [Alpha_context.Script_int.num ** stack] [x, rest] in
    consume_gas_unop __descr_value (Alpha_context.Script_int.__int_value, x)
      Interp_costs.__int_value rest ctxt
  
  | (Script_typed_ir.Neg_int, Item x rest) =&gt;
    let '[x, rest] := cast [Alpha_context.Script_int.num ** stack] [x, rest] in
    consume_gas_unop __descr_value (Alpha_context.Script_int.neg, x)
      Interp_costs.neg rest ctxt
  
  | (Script_typed_ir.Neg_nat, Item x rest) =&gt;
    let '[x, rest] := cast [Alpha_context.Script_int.num ** stack] [x, rest] in
    consume_gas_unop __descr_value (Alpha_context.Script_int.neg, x)
      Interp_costs.neg rest ctxt
  
  | (Script_typed_ir.Add_intint, Item x (Item y rest)) =&gt;
    let '[x, y, rest] :=
      cast
        [Alpha_context.Script_int.num ** Alpha_context.Script_int.num ** stack]
        [x, y, rest] in
    consume_gas_binop __descr_value (Alpha_context.Script_int.add, x, y)
      Interp_costs.add rest ctxt
  
  | (Script_typed_ir.Add_intnat, Item x (Item y rest)) =&gt;
    let '[x, y, rest] :=
      cast
        [Alpha_context.Script_int.num ** Alpha_context.Script_int.num ** stack]
        [x, y, rest] in
    consume_gas_binop __descr_value (Alpha_context.Script_int.add, x, y)
      Interp_costs.add rest ctxt
  
  | (Script_typed_ir.Add_natint, Item x (Item y rest)) =&gt;
    let '[x, y, rest] :=
      cast
        [Alpha_context.Script_int.num ** Alpha_context.Script_int.num ** stack]
        [x, y, rest] in
    consume_gas_binop __descr_value (Alpha_context.Script_int.add, x, y)
      Interp_costs.add rest ctxt
  
  | (Script_typed_ir.Add_natnat, Item x (Item y rest)) =&gt;
    let '[x, y, rest] :=
      cast
        [Alpha_context.Script_int.num ** Alpha_context.Script_int.num ** stack]
        [x, y, rest] in
    consume_gas_binop __descr_value (Alpha_context.Script_int.add_n, x, y)
      Interp_costs.add rest ctxt
  
  | (Script_typed_ir.Sub_int, Item x (Item y rest)) =&gt;
    let '[x, y, rest] :=
      cast
        [Alpha_context.Script_int.num ** Alpha_context.Script_int.num ** stack]
        [x, y, rest] in
    consume_gas_binop __descr_value (Alpha_context.Script_int.sub, x, y)
      Interp_costs.sub rest ctxt
  
  | (Script_typed_ir.Mul_intint, Item x (Item y rest)) =&gt;
    let '[x, y, rest] :=
      cast
        [Alpha_context.Script_int.num ** Alpha_context.Script_int.num ** stack]
        [x, y, rest] in
    consume_gas_binop __descr_value (Alpha_context.Script_int.mul, x, y)
      Interp_costs.mul rest ctxt
  
  | (Script_typed_ir.Mul_intnat, Item x (Item y rest)) =&gt;
    let '[x, y, rest] :=
      cast
        [Alpha_context.Script_int.num ** Alpha_context.Script_int.num ** stack]
        [x, y, rest] in
    consume_gas_binop __descr_value (Alpha_context.Script_int.mul, x, y)
      Interp_costs.mul rest ctxt
  
  | (Script_typed_ir.Mul_natint, Item x (Item y rest)) =&gt;
    let '[x, y, rest] :=
      cast
        [Alpha_context.Script_int.num ** Alpha_context.Script_int.num ** stack]
        [x, y, rest] in
    consume_gas_binop __descr_value (Alpha_context.Script_int.mul, x, y)
      Interp_costs.mul rest ctxt
  
  | (Script_typed_ir.Mul_natnat, Item x (Item y rest)) =&gt;
    let '[x, y, rest] :=
      cast
        [Alpha_context.Script_int.num ** Alpha_context.Script_int.num ** stack]
        [x, y, rest] in
    consume_gas_binop __descr_value (Alpha_context.Script_int.mul_n, x, y)
      Interp_costs.mul rest ctxt
  
  | (Script_typed_ir.Ediv_teznat, Item x (Item y rest)) =&gt;
    let '[x, y, rest] :=
      cast [Alpha_context.Tez.t ** Alpha_context.Script_int.num ** stack]
        [x, y, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.int64_to_z) in
    let x := Alpha_context.Script_int.of_int64 (Alpha_context.Tez.to_mutez x) in
    let op (x : Alpha_context.Script_int.num) (y : Alpha_context.Script_int.num)
      : option (Alpha_context.Tez.tez * Alpha_context.Tez.tez) :=
      match Alpha_context.Script_int.ediv x y with
      | None =&gt; None
      | Some (q, __r_value) =&gt;
        match
          ((Alpha_context.Script_int.to_int64 q),
            (Alpha_context.Script_int.to_int64 __r_value)) with
        | (Some q, Some __r_value) =&gt;
          match
            ((Alpha_context.Tez.of_mutez q),
              (Alpha_context.Tez.of_mutez __r_value)) with
          | (Some q, Some __r_value) =&gt; Some (q, __r_value)
          | _ =&gt;
            (* ‚ùå Assert instruction is not handled. *)
            assert (option (Alpha_context.Tez.tez * Alpha_context.Tez.tez))
              false
          end
        | _ =&gt;
          (* ‚ùå Assert instruction is not handled. *)
          assert (option (Alpha_context.Tez.tez * Alpha_context.Tez.tez)) false
        end
      end in
    consume_gas_binop __descr_value (op, x, y) Interp_costs.div rest ctxt
  
  | (Script_typed_ir.Ediv_tez, Item x (Item y rest)) =&gt;
    let '[x, y, rest] :=
      cast [Alpha_context.Tez.t ** Alpha_context.Tez.t ** stack] [x, y, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.int64_to_z) in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.int64_to_z) in
    let x :=
      Alpha_context.Script_int.abs
        (Alpha_context.Script_int.of_int64 (Alpha_context.Tez.to_mutez x)) in
    let y :=
      Alpha_context.Script_int.abs
        (Alpha_context.Script_int.of_int64 (Alpha_context.Tez.to_mutez y)) in
    let op (x : Alpha_context.Script_int.num) (y : Alpha_context.Script_int.num)
      : option (Alpha_context.Script_int.num * Alpha_context.Tez.tez) :=
      match Alpha_context.Script_int.ediv_n x y with
      | None =&gt; None
      | Some (q, __r_value) =&gt;
        match Alpha_context.Script_int.to_int64 __r_value with
        | None =&gt;
          (* ‚ùå Assert instruction is not handled. *)
          assert (option (Alpha_context.Script_int.num * Alpha_context.Tez.tez))
            false
        | Some __r_value =&gt;
          match Alpha_context.Tez.of_mutez __r_value with
          | None =&gt;
            (* ‚ùå Assert instruction is not handled. *)
            assert
              (option (Alpha_context.Script_int.num * Alpha_context.Tez.tez))
              false
          | Some __r_value =&gt; Some (q, __r_value)
          end
        end
      end in
    consume_gas_binop __descr_value (op, x, y) Interp_costs.div rest ctxt
  
  | (Script_typed_ir.Ediv_intint, Item x (Item y rest)) =&gt;
    let '[x, y, rest] :=
      cast
        [Alpha_context.Script_int.num ** Alpha_context.Script_int.num ** stack]
        [x, y, rest] in
    consume_gas_binop __descr_value (Alpha_context.Script_int.ediv, x, y)
      Interp_costs.div rest ctxt
  
  | (Script_typed_ir.Ediv_intnat, Item x (Item y rest)) =&gt;
    let '[x, y, rest] :=
      cast
        [Alpha_context.Script_int.num ** Alpha_context.Script_int.num ** stack]
        [x, y, rest] in
    consume_gas_binop __descr_value (Alpha_context.Script_int.ediv, x, y)
      Interp_costs.div rest ctxt
  
  | (Script_typed_ir.Ediv_natint, Item x (Item y rest)) =&gt;
    let '[x, y, rest] :=
      cast
        [Alpha_context.Script_int.num ** Alpha_context.Script_int.num ** stack]
        [x, y, rest] in
    consume_gas_binop __descr_value (Alpha_context.Script_int.ediv, x, y)
      Interp_costs.div rest ctxt
  
  | (Script_typed_ir.Ediv_natnat, Item x (Item y rest)) =&gt;
    let '[x, y, rest] :=
      cast
        [Alpha_context.Script_int.num ** Alpha_context.Script_int.num ** stack]
        [x, y, rest] in
    consume_gas_binop __descr_value (Alpha_context.Script_int.ediv_n, x, y)
      Interp_costs.div rest ctxt
  
  | (Script_typed_ir.Lsl_nat, Item x (Item y rest)) =&gt;
    let '[x, y, rest] :=
      cast
        [Alpha_context.Script_int.num ** Alpha_context.Script_int.num ** stack]
        [x, y, rest] in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt (Interp_costs.shift_left x y)) in
    match Alpha_context.Script_int.shift_left_n x y with
    | None =&gt; Error_monad.fail extensible_type_value
    | Some x =&gt; logged_return ((Item x rest), ctxt)
    end
  
  | (Script_typed_ir.Lsr_nat, Item x (Item y rest)) =&gt;
    let '[x, y, rest] :=
      cast
        [Alpha_context.Script_int.num ** Alpha_context.Script_int.num ** stack]
        [x, y, rest] in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt (Interp_costs.shift_right x y)) in
    match Alpha_context.Script_int.shift_right_n x y with
    | None =&gt; Error_monad.fail extensible_type_value
    | Some __r_value =&gt; logged_return ((Item __r_value rest), ctxt)
    end
  
  | (Script_typed_ir.Or_nat, Item x (Item y rest)) =&gt;
    let '[x, y, rest] :=
      cast
        [Alpha_context.Script_int.num ** Alpha_context.Script_int.num ** stack]
        [x, y, rest] in
    consume_gas_binop __descr_value (Alpha_context.Script_int.logor, x, y)
      Interp_costs.logor rest ctxt
  
  | (Script_typed_ir.And_nat, Item x (Item y rest)) =&gt;
    let '[x, y, rest] :=
      cast
        [Alpha_context.Script_int.num ** Alpha_context.Script_int.num ** stack]
        [x, y, rest] in
    consume_gas_binop __descr_value (Alpha_context.Script_int.logand, x, y)
      Interp_costs.logand rest ctxt
  
  | (Script_typed_ir.And_int_nat, Item x (Item y rest)) =&gt;
    let '[x, y, rest] :=
      cast
        [Alpha_context.Script_int.num ** Alpha_context.Script_int.num ** stack]
        [x, y, rest] in
    consume_gas_binop __descr_value (Alpha_context.Script_int.logand, x, y)
      Interp_costs.logand rest ctxt
  
  | (Script_typed_ir.Xor_nat, Item x (Item y rest)) =&gt;
    let '[x, y, rest] :=
      cast
        [Alpha_context.Script_int.num ** Alpha_context.Script_int.num ** stack]
        [x, y, rest] in
    consume_gas_binop __descr_value (Alpha_context.Script_int.logxor, x, y)
      Interp_costs.logxor rest ctxt
  
  | (Script_typed_ir.Not_int, Item x rest) =&gt;
    let '[x, rest] := cast [Alpha_context.Script_int.num ** stack] [x, rest] in
    consume_gas_unop __descr_value (Alpha_context.Script_int.lognot, x)
      Interp_costs.lognot rest ctxt
  
  | (Script_typed_ir.Not_nat, Item x rest) =&gt;
    let '[x, rest] := cast [Alpha_context.Script_int.num ** stack] [x, rest] in
    consume_gas_unop __descr_value (Alpha_context.Script_int.lognot, x)
      Interp_costs.lognot rest ctxt
  
  | (Script_typed_ir.Seq hd tl, __stack_value) =&gt;
    let '[hd, tl, __stack_value] :=
      cast [Script_typed_ir.descr ** Script_typed_ir.descr ** stack]
        [hd, tl, __stack_value] in
    let=? '(trans, ctxt) := step_descr log ctxt step_constants hd __stack_value
      in
    step_descr log ctxt step_constants tl trans
  
  | (Script_typed_ir.If bt bf, Item __b_value rest) =&gt;
    let '[bt, bf, __b_value, rest] :=
      cast [Script_typed_ir.descr ** Script_typed_ir.descr ** bool ** stack]
        [bt, bf, __b_value, rest] in
    if __b_value then
      let=? ctxt :=
        Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.branch) in
      step_descr log ctxt step_constants bt rest
    else
      let=? ctxt :=
        Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.branch) in
      step_descr log ctxt step_constants bf rest
  
  | (Script_typed_ir.Loop body, Item __b_value rest) =&gt;
    let '[body, __b_value, rest] :=
      cast [Script_typed_ir.descr ** bool ** stack] [body, __b_value, rest] in
    if __b_value then
      let=? ctxt :=
        Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.loop_cycle) in
      let=? '(trans, ctxt) := step_descr log ctxt step_constants body rest in
      step_descr log ctxt step_constants __descr_value trans
    else
      logged_return (rest, ctxt)
  
  | (Script_typed_ir.Loop_left body, Item v rest) =&gt;
    let 'existT _ [__134, __135] [body, v, rest] :=
      cast_exists (Es := [Set ** Set])
        (fun '[__134, __135] =&gt;
          [Script_typed_ir.descr ** Script_typed_ir.union __134 __135 ** stack])
        [body, v, rest] in
    match v with
    | Script_typed_ir.L v =&gt;
      let=? ctxt :=
        Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.loop_cycle) in
      let=? '(trans, ctxt) :=
        step_descr log ctxt step_constants body (Item v rest) in
      step_descr log ctxt step_constants __descr_value trans
    | Script_typed_ir.R v =&gt;
      let=? ctxt :=
        Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.loop_cycle) in
      logged_return ((Item v rest), ctxt)
    end
  
  | (Script_typed_ir.Dip __b_value, Item ign rest) =&gt;
    let 'existT _ __137 [__b_value, ign, rest] :=
      cast_exists (Es := Set)
        (fun __137 =&gt; [Script_typed_ir.descr ** __137 ** stack])
        [__b_value, ign, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.stack_op) in
    let=? '(res, ctxt) := step_descr log ctxt step_constants __b_value rest in
    logged_return ((Item ign res), ctxt)
  
  | (Script_typed_ir.Exec, Item arg (Item lam rest)) =&gt;
    let 'existT _ __140 [arg, lam, rest] :=
      cast_exists (Es := Set)
        (fun __140 =&gt; [__140 ** Script_typed_ir.lambda ** stack])
        [arg, lam, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.exec) in
    let=? '(res, ctxt) := interp log ctxt step_constants lam arg in
    logged_return ((Item (ty := unit) res rest), ctxt)
  
  | (Script_typed_ir.Apply capture_ty, Item capture (Item lam rest)) =&gt;
    let 'existT _ __143 [capture_ty, capture, lam, rest] :=
      cast_exists (Es := Set)
        (fun __143 =&gt;
          [Script_typed_ir.ty ** __143 ** Script_typed_ir.lambda ** stack])
        [capture_ty, capture, lam, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.apply) in
    let '{| Script_typed_ir.lambda.lam := (__descr_value, expr) |} := lam in
    let full_arg_ty :=
      match __descr_value.(Script_typed_ir.descr.bef) with
      | Script_typed_ir.Item_t full_arg_ty _ _ =&gt; full_arg_ty
      | _ =&gt; unreachable_gadt_branch
      end in
    let=? '(const_expr, ctxt) :=
      Script_ir_translator.unparse_data ctxt Script_ir_translator.Optimized
        capture_ty capture in
    let=? '(ty_expr, ctxt) := Script_ir_translator.unparse_ty ctxt capture_ty in
    match full_arg_ty with
    | Script_typed_ir.Pair_t (capture_ty, _, _) (arg_ty, _, _) _ _ =&gt;
      let '[capture_ty, arg_ty] :=
        cast [Script_typed_ir.ty ** Script_typed_ir.ty] [capture_ty, arg_ty] in
      let arg_stack_ty :=
        Script_typed_ir.Item_t arg_ty Script_typed_ir.Empty_t None in
      let const_descr :=
        {|
          Script_typed_ir.descr.loc := __descr_value.(Script_typed_ir.descr.loc);
          Script_typed_ir.descr.bef := arg_stack_ty;
          Script_typed_ir.descr.aft :=
            Script_typed_ir.Item_t capture_ty arg_stack_ty None;
          Script_typed_ir.descr.instr := Script_typed_ir.Const capture |} in
      let pair_descr :=
        {|
          Script_typed_ir.descr.loc := __descr_value.(Script_typed_ir.descr.loc);
          Script_typed_ir.descr.bef :=
            Script_typed_ir.Item_t capture_ty arg_stack_ty None;
          Script_typed_ir.descr.aft :=
            Script_typed_ir.Item_t full_arg_ty Script_typed_ir.Empty_t None;
          Script_typed_ir.descr.instr := Script_typed_ir.Cons_pair |} in
      let seq_descr :=
        {|
          Script_typed_ir.descr.loc := __descr_value.(Script_typed_ir.descr.loc);
          Script_typed_ir.descr.bef := arg_stack_ty;
          Script_typed_ir.descr.aft :=
            Script_typed_ir.Item_t full_arg_ty Script_typed_ir.Empty_t None;
          Script_typed_ir.descr.instr :=
            Script_typed_ir.Seq const_descr pair_descr |} in
      let full_descr :=
        {|
          Script_typed_ir.descr.loc := __descr_value.(Script_typed_ir.descr.loc);
          Script_typed_ir.descr.bef := arg_stack_ty;
          Script_typed_ir.descr.aft := __descr_value.(Script_typed_ir.descr.aft);
          Script_typed_ir.descr.instr :=
            Script_typed_ir.Seq seq_descr __descr_value |} in
      let full_expr :=
        Micheline.Seq 0
          [
            Micheline.Prim 0 Alpha_context.Script.I_PUSH [ ty_expr; const_expr ]
              nil;
            Micheline.Prim 0 Alpha_context.Script.I_PAIR nil nil;
            expr
          ] in
      let lam' := {| Script_typed_ir.lambda.lam := (full_descr, full_expr) |} in
      logged_return ((Item lam' rest), ctxt)
    | _ =&gt;
      (* ‚ùå Assert instruction is not handled. *)
      assert (Lwt.t (Error_monad.tzresult (stack * Alpha_context.context)))
        false
    end
  
  | (Script_typed_ir.Lambda lam, rest) =&gt;
    let '[lam, rest] := cast [Script_typed_ir.lambda ** stack] [lam, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.push) in
    logged_return ((Item lam rest), ctxt)
  
  | (Script_typed_ir.Failwith tv, Item v _) =&gt;
    let 'existT _ __149 [tv, v] :=
      cast_exists (Es := Set) (fun __149 =&gt; [Script_typed_ir.ty ** __149])
        [tv, v] in
    let=? '(v, _ctxt) :=
      Error_monad.trace extensible_type_value
        (Script_ir_translator.unparse_data ctxt Script_ir_translator.Optimized
          tv v) in
    let v := Micheline.strip_locations v in
    Error_monad.fail extensible_type_value
  
  | (Script_typed_ir.Nop, __stack_value) =&gt;
    let __stack_value := cast stack __stack_value in
    logged_return (__stack_value, ctxt)
  
  | (Script_typed_ir.Compare ty, Item __a_value (Item __b_value rest)) =&gt;
    let 'existT _ __151 [ty, __a_value, __b_value, rest] :=
      cast_exists (Es := Set)
        (fun __151 =&gt; [Script_typed_ir.comparable_ty ** __151 ** __151 ** stack])
        [ty, __a_value, __b_value, rest] in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt
          (Interp_costs.compare ty __a_value __b_value)) in
    logged_return
      ((Item
        (Alpha_context.Script_int.of_int
          (Script_ir_translator.compare_comparable ty __a_value __b_value)) rest),
        ctxt)
  
  | (Script_typed_ir.Eq, Item cmpres rest) =&gt;
    let '[cmpres, rest] :=
      cast [Alpha_context.Script_int.num ** stack] [cmpres, rest] in
    let cmpres :=
      Alpha_context.Script_int.compare cmpres Alpha_context.Script_int.zero in
    let cmpres := (|Compare.Int|).(Compare.S.op_eq) cmpres 0 in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.compare_res) in
    logged_return ((Item cmpres rest), ctxt)
  
  | (Script_typed_ir.Neq, Item cmpres rest) =&gt;
    let '[cmpres, rest] :=
      cast [Alpha_context.Script_int.num ** stack] [cmpres, rest] in
    let cmpres :=
      Alpha_context.Script_int.compare cmpres Alpha_context.Script_int.zero in
    let cmpres := (|Compare.Int|).(Compare.S.op_ltgt) cmpres 0 in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.compare_res) in
    logged_return ((Item cmpres rest), ctxt)
  
  | (Script_typed_ir.Lt, Item cmpres rest) =&gt;
    let '[cmpres, rest] :=
      cast [Alpha_context.Script_int.num ** stack] [cmpres, rest] in
    let cmpres :=
      Alpha_context.Script_int.compare cmpres Alpha_context.Script_int.zero in
    let cmpres := (|Compare.Int|).(Compare.S.op_lt) cmpres 0 in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.compare_res) in
    logged_return ((Item cmpres rest), ctxt)
  
  | (Script_typed_ir.Le, Item cmpres rest) =&gt;
    let '[cmpres, rest] :=
      cast [Alpha_context.Script_int.num ** stack] [cmpres, rest] in
    let cmpres :=
      Alpha_context.Script_int.compare cmpres Alpha_context.Script_int.zero in
    let cmpres := (|Compare.Int|).(Compare.S.op_lteq) cmpres 0 in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.compare_res) in
    logged_return ((Item cmpres rest), ctxt)
  
  | (Script_typed_ir.Gt, Item cmpres rest) =&gt;
    let '[cmpres, rest] :=
      cast [Alpha_context.Script_int.num ** stack] [cmpres, rest] in
    let cmpres :=
      Alpha_context.Script_int.compare cmpres Alpha_context.Script_int.zero in
    let cmpres := (|Compare.Int|).(Compare.S.op_gt) cmpres 0 in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.compare_res) in
    logged_return ((Item cmpres rest), ctxt)
  
  | (Script_typed_ir.Ge, Item cmpres rest) =&gt;
    let '[cmpres, rest] :=
      cast [Alpha_context.Script_int.num ** stack] [cmpres, rest] in
    let cmpres :=
      Alpha_context.Script_int.compare cmpres Alpha_context.Script_int.zero in
    let cmpres := (|Compare.Int|).(Compare.S.op_gteq) cmpres 0 in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.compare_res) in
    logged_return ((Item cmpres rest), ctxt)
  
  | (Script_typed_ir.Pack __t_value, Item value rest) =&gt;
    let 'existT _ __159 [__t_value, value, rest] :=
      cast_exists (Es := Set)
        (fun __159 =&gt; [Script_typed_ir.ty ** __159 ** stack])
        [__t_value, value, rest] in
    let=? '(__bytes_value, ctxt) :=
      Script_ir_translator.pack_data ctxt __t_value value in
    logged_return ((Item __bytes_value rest), ctxt)
  
  | (Script_typed_ir.Unpack __t_value, Item __bytes_value rest) =&gt;
    let '[__t_value, __bytes_value, rest] :=
      cast [Script_typed_ir.ty ** MBytes.t ** stack]
        [__t_value, __bytes_value, rest] in
    let=? '_ :=
      Lwt.__return
        (Alpha_context.Gas.check_enough ctxt
          (Alpha_context.Script.serialized_cost __bytes_value)) in
    if
      Pervasives.op_andand
        ((|Compare.Int|).(Compare.S.op_gteq) (MBytes.length __bytes_value) 1)
        ((|Compare.Int|).(Compare.S.op_eq) (MBytes.get_uint8 __bytes_value 0) 5)
      then
      let __bytes_value :=
        MBytes.sub __bytes_value 1
          (Pervasives.op_minus (MBytes.length __bytes_value) 1) in
      match
        Data_encoding.Binary.of_bytes Alpha_context.Script.expr_encoding
          __bytes_value with
      | None =&gt;
        let=? ctxt :=
          Lwt.__return
            (Alpha_context.Gas.consume ctxt
              (Interp_costs.unpack_failed __bytes_value)) in
        logged_return ((Item (None (A := unit)) rest), ctxt)
      | Some expr =&gt;
        let=? ctxt :=
          Lwt.__return
            (Alpha_context.Gas.consume ctxt
              (Alpha_context.Script.deserialized_cost expr)) in
        let= function_parameter :=
          (Script_ir_translator.parse_data (a := unit)) None ctxt false
            __t_value (Micheline.root expr) in
        match function_parameter with
        | Pervasives.Ok (value, ctxt) =&gt;
          logged_return ((Item (Some value) rest), ctxt)
        | Pervasives.Error _ignored =&gt;
          let=? ctxt :=
            Lwt.__return
              (Alpha_context.Gas.consume ctxt
                (Interp_costs.unpack_failed __bytes_value)) in
          logged_return ((Item (None (A := unit)) rest), ctxt)
        end
      end
    else
      logged_return ((Item (None (A := unit)) rest), ctxt)
  
  | (Script_typed_ir.Address, Item pair rest) =&gt;
    let '[pair, rest] :=
      cast [Script_typed_ir.typed_contract ** stack] [pair, rest] in
    let '(_, address) := pair in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.address) in
    logged_return ((Item address rest), ctxt)
  
  | (Script_typed_ir.Contract __t_value entrypoint, Item contract rest) =&gt;
    let '[__t_value, entrypoint, contract, rest] :=
      cast [Script_typed_ir.ty ** string ** Script_typed_ir.address ** stack]
        [__t_value, entrypoint, contract, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.contract) in
    let '(contract, entrypoint') := contract in
    let entrypoint :=
      match (entrypoint, entrypoint') with
      | (&quot;default&quot;, entrypoint) =&gt; Some entrypoint
      | (entrypoint, &quot;default&quot;) =&gt; Some entrypoint
      | _ =&gt; None
      end in
    match entrypoint with
    | Some entrypoint =&gt;
      let=? '(ctxt, maybe_contract) :=
        Script_ir_translator.parse_contract_for_script false ctxt loc __t_value
          contract entrypoint in
      logged_return ((Item maybe_contract rest), ctxt)
    | _ =&gt; logged_return ((Item (None (A := unit)) rest), ctxt)
    end
  
  |
    (Script_typed_ir.Transfer_tokens,
      Item __p_value (Item amount (Item triple rest))) =&gt;
    let 'existT _ __167 [__p_value, amount, triple, rest] :=
      cast_exists (Es := Set)
        (fun __167 =&gt;
          [__167 ** Alpha_context.Tez.t ** Script_typed_ir.typed_contract **
            stack]) [__p_value, amount, triple, rest] in
    let '(tp, (destination, entrypoint)) := triple in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.transfer) in
    let=? '(to_duplicate, ctxt) :=
      Script_ir_translator.collect_big_maps ctxt tp __p_value in
    let to_update := Script_ir_translator.no_big_map_id in
    let=? '(__p_value, big_map_diff, ctxt) :=
      Script_ir_translator.extract_big_map_diff ctxt
        Script_ir_translator.Optimized true to_duplicate to_update tp __p_value
      in
    let=? '(__p_value, ctxt) :=
      Script_ir_translator.unparse_data ctxt Script_ir_translator.Optimized tp
        __p_value in
    let operation :=
      Alpha_context.Transaction
        {| Alpha_context.manager_operation.Transaction.amount := amount;
          Alpha_context.manager_operation.Transaction.parameters :=
            Alpha_context.Script.__lazy_expr_value
              (Micheline.strip_locations __p_value);
          Alpha_context.manager_operation.Transaction.entrypoint := entrypoint;
          Alpha_context.manager_operation.Transaction.destination := destination
          |} in
    let=? '(ctxt, __nonce_value) :=
      Lwt.__return (Alpha_context.fresh_internal_nonce ctxt) in
    logged_return
      ((Item
        ((Alpha_context.Internal_operation
          {|
            Alpha_context.internal_operation.source :=
              step_constants.(step_constants.self);
            Alpha_context.internal_operation.operation := operation;
            Alpha_context.internal_operation.nonce := __nonce_value |}),
          big_map_diff) rest), ctxt)
  
  |
    (Script_typed_ir.Create_account,
      Item manager (Item delegate (Item _delegatable (Item credit rest)))) =&gt;
    let '[manager, delegate, _delegatable, credit, rest] :=
      cast
        [Alpha_context.public_key_hash ** option Alpha_context.public_key_hash
          ** bool ** Alpha_context.Tez.t ** stack]
        [manager, delegate, _delegatable, credit, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.create_account)
      in
    let=? '(ctxt, contract) :=
      Alpha_context.Contract.fresh_contract_from_current_nonce ctxt in
    let manager_bytes :=
      Data_encoding.Binary.to_bytes_exn
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding) manager in
    let storage :=
      Script_repr.__lazy_expr_value
        (Micheline.strip_locations (Micheline.Bytes 0 manager_bytes)) in
    let script :=
      {|
        Alpha_context.Script.t.code :=
          Alpha_context.Script.Legacy_support.manager_script_code;
        Alpha_context.Script.t.storage := storage |} in
    let operation :=
      Alpha_context.Origination
        {| Alpha_context.manager_operation.Origination.delegate := delegate;
          Alpha_context.manager_operation.Origination.script := script;
          Alpha_context.manager_operation.Origination.credit := credit;
          Alpha_context.manager_operation.Origination.preorigination :=
            Some contract |} in
    let=? '(ctxt, __nonce_value) :=
      Lwt.__return (Alpha_context.fresh_internal_nonce ctxt) in
    logged_return
      ((Item
        ((Alpha_context.Internal_operation
          {|
            Alpha_context.internal_operation.source :=
              step_constants.(step_constants.self);
            Alpha_context.internal_operation.operation := operation;
            Alpha_context.internal_operation.nonce := __nonce_value |}),
          (None (A := unit))) (Item (contract, &quot;default&quot;) rest)), ctxt)
  
  | (Script_typed_ir.Implicit_account, Item __key_value rest) =&gt;
    let '[__key_value, rest] :=
      cast [Alpha_context.public_key_hash ** stack] [__key_value, rest] in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt Interp_costs.implicit_account) in
    let contract := Alpha_context.Contract.implicit_contract __key_value in
    logged_return
      ((Item ((Script_typed_ir.Unit_t None), (contract, &quot;default&quot;)) rest), ctxt)
  
  |
    (Script_typed_ir.Create_contract storage_type param_type {|
      Script_typed_ir.lambda.lam := (_, code) |} root_name,
      Item manager
        (Item delegate
          (Item spendable (Item delegatable (Item credit (Item init rest))))))
    =&gt;
    let 'existT _ __171
      [storage_type, param_type, code, root_name, manager, delegate, spendable,
        delegatable, credit, init, rest] :=
      cast_exists (Es := Set)
        (fun __171 =&gt;
          [Script_typed_ir.ty ** Script_typed_ir.ty ** Alpha_context.Script.node
            ** option string ** Alpha_context.public_key_hash **
            option Alpha_context.public_key_hash ** bool ** bool **
            Alpha_context.Tez.t ** __171 ** stack])
        [storage_type, param_type, code, root_name, manager, delegate,
          spendable, delegatable, credit, init, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.create_contract)
      in
    let=? '(unparsed_param_type, ctxt) :=
      Script_ir_translator.unparse_ty ctxt param_type in
    let unparsed_param_type :=
      Script_ir_translator.add_field_annot
        (Option.map (fun n =&gt; Script_typed_ir.Field_annot n) root_name) None
        unparsed_param_type in
    let=? '(unparsed_storage_type, ctxt) :=
      Script_ir_translator.unparse_ty ctxt storage_type in
    let code :=
      Alpha_context.Script.__lazy_expr_value
        (Micheline.strip_locations
          (Micheline.Seq 0
            [
              Micheline.Prim 0 Alpha_context.Script.K_parameter
                [ unparsed_param_type ] nil;
              Micheline.Prim 0 Alpha_context.Script.K_storage
                [ unparsed_storage_type ] nil;
              Micheline.Prim 0 Alpha_context.Script.K_code [ code ] nil
            ])) in
    let=? '(to_duplicate, ctxt) :=
      Script_ir_translator.collect_big_maps ctxt storage_type init in
    let to_update := Script_ir_translator.no_big_map_id in
    let=? '(init, big_map_diff, ctxt) :=
      Script_ir_translator.extract_big_map_diff ctxt
        Script_ir_translator.Optimized true to_duplicate to_update storage_type
        init in
    let=? '(storage, ctxt) :=
      Script_ir_translator.unparse_data ctxt Script_ir_translator.Optimized
        storage_type init in
    let storage :=
      Alpha_context.Script.__lazy_expr_value (Micheline.strip_locations storage)
      in
    let=? '(code, storage) :=
      if spendable then
        Alpha_context.Script.Legacy_support.add_do manager code storage
      else
        if delegatable then
          Alpha_context.Script.Legacy_support.add_set_delegate manager code
            storage
        else
          if Alpha_context.Script.Legacy_support.has_default_entrypoint code
            then
            let=? code :=
              Alpha_context.Script.Legacy_support.add_root_entrypoint code in
            Error_monad.__return (code, storage)
          else
            Error_monad.__return (code, storage) in
    let=? '(ctxt, contract) :=
      Alpha_context.Contract.fresh_contract_from_current_nonce ctxt in
    let operation :=
      Alpha_context.Origination
        {| Alpha_context.manager_operation.Origination.delegate := delegate;
          Alpha_context.manager_operation.Origination.script :=
            {| Alpha_context.Script.t.code := code;
              Alpha_context.Script.t.storage := storage |};
          Alpha_context.manager_operation.Origination.credit := credit;
          Alpha_context.manager_operation.Origination.preorigination :=
            Some contract |} in
    let=? '(ctxt, __nonce_value) :=
      Lwt.__return (Alpha_context.fresh_internal_nonce ctxt) in
    logged_return
      ((Item
        ((Alpha_context.Internal_operation
          {|
            Alpha_context.internal_operation.source :=
              step_constants.(step_constants.self);
            Alpha_context.internal_operation.operation := operation;
            Alpha_context.internal_operation.nonce := __nonce_value |}),
          big_map_diff) (Item (contract, &quot;default&quot;) rest)), ctxt)
  
  |
    (Script_typed_ir.Create_contract_2 storage_type param_type {|
      Script_typed_ir.lambda.lam := (_, code) |} root_name,
      Item delegate (Item credit (Item init rest))) =&gt;
    let 'existT _ __173
      [storage_type, param_type, code, root_name, delegate, credit, init, rest]
      :=
      cast_exists (Es := Set)
        (fun __173 =&gt;
          [Script_typed_ir.ty ** Script_typed_ir.ty ** Alpha_context.Script.node
            ** option string ** option Alpha_context.public_key_hash **
            Alpha_context.Tez.t ** __173 ** stack])
        [storage_type, param_type, code, root_name, delegate, credit, init,
          rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.create_contract)
      in
    let=? '(unparsed_param_type, ctxt) :=
      Script_ir_translator.unparse_ty ctxt param_type in
    let unparsed_param_type :=
      Script_ir_translator.add_field_annot
        (Option.map (fun n =&gt; Script_typed_ir.Field_annot n) root_name) None
        unparsed_param_type in
    let=? '(unparsed_storage_type, ctxt) :=
      Script_ir_translator.unparse_ty ctxt storage_type in
    let code :=
      Micheline.strip_locations
        (Micheline.Seq 0
          [
            Micheline.Prim 0 Alpha_context.Script.K_parameter
              [ unparsed_param_type ] nil;
            Micheline.Prim 0 Alpha_context.Script.K_storage
              [ unparsed_storage_type ] nil;
            Micheline.Prim 0 Alpha_context.Script.K_code [ code ] nil
          ]) in
    let=? '(to_duplicate, ctxt) :=
      Script_ir_translator.collect_big_maps ctxt storage_type init in
    let to_update := Script_ir_translator.no_big_map_id in
    let=? '(init, big_map_diff, ctxt) :=
      Script_ir_translator.extract_big_map_diff ctxt
        Script_ir_translator.Optimized true to_duplicate to_update storage_type
        init in
    let=? '(storage, ctxt) :=
      Script_ir_translator.unparse_data ctxt Script_ir_translator.Optimized
        storage_type init in
    let storage := Micheline.strip_locations storage in
    let=? '(ctxt, contract) :=
      Alpha_context.Contract.fresh_contract_from_current_nonce ctxt in
    let operation :=
      Alpha_context.Origination
        {| Alpha_context.manager_operation.Origination.delegate := delegate;
          Alpha_context.manager_operation.Origination.script :=
            {|
              Alpha_context.Script.t.code :=
                Alpha_context.Script.__lazy_expr_value code;
              Alpha_context.Script.t.storage :=
                Alpha_context.Script.__lazy_expr_value storage |};
          Alpha_context.manager_operation.Origination.credit := credit;
          Alpha_context.manager_operation.Origination.preorigination :=
            Some contract |} in
    let=? '(ctxt, __nonce_value) :=
      Lwt.__return (Alpha_context.fresh_internal_nonce ctxt) in
    logged_return
      ((Item
        ((Alpha_context.Internal_operation
          {|
            Alpha_context.internal_operation.source :=
              step_constants.(step_constants.self);
            Alpha_context.internal_operation.operation := operation;
            Alpha_context.internal_operation.nonce := __nonce_value |}),
          big_map_diff) (Item (contract, &quot;default&quot;) rest)), ctxt)
  
  | (Script_typed_ir.Set_delegate, Item delegate rest) =&gt;
    let '[delegate, rest] :=
      cast [option Alpha_context.public_key_hash ** stack] [delegate, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.create_account)
      in
    let operation := Alpha_context.Delegation delegate in
    let=? '(ctxt, __nonce_value) :=
      Lwt.__return (Alpha_context.fresh_internal_nonce ctxt) in
    logged_return
      ((Item
        ((Alpha_context.Internal_operation
          {|
            Alpha_context.internal_operation.source :=
              step_constants.(step_constants.self);
            Alpha_context.internal_operation.operation := operation;
            Alpha_context.internal_operation.nonce := __nonce_value |}),
          (None (A := unit))) rest), ctxt)
  
  | (Script_typed_ir.Balance, rest) =&gt;
    let rest := cast stack rest in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.balance) in
    let=? balance :=
      Alpha_context.Contract.get_balance ctxt
        step_constants.(step_constants.self) in
    logged_return ((Item balance rest), ctxt)
  
  | (Script_typed_ir.Now, rest) =&gt;
    let rest := cast stack rest in
    let=? ctxt := Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.now)
      in
    let now := Alpha_context.Script_timestamp.now ctxt in
    logged_return ((Item now rest), ctxt)
  
  |
    (Script_typed_ir.Check_signature,
      Item __key_value (Item signature (Item message rest))) =&gt;
    let '[__key_value, signature, message, rest] :=
      cast
        [Alpha_context.public_key ** Alpha_context.signature ** MBytes.t **
          stack] [__key_value, signature, message, rest] in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt
          (Interp_costs.check_signature __key_value message)) in
    let res := Signature.check None __key_value signature message in
    logged_return ((Item res rest), ctxt)
  
  | (Script_typed_ir.Hash_key, Item __key_value rest) =&gt;
    let '[__key_value, rest] :=
      cast [Alpha_context.public_key ** stack] [__key_value, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.hash_key) in
    logged_return
      ((Item ((|Signature.Public_key|).(S.SPublic_key.__hash_value) __key_value)
        rest), ctxt)
  
  | (Script_typed_ir.Blake2b, Item __bytes_value rest) =&gt;
    let '[__bytes_value, rest] := cast [MBytes.t ** stack] [__bytes_value, rest]
      in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt
          (Interp_costs.hash_blake2b __bytes_value)) in
    let __hash_value := Raw_hashes.blake2b __bytes_value in
    logged_return ((Item __hash_value rest), ctxt)
  
  | (Script_typed_ir.Sha256, Item __bytes_value rest) =&gt;
    let '[__bytes_value, rest] := cast [MBytes.t ** stack] [__bytes_value, rest]
      in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt (Interp_costs.hash_sha256 __bytes_value))
      in
    let __hash_value := Raw_hashes.sha256 __bytes_value in
    logged_return ((Item __hash_value rest), ctxt)
  
  | (Script_typed_ir.Sha512, Item __bytes_value rest) =&gt;
    let '[__bytes_value, rest] := cast [MBytes.t ** stack] [__bytes_value, rest]
      in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt (Interp_costs.hash_sha512 __bytes_value))
      in
    let __hash_value := Raw_hashes.sha512 __bytes_value in
    logged_return ((Item __hash_value rest), ctxt)
  
  | (Script_typed_ir.Steps_to_quota, rest) =&gt;
    let rest := cast stack rest in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.steps_to_quota)
      in
    let steps :=
      match Alpha_context.Gas.level ctxt with
      |
        Alpha_context.Gas.Limited {|
          Alpha_context.Gas.t.Limited.remaining := remaining |} =&gt; remaining
      | Alpha_context.Gas.Unaccounted =&gt; Z.of_string &quot;99999999&quot;
      end in
    logged_return
      ((Item
        (Alpha_context.Script_int.abs (Alpha_context.Script_int.of_zint steps))
        rest), ctxt)
  
  | (Script_typed_ir.Source, rest) =&gt;
    let rest := cast stack rest in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.source) in
    logged_return
      ((Item (step_constants.(step_constants.payer), &quot;default&quot;) rest), ctxt)
  
  | (Script_typed_ir.Sender, rest) =&gt;
    let rest := cast stack rest in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.source) in
    logged_return
      ((Item (step_constants.(step_constants.source), &quot;default&quot;) rest), ctxt)
  
  | (Script_typed_ir.Self __t_value entrypoint, rest) =&gt;
    let '[__t_value, entrypoint, rest] :=
      cast [Script_typed_ir.ty ** string ** stack] [__t_value, entrypoint, rest]
      in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.self) in
    logged_return
      ((Item (__t_value, (step_constants.(step_constants.self), entrypoint))
        rest), ctxt)
  
  | (Script_typed_ir.Amount, rest) =&gt;
    let rest := cast stack rest in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.amount) in
    logged_return ((Item step_constants.(step_constants.amount) rest), ctxt)
  
  | (Script_typed_ir.Dig n n', __stack_value) =&gt;
    let '[n, n', __stack_value] :=
      cast [int ** Script_typed_ir.stack_prefix_preservation_witness ** stack]
        [n, n', __stack_value] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt (Interp_costs.stack_n_op n))
      in
    let dig {A : Set} (n' : Script_typed_ir.stack_prefix_preservation_witness)
      : Lwt.t (Error_monad.tzresult (stack * A)) :=
      interp_stack_prefix_preserving_operation
        (fun function_parameter =&gt;
          match function_parameter with
          | Item v rest =&gt;
            let '[v, rest] := cast [A ** stack] [v, rest] in
            Error_monad.__return (rest, v)
          | _ =&gt; unreachable_gadt_branch
          end) n' __stack_value in
    let=? '(aft, x) := (dig (A := unit)) n' in
    logged_return ((Item x aft), ctxt)
  
  | (Script_typed_ir.Dug n n', Item v rest) =&gt;
    let 'existT _ __184 [n, n', v, rest] :=
      cast_exists (Es := Set)
        (fun __184 =&gt;
          [int ** Script_typed_ir.stack_prefix_preservation_witness ** __184 **
            stack]) [n, n', v, rest] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt (Interp_costs.stack_n_op n))
      in
    let=? '(aft, _) :=
      interp_stack_prefix_preserving_operation
        (fun stk =&gt; Error_monad.__return ((Item v stk), tt)) n' rest in
    logged_return (aft, ctxt)
  
  | (Script_typed_ir.Dipn n n' __b_value, __stack_value) =&gt;
    let '[n, n', __b_value, __stack_value] :=
      cast
        [int ** Script_typed_ir.stack_prefix_preservation_witness **
          Script_typed_ir.descr ** stack] [n, n', __b_value, __stack_value] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt (Interp_costs.stack_n_op n))
      in
    let=? '(aft, ctxt') :=
      interp_stack_prefix_preserving_operation
        (fun stk =&gt;
          let=? '(res, ctxt') :=
            step_descr log ctxt step_constants __b_value stk in
          Error_monad.__return (res, ctxt')) n' __stack_value in
    logged_return (aft, ctxt')
  
  | (Script_typed_ir.Dropn n n', __stack_value) =&gt;
    let '[n, n', __stack_value] :=
      cast [int ** Script_typed_ir.stack_prefix_preservation_witness ** stack]
        [n, n', __stack_value] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt (Interp_costs.stack_n_op n))
      in
    let=? '(_, rest) :=
      interp_stack_prefix_preserving_operation
        (fun stk =&gt; Error_monad.__return (stk, stk)) n' __stack_value in
    logged_return (rest, ctxt)
  
  | (Script_typed_ir.ChainId, rest) =&gt;
    let rest := cast stack rest in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.chain_id) in
    logged_return ((Item step_constants.(step_constants.chain_id) rest), ctxt)
  | _ =&gt; unreachable_gadt_branch
  end

with loop_list_map {a b : Set}
  (log : option (Pervasives.ref execution_trace))
  (step_constants : step_constants) (body : Script_typed_ir.descr)
  (rest : stack) (ctxt : Alpha_context.context) (l : list a) (acc : list b)
  {struct l} : Lwt.t (Error_monad.tzresult (stack * Alpha_context.context)) :=
  let=? ctxt :=
    Lwt.__return (Alpha_context.Gas.consume ctxt Interp_costs.loop_map) in
  match l with
  | [] =&gt; Error_monad.__return ((Item (List.rev acc) rest), ctxt)
  | cons hd tl =&gt;
    let=? function_parameter :=
      step_descr log ctxt step_constants body (Item hd rest) in
    match function_parameter with
    | (Item hd rest, ctxt) =&gt;
      let '[hd, rest, ctxt] :=
        cast [b ** stack ** Alpha_context.context] [hd, rest, ctxt] in
      loop_list_map log step_constants body rest ctxt tl (cons hd acc)
    | _ =&gt; unreachable_gadt_branch
    end
  end

with step_descr
  (log : option (Pervasives.ref execution_trace)) (ctxt : Alpha_context.context)
  (step_constants : step_constants) (__descr_value : Script_typed_ir.descr)
  (__stack_value : stack) {struct __descr_value}
  : Lwt.t (Error_monad.tzresult (stack * Alpha_context.context)) :=
  step __descr_value.(Script_typed_ir.descr.instr)
    __descr_value.(Script_typed_ir.descr.loc)
    __descr_value.(Script_typed_ir.descr.bef)
    __descr_value.(Script_typed_ir.descr.aft) log ctxt step_constants
    __stack_value

with interp {p r : Set}
  (log : option (Pervasives.ref execution_trace)) (ctxt : Alpha_context.context)
  (step_constants : step_constants) (lam : Script_typed_ir.lambda) (arg : p)
  {struct lam} : Lwt.t (Error_monad.tzresult (r * Alpha_context.context)) :=
  let __stack_value := Item arg Empty in
  let '{| Script_typed_ir.lambda.lam := (code, _) |} := lam in
  let code := cast Script_typed_ir.descr code in
  let=? '_ :=
    match log with
    | None =&gt; Error_monad.return_unit
    | Some log =&gt;
      let=? __stack_value :=
        Error_monad.trace extensible_type_value
          (unparse_stack ctxt (__stack_value, code.(Script_typed_ir.descr.bef)))
        in
      (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
      (* ‚ùå instruction_sequence &quot;;&quot; *)
      Error_monad.return_unit
    end in
  let=? function_parameter :=
    step_descr log ctxt step_constants code __stack_value in
  match function_parameter with
  | (Item ret Empty, ctxt) =&gt;
    let '[ret, ctxt] := cast [r ** Alpha_context.context] [ret, ctxt] in
    Error_monad.__return (ret, ctxt)
  | _ =&gt; unreachable_gadt_branch
  end.

Definition execute
  (log : option (Pervasives.ref execution_trace)) (ctxt : Alpha_context.context)
  (mode : Script_ir_translator.unparsing_mode) (step_constants : step_constants)
  (entrypoint : string) (unparsed_script : Alpha_context.Script.t)
  (arg : Alpha_context.Script.node)
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.Script.expr * list Alpha_context.packed_internal_operation
        * Alpha_context.context * option Alpha_context.Contract.big_map_diff)) :=
  let=?
    '(Script_ir_translator.Ex_script {|
      Script_typed_ir.script.code := code;
        Script_typed_ir.script.arg_type := arg_type;
        Script_typed_ir.script.storage := storage;
        Script_typed_ir.script.storage_type := storage_type;
        Script_typed_ir.script.root_name := root_name
        |}, ctxt) :=
    Script_ir_translator.parse_script None ctxt true unparsed_script in
  let 'existT _ __Ex_script_'b
    [code, arg_type, storage, storage_type, root_name, ctxt] :=
    cast_exists (Es := Set)
      (fun __Ex_script_'b =&gt;
        [Script_typed_ir.lambda ** Script_typed_ir.ty ** __Ex_script_'b **
          Script_typed_ir.ty ** option string ** Alpha_context.context])
      [code, arg_type, storage, storage_type, root_name, ctxt] in
  let=? '(box, _) :=
    Error_monad.trace extensible_type_value
      (Lwt.__return
        (Script_ir_translator.find_entrypoint arg_type root_name entrypoint)) in
  let=? '(arg, ctxt) :=
    Error_monad.trace extensible_type_value
      (Script_ir_translator.parse_data None ctxt false arg_type (box arg)) in
  let=? '(script_code, ctxt) :=
    Alpha_context.Script.force_decode_in_context ctxt
      unparsed_script.(Alpha_context.Script.t.code) in
  let=? '(to_duplicate, ctxt) :=
    (Script_ir_translator.collect_big_maps (A := unit)) ctxt arg_type arg in
  let=? '(to_update, ctxt) :=
    Script_ir_translator.collect_big_maps ctxt storage_type storage in
  let=? '((ops, storage), ctxt) :=
    Error_monad.trace extensible_type_value
      ((interp (r := list Script_typed_ir.operation * unit)) log ctxt
        step_constants code (arg, storage)) in
  let=? '(storage, big_map_diff, ctxt) :=
    Script_ir_translator.extract_big_map_diff ctxt mode false to_duplicate
      to_update storage_type storage in
  let=? '(storage, ctxt) :=
    Error_monad.trace extensible_type_value
      ((Script_ir_translator.unparse_data (a := unit)) ctxt mode storage_type
        storage) in
  let '(ops, op_diffs) := List.split ops in
  let big_map_diff :=
    match
      List.flatten
        (List.map (Option.unopt nil)
          (Pervasives.op_at op_diffs [ big_map_diff ])) with
    | [] =&gt; None
    | diff =&gt; Some diff
    end in
  Error_monad.__return
    ((Micheline.strip_locations storage), ops, ctxt, big_map_diff).

Module execution_result.
  Record record : Set := Build {
    ctxt : Alpha_context.context;
    storage : Alpha_context.Script.expr;
    big_map_diff : option Alpha_context.Contract.big_map_diff;
    operations : list Alpha_context.packed_internal_operation }.
  Definition with_ctxt ctxt (r : record) :=
    Build ctxt r.(storage) r.(big_map_diff) r.(operations).
  Definition with_storage storage (r : record) :=
    Build r.(ctxt) storage r.(big_map_diff) r.(operations).
  Definition with_big_map_diff big_map_diff (r : record) :=
    Build r.(ctxt) r.(storage) big_map_diff r.(operations).
  Definition with_operations operations (r : record) :=
    Build r.(ctxt) r.(storage) r.(big_map_diff) operations.
End execution_result.
Definition execution_result := execution_result.record.

Definition trace
  (ctxt : Alpha_context.context) (mode : Script_ir_translator.unparsing_mode)
  (step_constants : step_constants) (script : Alpha_context.Script.t)
  (entrypoint : string)
  (parameter : Micheline.canonical Alpha_context.Script.prim)
  : Lwt.t
    (Error_monad.tzresult
      (execution_result *
        list
          (Alpha_context.Script.location * Alpha_context.Gas.t *
            list (Alpha_context.Script.expr * option string)))) :=
  let log := Pervasives.__ref_value nil in
  let=? '(storage, operations, ctxt, big_map_diff) :=
    execute (Some log) ctxt mode step_constants entrypoint script
      (Micheline.root parameter) in
  let trace := List.rev (Pervasives.op_exclamation log) in
  Error_monad.__return
    ({| execution_result.ctxt := ctxt; execution_result.storage := storage;
      execution_result.big_map_diff := big_map_diff;
      execution_result.operations := operations |}, trace).

Definition execute_wrapper
  (ctxt : Alpha_context.context) (mode : Script_ir_translator.unparsing_mode)
  (step_constants : step_constants) (script : Alpha_context.Script.t)
  (entrypoint : string)
  (parameter : Micheline.canonical Alpha_context.Script.prim)
  : Lwt.t (Error_monad.tzresult execution_result) :=
  let=? '(storage, operations, ctxt, big_map_diff) :=
    execute None ctxt mode step_constants entrypoint script
      (Micheline.root parameter) in
  Error_monad.__return
    {| execution_result.ctxt := ctxt; execution_result.storage := storage;
      execution_result.big_map_diff := big_map_diff;
      execution_result.operations := operations |}.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_interpreter.mli">
  <div style="margin: 20px;">
    <h3>Script_interpreter_mli</h3>
    <ul>
      <li>OCaml size: 89 lines</li>
      <li>Coq size: 91 lines (+2% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#script_interpreter.mli"><code>script_interpreter.mli</code></a>&nbsp;<span class="label label-warning">7 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

type execution_trace =
  (Script.location * Gas.t * (Script.expr * string option) list) list

<abbr class="mark-warning" title="Extensible types are not handled.">type error +=
  | Reject of Script.location * Script.expr * execution_trace option</abbr>

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Overflow of Script.location * execution_trace option</abbr>

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Runtime_contract_error : Contract.t * Script.expr -&gt; error</abbr>

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Bad_contract_parameter of Contract.t</abbr> (* `Permanent *)

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Cannot_serialize_log</abbr>

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Cannot_serialize_failure</abbr>

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Cannot_serialize_storage</abbr>

type execution_result = {
  ctxt : context;
  storage : Script.expr;
  big_map_diff : Contract.big_map_diff option;
  operations : packed_internal_operation list;
}

type step_constants = {
  source : Contract.t;
  payer : Contract.t;
  self : Contract.t;
  amount : Tez.t;
  chain_id : Chain_id.t;
}

type 'tys stack =
  | Item : 'ty * 'rest stack -&gt; ('ty * 'rest) stack
  | Empty : Script_typed_ir.end_of_stack stack

val step_descr :
  ?log:execution_trace ref -&gt;
  context -&gt;
  step_constants -&gt;
  ('bef, 'aft) Script_typed_ir.descr -&gt;
  'bef stack -&gt;
  ('aft stack * context) tzresult Lwt.t

val execute_wrapper :
  Alpha_context.t -&gt;
  Script_ir_translator.unparsing_mode -&gt;
  step_constants -&gt;
  script:Script.t -&gt;
  entrypoint:string -&gt;
  parameter:Script.expr -&gt;
  execution_result tzresult Lwt.t

val trace :
  Alpha_context.t -&gt;
  Script_ir_translator.unparsing_mode -&gt;
  step_constants -&gt;
  script:Script.t -&gt;
  entrypoint:string -&gt;
  parameter:Script.expr -&gt;
  (execution_result * execution_trace) tzresult Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_interpreter.mli"><code>Script_interpreter_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Script_ir_translator.
Require Tezos.Script_typed_ir.

Import Alpha_context.

Definition execution_trace : Set :=
  list
    (Alpha_context.Script.location * Alpha_context.Gas.t *
      list (Alpha_context.Script.expr * option string)).

(* extensible_type_definition `error` *)

(* extensible_type_definition `error` *)

(* extensible_type_definition `error` *)

(* extensible_type_definition `error` *)

(* extensible_type_definition `error` *)

(* extensible_type_definition `error` *)

(* extensible_type_definition `error` *)

Module execution_result.
  Record record : Set := Build {
    ctxt : Alpha_context.context;
    storage : Alpha_context.Script.expr;
    big_map_diff : option Alpha_context.Contract.big_map_diff;
    operations : list Alpha_context.packed_internal_operation }.
  Definition with_ctxt ctxt (r : record) :=
    Build ctxt r.(storage) r.(big_map_diff) r.(operations).
  Definition with_storage storage (r : record) :=
    Build r.(ctxt) storage r.(big_map_diff) r.(operations).
  Definition with_big_map_diff big_map_diff (r : record) :=
    Build r.(ctxt) r.(storage) big_map_diff r.(operations).
  Definition with_operations operations (r : record) :=
    Build r.(ctxt) r.(storage) r.(big_map_diff) operations.
End execution_result.
Definition execution_result := execution_result.record.

Module step_constants.
  Record record : Set := Build {
    source : Alpha_context.Contract.t;
    payer : Alpha_context.Contract.t;
    self : Alpha_context.Contract.t;
    amount : Alpha_context.Tez.t;
    chain_id : (|Chain_id|).(S.HASH.t) }.
  Definition with_source source (r : record) :=
    Build source r.(payer) r.(self) r.(amount) r.(chain_id).
  Definition with_payer payer (r : record) :=
    Build r.(source) payer r.(self) r.(amount) r.(chain_id).
  Definition with_self self (r : record) :=
    Build r.(source) r.(payer) self r.(amount) r.(chain_id).
  Definition with_amount amount (r : record) :=
    Build r.(source) r.(payer) r.(self) amount r.(chain_id).
  Definition with_chain_id chain_id (r : record) :=
    Build r.(source) r.(payer) r.(self) r.(amount) chain_id.
End step_constants.
Definition step_constants := step_constants.record.

Inductive stack : Set :=
| Item : forall {ty : Set}, ty -&gt; stack -&gt; stack
| Empty : stack.

Parameter step_descr :
  option (Pervasives.ref execution_trace) -&gt; Alpha_context.context -&gt;
  step_constants -&gt; Script_typed_ir.descr -&gt; stack -&gt;
  Lwt.t (Error_monad.tzresult (stack * Alpha_context.context)).

Parameter execute_wrapper :
  Alpha_context.t -&gt; Script_ir_translator.unparsing_mode -&gt; step_constants -&gt;
  Alpha_context.Script.t -&gt; string -&gt; Alpha_context.Script.expr -&gt;
  Lwt.t (Error_monad.tzresult execution_result).

Parameter trace :
  Alpha_context.t -&gt; Script_ir_translator.unparsing_mode -&gt; step_constants -&gt;
  Alpha_context.Script.t -&gt; string -&gt; Alpha_context.Script.expr -&gt;
  Lwt.t (Error_monad.tzresult (execution_result * execution_trace)).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_ir_annot.ml">
  <div style="margin: 20px;">
    <h3>Script_ir_annot</h3>
    <ul>
      <li>OCaml size: 521 lines</li>
      <li>Coq size: 665 lines (+27% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#script_ir_annot.ml"><code>script_ir_annot.ml</code></a>&nbsp;<span class="label label-warning">14 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context
open Micheline
open Script_tc_errors
open Script_typed_ir

let default_now_annot = Some (Var_annot &quot;now&quot;)

let default_amount_annot = Some (Var_annot &quot;amount&quot;)

let default_balance_annot = Some (Var_annot &quot;balance&quot;)

let default_steps_annot = Some (Var_annot &quot;steps&quot;)

let default_source_annot = Some (Var_annot &quot;source&quot;)

let default_sender_annot = Some (Var_annot &quot;sender&quot;)

let default_self_annot = Some (Var_annot &quot;self&quot;)

let default_arg_annot = Some (Var_annot &quot;arg&quot;)

let default_param_annot = Some (Var_annot &quot;parameter&quot;)

let default_storage_annot = Some (Var_annot &quot;storage&quot;)

let default_car_annot = Some (Field_annot &quot;car&quot;)

let default_cdr_annot = Some (Field_annot &quot;cdr&quot;)

let default_contract_annot = Some (Field_annot &quot;contract&quot;)

let default_addr_annot = Some (Field_annot &quot;address&quot;)

let default_manager_annot = Some (Field_annot &quot;manager&quot;)

let default_pack_annot = Some (Field_annot &quot;packed&quot;)

let default_unpack_annot = Some (Field_annot &quot;unpacked&quot;)

let default_slice_annot = Some (Field_annot &quot;slice&quot;)

let default_elt_annot = Some (Field_annot &quot;elt&quot;)

let default_key_annot = Some (Field_annot &quot;key&quot;)

let default_hd_annot = Some (Field_annot &quot;hd&quot;)

let default_tl_annot = Some (Field_annot &quot;tl&quot;)

let default_some_annot = Some (Field_annot &quot;some&quot;)

let default_left_annot = Some (Field_annot &quot;left&quot;)

let default_right_annot = Some (Field_annot &quot;right&quot;)

let default_binding_annot = Some (Field_annot &quot;bnd&quot;)

let unparse_type_annot : type_annot option -&gt; string list = function
  | None -&gt;
      []
  | Some (Type_annot a) -&gt;
      [&quot;:&quot; ^ a]

let unparse_var_annot : var_annot option -&gt; string list = function
  | None -&gt;
      []
  | Some (Var_annot a) -&gt;
      [&quot;@&quot; ^ a]

let unparse_field_annot : field_annot option -&gt; string list = function
  | None -&gt;
      []
  | Some (Field_annot a) -&gt;
      [&quot;%&quot; ^ a]

let field_to_var_annot : field_annot option -&gt; var_annot option = function
  | None -&gt;
      None
  | Some (Field_annot s) -&gt;
      Some (Var_annot s)

let type_to_var_annot : type_annot option -&gt; var_annot option = function
  | None -&gt;
      None
  | Some (Type_annot s) -&gt;
      Some (Var_annot s)

let var_to_field_annot : var_annot option -&gt; field_annot option = function
  | None -&gt;
      None
  | Some (Var_annot s) -&gt;
      Some (Field_annot s)

let default_annot ~default = function None -&gt; default | annot -&gt; annot

let gen_access_annot :
    var_annot option -&gt;
    ?default:field_annot option -&gt;
    field_annot option -&gt;
    var_annot option =
 fun value_annot ?(default = None) field_annot -&gt;
  match (value_annot, field_annot, default) with
  | (None, None, _) | (Some _, None, None) | (None, Some (Field_annot &quot;&quot;), _)
    -&gt;
      None
  | (None, Some (Field_annot f), _) -&gt;
      Some (Var_annot f)
  | (Some (Var_annot v), (None | Some (Field_annot &quot;&quot;)), Some (Field_annot f))
    -&gt;
      Some (Var_annot (String.concat &quot;.&quot; [v; f]))
  | (Some (Var_annot v), Some (Field_annot f), _) -&gt;
      Some (Var_annot (String.concat &quot;.&quot; [v; f]))

let merge_type_annot :
    legacy:bool -&gt;
    type_annot option -&gt;
    type_annot option -&gt;
    type_annot option tzresult =
 fun ~legacy annot1 annot2 -&gt;
  match (annot1, annot2) with
  | (None, None) | (Some _, None) | (None, Some _) -&gt;
      ok None
  | (Some (Type_annot a1), Some (Type_annot a2)) -&gt;
      if legacy || String.equal a1 a2 then ok annot1
      else error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Inconsistent_annotations (&quot;:&quot; ^ a1, &quot;:&quot; ^ a2))</abbr>

let merge_field_annot :
    legacy:bool -&gt;
    field_annot option -&gt;
    field_annot option -&gt;
    field_annot option tzresult =
 fun ~legacy annot1 annot2 -&gt;
  match (annot1, annot2) with
  | (None, None) | (Some _, None) | (None, Some _) -&gt;
      ok None
  | (Some (Field_annot a1), Some (Field_annot a2)) -&gt;
      if legacy || String.equal a1 a2 then ok annot1
      else error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Inconsistent_annotations (&quot;%&quot; ^ a1, &quot;%&quot; ^ a2))</abbr>

let merge_var_annot : var_annot option -&gt; var_annot option -&gt; var_annot option
    =
 fun annot1 annot2 -&gt;
  match (annot1, annot2) with
  | (None, None) | (Some _, None) | (None, Some _) -&gt;
      None
  | (Some (Var_annot a1), Some (Var_annot a2)) -&gt;
      if String.equal a1 a2 then annot1 else None

let error_unexpected_annot loc annot =
  match annot with [] -&gt; ok () | _ :: _ -&gt; error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Unexpected_annotation loc)</abbr>

let fail_unexpected_annot loc annot =
  Lwt.return (error_unexpected_annot loc annot)

type annot_opt =
  | Field_annot_opt of string option
  | Type_annot_opt of string option
  | Var_annot_opt of string option

let parse_annots loc ?(allow_special_var = false)
    ?(allow_special_field = false) l =
  (* allow emtpty annotations as wildcards but otherwise only accept
     annotations that start with [a-zA-Z_] *)
  let sub_or_wildcard ~specials wrap s acc =
    let len = String.length s in
    if Compare.Int.(len = 1) then ok @@ (wrap None :: acc)
    else
      match s.[1] with
      | 'a' .. 'z' | 'A' .. 'Z' | '_' -&gt;
          ok @@ (wrap (Some (String.sub s 1 (len - 1))) :: acc)
      | '@' when Compare.Int.(len = 2) &amp;&amp; List.mem '@' specials -&gt;
          ok @@ (wrap (Some &quot;@&quot;) :: acc)
      | '%' when List.mem '%' specials -&gt;
          if Compare.Int.(len = 2) then ok @@ (wrap (Some &quot;%&quot;) :: acc)
          else if Compare.Int.(len = 3) &amp;&amp; Compare.Char.(s.[2] = '%') then
            ok @@ (wrap (Some &quot;%%&quot;) :: acc)
          else error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Unexpected_annotation loc)</abbr>
      | _ -&gt;
          error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Unexpected_annotation loc)</abbr>
  in
  List.fold_left
    (fun acc s -&gt;
      acc
      &gt;&gt;? fun acc -&gt;
      if Compare.Int.(String.length s = 0) then
        error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Unexpected_annotation loc)</abbr>
      else
        match s.[0] with
        | ':' -&gt;
            sub_or_wildcard ~specials:[] (fun a -&gt; Type_annot_opt a) s acc
        | '@' -&gt;
            sub_or_wildcard
              ~specials:(if allow_special_var then ['%'] else [])
              (fun a -&gt; Var_annot_opt a)
              s
              acc
        | '%' -&gt;
            sub_or_wildcard
              ~specials:(if allow_special_field then ['@'] else [])
              (fun a -&gt; Field_annot_opt a)
              s
              acc
        | _ -&gt;
            error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Unexpected_annotation loc)</abbr>)
    (ok [])
    l
  &gt;|? List.rev

let opt_var_of_var_opt = function None -&gt; None | Some a -&gt; Some (Var_annot a)

let opt_field_of_field_opt = function
  | None -&gt;
      None
  | Some a -&gt;
      Some (Field_annot a)

let opt_type_of_type_opt = function
  | None -&gt;
      None
  | Some a -&gt;
      Some (Type_annot a)

let classify_annot loc l :
    (var_annot option list * type_annot option list * field_annot option list)
    tzresult =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
    let (_, rv, _, rt, _, rf) =
      List.fold_left
        (fun (in_v, rv, in_t, rt, in_f, rf) a -&gt;
          match (a, in_v, rv, in_t, rt, in_f, rf) with
          | (Var_annot_opt a, true, _, _, _, _, _)
          | (Var_annot_opt a, false, [], _, _, _, _) -&gt;
              (true, opt_var_of_var_opt a :: rv, false, rt, false, rf)
          | (Type_annot_opt a, _, _, true, _, _, _)
          | (Type_annot_opt a, _, _, false, [], _, _) -&gt;
              (false, rv, true, opt_type_of_type_opt a :: rt, false, rf)
          | (Field_annot_opt a, _, _, _, _, true, _)
          | (Field_annot_opt a, _, _, _, _, false, []) -&gt;
              (false, rv, false, rt, true, opt_field_of_field_opt a :: rf)
          | _ -&gt;
              raise </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Values of extensible types are ignored.

They are sent to a unit type.">Exit</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">)
        (false, [], false, [], false, [])
        l
    in
    ok (List.rev rv, List.rev rt, List.rev rf)
  with Exit -&gt; error (Ungrouped_annotations loc)</abbr>

let get_one_annot loc = function
  | [] -&gt;
      ok None
  | [a] -&gt;
      ok a
  | _ -&gt;
      error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Unexpected_annotation loc)</abbr>

let get_two_annot loc = function
  | [] -&gt;
      ok (None, None)
  | [a] -&gt;
      ok (a, None)
  | [a; b] -&gt;
      ok (a, b)
  | _ -&gt;
      error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Unexpected_annotation loc)</abbr>

let parse_type_annot : int -&gt; string list -&gt; type_annot option tzresult =
 fun loc annot -&gt;
  parse_annots loc annot &gt;&gt;? classify_annot loc
  &gt;&gt;? fun (vars, types, fields) -&gt;
  error_unexpected_annot loc vars
  &gt;&gt;? fun () -&gt;
  error_unexpected_annot loc fields &gt;&gt;? fun () -&gt; get_one_annot loc types

let parse_type_field_annot :
    int -&gt; string list -&gt; (type_annot option * field_annot option) tzresult =
 fun loc annot -&gt;
  parse_annots loc annot &gt;&gt;? classify_annot loc
  &gt;&gt;? fun (vars, types, fields) -&gt;
  error_unexpected_annot loc vars
  &gt;&gt;? fun () -&gt;
  get_one_annot loc types
  &gt;&gt;? fun t -&gt; get_one_annot loc fields &gt;|? fun f -&gt; (t, f)

let parse_composed_type_annot :
    int -&gt;
    string list -&gt;
    (type_annot option * field_annot option * field_annot option) tzresult =
 fun loc annot -&gt;
  parse_annots loc annot &gt;&gt;? classify_annot loc
  &gt;&gt;? fun (vars, types, fields) -&gt;
  error_unexpected_annot loc vars
  &gt;&gt;? fun () -&gt;
  get_one_annot loc types
  &gt;&gt;? fun t -&gt; get_two_annot loc fields &gt;|? fun (f1, f2) -&gt; (t, f1, f2)

let parse_field_annot : int -&gt; string list -&gt; field_annot option tzresult =
 fun loc annot -&gt;
  parse_annots loc annot &gt;&gt;? classify_annot loc
  &gt;&gt;? fun (vars, types, fields) -&gt;
  error_unexpected_annot loc vars
  &gt;&gt;? fun () -&gt;
  error_unexpected_annot loc types &gt;&gt;? fun () -&gt; get_one_annot loc fields

let extract_field_annot :
    Script.node -&gt; (Script.node * field_annot option) tzresult = function
  | Prim (loc, prim, args, annot) -&gt;
      let rec extract_first acc = function
        | [] -&gt;
            (None, annot)
        | s :: rest -&gt;
            if Compare.Int.(String.length s &gt; 0) &amp;&amp; Compare.Char.(s.[0] = '%')
            then (Some s, List.rev_append acc rest)
            else extract_first (s :: acc) rest
      in
      let (field_annot, annot) = extract_first [] annot in
      let field_annot =
        match field_annot with
        | None -&gt;
            None
        | Some field_annot -&gt;
            Some
              (Field_annot
                 (String.sub field_annot 1 (String.length field_annot - 1)))
      in
      ok (Prim (loc, prim, args, annot), field_annot)
  | expr -&gt;
      ok (expr, None)

let check_correct_field :
    field_annot option -&gt; field_annot option -&gt; unit tzresult =
 fun f1 f2 -&gt;
  match (f1, f2) with
  | (None, _) | (_, None) -&gt;
      ok ()
  | (Some (Field_annot s1), Some (Field_annot s2)) -&gt;
      if String.equal s1 s2 then ok ()
      else error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Inconsistent_field_annotations (&quot;%&quot; ^ s1, &quot;%&quot; ^ s2))</abbr>

let parse_var_annot :
    int -&gt;
    ?default:var_annot option -&gt;
    string list -&gt;
    var_annot option tzresult =
 fun loc ?default annot -&gt;
  parse_annots loc annot &gt;&gt;? classify_annot loc
  &gt;&gt;? fun (vars, types, fields) -&gt;
  error_unexpected_annot loc types
  &gt;&gt;? fun () -&gt;
  error_unexpected_annot loc fields
  &gt;&gt;? fun () -&gt;
  get_one_annot loc vars
  &gt;|? function
  | Some _ as a -&gt;
      a
  | None -&gt; (
    match default with Some a -&gt; a | None -&gt; None )

let split_last_dot = function
  | None -&gt;
      (None, None)
  | Some (Field_annot s) -&gt; (
    match String.rindex_opt s '.' with
    | None -&gt;
        (None, Some (Field_annot s))
    | Some i -&gt;
        let s1 = String.sub s 0 i in
        let s2 = String.sub s (i + 1) (String.length s - i - 1) in
        let f =
          if Compare.String.equal s2 &quot;car&quot; || Compare.String.equal s2 &quot;cdr&quot;
          then None
          else Some (Field_annot s2)
        in
        (Some (Var_annot s1), f) )

let common_prefix v1 v2 =
  match (v1, v2) with
  | (Some (Var_annot s1), Some (Var_annot s2)) when Compare.String.equal s1 s2
    -&gt;
      v1
  | (Some _, None) -&gt;
      v1
  | (None, Some _) -&gt;
      v2
  | (_, _) -&gt;
      None

let parse_constr_annot :
    int -&gt;
    ?if_special_first:field_annot option -&gt;
    ?if_special_second:field_annot option -&gt;
    string list -&gt;
    ( var_annot option
    * type_annot option
    * field_annot option
    * field_annot option )
    tzresult =
 fun loc ?if_special_first ?if_special_second annot -&gt;
  parse_annots ~allow_special_field:true loc annot
  &gt;&gt;? classify_annot loc
  &gt;&gt;? fun (vars, types, fields) -&gt;
  get_one_annot loc vars
  &gt;&gt;? fun v -&gt;
  get_one_annot loc types
  &gt;&gt;? fun t -&gt;
  get_two_annot loc fields
  &gt;&gt;? fun (f1, f2) -&gt;
  ( match (if_special_first, f1) with
  | (Some special_var, Some (Field_annot &quot;@&quot;)) -&gt;
      ok (split_last_dot special_var)
  | (None, Some (Field_annot &quot;@&quot;)) -&gt;
      error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Unexpected_annotation loc)</abbr>
  | (_, _) -&gt;
      ok (v, f1) )
  &gt;&gt;? fun (v1, f1) -&gt;
  ( match (if_special_second, f2) with
  | (Some special_var, Some (Field_annot &quot;@&quot;)) -&gt;
      ok (split_last_dot special_var)
  | (None, Some (Field_annot &quot;@&quot;)) -&gt;
      error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Unexpected_annotation loc)</abbr>
  | (_, _) -&gt;
      ok (v, f2) )
  &gt;|? fun (v2, f2) -&gt;
  let v = match v with None -&gt; common_prefix v1 v2 | Some _ -&gt; v in
  (v, t, f1, f2)

let parse_two_var_annot :
    int -&gt; string list -&gt; (var_annot option * var_annot option) tzresult =
 fun loc annot -&gt;
  parse_annots loc annot &gt;&gt;? classify_annot loc
  &gt;&gt;? fun (vars, types, fields) -&gt;
  error_unexpected_annot loc types
  &gt;&gt;? fun () -&gt;
  error_unexpected_annot loc fields &gt;&gt;? fun () -&gt; get_two_annot loc vars

let parse_destr_annot :
    int -&gt;
    string list -&gt;
    default_accessor:field_annot option -&gt;
    field_name:field_annot option -&gt;
    pair_annot:var_annot option -&gt;
    value_annot:var_annot option -&gt;
    (var_annot option * field_annot option) tzresult =
 fun loc annot ~default_accessor ~field_name ~pair_annot ~value_annot -&gt;
  parse_annots loc ~allow_special_var:true annot
  &gt;&gt;? classify_annot loc
  &gt;&gt;? fun (vars, types, fields) -&gt;
  error_unexpected_annot loc types
  &gt;&gt;? fun () -&gt;
  get_one_annot loc vars
  &gt;&gt;? fun v -&gt;
  get_one_annot loc fields
  &gt;|? fun f -&gt;
  let default =
    gen_access_annot pair_annot field_name ~default:default_accessor
  in
  let v =
    match v with
    | Some (Var_annot &quot;%&quot;) -&gt;
        field_to_var_annot field_name
    | Some (Var_annot &quot;%%&quot;) -&gt;
        default
    | Some _ -&gt;
        v
    | None -&gt;
        value_annot
  in
  (v, f)

let parse_entrypoint_annot :
    int -&gt;
    ?default:var_annot option -&gt;
    string list -&gt;
    (var_annot option * field_annot option) tzresult =
 fun loc ?default annot -&gt;
  parse_annots loc annot &gt;&gt;? classify_annot loc
  &gt;&gt;? fun (vars, types, fields) -&gt;
  error_unexpected_annot loc types
  &gt;&gt;? fun () -&gt;
  get_one_annot loc fields
  &gt;&gt;? fun f -&gt;
  get_one_annot loc vars
  &gt;|? function
  | Some _ as a -&gt;
      (a, f)
  | None -&gt; (
    match default with Some a -&gt; (a, f) | None -&gt; (None, f) )

let parse_var_type_annot :
    int -&gt; string list -&gt; (var_annot option * type_annot option) tzresult =
 fun loc annot -&gt;
  parse_annots loc annot &gt;&gt;? classify_annot loc
  &gt;&gt;? fun (vars, types, fields) -&gt;
  error_unexpected_annot loc fields
  &gt;&gt;? fun () -&gt;
  get_one_annot loc vars
  &gt;&gt;? fun v -&gt; get_one_annot loc types &gt;|? fun t -&gt; (v, t)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_ir_annot.ml"><code>Script_ir_annot.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Script_tc_errors.
Require Tezos.Script_typed_ir.

Import Alpha_context.

Import Micheline.

Import Script_tc_errors.

Import Script_typed_ir.

Definition default_now_annot : option Script_typed_ir.var_annot :=
  Some (Script_typed_ir.Var_annot &quot;now&quot;).

Definition default_amount_annot : option Script_typed_ir.var_annot :=
  Some (Script_typed_ir.Var_annot &quot;amount&quot;).

Definition default_balance_annot : option Script_typed_ir.var_annot :=
  Some (Script_typed_ir.Var_annot &quot;balance&quot;).

Definition default_steps_annot : option Script_typed_ir.var_annot :=
  Some (Script_typed_ir.Var_annot &quot;steps&quot;).

Definition default_source_annot : option Script_typed_ir.var_annot :=
  Some (Script_typed_ir.Var_annot &quot;source&quot;).

Definition default_sender_annot : option Script_typed_ir.var_annot :=
  Some (Script_typed_ir.Var_annot &quot;sender&quot;).

Definition default_self_annot : option Script_typed_ir.var_annot :=
  Some (Script_typed_ir.Var_annot &quot;self&quot;).

Definition default_arg_annot : option Script_typed_ir.var_annot :=
  Some (Script_typed_ir.Var_annot &quot;arg&quot;).

Definition default_param_annot : option Script_typed_ir.var_annot :=
  Some (Script_typed_ir.Var_annot &quot;parameter&quot;).

Definition default_storage_annot : option Script_typed_ir.var_annot :=
  Some (Script_typed_ir.Var_annot &quot;storage&quot;).

Definition default_car_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot &quot;car&quot;).

Definition default_cdr_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot &quot;cdr&quot;).

Definition default_contract_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot &quot;contract&quot;).

Definition default_addr_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot &quot;address&quot;).

Definition default_manager_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot &quot;manager&quot;).

Definition default_pack_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot &quot;packed&quot;).

Definition default_unpack_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot &quot;unpacked&quot;).

Definition default_slice_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot &quot;slice&quot;).

Definition default_elt_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot &quot;elt&quot;).

Definition default_key_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot &quot;key&quot;).

Definition default_hd_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot &quot;hd&quot;).

Definition default_tl_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot &quot;tl&quot;).

Definition default_some_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot &quot;some&quot;).

Definition default_left_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot &quot;left&quot;).

Definition default_right_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot &quot;right&quot;).

Definition default_binding_annot : option Script_typed_ir.field_annot :=
  Some (Script_typed_ir.Field_annot &quot;bnd&quot;).

Definition unparse_type_annot
  (function_parameter : option Script_typed_ir.type_annot) : list string :=
  match function_parameter with
  | None =&gt; nil
  | Some (Script_typed_ir.Type_annot __a_value) =&gt;
    [ Pervasives.op_caret &quot;:&quot; __a_value ]
  end.

Definition unparse_var_annot
  (function_parameter : option Script_typed_ir.var_annot) : list string :=
  match function_parameter with
  | None =&gt; nil
  | Some (Script_typed_ir.Var_annot __a_value) =&gt;
    [ Pervasives.op_caret &quot;@&quot; __a_value ]
  end.

Definition unparse_field_annot
  (function_parameter : option Script_typed_ir.field_annot) : list string :=
  match function_parameter with
  | None =&gt; nil
  | Some (Script_typed_ir.Field_annot __a_value) =&gt;
    [ Pervasives.op_caret &quot;%&quot; __a_value ]
  end.

Definition field_to_var_annot
  (function_parameter : option Script_typed_ir.field_annot)
  : option Script_typed_ir.var_annot :=
  match function_parameter with
  | None =&gt; None
  | Some (Script_typed_ir.Field_annot s) =&gt; Some (Script_typed_ir.Var_annot s)
  end.

Definition type_to_var_annot
  (function_parameter : option Script_typed_ir.type_annot)
  : option Script_typed_ir.var_annot :=
  match function_parameter with
  | None =&gt; None
  | Some (Script_typed_ir.Type_annot s) =&gt; Some (Script_typed_ir.Var_annot s)
  end.

Definition var_to_field_annot
  (function_parameter : option Script_typed_ir.var_annot)
  : option Script_typed_ir.field_annot :=
  match function_parameter with
  | None =&gt; None
  | Some (Script_typed_ir.Var_annot s) =&gt; Some (Script_typed_ir.Field_annot s)
  end.

Definition default_annot {A : Set}
  (default : option A) (function_parameter : option A) : option A :=
  match function_parameter with
  | None =&gt; default
  | annot =&gt; annot
  end.

Definition gen_access_annot
  (value_annot : option Script_typed_ir.var_annot)
  (op_staroptstar : option (option Script_typed_ir.field_annot))
  : option Script_typed_ir.field_annot -&gt; option Script_typed_ir.var_annot :=
  let default :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; None
    end in
  fun field_annot =&gt;
    match (value_annot, field_annot, default) with
    |
      ((None, None, _) | (Some _, None, None) |
      (None, Some (Script_typed_ir.Field_annot &quot;&quot;), _)) =&gt; None
    | (None, Some (Script_typed_ir.Field_annot f), _) =&gt;
      Some (Script_typed_ir.Var_annot f)
    |
      (Some (Script_typed_ir.Var_annot v),
        (None | Some (Script_typed_ir.Field_annot &quot;&quot;)),
        Some (Script_typed_ir.Field_annot f)) =&gt;
      Some (Script_typed_ir.Var_annot (String.concat &quot;.&quot; [ v; f ]))
    |
      (Some (Script_typed_ir.Var_annot v), Some (Script_typed_ir.Field_annot f),
        _) =&gt; Some (Script_typed_ir.Var_annot (String.concat &quot;.&quot; [ v; f ]))
    end.

Definition merge_type_annot
  (legacy : bool) (annot1 : option Script_typed_ir.type_annot)
  (annot2 : option Script_typed_ir.type_annot)
  : Error_monad.tzresult (option Script_typed_ir.type_annot) :=
  match (annot1, annot2) with
  | ((None, None) | (Some _, None) | (None, Some _)) =&gt; Error_monad.ok None
  | (Some (Script_typed_ir.Type_annot a1), Some (Script_typed_ir.Type_annot a2))
    =&gt;
    if Pervasives.op_pipepipe legacy (String.equal a1 a2) then
      Error_monad.ok annot1
    else
      Error_monad.__error_value extensible_type_value
  end.

Definition merge_field_annot
  (legacy : bool) (annot1 : option Script_typed_ir.field_annot)
  (annot2 : option Script_typed_ir.field_annot)
  : Error_monad.tzresult (option Script_typed_ir.field_annot) :=
  match (annot1, annot2) with
  | ((None, None) | (Some _, None) | (None, Some _)) =&gt; Error_monad.ok None
  |
    (Some (Script_typed_ir.Field_annot a1),
      Some (Script_typed_ir.Field_annot a2)) =&gt;
    if Pervasives.op_pipepipe legacy (String.equal a1 a2) then
      Error_monad.ok annot1
    else
      Error_monad.__error_value extensible_type_value
  end.

Definition merge_var_annot
  (annot1 : option Script_typed_ir.var_annot)
  (annot2 : option Script_typed_ir.var_annot)
  : option Script_typed_ir.var_annot :=
  match (annot1, annot2) with
  | ((None, None) | (Some _, None) | (None, Some _)) =&gt; None
  | (Some (Script_typed_ir.Var_annot a1), Some (Script_typed_ir.Var_annot a2))
    =&gt;
    if String.equal a1 a2 then
      annot1
    else
      None
  end.

Definition error_unexpected_annot {A : Set}
  (loc : Alpha_context.Script.location) (annot : list A)
  : Error_monad.tzresult unit :=
  match annot with
  | [] =&gt; Error_monad.ok tt
  | cons _ _ =&gt; Error_monad.__error_value extensible_type_value
  end.

Definition fail_unexpected_annot {A : Set}
  (loc : Alpha_context.Script.location) (annot : list A)
  : Lwt.t (Error_monad.tzresult unit) :=
  Lwt.__return (error_unexpected_annot loc annot).

Inductive annot_opt : Set :=
| Field_annot_opt : option string -&gt; annot_opt
| Type_annot_opt : option string -&gt; annot_opt
| Var_annot_opt : option string -&gt; annot_opt.

Definition parse_annots
  (loc : Alpha_context.Script.location) (op_staroptstar : option bool)
  : option bool -&gt; list string -&gt; Error_monad.tzresult (list annot_opt) :=
  let allow_special_var :=
    match op_staroptstar with
    | Some op_starsthstar =&gt; op_starsthstar
    | None =&gt; false
    end in
  fun op_staroptstar =&gt;
    let allow_special_field :=
      match op_staroptstar with
      | Some op_starsthstar =&gt; op_starsthstar
      | None =&gt; false
      end in
    fun l =&gt;
      let sub_or_wildcard {A : Set}
        (specials : list ascii) (wrap : option string -&gt; A) (s : string)
        (acc : list A) : Error_monad.tzresult (list A) :=
        let len := String.length s in
        if (|Compare.Int|).(Compare.S.op_eq) len 1 then
          Error_monad.ok (cons (wrap None) acc)
        else
          match
            ((String.get s 1),
              match String.get s 1 with
              | &quot;@&quot; % char =&gt;
                Pervasives.op_andand ((|Compare.Int|).(Compare.S.op_eq) len 2)
                  (List.mem &quot;@&quot; % char specials)
              | _ =&gt; false
              end,
              match String.get s 1 with
              | &quot;%&quot; % char =&gt; List.mem &quot;%&quot; % char specials
              | _ =&gt; false
              end) with
          |
            ((&quot;a&quot; % char | &quot;b&quot; % char | &quot;c&quot; % char | &quot;d&quot; % char | &quot;e&quot; % char |
            &quot;f&quot; % char | &quot;g&quot; % char | &quot;h&quot; % char | &quot;i&quot; % char | &quot;j&quot; % char |
            &quot;k&quot; % char | &quot;l&quot; % char | &quot;m&quot; % char | &quot;n&quot; % char | &quot;o&quot; % char |
            &quot;p&quot; % char | &quot;q&quot; % char | &quot;r&quot; % char | &quot;s&quot; % char | &quot;t&quot; % char |
            &quot;u&quot; % char | &quot;v&quot; % char | &quot;w&quot; % char | &quot;x&quot; % char | &quot;y&quot; % char |
            &quot;z&quot; % char | &quot;A&quot; % char | &quot;B&quot; % char | &quot;C&quot; % char | &quot;D&quot; % char |
            &quot;E&quot; % char | &quot;F&quot; % char | &quot;G&quot; % char | &quot;H&quot; % char | &quot;I&quot; % char |
            &quot;J&quot; % char | &quot;K&quot; % char | &quot;L&quot; % char | &quot;M&quot; % char | &quot;N&quot; % char |
            &quot;O&quot; % char | &quot;P&quot; % char | &quot;Q&quot; % char | &quot;R&quot; % char | &quot;S&quot; % char |
            &quot;T&quot; % char | &quot;U&quot; % char | &quot;V&quot; % char | &quot;W&quot; % char | &quot;X&quot; % char |
            &quot;Y&quot; % char | &quot;Z&quot; % char | &quot;_&quot; % char), _, _) =&gt;
            Error_monad.ok
              (cons (wrap (Some (String.sub s 1 (Pervasives.op_minus len 1))))
                acc)
          | (&quot;@&quot; % char, true, _) =&gt; Error_monad.ok (cons (wrap (Some &quot;@&quot;)) acc)
          | (&quot;%&quot; % char, _, true) =&gt;
            if (|Compare.Int|).(Compare.S.op_eq) len 2 then
              Error_monad.ok (cons (wrap (Some &quot;%&quot;)) acc)
            else
              if
                Pervasives.op_andand ((|Compare.Int|).(Compare.S.op_eq) len 3)
                  ((|Compare.Char|).(Compare.S.op_eq) (String.get s 2)
                    &quot;%&quot; % char) then
                Error_monad.ok (cons (wrap (Some &quot;%%&quot;)) acc)
              else
                Error_monad.__error_value extensible_type_value
          | (_, _, _) =&gt; Error_monad.__error_value extensible_type_value
          end in
      Error_monad.op_gtpipequestion
        (List.fold_left
          (fun acc =&gt;
            fun s =&gt;
              let? acc := acc in
              if (|Compare.Int|).(Compare.S.op_eq) (String.length s) 0 then
                Error_monad.__error_value extensible_type_value
              else
                match String.get s 0 with
                | &quot;:&quot; % char =&gt;
                  sub_or_wildcard nil
                    (fun __a_value =&gt; Type_annot_opt __a_value) s acc
                | &quot;@&quot; % char =&gt;
                  sub_or_wildcard
                    (if allow_special_var then
                      [ &quot;%&quot; % char ]
                    else
                      nil) (fun __a_value =&gt; Var_annot_opt __a_value) s acc
                | &quot;%&quot; % char =&gt;
                  sub_or_wildcard
                    (if allow_special_field then
                      [ &quot;@&quot; % char ]
                    else
                      nil) (fun __a_value =&gt; Field_annot_opt __a_value) s acc
                | _ =&gt; Error_monad.__error_value extensible_type_value
                end) (Error_monad.ok nil) l) List.rev.

Definition opt_var_of_var_opt (function_parameter : option string)
  : option Script_typed_ir.var_annot :=
  match function_parameter with
  | None =&gt; None
  | Some __a_value =&gt; Some (Script_typed_ir.Var_annot __a_value)
  end.

Definition opt_field_of_field_opt (function_parameter : option string)
  : option Script_typed_ir.field_annot :=
  match function_parameter with
  | None =&gt; None
  | Some __a_value =&gt; Some (Script_typed_ir.Field_annot __a_value)
  end.

Definition opt_type_of_type_opt (function_parameter : option string)
  : option Script_typed_ir.type_annot :=
  match function_parameter with
  | None =&gt; None
  | Some __a_value =&gt; Some (Script_typed_ir.Type_annot __a_value)
  end.

Definition classify_annot
  (loc : Alpha_context.Script.location) (l : list annot_opt)
  : Error_monad.tzresult
    (list (option Script_typed_ir.var_annot) *
      list (option Script_typed_ir.type_annot) *
      list (option Script_typed_ir.field_annot)) :=
  (* ‚ùå Try-with are not handled *)
  try
    (let '(_, rv, _, rt, _, rf) :=
      List.fold_left
        (fun function_parameter =&gt;
          let '(in_v, rv, in_t, rt, in_f, rf) := function_parameter in
          fun __a_value =&gt;
            match (__a_value, in_v, rv, in_t, rt, in_f, rf) with
            |
              ((Var_annot_opt __a_value, true, _, _, _, _, _) |
              (Var_annot_opt __a_value, false, [], _, _, _, _)) =&gt;
              (true, (cons (opt_var_of_var_opt __a_value) rv), false, rt, false,
                rf)
            |
              ((Type_annot_opt __a_value, _, _, true, _, _, _) |
              (Type_annot_opt __a_value, _, _, false, [], _, _)) =&gt;
              (false, rv, true, (cons (opt_type_of_type_opt __a_value) rt),
                false, rf)
            |
              ((Field_annot_opt __a_value, _, _, _, _, true, _) |
              (Field_annot_opt __a_value, _, _, _, _, false, [])) =&gt;
              (false, rv, false, rt, true,
                (cons (opt_field_of_field_opt __a_value) rf))
            | _ =&gt; Pervasives.raise extensible_type_value
            end) (false, nil, false, nil, false, nil) l in
    Error_monad.ok ((List.rev rv), (List.rev rt), (List.rev rf))).

Definition get_one_annot {A : Set}
  (loc : Alpha_context.Script.location) (function_parameter : list (option A))
  : Error_monad.tzresult (option A) :=
  match function_parameter with
  | [] =&gt; Error_monad.ok None
  | cons __a_value [] =&gt; Error_monad.ok __a_value
  | _ =&gt; Error_monad.__error_value extensible_type_value
  end.

Definition get_two_annot {A : Set}
  (loc : Alpha_context.Script.location) (function_parameter : list (option A))
  : Error_monad.tzresult (option A * option A) :=
  match function_parameter with
  | [] =&gt; Error_monad.ok (None, None)
  | cons __a_value [] =&gt; Error_monad.ok (__a_value, None)
  | cons __a_value (cons __b_value []) =&gt; Error_monad.ok (__a_value, __b_value)
  | _ =&gt; Error_monad.__error_value extensible_type_value
  end.

Definition parse_type_annot (loc : int) (annot : list string)
  : Error_monad.tzresult (option Script_typed_ir.type_annot) :=
  let? '(vars, types, fields) :=
    Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc) in
  let? '_ := error_unexpected_annot loc vars in
  let? '_ := error_unexpected_annot loc fields in
  get_one_annot loc types.

Definition parse_type_field_annot (loc : int) (annot : list string)
  : Error_monad.tzresult
    (option Script_typed_ir.type_annot * option Script_typed_ir.field_annot) :=
  let? '(vars, types, fields) :=
    Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc) in
  let? '_ := error_unexpected_annot loc vars in
  let? __t_value := get_one_annot loc types in
  Error_monad.op_gtpipequestion (get_one_annot loc fields)
    (fun f =&gt; (__t_value, f)).

Definition parse_composed_type_annot (loc : int) (annot : list string)
  : Error_monad.tzresult
    (option Script_typed_ir.type_annot * option Script_typed_ir.field_annot *
      option Script_typed_ir.field_annot) :=
  let? '(vars, types, fields) :=
    Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc) in
  let? '_ := error_unexpected_annot loc vars in
  let? __t_value := get_one_annot loc types in
  Error_monad.op_gtpipequestion (get_two_annot loc fields)
    (fun function_parameter =&gt;
      let '(f1, f2) := function_parameter in
      (__t_value, f1, f2)).

Definition parse_field_annot (loc : int) (annot : list string)
  : Error_monad.tzresult (option Script_typed_ir.field_annot) :=
  let? '(vars, types, fields) :=
    Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc) in
  let? '_ := error_unexpected_annot loc vars in
  let? '_ := error_unexpected_annot loc types in
  get_one_annot loc fields.

Definition extract_field_annot (function_parameter : Alpha_context.Script.node)
  : Error_monad.tzresult
    (Alpha_context.Script.node * option Script_typed_ir.field_annot) :=
  match function_parameter with
  | Micheline.Prim loc prim args annot =&gt;
    let fix extract_first (acc : list string) (function_parameter : list string)
      : option string * Micheline.annot :=
      match function_parameter with
      | [] =&gt; (None, annot)
      | cons s rest =&gt;
        if
          Pervasives.op_andand
            ((|Compare.Int|).(Compare.S.op_gt) (String.length s) 0)
            ((|Compare.Char|).(Compare.S.op_eq) (String.get s 0) &quot;%&quot; % char)
          then
          ((Some s), (List.rev_append acc rest))
        else
          extract_first (cons s acc) rest
      end in
    let '(field_annot, annot) := extract_first nil annot in
    let field_annot :=
      match field_annot with
      | None =&gt; None
      | Some field_annot =&gt;
        Some
          (Script_typed_ir.Field_annot
            (String.sub field_annot 1
              (Pervasives.op_minus (String.length field_annot) 1)))
      end in
    Error_monad.ok ((Micheline.Prim loc prim args annot), field_annot)
  | expr =&gt; Error_monad.ok (expr, None)
  end.

Definition check_correct_field
  (f1 : option Script_typed_ir.field_annot)
  (f2 : option Script_typed_ir.field_annot) : Error_monad.tzresult unit :=
  match (f1, f2) with
  | ((None, _) | (_, None)) =&gt; Error_monad.ok tt
  |
    (Some (Script_typed_ir.Field_annot s1),
      Some (Script_typed_ir.Field_annot s2)) =&gt;
    if String.equal s1 s2 then
      Error_monad.ok tt
    else
      Error_monad.__error_value extensible_type_value
  end.

Definition parse_var_annot
  (loc : int) (default : option (option Script_typed_ir.var_annot))
  (annot : list string)
  : Error_monad.tzresult (option Script_typed_ir.var_annot) :=
  let? '(vars, types, fields) :=
    Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc) in
  let? '_ := error_unexpected_annot loc types in
  let? '_ := error_unexpected_annot loc fields in
  Error_monad.op_gtpipequestion (get_one_annot loc vars)
    (fun function_parameter =&gt;
      match function_parameter with
      | (Some _) as __a_value =&gt; __a_value
      | None =&gt;
        match default with
        | Some __a_value =&gt; __a_value
        | None =&gt; None
        end
      end).

Definition split_last_dot
  (function_parameter : option Script_typed_ir.field_annot)
  : option Script_typed_ir.var_annot * option Script_typed_ir.field_annot :=
  match function_parameter with
  | None =&gt; (None, None)
  | Some (Script_typed_ir.Field_annot s) =&gt;
    match String.rindex_opt s &quot;.&quot; % char with
    | None =&gt; (None, (Some (Script_typed_ir.Field_annot s)))
    | Some i =&gt;
      let s1 := String.sub s 0 i in
      let s2 :=
        String.sub s (Pervasives.op_plus i 1)
          (Pervasives.op_minus (Pervasives.op_minus (String.length s) i) 1) in
      let f :=
        if
          Pervasives.op_pipepipe ((|Compare.String|).(Compare.S.equal) s2 &quot;car&quot;)
            ((|Compare.String|).(Compare.S.equal) s2 &quot;cdr&quot;) then
          None
        else
          Some (Script_typed_ir.Field_annot s2) in
      ((Some (Script_typed_ir.Var_annot s1)), f)
    end
  end.

Definition common_prefix
  (v1 : option Script_typed_ir.var_annot)
  (v2 : option Script_typed_ir.var_annot) : option Script_typed_ir.var_annot :=
  match
    ((v1, v2),
      match (v1, v2) with
      |
        (Some (Script_typed_ir.Var_annot s1),
          Some (Script_typed_ir.Var_annot s2)) =&gt;
        (|Compare.String|).(Compare.S.equal) s1 s2
      | _ =&gt; false
      end) with
  |
    ((Some (Script_typed_ir.Var_annot s1), Some (Script_typed_ir.Var_annot s2)),
      true) =&gt; v1
  | ((Some _, None), _) =&gt; v1
  | ((None, Some _), _) =&gt; v2
  | ((_, _), _) =&gt; None
  end.

Definition parse_constr_annot
  (loc : int) (if_special_first : option (option Script_typed_ir.field_annot))
  (if_special_second : option (option Script_typed_ir.field_annot))
  (annot : list string)
  : Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.type_annot *
      option Script_typed_ir.field_annot * option Script_typed_ir.field_annot) :=
  let? '(vars, types, fields) :=
    Error_monad.op_gtgtquestion (parse_annots loc None (Some true) annot)
      (classify_annot loc) in
  let? v := get_one_annot loc vars in
  let? __t_value := get_one_annot loc types in
  let? '(f1, f2) := get_two_annot loc fields in
  let? '(v1, f1) :=
    match (if_special_first, f1) with
    | (Some special_var, Some (Script_typed_ir.Field_annot &quot;@&quot;)) =&gt;
      Error_monad.ok (split_last_dot special_var)
    | (None, Some (Script_typed_ir.Field_annot &quot;@&quot;)) =&gt;
      Error_monad.__error_value extensible_type_value
    | (_, _) =&gt; Error_monad.ok (v, f1)
    end in
  Error_monad.op_gtpipequestion
    match (if_special_second, f2) with
    | (Some special_var, Some (Script_typed_ir.Field_annot &quot;@&quot;)) =&gt;
      Error_monad.ok (split_last_dot special_var)
    | (None, Some (Script_typed_ir.Field_annot &quot;@&quot;)) =&gt;
      Error_monad.__error_value extensible_type_value
    | (_, _) =&gt; Error_monad.ok (v, f2)
    end
    (fun function_parameter =&gt;
      let '(v2, f2) := function_parameter in
      let v :=
        match v with
        | None =&gt; common_prefix v1 v2
        | Some _ =&gt; v
        end in
      (v, __t_value, f1, f2)).

Definition parse_two_var_annot (loc : int) (annot : list string)
  : Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.var_annot) :=
  let? '(vars, types, fields) :=
    Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc) in
  let? '_ := error_unexpected_annot loc types in
  let? '_ := error_unexpected_annot loc fields in
  get_two_annot loc vars.

Definition parse_destr_annot
  (loc : int) (annot : list string)
  (default_accessor : option Script_typed_ir.field_annot)
  (field_name : option Script_typed_ir.field_annot)
  (pair_annot : option Script_typed_ir.var_annot)
  (value_annot : option Script_typed_ir.var_annot)
  : Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.field_annot) :=
  let? '(vars, types, fields) :=
    Error_monad.op_gtgtquestion (parse_annots loc (Some true) None annot)
      (classify_annot loc) in
  let? '_ := error_unexpected_annot loc types in
  let? v := get_one_annot loc vars in
  Error_monad.op_gtpipequestion (get_one_annot loc fields)
    (fun f =&gt;
      let default :=
        gen_access_annot pair_annot (Some default_accessor) field_name in
      let v :=
        match v with
        | Some (Script_typed_ir.Var_annot &quot;%&quot;) =&gt; field_to_var_annot field_name
        | Some (Script_typed_ir.Var_annot &quot;%%&quot;) =&gt; default
        | Some _ =&gt; v
        | None =&gt; value_annot
        end in
      (v, f)).

Definition parse_entrypoint_annot
  (loc : int) (default : option (option Script_typed_ir.var_annot))
  (annot : list string)
  : Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.field_annot) :=
  let? '(vars, types, fields) :=
    Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc) in
  let? '_ := error_unexpected_annot loc types in
  let? f := get_one_annot loc fields in
  Error_monad.op_gtpipequestion (get_one_annot loc vars)
    (fun function_parameter =&gt;
      match function_parameter with
      | (Some _) as __a_value =&gt; (__a_value, f)
      | None =&gt;
        match default with
        | Some __a_value =&gt; (__a_value, f)
        | None =&gt; (None, f)
        end
      end).

Definition parse_var_type_annot (loc : int) (annot : list string)
  : Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.type_annot) :=
  let? '(vars, types, fields) :=
    Error_monad.op_gtgtquestion (parse_annots loc None None annot)
      (classify_annot loc) in
  let? '_ := error_unexpected_annot loc fields in
  let? v := get_one_annot loc vars in
  Error_monad.op_gtpipequestion (get_one_annot loc types)
    (fun __t_value =&gt; (v, __t_value)).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_ir_annot.mli">
  <div style="margin: 20px;">
    <h3>Script_ir_annot_mli</h3>
    <ul>
      <li>OCaml size: 198 lines</li>
      <li>Coq size: 172 lines (-14% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#script_ir_annot.mli"><code>script_ir_annot.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context
open Script_typed_ir

(** Default annotations *)

val default_now_annot : var_annot option

val default_amount_annot : var_annot option

val default_balance_annot : var_annot option

val default_steps_annot : var_annot option

val default_source_annot : var_annot option

val default_sender_annot : var_annot option

val default_self_annot : var_annot option

val default_arg_annot : var_annot option

val default_param_annot : var_annot option

val default_storage_annot : var_annot option

val default_car_annot : field_annot option

val default_cdr_annot : field_annot option

val default_contract_annot : field_annot option

val default_addr_annot : field_annot option

val default_manager_annot : field_annot option

val default_pack_annot : field_annot option

val default_unpack_annot : field_annot option

val default_slice_annot : field_annot option

val default_elt_annot : field_annot option

val default_key_annot : field_annot option

val default_hd_annot : field_annot option

val default_tl_annot : field_annot option

val default_some_annot : field_annot option

val default_left_annot : field_annot option

val default_right_annot : field_annot option

val default_binding_annot : field_annot option

(** Unparse annotations to their string representation *)

val unparse_type_annot : type_annot option -&gt; string list

val unparse_var_annot : var_annot option -&gt; string list

val unparse_field_annot : field_annot option -&gt; string list

(** Convertions functions between different annotation kinds *)

val field_to_var_annot : field_annot option -&gt; var_annot option

val type_to_var_annot : type_annot option -&gt; var_annot option

val var_to_field_annot : var_annot option -&gt; field_annot option

(** Replace an annotation by its default value if it is [None] *)
val default_annot : default:'a option -&gt; 'a option -&gt; 'a option

(** Generate annotation for field accesses, of the form [var.field1.field2] *)
val gen_access_annot :
  var_annot option -&gt;
  ?default:field_annot option -&gt;
  field_annot option -&gt;
  var_annot option

(** Merge type annotations.
    @return an error {!Inconsistent_type_annotations} if they are both present
    and different, unless [legacy] *)
val merge_type_annot :
  legacy:bool -&gt;
  type_annot option -&gt;
  type_annot option -&gt;
  type_annot option tzresult

(** Merge field annotations.
    @return an error {!Inconsistent_type_annotations} if they are both present
    and different, unless [legacy] *)
val merge_field_annot :
  legacy:bool -&gt;
  field_annot option -&gt;
  field_annot option -&gt;
  field_annot option tzresult

(** Merge variable annotations, does not fail ([None] if different). *)
val merge_var_annot : var_annot option -&gt; var_annot option -&gt; var_annot option

(** @return an error {!Unexpected_annotation} in the monad the list is not empty. *)
val error_unexpected_annot : int -&gt; 'a list -&gt; unit tzresult

(** Same as {!error_unexpected_annot} in Lwt. *)
val fail_unexpected_annot : int -&gt; 'a list -&gt; unit tzresult Lwt.t

(** Parse a type annotation only. *)
val parse_type_annot : int -&gt; string list -&gt; type_annot option tzresult

(** Parse a field annotation only. *)
val parse_field_annot : int -&gt; string list -&gt; field_annot option tzresult

(** Parse an annotation for composed types, of the form
    [:ty_name %field] in any order. *)
val parse_type_field_annot :
  int -&gt; string list -&gt; (type_annot option * field_annot option) tzresult

(** Parse an annotation for composed types, of the form
    [:ty_name %field1 %field2] in any order. *)
val parse_composed_type_annot :
  int -&gt;
  string list -&gt;
  (type_annot option * field_annot option * field_annot option) tzresult

(** Extract and remove a field annotation from a node *)
val extract_field_annot :
  Script.node -&gt; (Script.node * field_annot option) tzresult

(** Check that field annotations match, used for field accesses. *)
val check_correct_field :
  field_annot option -&gt; field_annot option -&gt; unit tzresult

(** Instruction annotations parsing *)

(** Parse a variable annotation, replaced by a default value if [None]. *)
val parse_var_annot :
  int -&gt; ?default:var_annot option -&gt; string list -&gt; var_annot option tzresult

val parse_constr_annot :
  int -&gt;
  ?if_special_first:field_annot option -&gt;
  ?if_special_second:field_annot option -&gt;
  string list -&gt;
  ( var_annot option
  * type_annot option
  * field_annot option
  * field_annot option )
  tzresult

val parse_two_var_annot :
  int -&gt; string list -&gt; (var_annot option * var_annot option) tzresult

val parse_destr_annot :
  int -&gt;
  string list -&gt;
  default_accessor:field_annot option -&gt;
  field_name:field_annot option -&gt;
  pair_annot:var_annot option -&gt;
  value_annot:var_annot option -&gt;
  (var_annot option * field_annot option) tzresult

val parse_entrypoint_annot :
  int -&gt;
  ?default:var_annot option -&gt;
  string list -&gt;
  (var_annot option * field_annot option) tzresult

val parse_var_type_annot :
  int -&gt; string list -&gt; (var_annot option * type_annot option) tzresult
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_ir_annot.mli"><code>Script_ir_annot_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Script_typed_ir.

Import Alpha_context.

Import Script_typed_ir.

Parameter default_now_annot : option Script_typed_ir.var_annot.

Parameter default_amount_annot : option Script_typed_ir.var_annot.

Parameter default_balance_annot : option Script_typed_ir.var_annot.

Parameter default_steps_annot : option Script_typed_ir.var_annot.

Parameter default_source_annot : option Script_typed_ir.var_annot.

Parameter default_sender_annot : option Script_typed_ir.var_annot.

Parameter default_self_annot : option Script_typed_ir.var_annot.

Parameter default_arg_annot : option Script_typed_ir.var_annot.

Parameter default_param_annot : option Script_typed_ir.var_annot.

Parameter default_storage_annot : option Script_typed_ir.var_annot.

Parameter default_car_annot : option Script_typed_ir.field_annot.

Parameter default_cdr_annot : option Script_typed_ir.field_annot.

Parameter default_contract_annot : option Script_typed_ir.field_annot.

Parameter default_addr_annot : option Script_typed_ir.field_annot.

Parameter default_manager_annot : option Script_typed_ir.field_annot.

Parameter default_pack_annot : option Script_typed_ir.field_annot.

Parameter default_unpack_annot : option Script_typed_ir.field_annot.

Parameter default_slice_annot : option Script_typed_ir.field_annot.

Parameter default_elt_annot : option Script_typed_ir.field_annot.

Parameter default_key_annot : option Script_typed_ir.field_annot.

Parameter default_hd_annot : option Script_typed_ir.field_annot.

Parameter default_tl_annot : option Script_typed_ir.field_annot.

Parameter default_some_annot : option Script_typed_ir.field_annot.

Parameter default_left_annot : option Script_typed_ir.field_annot.

Parameter default_right_annot : option Script_typed_ir.field_annot.

Parameter default_binding_annot : option Script_typed_ir.field_annot.

Parameter unparse_type_annot : option Script_typed_ir.type_annot -&gt; list string.

Parameter unparse_var_annot : option Script_typed_ir.var_annot -&gt; list string.

Parameter unparse_field_annot :
  option Script_typed_ir.field_annot -&gt; list string.

Parameter field_to_var_annot :
  option Script_typed_ir.field_annot -&gt; option Script_typed_ir.var_annot.

Parameter type_to_var_annot :
  option Script_typed_ir.type_annot -&gt; option Script_typed_ir.var_annot.

Parameter var_to_field_annot :
  option Script_typed_ir.var_annot -&gt; option Script_typed_ir.field_annot.

Parameter default_annot : forall {a : Set}, option a -&gt; option a -&gt; option a.

Parameter gen_access_annot :
  option Script_typed_ir.var_annot -&gt;
  option (option Script_typed_ir.field_annot) -&gt;
  option Script_typed_ir.field_annot -&gt; option Script_typed_ir.var_annot.

Parameter merge_type_annot :
  bool -&gt; option Script_typed_ir.type_annot -&gt;
  option Script_typed_ir.type_annot -&gt;
  Error_monad.tzresult (option Script_typed_ir.type_annot).

Parameter merge_field_annot :
  bool -&gt; option Script_typed_ir.field_annot -&gt;
  option Script_typed_ir.field_annot -&gt;
  Error_monad.tzresult (option Script_typed_ir.field_annot).

Parameter merge_var_annot :
  option Script_typed_ir.var_annot -&gt; option Script_typed_ir.var_annot -&gt;
  option Script_typed_ir.var_annot.

Parameter error_unexpected_annot : forall {a : Set},
  int -&gt; list a -&gt; Error_monad.tzresult unit.

Parameter fail_unexpected_annot : forall {a : Set},
  int -&gt; list a -&gt; Lwt.t (Error_monad.tzresult unit).

Parameter parse_type_annot :
  int -&gt; list string -&gt; Error_monad.tzresult (option Script_typed_ir.type_annot).

Parameter parse_field_annot :
  int -&gt; list string -&gt;
  Error_monad.tzresult (option Script_typed_ir.field_annot).

Parameter parse_type_field_annot :
  int -&gt; list string -&gt;
  Error_monad.tzresult
    (option Script_typed_ir.type_annot * option Script_typed_ir.field_annot).

Parameter parse_composed_type_annot :
  int -&gt; list string -&gt;
  Error_monad.tzresult
    (option Script_typed_ir.type_annot * option Script_typed_ir.field_annot *
      option Script_typed_ir.field_annot).

Parameter extract_field_annot :
  Alpha_context.Script.node -&gt;
  Error_monad.tzresult
    (Alpha_context.Script.node * option Script_typed_ir.field_annot).

Parameter check_correct_field :
  option Script_typed_ir.field_annot -&gt; option Script_typed_ir.field_annot -&gt;
  Error_monad.tzresult unit.

Parameter parse_var_annot :
  int -&gt; option (option Script_typed_ir.var_annot) -&gt; list string -&gt;
  Error_monad.tzresult (option Script_typed_ir.var_annot).

Parameter parse_constr_annot :
  int -&gt; option (option Script_typed_ir.field_annot) -&gt;
  option (option Script_typed_ir.field_annot) -&gt; list string -&gt;
  Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.type_annot *
      option Script_typed_ir.field_annot * option Script_typed_ir.field_annot).

Parameter parse_two_var_annot :
  int -&gt; list string -&gt;
  Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.var_annot).

Parameter parse_destr_annot :
  int -&gt; list string -&gt; option Script_typed_ir.field_annot -&gt;
  option Script_typed_ir.field_annot -&gt; option Script_typed_ir.var_annot -&gt;
  option Script_typed_ir.var_annot -&gt;
  Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.field_annot).

Parameter parse_entrypoint_annot :
  int -&gt; option (option Script_typed_ir.var_annot) -&gt; list string -&gt;
  Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.field_annot).

Parameter parse_var_type_annot :
  int -&gt; list string -&gt;
  Error_monad.tzresult
    (option Script_typed_ir.var_annot * option Script_typed_ir.type_annot).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_ir_translator.ml">
  <div style="margin: 20px;">
    <h3>Script_ir_translator</h3>
    <ul>
      <li>OCaml size: 6115 lines</li>
      <li>Coq size: 7063 lines (+15% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#script_ir_translator.ml"><code>script_ir_translator.ml</code></a>&nbsp;<span class="label label-warning">179 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context
open Micheline
open Script
open Script_typed_ir
open Script_tc_errors
open Script_ir_annot
module Typecheck_costs = Michelson_v1_gas.Cost_of.Typechecking
module Unparse_costs = Michelson_v1_gas.Cost_of.Unparse

type ex_comparable_ty =
  | Ex_comparable_ty : 'a comparable_ty -&gt; ex_comparable_ty

type ex_ty = Ex_ty : 'a ty -&gt; ex_ty

type ex_stack_ty = Ex_stack_ty : 'a stack_ty -&gt; ex_stack_ty

type tc_context =
  | Lambda : tc_context
  | Dip : 'a stack_ty * tc_context -&gt; tc_context
  | Toplevel : {
      storage_type : 'sto ty;
      param_type : 'param ty;
      root_name : string option;
      legacy_create_contract_literal : bool;
    }
      -&gt; tc_context

type unparsing_mode = Optimized | Readable

type type_logger =
  int -&gt;
  (Script.expr * Script.annot) list -&gt;
  (Script.expr * Script.annot) list -&gt;
  unit

let add_dip ty annot prev =
  match prev with
  | Lambda | Toplevel _ -&gt;
      Dip (Item_t (ty, Empty_t, annot), prev)
  | Dip (stack, _) -&gt;
      Dip (Item_t (ty, stack, annot), prev)

(* ---- Type size accounting ------------------------------------------------*)

let rec comparable_type_size : type t a. (t, a) comparable_struct -&gt; int =
 fun ty -&gt;
  (* No wildcard to force the update when comparable_ty chages. *)
  match ty with
  | Int_key _ -&gt;
      1
  | Nat_key _ -&gt;
      1
  | String_key _ -&gt;
      1
  | Bytes_key _ -&gt;
      1
  | Mutez_key _ -&gt;
      1
  | Bool_key _ -&gt;
      1
  | Key_hash_key _ -&gt;
      1
  | Timestamp_key _ -&gt;
      1
  | Address_key _ -&gt;
      1
  | Pair_key (_, (t, _), _) -&gt;
      1 + comparable_type_size t

let rec type_size : type t. t ty -&gt; int =
 fun ty -&gt;
  match ty with
  | Unit_t _ -&gt;
      1
  | Int_t _ -&gt;
      1
  | Nat_t _ -&gt;
      1
  | Signature_t _ -&gt;
      1
  | Bytes_t _ -&gt;
      1
  | String_t _ -&gt;
      1
  | Mutez_t _ -&gt;
      1
  | Key_hash_t _ -&gt;
      1
  | Key_t _ -&gt;
      1
  | Timestamp_t _ -&gt;
      1
  | Address_t _ -&gt;
      1
  | Bool_t _ -&gt;
      1
  | Operation_t _ -&gt;
      1
  | Pair_t ((l, _, _), (r, _, _), _, _) -&gt;
      1 + type_size l + type_size r
  | Union_t ((l, _), (r, _), _, _) -&gt;
      1 + type_size l + type_size r
  | Lambda_t (arg, ret, _) -&gt;
      1 + type_size arg + type_size ret
  | Option_t (t, _, _) -&gt;
      1 + type_size t
  | List_t (t, _, _) -&gt;
      1 + type_size t
  | Set_t (k, _) -&gt;
      1 + comparable_type_size k
  | Map_t (k, v, _, _) -&gt;
      1 + comparable_type_size k + type_size v
  | Big_map_t (k, v, _) -&gt;
      1 + comparable_type_size k + type_size v
  | Contract_t (arg, _) -&gt;
      1 + type_size arg
  | Chain_id_t _ -&gt;
      1

let rec type_size_of_stack_head : type st. st stack_ty -&gt; up_to:int -&gt; int =
 fun stack ~up_to -&gt;
  match stack with
  | Empty_t -&gt;
      0
  | Item_t (head, tail, _annot) -&gt;
      if Compare.Int.(up_to &gt; 0) then
        Compare.Int.max
          (type_size head)
          (type_size_of_stack_head tail ~up_to:(up_to - 1))
      else 0

(* This is the depth of the stack to inspect for sizes overflow. We
   only need to check the produced types that can be larger than the
   arguments. That's why Swap is 0 for instance as no type grows.
   Constant sized types are not checked: it is assumed they are lower
   than the bound (otherwise every program would be rejected). *)
let number_of_generated_growing_types : type b a. (b, a) instr -&gt; int =
  function
  | Drop -&gt;
      0
  | Dup -&gt;
      0
  | Swap -&gt;
      0
  | Const _ -&gt;
      1
  | Cons_pair -&gt;
      1
  | Car -&gt;
      0
  | Cdr -&gt;
      0
  | Cons_some -&gt;
      1
  | Cons_none _ -&gt;
      1
  | If_none _ -&gt;
      0
  | Left -&gt;
      0
  | Right -&gt;
      0
  | If_left _ -&gt;
      0
  | Cons_list -&gt;
      1
  | Nil -&gt;
      1
  | If_cons _ -&gt;
      0
  | List_map _ -&gt;
      1
  | List_size -&gt;
      0
  | List_iter _ -&gt;
      1
  | Empty_set _ -&gt;
      1
  | Set_iter _ -&gt;
      0
  | Set_mem -&gt;
      0
  | Set_update -&gt;
      0
  | Set_size -&gt;
      0
  | Empty_map _ -&gt;
      1
  | Map_map _ -&gt;
      1
  | Map_iter _ -&gt;
      1
  | Map_mem -&gt;
      0
  | Map_get -&gt;
      0
  | Map_update -&gt;
      0
  | Map_size -&gt;
      0
  | Empty_big_map _ -&gt;
      1
  | Big_map_get -&gt;
      0
  | Big_map_update -&gt;
      0
  | Big_map_mem -&gt;
      0
  | Concat_string -&gt;
      0
  | Concat_string_pair -&gt;
      0
  | Slice_string -&gt;
      0
  | String_size -&gt;
      0
  | Concat_bytes -&gt;
      0
  | Concat_bytes_pair -&gt;
      0
  | Slice_bytes -&gt;
      0
  | Bytes_size -&gt;
      0
  | Add_seconds_to_timestamp -&gt;
      0
  | Add_timestamp_to_seconds -&gt;
      0
  | Sub_timestamp_seconds -&gt;
      0
  | Diff_timestamps -&gt;
      0
  | Add_tez -&gt;
      0
  | Sub_tez -&gt;
      0
  | Mul_teznat -&gt;
      0
  | Mul_nattez -&gt;
      0
  | Ediv_teznat -&gt;
      0
  | Ediv_tez -&gt;
      0
  | Or -&gt;
      0
  | And -&gt;
      0
  | Xor -&gt;
      0
  | Not -&gt;
      0
  | Is_nat -&gt;
      0
  | Neg_nat -&gt;
      0
  | Neg_int -&gt;
      0
  | Abs_int -&gt;
      0
  | Int_nat -&gt;
      0
  | Add_intint -&gt;
      0
  | Add_intnat -&gt;
      0
  | Add_natint -&gt;
      0
  | Add_natnat -&gt;
      0
  | Sub_int -&gt;
      0
  | Mul_intint -&gt;
      0
  | Mul_intnat -&gt;
      0
  | Mul_natint -&gt;
      0
  | Mul_natnat -&gt;
      0
  | Ediv_intint -&gt;
      0
  | Ediv_intnat -&gt;
      0
  | Ediv_natint -&gt;
      0
  | Ediv_natnat -&gt;
      0
  | Lsl_nat -&gt;
      0
  | Lsr_nat -&gt;
      0
  | Or_nat -&gt;
      0
  | And_nat -&gt;
      0
  | And_int_nat -&gt;
      0
  | Xor_nat -&gt;
      0
  | Not_nat -&gt;
      0
  | Not_int -&gt;
      0
  | Seq _ -&gt;
      0
  | If _ -&gt;
      0
  | Loop _ -&gt;
      0
  | Loop_left _ -&gt;
      0
  | Dip _ -&gt;
      0
  | Exec -&gt;
      0
  | Apply _ -&gt;
      0
  | Lambda _ -&gt;
      1
  | Failwith _ -&gt;
      1
  | Nop -&gt;
      0
  | Compare _ -&gt;
      1
  | Eq -&gt;
      0
  | Neq -&gt;
      0
  | Lt -&gt;
      0
  | Gt -&gt;
      0
  | Le -&gt;
      0
  | Ge -&gt;
      0
  | Address -&gt;
      0
  | Contract _ -&gt;
      1
  | Transfer_tokens -&gt;
      1
  | Create_account -&gt;
      0
  | Implicit_account -&gt;
      0
  | Create_contract _ -&gt;
      1
  | Create_contract_2 _ -&gt;
      1
  | Now -&gt;
      0
  | Balance -&gt;
      0
  | Check_signature -&gt;
      0
  | Hash_key -&gt;
      0
  | Blake2b -&gt;
      0
  | Sha256 -&gt;
      0
  | Sha512 -&gt;
      0
  | Steps_to_quota -&gt;
      0
  | Source -&gt;
      0
  | Sender -&gt;
      0
  | Self _ -&gt;
      1
  | Amount -&gt;
      0
  | Set_delegate -&gt;
      0
  | Pack _ -&gt;
      0
  | Unpack _ -&gt;
      1
  | Dig _ -&gt;
      0
  | Dug _ -&gt;
      0
  | Dipn _ -&gt;
      0
  | Dropn _ -&gt;
      0
  | ChainId -&gt;
      0

(* ---- Error helpers -------------------------------------------------------*)

let location = function
  | Prim (loc, _, _, _)
  | Int (loc, _)
  | String (loc, _)
  | Bytes (loc, _)
  | Seq (loc, _) -&gt;
      loc

let kind = function
  | Int _ -&gt;
      Int_kind
  | String _ -&gt;
      String_kind
  | Bytes _ -&gt;
      Bytes_kind
  | Prim _ -&gt;
      Prim_kind
  | Seq _ -&gt;
      Seq_kind

let namespace = function
  | K_parameter | K_storage | K_code -&gt;
      Keyword_namespace
  | D_False
  | D_Elt
  | D_Left
  | D_None
  | D_Pair
  | D_Right
  | D_Some
  | D_True
  | D_Unit -&gt;
      Constant_namespace
  | I_PACK
  | I_UNPACK
  | I_BLAKE2B
  | I_SHA256
  | I_SHA512
  | I_ABS
  | I_ADD
  | I_AMOUNT
  | I_AND
  | I_BALANCE
  | I_CAR
  | I_CDR
  | I_CHAIN_ID
  | I_CHECK_SIGNATURE
  | I_COMPARE
  | I_CONCAT
  | I_CONS
  | I_CREATE_ACCOUNT
  | I_CREATE_CONTRACT
  | I_IMPLICIT_ACCOUNT
  | I_DIP
  | I_DROP
  | I_DUP
  | I_EDIV
  | I_EMPTY_BIG_MAP
  | I_EMPTY_MAP
  | I_EMPTY_SET
  | I_EQ
  | I_EXEC
  | I_APPLY
  | I_FAILWITH
  | I_GE
  | I_GET
  | I_GT
  | I_HASH_KEY
  | I_IF
  | I_IF_CONS
  | I_IF_LEFT
  | I_IF_NONE
  | I_INT
  | I_LAMBDA
  | I_LE
  | I_LEFT
  | I_LOOP
  | I_LSL
  | I_LSR
  | I_LT
  | I_MAP
  | I_MEM
  | I_MUL
  | I_NEG
  | I_NEQ
  | I_NIL
  | I_NONE
  | I_NOT
  | I_NOW
  | I_OR
  | I_PAIR
  | I_PUSH
  | I_RIGHT
  | I_SIZE
  | I_SOME
  | I_SOURCE
  | I_SENDER
  | I_SELF
  | I_SLICE
  | I_STEPS_TO_QUOTA
  | I_SUB
  | I_SWAP
  | I_TRANSFER_TOKENS
  | I_SET_DELEGATE
  | I_UNIT
  | I_UPDATE
  | I_XOR
  | I_ITER
  | I_LOOP_LEFT
  | I_ADDRESS
  | I_CONTRACT
  | I_ISNAT
  | I_CAST
  | I_RENAME
  | I_DIG
  | I_DUG -&gt;
      Instr_namespace
  | T_bool
  | T_contract
  | T_int
  | T_key
  | T_key_hash
  | T_lambda
  | T_list
  | T_map
  | T_big_map
  | T_nat
  | T_option
  | T_or
  | T_pair
  | T_set
  | T_signature
  | T_string
  | T_bytes
  | T_mutez
  | T_timestamp
  | T_unit
  | T_operation
  | T_address
  | T_chain_id -&gt;
      Type_namespace

let unexpected expr exp_kinds exp_ns exp_prims =
  match expr with
  | Int (loc, _) -&gt;
      <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_kind (loc, Prim_kind :: exp_kinds, Int_kind)</abbr>
  | String (loc, _) -&gt;
      <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_kind (loc, Prim_kind :: exp_kinds, String_kind)</abbr>
  | Bytes (loc, _) -&gt;
      <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_kind (loc, Prim_kind :: exp_kinds, Bytes_kind)</abbr>
  | Seq (loc, _) -&gt;
      <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_kind (loc, Prim_kind :: exp_kinds, Seq_kind)</abbr>
  | Prim (loc, name, _, _) -&gt; (
    match (namespace name, exp_ns) with
    | (Type_namespace, Type_namespace)
    | (Instr_namespace, Instr_namespace)
    | (Constant_namespace, Constant_namespace) -&gt;
        <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_primitive (loc, exp_prims, name)</abbr>
    | (ns, _) -&gt;
        <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_namespace (loc, name, exp_ns, ns)</abbr> )

let check_kind kinds expr =
  let kind = kind expr in
  if List.mem kind kinds then return_unit
  else
    let loc = location expr in
    fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_kind (loc, kinds, kind))</abbr>

(* ---- Sets and Maps -------------------------------------------------------*)

let wrap_compare compare a b =
  let res = compare a b in
  if Compare.Int.(res = 0) then 0 else if Compare.Int.(res &gt; 0) then 1 else -1

let rec compare_comparable :
    type a s. (a, s) comparable_struct -&gt; a -&gt; a -&gt; int =
 fun kind x y -&gt;
  match[@coq_match_gadt] (kind, x, y) with
  | (String_key _, (x : string), (y : string)) -&gt;
      wrap_compare Compare.String.compare x y
  | (Bool_key _, (x : bool), (y : bool)) -&gt;
      wrap_compare Compare.Bool.compare x y
  | (Mutez_key _, (x : Tez.t), (y : Tez.t)) -&gt;
      wrap_compare Tez.compare x y
  | (Key_hash_key _, (x : public_key_hash), (y : public_key_hash)) -&gt;
      wrap_compare Signature.Public_key_hash.compare x y
  | (Int_key _, (x : Script_int.num), (y : Script_int.num)) -&gt;
      wrap_compare Script_int.compare x y
  | (Nat_key _, (x : Script_int.num), (y : Script_int.num)) -&gt;
      wrap_compare Script_int.compare x y
  | (Timestamp_key _, (x : Script_timestamp.t), (y : Script_timestamp.t)) -&gt;
      wrap_compare Script_timestamp.compare x y
  | (Address_key _, (x : address), (y : address)) -&gt;
      ( wrap_compare
      @@ fun (x, ex) (y, ey) -&gt;
      let lres = Contract.compare x y in
      if Compare.Int.(lres = 0) then Compare.String.compare ex ey else lres )
        x
        y
  | (Bytes_key _, (x : MBytes.t), (y : MBytes.t)) -&gt;
      wrap_compare MBytes.compare x y
  | (Pair_key ((tl, _), (tr, _), _), (x : _ * _), (y : _ * _)) -&gt;
      (fun (lx, rx) (ly, ry) -&gt;
        let lres = compare_comparable tl lx ly in
        if Compare.Int.(lres = 0) then compare_comparable tr rx ry else lres)
        x
        y

let empty_set : type a. a comparable_ty -&gt; a set =
 fun ty -&gt;
  let module OPS = Set.Make (struct
    type t = a

    let compare x y = compare_comparable ty x y
  end) in
  ( module struct
    type elt = a

    let elt_ty = ty

    module OPS = OPS

    let boxed = OPS.empty

    let size = 0
  end )

let set_update : type a. a -&gt; bool -&gt; a set -&gt; a set =
 fun v b (module Box) -&gt;
  ( module struct
    type elt = a

    let elt_ty = Box.elt_ty

    module OPS = Box.OPS

    let boxed =
      if b then Box.OPS.add v Box.boxed else Box.OPS.remove v Box.boxed

    let size =
      let mem = Box.OPS.mem v Box.boxed in
      if mem then if b then Box.size else Box.size - 1
      else if b then Box.size + 1
      else Box.size
  end )

let set_mem : type elt. elt -&gt; elt set -&gt; bool =
 fun v (module Box) -&gt; Box.OPS.mem v Box.boxed

let set_fold : type elt acc. (elt -&gt; acc -&gt; acc) -&gt; elt set -&gt; acc -&gt; acc =
 fun f (module Box) -&gt; Box.OPS.fold f Box.boxed

let set_size : type elt. elt set -&gt; Script_int.num =
 fun (module Box) -&gt; Script_int.(abs (of_int Box.size))

let map_key_ty : type a b. (a, b) map -&gt; a comparable_ty =
 fun (module Box) -&gt; Box.key_ty

let empty_map : type a b. a comparable_ty -&gt; (a, b) map =
 fun ty -&gt;
  let module OPS = Map.Make (struct
    type t = a

    let compare x y = compare_comparable ty x y
  end) in
  ( module struct
    type key = a

    type value = b

    let key_ty = ty

    module OPS = OPS

    let boxed = (OPS.empty, 0)
  end )

let map_get : type key value. key -&gt; (key, value) map -&gt; value option =
 fun k (module Box) -&gt; Box.OPS.find_opt k (fst Box.boxed)

let map_update : type a b. a -&gt; b option -&gt; (a, b) map -&gt; (a, b) map =
 fun k v (module Box) -&gt;
  ( module struct
    type key = a

    type value = b

    let key_ty = Box.key_ty

    module OPS = Box.OPS

    let boxed =
      let (map, size) = Box.boxed in
      let contains = Box.OPS.mem k map in
      match v with
      | Some v -&gt;
          (Box.OPS.add k v map, size + if contains then 0 else 1)
      | None -&gt;
          (Box.OPS.remove k map, size - if contains then 1 else 0)
  end )

let map_set : type a b. a -&gt; b -&gt; (a, b) map -&gt; (a, b) map =
 fun k v (module Box) -&gt;
  ( module struct
    type key = a

    type value = b

    let key_ty = Box.key_ty

    module OPS = Box.OPS

    let boxed =
      let (map, size) = Box.boxed in
      (Box.OPS.add k v map, if Box.OPS.mem k map then size else size + 1)
  end )

let map_mem : type key value. key -&gt; (key, value) map -&gt; bool =
 fun k (module Box) -&gt; Box.OPS.mem k (fst Box.boxed)

let map_fold :
    type key value acc.
    (key -&gt; value -&gt; acc -&gt; acc) -&gt; (key, value) map -&gt; acc -&gt; acc =
 fun f (module Box) -&gt; Box.OPS.fold f (fst Box.boxed)

let map_size : type key value. (key, value) map -&gt; Script_int.num =
 fun (module Box) -&gt; Script_int.(abs (of_int (snd Box.boxed)))

(* ---- Unparsing (Typed IR -&gt; Untyped expressions) of types -----------------*)

let rec ty_of_comparable_ty : type a s. (a, s) comparable_struct -&gt; a ty =
  function
  | Int_key tname -&gt;
      Int_t tname
  | Nat_key tname -&gt;
      Nat_t tname
  | String_key tname -&gt;
      String_t tname
  | Bytes_key tname -&gt;
      Bytes_t tname
  | Mutez_key tname -&gt;
      Mutez_t tname
  | Bool_key tname -&gt;
      Bool_t tname
  | Key_hash_key tname -&gt;
      Key_hash_t tname
  | Timestamp_key tname -&gt;
      Timestamp_t tname
  | Address_key tname -&gt;
      Address_t tname
  | Pair_key ((l, al), (r, ar), tname) -&gt;
      Pair_t
        ( (ty_of_comparable_ty l, al, None),
          (ty_of_comparable_ty r, ar, None),
          tname,
          false )

let rec comparable_ty_of_ty : type a. a ty -&gt; a comparable_ty option = function
  | Int_t tname -&gt;
      Some (Int_key tname)
  | Nat_t tname -&gt;
      Some (Nat_key tname)
  | String_t tname -&gt;
      Some (String_key tname)
  | Bytes_t tname -&gt;
      Some (Bytes_key tname)
  | Mutez_t tname -&gt;
      Some (Mutez_key tname)
  | Bool_t tname -&gt;
      Some (Bool_key tname)
  | Key_hash_t tname -&gt;
      Some (Key_hash_key tname)
  | Timestamp_t tname -&gt;
      Some (Timestamp_key tname)
  | Address_t tname -&gt;
      Some (Address_key tname)
  | Pair_t ((l, al, _), (r, ar, _), pname, _) -&gt; (
    match comparable_ty_of_ty r with
    | None -&gt;
        None
    | Some rty -&gt; (
      match comparable_ty_of_ty l with
      | None -&gt;
          None
      | Some (Pair_key _) -&gt;
          None (* not a comb *)
      | Some (Int_key tname) -&gt;
          Some (Pair_key ((Int_key tname, al), (rty, ar), pname))
      | Some (Nat_key tname) -&gt;
          Some (Pair_key ((Nat_key tname, al), (rty, ar), pname))
      | Some (String_key tname) -&gt;
          Some (Pair_key ((String_key tname, al), (rty, ar), pname))
      | Some (Bytes_key tname) -&gt;
          Some (Pair_key ((Bytes_key tname, al), (rty, ar), pname))
      | Some (Mutez_key tname) -&gt;
          Some (Pair_key ((Mutez_key tname, al), (rty, ar), pname))
      | Some (Bool_key tname) -&gt;
          Some (Pair_key ((Bool_key tname, al), (rty, ar), pname))
      | Some (Key_hash_key tname) -&gt;
          Some (Pair_key ((Key_hash_key tname, al), (rty, ar), pname))
      | Some (Timestamp_key tname) -&gt;
          Some (Pair_key ((Timestamp_key tname, al), (rty, ar), pname))
      | Some (Address_key tname) -&gt;
          Some (Pair_key ((Address_key tname, al), (rty, ar), pname)) ) )
  | _ -&gt;
      None

let add_field_annot a var = function
  | Prim (loc, prim, args, annots) -&gt;
      Prim
        ( loc,
          prim,
          args,
          annots @ unparse_field_annot a @ unparse_var_annot var )
  | expr -&gt;
      expr

let rec unparse_comparable_ty :
    type a s. (a, s) comparable_struct -&gt; Script.node = function
  | Int_key tname -&gt;
      Prim (-1, T_int, [], unparse_type_annot tname)
  | Nat_key tname -&gt;
      Prim (-1, T_nat, [], unparse_type_annot tname)
  | String_key tname -&gt;
      Prim (-1, T_string, [], unparse_type_annot tname)
  | Bytes_key tname -&gt;
      Prim (-1, T_bytes, [], unparse_type_annot tname)
  | Mutez_key tname -&gt;
      Prim (-1, T_mutez, [], unparse_type_annot tname)
  | Bool_key tname -&gt;
      Prim (-1, T_bool, [], unparse_type_annot tname)
  | Key_hash_key tname -&gt;
      Prim (-1, T_key_hash, [], unparse_type_annot tname)
  | Timestamp_key tname -&gt;
      Prim (-1, T_timestamp, [], unparse_type_annot tname)
  | Address_key tname -&gt;
      Prim (-1, T_address, [], unparse_type_annot tname)
  | Pair_key ((l, al), (r, ar), pname) -&gt;
      let tl = add_field_annot al None (unparse_comparable_ty l) in
      let tr = add_field_annot ar None (unparse_comparable_ty r) in
      Prim (-1, T_pair, [tl; tr], unparse_type_annot pname)

let rec unparse_ty_no_lwt :
    type a. context -&gt; a ty -&gt; (Script.node * context) tzresult =
 fun ctxt ty -&gt;
  Gas.consume ctxt Unparse_costs.cycle
  &gt;&gt;? fun ctxt -&gt;
  let return ctxt (name, args, annot) =
    let result = Prim (-1, name, args, annot) in
    Gas.consume ctxt (Unparse_costs.prim_cost (List.length args) annot)
    &gt;&gt;? fun ctxt -&gt; ok (result, ctxt)
  in
  match ty with
  | Unit_t tname -&gt;
      return ctxt (T_unit, [], unparse_type_annot tname)
  | Int_t tname -&gt;
      return ctxt (T_int, [], unparse_type_annot tname)
  | Nat_t tname -&gt;
      return ctxt (T_nat, [], unparse_type_annot tname)
  | String_t tname -&gt;
      return ctxt (T_string, [], unparse_type_annot tname)
  | Bytes_t tname -&gt;
      return ctxt (T_bytes, [], unparse_type_annot tname)
  | Mutez_t tname -&gt;
      return ctxt (T_mutez, [], unparse_type_annot tname)
  | Bool_t tname -&gt;
      return ctxt (T_bool, [], unparse_type_annot tname)
  | Key_hash_t tname -&gt;
      return ctxt (T_key_hash, [], unparse_type_annot tname)
  | Key_t tname -&gt;
      return ctxt (T_key, [], unparse_type_annot tname)
  | Timestamp_t tname -&gt;
      return ctxt (T_timestamp, [], unparse_type_annot tname)
  | Address_t tname -&gt;
      return ctxt (T_address, [], unparse_type_annot tname)
  | Signature_t tname -&gt;
      return ctxt (T_signature, [], unparse_type_annot tname)
  | Operation_t tname -&gt;
      return ctxt (T_operation, [], unparse_type_annot tname)
  | Chain_id_t tname -&gt;
      return ctxt (T_chain_id, [], unparse_type_annot tname)
  | Contract_t (ut, tname) -&gt;
      unparse_ty_no_lwt ctxt ut
      &gt;&gt;? fun (t, ctxt) -&gt;
      return ctxt (T_contract, [t], unparse_type_annot tname)
  | Pair_t ((utl, l_field, l_var), (utr, r_field, r_var), tname, _) -&gt;
      let annot = unparse_type_annot tname in
      unparse_ty_no_lwt ctxt utl
      &gt;&gt;? fun (utl, ctxt) -&gt;
      let tl = add_field_annot l_field l_var utl in
      unparse_ty_no_lwt ctxt utr
      &gt;&gt;? fun (utr, ctxt) -&gt;
      let tr = add_field_annot r_field r_var utr in
      return ctxt (T_pair, [tl; tr], annot)
  | Union_t ((utl, l_field), (utr, r_field), tname, _) -&gt;
      let annot = unparse_type_annot tname in
      unparse_ty_no_lwt ctxt utl
      &gt;&gt;? fun (utl, ctxt) -&gt;
      let tl = add_field_annot l_field None utl in
      unparse_ty_no_lwt ctxt utr
      &gt;&gt;? fun (utr, ctxt) -&gt;
      let tr = add_field_annot r_field None utr in
      return ctxt (T_or, [tl; tr], annot)
  | Lambda_t (uta, utr, tname) -&gt;
      unparse_ty_no_lwt ctxt uta
      &gt;&gt;? fun (ta, ctxt) -&gt;
      unparse_ty_no_lwt ctxt utr
      &gt;&gt;? fun (tr, ctxt) -&gt;
      return ctxt (T_lambda, [ta; tr], unparse_type_annot tname)
  | Option_t (ut, tname, _) -&gt;
      let annot = unparse_type_annot tname in
      unparse_ty_no_lwt ctxt ut
      &gt;&gt;? fun (ut, ctxt) -&gt; return ctxt (T_option, [ut], annot)
  | List_t (ut, tname, _) -&gt;
      unparse_ty_no_lwt ctxt ut
      &gt;&gt;? fun (t, ctxt) -&gt; return ctxt (T_list, [t], unparse_type_annot tname)
  | Set_t (ut, tname) -&gt;
      let t = unparse_comparable_ty ut in
      return ctxt (T_set, [t], unparse_type_annot tname)
  | Map_t (uta, utr, tname, _) -&gt;
      let ta = unparse_comparable_ty uta in
      unparse_ty_no_lwt ctxt utr
      &gt;&gt;? fun (tr, ctxt) -&gt;
      return ctxt (T_map, [ta; tr], unparse_type_annot tname)
  | Big_map_t (uta, utr, tname) -&gt;
      let ta = unparse_comparable_ty uta in
      unparse_ty_no_lwt ctxt utr
      &gt;&gt;? fun (tr, ctxt) -&gt;
      return ctxt (T_big_map, [ta; tr], unparse_type_annot tname)

let unparse_ty ctxt ty = Lwt.return (unparse_ty_no_lwt ctxt ty)

let rec strip_var_annots = function
  | (Int _ | String _ | Bytes _) as atom -&gt;
      atom
  | Seq (loc, args) -&gt;
      Seq (loc, List.map strip_var_annots args)
  | Prim (loc, name, args, annots) -&gt;
      let not_var_annot s = Compare.Char.(s.[0] &lt;&gt; '@') in
      let annots = List.filter not_var_annot annots in
      Prim (loc, name, List.map strip_var_annots args, annots)

let serialize_ty_for_error ctxt ty =
  unparse_ty_no_lwt ctxt ty
  |&gt; record_trace <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Cannot_serialize_error</abbr>
  &gt;|? fun (ty, ctxt) -&gt; (strip_locations (strip_var_annots ty), ctxt)

let rec unparse_stack :
    type a.
    context -&gt;
    a stack_ty -&gt;
    ((Script.expr * Script.annot) list * context) tzresult Lwt.t =
 fun ctxt -&gt; function
  | Empty_t -&gt;
      return ([], ctxt)
  | Item_t (ty, rest, annot) -&gt;
      unparse_ty ctxt ty
      &gt;&gt;=? fun (uty, ctxt) -&gt;
      unparse_stack ctxt rest
      &gt;&gt;=? fun (urest, ctxt) -&gt;
      return ((strip_locations uty, unparse_var_annot annot) :: urest, ctxt)

let serialize_stack_for_error ctxt stack_ty =
  trace <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Cannot_serialize_error</abbr> (unparse_stack ctxt stack_ty)

let name_of_ty : type a. a ty -&gt; type_annot option = function
  | Unit_t tname -&gt;
      tname
  | Int_t tname -&gt;
      tname
  | Nat_t tname -&gt;
      tname
  | String_t tname -&gt;
      tname
  | Bytes_t tname -&gt;
      tname
  | Mutez_t tname -&gt;
      tname
  | Bool_t tname -&gt;
      tname
  | Key_hash_t tname -&gt;
      tname
  | Key_t tname -&gt;
      tname
  | Timestamp_t tname -&gt;
      tname
  | Address_t tname -&gt;
      tname
  | Signature_t tname -&gt;
      tname
  | Operation_t tname -&gt;
      tname
  | Chain_id_t tname -&gt;
      tname
  | Contract_t (_, tname) -&gt;
      tname
  | Pair_t (_, _, tname, _) -&gt;
      tname
  | Union_t (_, _, tname, _) -&gt;
      tname
  | Lambda_t (_, _, tname) -&gt;
      tname
  | Option_t (_, tname, _) -&gt;
      tname
  | List_t (_, tname, _) -&gt;
      tname
  | Set_t (_, tname) -&gt;
      tname
  | Map_t (_, _, tname, _) -&gt;
      tname
  | Big_map_t (_, _, tname) -&gt;
      tname

(* ---- Equality witnesses --------------------------------------------------*)

type ('ta, 'tb) eq = Eq : ('same, 'same) eq

let comparable_ty_eq :
    type ta tb.
    context -&gt;
    ta comparable_ty -&gt;
    tb comparable_ty -&gt;
    (ta comparable_ty, tb comparable_ty) eq tzresult =
 fun ctxt ta tb -&gt;
  match (ta, tb) with
  | (Int_key _, Int_key _) -&gt;
      Ok Eq
  | (Nat_key _, Nat_key _) -&gt;
      Ok Eq
  | (String_key _, String_key _) -&gt;
      Ok Eq
  | (Bytes_key _, Bytes_key _) -&gt;
      Ok Eq
  | (Mutez_key _, Mutez_key _) -&gt;
      Ok Eq
  | (Bool_key _, Bool_key _) -&gt;
      Ok Eq
  | (Key_hash_key _, Key_hash_key _) -&gt;
      Ok Eq
  | (Timestamp_key _, Timestamp_key _) -&gt;
      Ok Eq
  | (Address_key _, Address_key _) -&gt;
      Ok Eq
  | (_, _) -&gt;
      serialize_ty_for_error ctxt (ty_of_comparable_ty ta)
      &gt;&gt;? fun (ta, ctxt) -&gt;
      serialize_ty_for_error ctxt (ty_of_comparable_ty tb)
      &gt;&gt;? fun (tb, _ctxt) -&gt; error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Inconsistent_types (ta, tb))</abbr>

let record_inconsistent ctxt ta tb =
  record_trace_eval (fun () -&gt;
      serialize_ty_for_error ctxt ta
      &gt;&gt;? fun (ta, ctxt) -&gt;
      serialize_ty_for_error ctxt tb
      &gt;|? fun (tb, _ctxt) -&gt; <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Inconsistent_types (ta, tb)</abbr>)

let record_inconsistent_type_annotations ctxt loc ta tb =
  record_trace_eval (fun () -&gt;
      serialize_ty_for_error ctxt ta
      &gt;&gt;? fun (ta, ctxt) -&gt;
      serialize_ty_for_error ctxt tb
      &gt;|? fun (tb, _ctxt) -&gt; <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Inconsistent_type_annotations (loc, ta, tb)</abbr>)

let[@coq_struct &quot;ta&quot;] rec ty_eq :
    type ta tb.
    context -&gt; ta ty -&gt; tb ty -&gt; ((ta ty, tb ty) eq * context) tzresult =
 fun ctxt ta tb -&gt;
  let ok (eq : (ta ty, tb ty) eq) ctxt nb_args :
      ((ta ty, tb ty) eq * context) tzresult =
    Gas.consume ctxt (Typecheck_costs.type_ (2 * nb_args))
    &gt;&gt;? fun ctxt -&gt; Ok (eq, ctxt)
  in
  Gas.consume ctxt Typecheck_costs.cycle
  &gt;&gt;? fun ctxt -&gt;
  match (ta, tb) with
  | (Unit_t _, Unit_t _) -&gt;
      ok Eq ctxt 0
  | (Int_t _, Int_t _) -&gt;
      ok Eq ctxt 0
  | (Nat_t _, Nat_t _) -&gt;
      ok Eq ctxt 0
  | (Key_t _, Key_t _) -&gt;
      ok Eq ctxt 0
  | (Key_hash_t _, Key_hash_t _) -&gt;
      ok Eq ctxt 0
  | (String_t _, String_t _) -&gt;
      ok Eq ctxt 0
  | (Bytes_t _, Bytes_t _) -&gt;
      ok Eq ctxt 0
  | (Signature_t _, Signature_t _) -&gt;
      ok Eq ctxt 0
  | (Mutez_t _, Mutez_t _) -&gt;
      ok Eq ctxt 0
  | (Timestamp_t _, Timestamp_t _) -&gt;
      ok Eq ctxt 0
  | (Chain_id_t _, Chain_id_t _) -&gt;
      ok Eq ctxt 0
  | (Address_t _, Address_t _) -&gt;
      ok Eq ctxt 0
  | (Bool_t _, Bool_t _) -&gt;
      ok Eq ctxt 0
  | (Operation_t _, Operation_t _) -&gt;
      ok Eq ctxt 0
  | (Map_t (tal, tar, _, _), Map_t (tbl, tbr, _, _)) -&gt;
      comparable_ty_eq ctxt tal tbl
      &gt;&gt;? (fun Eq -&gt; ty_eq ctxt tar tbr &gt;&gt;? fun (Eq, ctxt) -&gt; ok Eq ctxt 2)
      |&gt; record_inconsistent ctxt ta tb
  | (Big_map_t (tal, tar, _), Big_map_t (tbl, tbr, _)) -&gt;
      comparable_ty_eq ctxt tal tbl
      &gt;&gt;? (fun Eq -&gt; ty_eq ctxt tar tbr &gt;&gt;? fun (Eq, ctxt) -&gt; ok Eq ctxt 2)
      |&gt; record_inconsistent ctxt ta tb
  | (Set_t (ea, _), Set_t (eb, _)) -&gt;
      comparable_ty_eq ctxt ea eb
      &gt;&gt;? (fun Eq -&gt; ok Eq ctxt 1)
      |&gt; record_inconsistent ctxt ta tb
  | ( Pair_t ((tal, _, _), (tar, _, _), _, _),
      Pair_t ((tbl, _, _), (tbr, _, _), _, _) ) -&gt;
      ty_eq ctxt tal tbl
      &gt;&gt;? (fun (Eq, ctxt) -&gt;
            ty_eq ctxt tar tbr &gt;&gt;? fun (Eq, ctxt) -&gt; ok Eq ctxt 2)
      |&gt; record_inconsistent ctxt ta tb
  | (Union_t ((tal, _), (tar, _), _, _), Union_t ((tbl, _), (tbr, _), _, _)) -&gt;
      ty_eq ctxt tal tbl
      &gt;&gt;? (fun (Eq, ctxt) -&gt;
            ty_eq ctxt tar tbr &gt;&gt;? fun (Eq, ctxt) -&gt; ok Eq ctxt 2)
      |&gt; record_inconsistent ctxt ta tb
  | (Lambda_t (tal, tar, _), Lambda_t (tbl, tbr, _)) -&gt;
      ty_eq ctxt tal tbl
      &gt;&gt;? (fun (Eq, ctxt) -&gt;
            ty_eq ctxt tar tbr &gt;&gt;? fun (Eq, ctxt) -&gt; ok Eq ctxt 2)
      |&gt; record_inconsistent ctxt ta tb
  | (Contract_t (tal, _), Contract_t (tbl, _)) -&gt;
      ty_eq ctxt tal tbl
      &gt;&gt;? (fun (Eq, ctxt) -&gt; ok Eq ctxt 1)
      |&gt; record_inconsistent ctxt ta tb
  | (Option_t (tva, _, _), Option_t (tvb, _, _)) -&gt;
      ty_eq ctxt tva tvb
      &gt;&gt;? (fun (Eq, ctxt) -&gt; ok Eq ctxt 1)
      |&gt; record_inconsistent ctxt ta tb
  | (List_t (tva, _, _), List_t (tvb, _, _)) -&gt;
      ty_eq ctxt tva tvb
      &gt;&gt;? (fun (Eq, ctxt) -&gt; ok Eq ctxt 1)
      |&gt; record_inconsistent ctxt ta tb
  | (_, _) -&gt;
      serialize_ty_for_error ctxt ta
      &gt;&gt;? fun (ta, ctxt) -&gt;
      serialize_ty_for_error ctxt tb
      &gt;&gt;? fun (tb, _ctxt) -&gt; error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Inconsistent_types (ta, tb))</abbr>

let rec stack_ty_eq :
    type ta tb.
    context -&gt;
    int -&gt;
    ta stack_ty -&gt;
    tb stack_ty -&gt;
    ((ta stack_ty, tb stack_ty) eq * context) tzresult =
 fun ctxt lvl ta tb -&gt;
  match (ta, tb) with
  | (Item_t (tva, ra, _), Item_t (tvb, rb, _)) -&gt;
      ty_eq ctxt tva tvb
      |&gt; record_trace <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Bad_stack_item lvl)</abbr>
      &gt;&gt;? fun (Eq, ctxt) -&gt;
      stack_ty_eq ctxt (lvl + 1) ra rb
      &gt;&gt;? fun (Eq, ctxt) -&gt;
      (Ok (Eq, ctxt) : ((ta stack_ty, tb stack_ty) eq * context) tzresult)
  | (Empty_t, Empty_t) -&gt;
      Ok (Eq, ctxt)
  | (_, _) -&gt;
      error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Bad_stack_length</abbr>

let merge_comparable_types :
    type ta.
    legacy:bool -&gt;
    ta comparable_ty -&gt;
    ta comparable_ty -&gt;
    ta comparable_ty tzresult =
 fun ~legacy ta tb -&gt;
  match (ta, tb) with
  | (Int_key annot_a, Int_key annot_b) -&gt;
      merge_type_annot ~legacy annot_a annot_b &gt;|? fun annot -&gt; Int_key annot
  | (Nat_key annot_a, Nat_key annot_b) -&gt;
      merge_type_annot ~legacy annot_a annot_b &gt;|? fun annot -&gt; Nat_key annot
  | (String_key annot_a, String_key annot_b) -&gt;
      merge_type_annot ~legacy annot_a annot_b
      &gt;|? fun annot -&gt; String_key annot
  | (Bytes_key annot_a, Bytes_key annot_b) -&gt;
      merge_type_annot ~legacy annot_a annot_b &gt;|? fun annot -&gt; Bytes_key annot
  | (Mutez_key annot_a, Mutez_key annot_b) -&gt;
      merge_type_annot ~legacy annot_a annot_b &gt;|? fun annot -&gt; Mutez_key annot
  | (Bool_key annot_a, Bool_key annot_b) -&gt;
      merge_type_annot ~legacy annot_a annot_b &gt;|? fun annot -&gt; Bool_key annot
  | (Key_hash_key annot_a, Key_hash_key annot_b) -&gt;
      merge_type_annot ~legacy annot_a annot_b
      &gt;|? fun annot -&gt; Key_hash_key annot
  | (Timestamp_key annot_a, Timestamp_key annot_b) -&gt;
      merge_type_annot ~legacy annot_a annot_b
      &gt;|? fun annot -&gt; Timestamp_key annot
  | (Address_key annot_a, Address_key annot_b) -&gt;
      merge_type_annot ~legacy annot_a annot_b
      &gt;|? fun annot -&gt; Address_key annot
  | (_, _) -&gt;
      <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>

(* FIXME: fix injectivity of some types *)

let merge_types :
    type b.
    legacy:bool -&gt;
    context -&gt;
    Script.location -&gt;
    b ty -&gt;
    b ty -&gt;
    (b ty * context) tzresult =
 fun ~legacy -&gt;
  let rec help : type a. context -&gt; a ty -&gt; a ty -&gt; (a ty * context) tzresult =
   fun ctxt ty1 ty2 -&gt;
    match (ty1, ty2) with
    | (Unit_t tn1, Unit_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2 &gt;|? fun tname -&gt; (Unit_t tname, ctxt)
    | (Int_t tn1, Int_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2 &gt;|? fun tname -&gt; (Int_t tname, ctxt)
    | (Nat_t tn1, Nat_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2 &gt;|? fun tname -&gt; (Nat_t tname, ctxt)
    | (Key_t tn1, Key_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2 &gt;|? fun tname -&gt; (Key_t tname, ctxt)
    | (Key_hash_t tn1, Key_hash_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;|? fun tname -&gt; (Key_hash_t tname, ctxt)
    | (String_t tn1, String_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2 &gt;|? fun tname -&gt; (String_t tname, ctxt)
    | (Bytes_t tn1, Bytes_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2 &gt;|? fun tname -&gt; (Bytes_t tname, ctxt)
    | (Signature_t tn1, Signature_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;|? fun tname -&gt; (Signature_t tname, ctxt)
    | (Mutez_t tn1, Mutez_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2 &gt;|? fun tname -&gt; (Mutez_t tname, ctxt)
    | (Timestamp_t tn1, Timestamp_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;|? fun tname -&gt; (Timestamp_t tname, ctxt)
    | (Address_t tn1, Address_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;|? fun tname -&gt; (Address_t tname, ctxt)
    | (Bool_t tn1, Bool_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2 &gt;|? fun tname -&gt; (Bool_t tname, ctxt)
    | (Chain_id_t tn1, Chain_id_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;|? fun tname -&gt; (Chain_id_t tname, ctxt)
    | (Operation_t tn1, Operation_t tn2) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;|? fun tname -&gt; (Operation_t tname, ctxt)
    | (Map_t (tal, tar, tn1, has_big_map), Map_t (tbl, tbr, tn2, _)) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;&gt;? fun tname -&gt;
        help ctxt tar tbr
        &gt;&gt;? fun (value, ctxt) -&gt;
        ty_eq ctxt tar value
        &gt;&gt;? fun (Eq, ctxt) -&gt;
        merge_comparable_types ~legacy tal tbl
        &gt;|? fun tk -&gt; (Map_t (tk, value, tname, has_big_map), ctxt)
    | (Big_map_t (tal, tar, tn1), Big_map_t (tbl, tbr, tn2)) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;&gt;? fun tname -&gt;
        help ctxt tar tbr
        &gt;&gt;? fun (value, ctxt) -&gt;
        ty_eq ctxt tar value
        &gt;&gt;? fun (Eq, ctxt) -&gt;
        merge_comparable_types ~legacy tal tbl
        &gt;|? fun tk -&gt; (Big_map_t (tk, value, tname), ctxt)
    | (Set_t (ea, tn1), Set_t (eb, tn2)) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;&gt;? fun tname -&gt;
        merge_comparable_types ~legacy ea eb
        &gt;|? fun e -&gt; (Set_t (e, tname), ctxt)
    | ( Pair_t
          ((tal, l_field1, l_var1), (tar, r_field1, r_var1), tn1, has_big_map),
        Pair_t ((tbl, l_field2, l_var2), (tbr, r_field2, r_var2), tn2, _) ) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;&gt;? fun tname -&gt;
        merge_field_annot ~legacy l_field1 l_field2
        &gt;&gt;? fun l_field -&gt;
        merge_field_annot ~legacy r_field1 r_field2
        &gt;&gt;? fun r_field -&gt;
        let l_var = merge_var_annot l_var1 l_var2 in
        let r_var = merge_var_annot r_var1 r_var2 in
        help ctxt tal tbl
        &gt;&gt;? fun (left_ty, ctxt) -&gt;
        help ctxt tar tbr
        &gt;|? fun (right_ty, ctxt) -&gt;
        ( Pair_t
            ( (left_ty, l_field, l_var),
              (right_ty, r_field, r_var),
              tname,
              has_big_map ),
          ctxt )
    | ( Union_t ((tal, tal_annot), (tar, tar_annot), tn1, has_big_map),
        Union_t ((tbl, tbl_annot), (tbr, tbr_annot), tn2, _) ) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;&gt;? fun tname -&gt;
        merge_field_annot ~legacy tal_annot tbl_annot
        &gt;&gt;? fun left_annot -&gt;
        merge_field_annot ~legacy tar_annot tbr_annot
        &gt;&gt;? fun right_annot -&gt;
        help ctxt tal tbl
        &gt;&gt;? fun (left_ty, ctxt) -&gt;
        help ctxt tar tbr
        &gt;|? fun (right_ty, ctxt) -&gt;
        ( Union_t
            ((left_ty, left_annot), (right_ty, right_annot), tname, has_big_map),
          ctxt )
    | (Lambda_t (tal, tar, tn1), Lambda_t (tbl, tbr, tn2)) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;&gt;? fun tname -&gt;
        help ctxt tal tbl
        &gt;&gt;? fun (left_ty, ctxt) -&gt;
        help ctxt tar tbr
        &gt;|? fun (right_ty, ctxt) -&gt; (Lambda_t (left_ty, right_ty, tname), ctxt)
    | (Contract_t (tal, tn1), Contract_t (tbl, tn2)) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;&gt;? fun tname -&gt;
        help ctxt tal tbl
        &gt;|? fun (arg_ty, ctxt) -&gt; (Contract_t (arg_ty, tname), ctxt)
    | (Option_t (tva, tn1, has_big_map), Option_t (tvb, tn2, _)) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;&gt;? fun tname -&gt;
        help ctxt tva tvb
        &gt;|? fun (ty, ctxt) -&gt; (Option_t (ty, tname, has_big_map), ctxt)
    | (List_t (tva, tn1, has_big_map), List_t (tvb, tn2, _)) -&gt;
        merge_type_annot ~legacy tn1 tn2
        &gt;&gt;? fun tname -&gt;
        help ctxt tva tvb
        &gt;|? fun (ty, ctxt) -&gt; (List_t (ty, tname, has_big_map), ctxt)
    | (_, _) -&gt;
        <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
  in
  fun ctxt loc ty1 ty2 -&gt;
    record_inconsistent_type_annotations ctxt loc ty1 ty2 (help ctxt ty1 ty2)

let merge_stacks :
    type ta.
    legacy:bool -&gt;
    Script.location -&gt;
    context -&gt;
    ta stack_ty -&gt;
    ta stack_ty -&gt;
    (ta stack_ty * context) tzresult =
 fun ~legacy loc -&gt;
  let rec help :
      type a.
      context -&gt; a stack_ty -&gt; a stack_ty -&gt; (a stack_ty * context) tzresult =
   fun ctxt stack1 stack2 -&gt;
    match[@coq_match_with_default] (stack1, stack2) with
    | (Empty_t, Empty_t) -&gt;
        ok (Empty_t, ctxt)
    | (Item_t (ty1, rest1, annot1), Item_t (ty2, rest2, annot2)) -&gt;
        let annot = merge_var_annot annot1 annot2 in
        merge_types ~legacy ctxt loc ty1 ty2
        &gt;&gt;? fun (ty, ctxt) -&gt;
        help ctxt rest1 rest2
        &gt;|? fun (rest, ctxt) -&gt; (Item_t (ty, rest, annot), ctxt)
  in
  help

let has_big_map : type t. t ty -&gt; bool = function
  | Unit_t _ -&gt;
      false
  | Int_t _ -&gt;
      false
  | Nat_t _ -&gt;
      false
  | Signature_t _ -&gt;
      false
  | String_t _ -&gt;
      false
  | Bytes_t _ -&gt;
      false
  | Mutez_t _ -&gt;
      false
  | Key_hash_t _ -&gt;
      false
  | Key_t _ -&gt;
      false
  | Timestamp_t _ -&gt;
      false
  | Address_t _ -&gt;
      false
  | Bool_t _ -&gt;
      false
  | Lambda_t (_, _, _) -&gt;
      false
  | Set_t (_, _) -&gt;
      false
  | Big_map_t (_, _, _) -&gt;
      true
  | Contract_t (_, _) -&gt;
      false
  | Operation_t _ -&gt;
      false
  | Chain_id_t _ -&gt;
      false
  | Pair_t (_, _, _, has_big_map) -&gt;
      has_big_map
  | Union_t (_, _, _, has_big_map) -&gt;
      has_big_map
  | Option_t (_, _, has_big_map) -&gt;
      has_big_map
  | List_t (_, _, has_big_map) -&gt;
      has_big_map
  | Map_t (_, _, _, has_big_map) -&gt;
      has_big_map

(* ---- Type checker results -------------------------------------------------*)

type 'bef judgement =
  | Typed : ('bef, 'aft) descr -&gt; 'bef judgement
  | Failed : {
      descr : 'aft. 'aft stack_ty -&gt; ('bef, 'aft) descr;
    }
      -&gt; 'bef judgement
[@@coq_force_gadt]

(* ---- Type checker (Untyped expressions -&gt; Typed IR) ----------------------*)

type ('t, 'f, 'b) branch = {
  branch : 'r. ('t, 'r) descr -&gt; ('f, 'r) descr -&gt; ('b, 'r) descr;
}
[@@coq_force_gadt] [@@unboxed]

let merge_branches :
    type bef a b.
    legacy:bool -&gt;
    context -&gt;
    int -&gt;
    a judgement -&gt;
    b judgement -&gt;
    (a, b, bef) branch -&gt;
    (bef judgement * context) tzresult Lwt.t =
 fun ~legacy ctxt loc btr bfr {branch} -&gt;
  match (btr, bfr) with
  | (Typed ({aft = aftbt; _} as dbt), Typed ({aft = aftbf; _} as dbf)) -&gt;
      let unmatched_branches () =
        serialize_stack_for_error ctxt aftbt
        &gt;&gt;=? fun (aftbt, ctxt) -&gt;
        serialize_stack_for_error ctxt aftbf
        &gt;&gt;|? fun (aftbf, _ctxt) -&gt; <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Unmatched_branches (loc, aftbt, aftbf)</abbr>
      in
      trace_eval
        unmatched_branches
        ( Lwt.return (stack_ty_eq ctxt 1 aftbt aftbf)
        &gt;&gt;=? fun (Eq, ctxt) -&gt;
        Lwt.return (merge_stacks ~legacy loc ctxt aftbt aftbf)
        &gt;&gt;=? fun (merged_stack, ctxt) -&gt;
        return
          ( Typed
              (branch
                 {dbt with aft = merged_stack}
                 {dbf with aft = merged_stack}),
            ctxt ) )
  | (Failed {descr = descrt}, Failed {descr = descrf}) -&gt;
      let descr ret = branch (descrt ret) (descrf ret) in
      return (Failed {descr}, ctxt)
  | (Typed dbt, Failed {descr = descrf}) -&gt;
      return (Typed (branch dbt (descrf dbt.aft)), ctxt)
  | (Failed {descr = descrt}, Typed dbf) -&gt;
      return (Typed (branch (descrt dbf.aft) dbf), ctxt)

let parse_comparable_ty :
    context -&gt; Script.node -&gt; (ex_comparable_ty * context) tzresult =
 fun ctxt ty -&gt;
  Gas.consume ctxt Typecheck_costs.cycle
  &gt;&gt;? fun ctxt -&gt;
  Gas.consume ctxt (Typecheck_costs.type_ 0)
  &gt;&gt;? fun ctxt -&gt;
  match ty with
  | Prim (loc, T_int, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;|? fun tname -&gt; (Ex_comparable_ty (Int_key tname), ctxt)
  | Prim (loc, T_nat, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;|? fun tname -&gt; (Ex_comparable_ty (Nat_key tname), ctxt)
  | Prim (loc, T_string, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;|? fun tname -&gt; (Ex_comparable_ty (String_key tname), ctxt)
  | Prim (loc, T_bytes, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;|? fun tname -&gt; (Ex_comparable_ty (Bytes_key tname), ctxt)
  | Prim (loc, T_mutez, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;|? fun tname -&gt; (Ex_comparable_ty (Mutez_key tname), ctxt)
  | Prim (loc, T_bool, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;|? fun tname -&gt; (Ex_comparable_ty (Bool_key tname), ctxt)
  | Prim (loc, T_key_hash, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;|? fun tname -&gt; (Ex_comparable_ty (Key_hash_key tname), ctxt)
  | Prim (loc, T_timestamp, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;|? fun tname -&gt; (Ex_comparable_ty (Timestamp_key tname), ctxt)
  | Prim (loc, T_address, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;|? fun tname -&gt; (Ex_comparable_ty (Address_key tname), ctxt)
  | Prim
      ( loc,
        ( ( T_int
          | T_nat
          | T_string
          | T_mutez
          | T_bool
          | T_key
          | T_address
          | T_timestamp ) as prim ),
        l,
        _ ) -&gt;
      error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_arity (loc, prim, 0, List.length l))</abbr>
  | Prim
      ( loc,
        ( T_pair
        | T_or
        | T_set
        | T_map
        | T_list
        | T_option
        | T_lambda
        | T_unit
        | T_signature
        | T_contract ),
        _,
        _ ) -&gt;
      error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Comparable_type_expected (loc, Micheline.strip_locations ty))</abbr>
  | expr -&gt;
      error
      @@ unexpected
           expr
           []
           Type_namespace
           [ T_int;
             T_nat;
             T_string;
             T_mutez;
             T_bool;
             T_key;
             T_key_hash;
             T_timestamp ]

let rec parse_packable_ty :
    context -&gt; legacy:bool -&gt; Script.node -&gt; (ex_ty * context) tzresult =
 fun ctxt ~legacy -&gt;
  parse_ty
    ctxt
    ~legacy
    ~allow_big_map:false
    ~allow_operation:false
    ~allow_contract:legacy

and parse_parameter_ty :
    context -&gt; legacy:bool -&gt; Script.node -&gt; (ex_ty * context) tzresult =
 fun ctxt ~legacy -&gt;
  parse_ty
    ctxt
    ~legacy
    ~allow_big_map:true
    ~allow_operation:false
    ~allow_contract:true

and parse_any_ty :
    context -&gt; legacy:bool -&gt; Script.node -&gt; (ex_ty * context) tzresult =
 fun ctxt ~legacy -&gt;
  parse_ty
    ctxt
    ~legacy
    ~allow_big_map:true
    ~allow_operation:true
    ~allow_contract:true

and parse_ty :
    context -&gt;
    legacy:bool -&gt;
    allow_big_map:bool -&gt;
    allow_operation:bool -&gt;
    allow_contract:bool -&gt;
    Script.node -&gt;
    (ex_ty * context) tzresult =
 fun ctxt ~legacy ~allow_big_map ~allow_operation ~allow_contract node -&gt;
  Gas.consume ctxt Typecheck_costs.cycle
  &gt;&gt;? fun ctxt -&gt;
  match node with
  | Prim (loc, T_unit, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 0)
      &gt;|? fun ctxt -&gt; (Ex_ty (Unit_t ty_name), ctxt)
  | Prim (loc, T_int, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 0)
      &gt;|? fun ctxt -&gt; (Ex_ty (Int_t ty_name), ctxt)
  | Prim (loc, T_nat, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 0)
      &gt;|? fun ctxt -&gt; (Ex_ty (Nat_t ty_name), ctxt)
  | Prim (loc, T_string, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 0)
      &gt;|? fun ctxt -&gt; (Ex_ty (String_t ty_name), ctxt)
  | Prim (loc, T_bytes, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 0)
      &gt;|? fun ctxt -&gt; (Ex_ty (Bytes_t ty_name), ctxt)
  | Prim (loc, T_mutez, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 0)
      &gt;|? fun ctxt -&gt; (Ex_ty (Mutez_t ty_name), ctxt)
  | Prim (loc, T_bool, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 0)
      &gt;|? fun ctxt -&gt; (Ex_ty (Bool_t ty_name), ctxt)
  | Prim (loc, T_key, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 0)
      &gt;|? fun ctxt -&gt; (Ex_ty (Key_t ty_name), ctxt)
  | Prim (loc, T_key_hash, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 0)
      &gt;|? fun ctxt -&gt; (Ex_ty (Key_hash_t ty_name), ctxt)
  | Prim (loc, T_timestamp, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 0)
      &gt;|? fun ctxt -&gt; (Ex_ty (Timestamp_t ty_name), ctxt)
  | Prim (loc, T_address, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 0)
      &gt;|? fun ctxt -&gt; (Ex_ty (Address_t ty_name), ctxt)
  | Prim (loc, T_signature, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 0)
      &gt;|? fun ctxt -&gt; (Ex_ty (Signature_t ty_name), ctxt)
  | Prim (loc, T_operation, [], annot) -&gt;
      if allow_operation then
        parse_type_annot loc annot
        &gt;&gt;? fun ty_name -&gt;
        Gas.consume ctxt (Typecheck_costs.type_ 0)
        &gt;|? fun ctxt -&gt; (Ex_ty (Operation_t ty_name), ctxt)
      else error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Unexpected_operation loc)</abbr>
  | Prim (loc, T_chain_id, [], annot) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 0)
      &gt;|? fun ctxt -&gt; (Ex_ty (Chain_id_t ty_name), ctxt)
  | Prim (loc, T_contract, [utl], annot) -&gt;
      if allow_contract then
        parse_parameter_ty ctxt ~legacy utl
        &gt;&gt;? fun (Ex_ty tl, ctxt) -&gt;
        parse_type_annot loc annot
        &gt;&gt;? fun ty_name -&gt;
        Gas.consume ctxt (Typecheck_costs.type_ 1)
        &gt;|? fun ctxt -&gt; (Ex_ty (Contract_t (tl, ty_name)), ctxt)
      else error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Unexpected_contract loc)</abbr>
  | Prim (loc, T_pair, [utl; utr], annot) -&gt;
      extract_field_annot utl
      &gt;&gt;? fun (utl, left_field) -&gt;
      extract_field_annot utr
      &gt;&gt;? fun (utr, right_field) -&gt;
      parse_ty ctxt ~legacy ~allow_big_map ~allow_operation ~allow_contract utl
      &gt;&gt;? fun (Ex_ty tl, ctxt) -&gt;
      parse_ty ctxt ~legacy ~allow_big_map ~allow_operation ~allow_contract utr
      &gt;&gt;? fun (Ex_ty tr, ctxt) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 2)
      &gt;|? fun ctxt -&gt;
      ( Ex_ty
          (Pair_t
             ( (tl, left_field, None),
               (tr, right_field, None),
               ty_name,
               has_big_map tl || has_big_map tr )),
        ctxt )
  | Prim (loc, T_or, [utl; utr], annot) -&gt;
      extract_field_annot utl
      &gt;&gt;? fun (utl, left_constr) -&gt;
      extract_field_annot utr
      &gt;&gt;? fun (utr, right_constr) -&gt;
      parse_ty ctxt ~legacy ~allow_big_map ~allow_operation ~allow_contract utl
      &gt;&gt;? fun (Ex_ty tl, ctxt) -&gt;
      parse_ty ctxt ~legacy ~allow_big_map ~allow_operation ~allow_contract utr
      &gt;&gt;? fun (Ex_ty tr, ctxt) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 2)
      &gt;|? fun ctxt -&gt;
      ( Ex_ty
          (Union_t
             ( (tl, left_constr),
               (tr, right_constr),
               ty_name,
               has_big_map tl || has_big_map tr )),
        ctxt )
  | Prim (loc, T_lambda, [uta; utr], annot) -&gt;
      parse_any_ty ctxt ~legacy uta
      &gt;&gt;? fun (Ex_ty ta, ctxt) -&gt;
      parse_any_ty ctxt ~legacy utr
      &gt;&gt;? fun (Ex_ty tr, ctxt) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 2)
      &gt;|? fun ctxt -&gt; (Ex_ty (Lambda_t (ta, tr, ty_name)), ctxt)
  | Prim (loc, T_option, [ut], annot) -&gt;
      ( if legacy then
        (* legacy semantics with (broken) field annotations *)
        extract_field_annot ut
        &gt;&gt;? fun (ut, _some_constr) -&gt;
        parse_composed_type_annot loc annot
        &gt;&gt;? fun (ty_name, _none_constr, _) -&gt; ok (ut, ty_name)
      else parse_type_annot loc annot &gt;&gt;? fun ty_name -&gt; ok (ut, ty_name) )
      &gt;&gt;? fun (ut, ty_name) -&gt;
      parse_ty ctxt ~legacy ~allow_big_map ~allow_operation ~allow_contract ut
      &gt;&gt;? fun (Ex_ty t, ctxt) -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 2)
      &gt;|? fun ctxt -&gt; (Ex_ty (Option_t (t, ty_name, has_big_map t)), ctxt)
  | Prim (loc, T_list, [ut], annot) -&gt;
      parse_ty ctxt ~legacy ~allow_big_map ~allow_operation ~allow_contract ut
      &gt;&gt;? fun (Ex_ty t, ctxt) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 1)
      &gt;|? fun ctxt -&gt; (Ex_ty (List_t (t, ty_name, has_big_map t)), ctxt)
  | Prim (loc, T_set, [ut], annot) -&gt;
      parse_comparable_ty ctxt ut
      &gt;&gt;? fun (Ex_comparable_ty t, ctxt) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 1)
      &gt;|? fun ctxt -&gt; (Ex_ty (Set_t (t, ty_name)), ctxt)
  | Prim (loc, T_map, [uta; utr], annot) -&gt;
      parse_comparable_ty ctxt uta
      &gt;&gt;? fun (Ex_comparable_ty ta, ctxt) -&gt;
      parse_ty ctxt ~legacy ~allow_big_map ~allow_operation ~allow_contract utr
      &gt;&gt;? fun (Ex_ty tr, ctxt) -&gt;
      parse_type_annot loc annot
      &gt;&gt;? fun ty_name -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 2)
      &gt;|? fun ctxt -&gt; (Ex_ty (Map_t (ta, tr, ty_name, has_big_map tr)), ctxt)
  | Prim (loc, T_big_map, args, annot) when allow_big_map -&gt;
      parse_big_map_ty ctxt ~legacy loc args annot
      &gt;&gt;? fun (big_map_ty, ctxt) -&gt;
      Gas.consume ctxt (Typecheck_costs.type_ 2)
      &gt;|? fun ctxt -&gt; (big_map_ty, ctxt)
  | Prim (loc, T_big_map, _, _) -&gt;
      error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Unexpected_big_map loc)</abbr>
  | Prim
      ( loc,
        ( ( T_unit
          | T_signature
          | T_int
          | T_nat
          | T_string
          | T_bytes
          | T_mutez
          | T_bool
          | T_key
          | T_key_hash
          | T_timestamp
          | T_address ) as prim ),
        l,
        _ ) -&gt;
      error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_arity (loc, prim, 0, List.length l))</abbr>
  | Prim (loc, ((T_set | T_list | T_option | T_contract) as prim), l, _) -&gt;
      error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_arity (loc, prim, 1, List.length l))</abbr>
  | Prim (loc, ((T_pair | T_or | T_map | T_lambda) as prim), l, _) -&gt;
      error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_arity (loc, prim, 2, List.length l))</abbr>
  | expr -&gt;
      error
      @@ unexpected
           expr
           []
           Type_namespace
           [ T_pair;
             T_or;
             T_set;
             T_map;
             T_list;
             T_option;
             T_lambda;
             T_unit;
             T_signature;
             T_contract;
             T_int;
             T_nat;
             T_operation;
             T_string;
             T_bytes;
             T_mutez;
             T_bool;
             T_key;
             T_key_hash;
             T_timestamp;
             T_chain_id ]

and parse_big_map_ty ctxt ~legacy big_map_loc args map_annot =
  Gas.consume ctxt Typecheck_costs.cycle
  &gt;&gt;? fun ctxt -&gt;
  match args with
  | [key_ty; value_ty] -&gt;
      parse_comparable_ty ctxt key_ty
      &gt;&gt;? fun (Ex_comparable_ty key_ty, ctxt) -&gt;
      parse_packable_ty ctxt ~legacy value_ty
      &gt;&gt;? fun (Ex_ty value_ty, ctxt) -&gt;
      parse_type_annot big_map_loc map_annot
      &gt;|? fun map_name -&gt;
      let big_map_ty = Big_map_t (key_ty, value_ty, map_name) in
      (Ex_ty big_map_ty, ctxt)
  | args -&gt;
      error @@ <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_arity (big_map_loc, T_big_map, 2, List.length args)</abbr>

let parse_storage_ty :
    context -&gt; legacy:bool -&gt; Script.node -&gt; (ex_ty * context) tzresult =
 fun ctxt ~legacy node -&gt;
  match node with
  | Prim
      ( loc,
        T_pair,
        [Prim (big_map_loc, T_big_map, args, map_annot); remaining_storage],
        storage_annot )
    when legacy -&gt; (
    match storage_annot with
    | [] -&gt;
        parse_ty
          ctxt
          ~legacy
          ~allow_big_map:true
          ~allow_operation:false
          ~allow_contract:legacy
          node
    | [single]
      when Compare.Int.(String.length single &gt; 0)
           &amp;&amp; Compare.Char.(single.[0] = '%') -&gt;
        parse_ty
          ctxt
          ~legacy
          ~allow_big_map:true
          ~allow_operation:false
          ~allow_contract:legacy
          node
    | _ -&gt;
        (* legacy semantics of big maps used the wrong annotation parser *)
        Gas.consume ctxt Typecheck_costs.cycle
        &gt;&gt;? fun ctxt -&gt;
        parse_big_map_ty ctxt ~legacy big_map_loc args map_annot
        &gt;&gt;? fun (Ex_ty big_map_ty, ctxt) -&gt;
        parse_ty
          ctxt
          ~legacy
          ~allow_big_map:true
          ~allow_operation:false
          ~allow_contract:legacy
          remaining_storage
        &gt;&gt;? fun (Ex_ty remaining_storage, ctxt) -&gt;
        parse_composed_type_annot loc storage_annot
        &gt;&gt;? fun (ty_name, map_field, storage_field) -&gt;
        Gas.consume ctxt (Typecheck_costs.type_ 5)
        &gt;|? fun ctxt -&gt;
        ( Ex_ty
            (Pair_t
               ( (big_map_ty, map_field, None),
                 (remaining_storage, storage_field, None),
                 ty_name,
                 true )),
          ctxt ) )
  | _ -&gt;
      parse_ty
        ctxt
        ~legacy
        ~allow_big_map:true
        ~allow_operation:false
        ~allow_contract:legacy
        node

let check_packable ~legacy loc root =
  let rec check : type t. t ty -&gt; unit tzresult = function
    | Big_map_t _ -&gt;
        error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Unexpected_big_map loc)</abbr>
    | Operation_t _ -&gt;
        error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Unexpected_operation loc)</abbr>
    | Unit_t _ -&gt;
        ok ()
    | Int_t _ -&gt;
        ok ()
    | Nat_t _ -&gt;
        ok ()
    | Signature_t _ -&gt;
        ok ()
    | String_t _ -&gt;
        ok ()
    | Bytes_t _ -&gt;
        ok ()
    | Mutez_t _ -&gt;
        ok ()
    | Key_hash_t _ -&gt;
        ok ()
    | Key_t _ -&gt;
        ok ()
    | Timestamp_t _ -&gt;
        ok ()
    | Address_t _ -&gt;
        ok ()
    | Bool_t _ -&gt;
        ok ()
    | Chain_id_t _ -&gt;
        ok ()
    | Pair_t ((l_ty, _, _), (r_ty, _, _), _, _) -&gt;
        check l_ty &gt;&gt;? fun () -&gt; check r_ty
    | Union_t ((l_ty, _), (r_ty, _), _, _) -&gt;
        check l_ty &gt;&gt;? fun () -&gt; check r_ty
    | Option_t (v_ty, _, _) -&gt;
        check v_ty
    | List_t (elt_ty, _, _) -&gt;
        check elt_ty
    | Set_t (_, _) -&gt;
        ok ()
    | Map_t (_, elt_ty, _, _) -&gt;
        check elt_ty
    | Lambda_t (_l_ty, _r_ty, _) -&gt;
        ok ()
    | Contract_t (_, _) when legacy -&gt;
        ok ()
    | Contract_t (_, _) -&gt;
        error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Unexpected_contract loc)</abbr>
  in
  check root

type ex_script = Ex_script : ('a, 'c) script -&gt; ex_script

type _ dig_proof_argument =
  | Dig_proof_argument :
      ( ('x * 'rest, 'rest, 'bef, 'aft) stack_prefix_preservation_witness
      * ('x ty * var_annot option)
      * 'aft stack_ty )
      -&gt; 'bef dig_proof_argument
[@@coq_force_gadt]

type (_, _) dug_proof_argument =
  | Dug_proof_argument :
      ( ('rest, 'x * 'rest, 'bef, 'aft) stack_prefix_preservation_witness
      * unit
      * 'aft stack_ty )
      -&gt; ('bef, 'x) dug_proof_argument
[@@coq_force_gadt]

type _ dipn_proof_argument =
  | Dipn_proof_argument :
      ( ('fbef, 'faft, 'bef, 'aft) stack_prefix_preservation_witness
      * (context * ('fbef, 'faft) descr)
      * 'aft stack_ty )
      -&gt; 'bef dipn_proof_argument
[@@coq_force_gadt]

type _ dropn_proof_argument =
  | Dropn_proof_argument :
      ( ('rest, 'rest, 'bef, 'aft) stack_prefix_preservation_witness
      * 'rest stack_ty
      * 'aft stack_ty )
      -&gt; 'bef dropn_proof_argument
[@@coq_force_gadt]

(* Lwt versions *)
let parse_var_annot loc ?default annot =
  Lwt.return (parse_var_annot loc ?default annot)

let parse_entrypoint_annot loc ?default annot =
  Lwt.return (parse_entrypoint_annot loc ?default annot)

let parse_constr_annot loc ?if_special_first ?if_special_second annot =
  Lwt.return
    (parse_constr_annot loc ?if_special_first ?if_special_second annot)

let parse_two_var_annot loc annot = Lwt.return (parse_two_var_annot loc annot)

let parse_destr_annot loc annot ~default_accessor ~field_name ~pair_annot
    ~value_annot =
  Lwt.return
    (parse_destr_annot
       loc
       annot
       ~default_accessor
       ~field_name
       ~pair_annot
       ~value_annot)

let parse_var_type_annot loc annot =
  Lwt.return (parse_var_type_annot loc annot)

let find_entrypoint (type full) (full : full ty) ~root_name entrypoint =
  let rec find_entrypoint :
      type t. t ty -&gt; string -&gt; (Script.node -&gt; Script.node) * ex_ty =
   fun t entrypoint -&gt;
    match t with
    | Union_t ((tl, al), (tr, ar), _, _) -&gt; (
        if
          match al with
          | None -&gt;
              false
          | Some (Field_annot l) -&gt;
              Compare.String.(l = entrypoint)
        then ((fun e -&gt; Prim (0, D_Left, [e], [])), Ex_ty tl)
        else if
          match ar with
          | None -&gt;
              false
          | Some (Field_annot r) -&gt;
              Compare.String.(r = entrypoint)
        then ((fun e -&gt; Prim (0, D_Right, [e], [])), Ex_ty tr)
        else
          <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
            let (f, t) = find_entrypoint tl entrypoint in
            ((fun e -&gt; Prim (0, D_Left, [f e], [])), t)
          with Not_found -&gt;
            let (f, t) = find_entrypoint tr entrypoint in
            ((fun e -&gt; Prim (0, D_Right, [f e], [])), t)</abbr> )
    | _ -&gt;
        raise <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Not_found</abbr>
  in
  let entrypoint =
    if Compare.String.(entrypoint = &quot;&quot;) then &quot;default&quot; else entrypoint
  in
  if Compare.Int.(String.length entrypoint &gt; 31) then
    error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Entrypoint_name_too_long entrypoint)</abbr>
  else
    match root_name with
    | Some root_name when Compare.String.(entrypoint = root_name) -&gt;
        ok ((fun e -&gt; e), Ex_ty full)
    | _ -&gt; <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(
      try ok (find_entrypoint full entrypoint)
      with Not_found -&gt; (
        match entrypoint with
        | &quot;default&quot; -&gt;
            ok ((fun e -&gt; e), Ex_ty full)
        | _ -&gt;
            error (No_such_entrypoint entrypoint) ) )</abbr>

let find_entrypoint_for_type (type full exp) ~(full : full ty)
    ~(expected : exp ty) ~root_name entrypoint ctxt :
    (context * string * exp ty) tzresult =
  match (entrypoint, root_name) with
  | (&quot;default&quot;, Some &quot;root&quot;) -&gt; (
    match find_entrypoint full ~root_name entrypoint with
    | Error error -&gt;
        Error error
    | Ok (_, Ex_ty ty) -&gt; (
      match ty_eq ctxt expected ty with
      | Ok (Eq, ctxt) -&gt;
          ok (ctxt, &quot;default&quot;, (ty : exp ty))
      | Error _ -&gt;
          ty_eq ctxt expected full
          &gt;&gt;? fun (Eq, ctxt) -&gt; ok (ctxt, &quot;root&quot;, (full : exp ty)) ) )
  | _ -&gt;
      find_entrypoint full ~root_name entrypoint
      &gt;&gt;? fun (_, Ex_ty ty) -&gt;
      ty_eq ctxt expected ty
      &gt;&gt;? fun (Eq, ctxt) -&gt; ok (ctxt, entrypoint, (ty : exp ty))

module Entrypoints = Set.Make (String)

<abbr class="mark-warning" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception Duplicate of string</abbr>

<abbr class="mark-warning" title="The definition of exceptions is not handled.

Alternative: using sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent error cases.">exception Too_long of string</abbr>

let well_formed_entrypoints (type full) (full : full ty) ~root_name =
  let merge path annot (type t) (ty : t ty) reachable
      ((first_unreachable, all) as acc) =
    match annot with
    | None | Some (Field_annot &quot;&quot;) -&gt; (
        if reachable then acc
        else
          match ty with
          | Union_t _ -&gt;
              acc
          | _ -&gt; (
            match first_unreachable with
            | None -&gt;
                (Some (List.rev path), all)
            | Some _ -&gt;
                acc ) )
    | Some (Field_annot name) -&gt;
        if Compare.Int.(String.length name &gt; 31) then raise <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Too_long name)</abbr>
        else if Entrypoints.mem name all then raise <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Duplicate name)</abbr>
        else (first_unreachable, Entrypoints.add name all)
  in
  let rec check :
      type t.
      t ty -&gt;
      prim list -&gt;
      bool -&gt;
      prim list option * Entrypoints.t -&gt;
      prim list option * Entrypoints.t =
   fun t path reachable acc -&gt;
    match t with
    | Union_t ((tl, al), (tr, ar), _, _) -&gt;
        let acc = merge (D_Left :: path) al tl reachable acc in
        let acc = merge (D_Right :: path) ar tr reachable acc in
        let acc =
          check
            tl
            (D_Left :: path)
            (match al with Some _ -&gt; true | None -&gt; reachable)
            acc
        in
        check
          tr
          (D_Right :: path)
          (match ar with Some _ -&gt; true | None -&gt; reachable)
          acc
    | _ -&gt;
        acc
  in
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
    let (init, reachable) =
      match root_name with
      | None | Some &quot;&quot; -&gt;
          (Entrypoints.empty, false)
      | Some name -&gt;
          (Entrypoints.singleton name, true)
    in
    let (first_unreachable, all) = check full [] reachable (None, init) in
    if not (Entrypoints.mem &quot;default&quot; all) then ok ()
    else
      match first_unreachable with
      | None -&gt;
          ok ()
      | Some path -&gt;
          error </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Values of extensible types are ignored.

They are sent to a unit type.">(Unreachable_entrypoint path)</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">
  with
  | Duplicate name -&gt;
      error (Duplicate_entrypoint name)
  | Too_long name -&gt;
      error (Entrypoint_name_too_long name)</abbr>

let parse_int32 (n : (location, prim) Micheline.node) : int tzresult =
  let error' () =
    <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_syntactic_constant
      ( location n,
        strip_locations n,
        &quot;a positive 32-bit integer (between 0 and &quot;
        ^ Int32.to_string Int32.max_int
        ^ &quot;)&quot; )</abbr>
  in
  match n with
  | Micheline.Int (_, n') -&gt; <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(
    try
      let n'' = Z.to_int n' in
      if
        Compare.Int.(0 &lt;= n'')
        &amp;&amp; Compare.Int.(n'' &lt;= Int32.to_int Int32.max_int)
      then ok n''
      else error @@ error' ()
    with _ -&gt; error @@ error' () )</abbr>
  | _ -&gt;
      error @@ error' ()

let parse_toplevel :
    legacy:bool -&gt;
    Script.expr -&gt;
    (Script.node * Script.node * Script.node * string option) tzresult =
 fun ~legacy toplevel -&gt;
  record_trace <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Ill_typed_contract (toplevel, []))</abbr>
  @@
  match root toplevel with
  | Int (loc, _) -&gt;
      error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_kind (loc, [Seq_kind], Int_kind))</abbr>
  | String (loc, _) -&gt;
      error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_kind (loc, [Seq_kind], String_kind))</abbr>
  | Bytes (loc, _) -&gt;
      error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_kind (loc, [Seq_kind], Bytes_kind))</abbr>
  | Prim (loc, _, _, _) -&gt;
      error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_kind (loc, [Seq_kind], Prim_kind))</abbr>
  | Seq (_, fields) -&gt; (
      let rec find_fields p s c fields =
        match fields with
        | [] -&gt;
            ok (p, s, c)
        | Int (loc, _) :: _ -&gt;
            error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_kind (loc, [Prim_kind], Int_kind))</abbr>
        | String (loc, _) :: _ -&gt;
            error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_kind (loc, [Prim_kind], String_kind))</abbr>
        | Bytes (loc, _) :: _ -&gt;
            error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_kind (loc, [Prim_kind], Bytes_kind))</abbr>
        | Seq (loc, _) :: _ -&gt;
            error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_kind (loc, [Prim_kind], Seq_kind))</abbr>
        | Prim (loc, K_parameter, [arg], annot) :: rest -&gt; (
          match p with
          | None -&gt;
              find_fields (Some (arg, loc, annot)) s c rest
          | Some _ -&gt;
              error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Duplicate_field (loc, K_parameter))</abbr> )
        | Prim (loc, K_storage, [arg], annot) :: rest -&gt; (
          match s with
          | None -&gt;
              find_fields p (Some (arg, loc, annot)) c rest
          | Some _ -&gt;
              error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Duplicate_field (loc, K_storage))</abbr> )
        | Prim (loc, K_code, [arg], annot) :: rest -&gt; (
          match c with
          | None -&gt;
              find_fields p s (Some (arg, loc, annot)) rest
          | Some _ -&gt;
              error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Duplicate_field (loc, K_code))</abbr> )
        | Prim (loc, ((K_parameter | K_storage | K_code) as name), args, _)
          :: _ -&gt;
            error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_arity (loc, name, 1, List.length args))</abbr>
        | Prim (loc, name, _, _) :: _ -&gt;
            let allowed = [K_parameter; K_storage; K_code] in
            error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_primitive (loc, allowed, name))</abbr>
      in
      find_fields None None None fields
      &gt;&gt;? function
      | (None, _, _) -&gt;
          error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Missing_field K_parameter)</abbr>
      | (Some _, None, _) -&gt;
          error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Missing_field K_storage)</abbr>
      | (Some _, Some _, None) -&gt;
          error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Missing_field K_code)</abbr>
      | (Some (p, ploc, pannot), Some (s, sloc, sannot), Some (c, cloc, carrot))
        -&gt;
          let maybe_root_name =
            (* root name can be attached to either the parameter
                primitive or the toplevel constructor *)
            Script_ir_annot.extract_field_annot p
            &gt;&gt;? fun (p, root_name) -&gt;
            match root_name with
            | Some (Field_annot root_name) -&gt;
                ok (p, pannot, Some root_name)
            | None -&gt; (
              match pannot with
              | [single]
                when Compare.Int.(String.length single &gt; 0)
                     &amp;&amp; Compare.Char.(single.[0] = '%') -&gt;
                  ok
                    ( p,
                      [],
                      Some (String.sub single 1 (String.length single - 1)) )
              | _ -&gt;
                  ok (p, pannot, None) )
          in
          if legacy then
            (* legacy semantics ignores spurious annotations *)
            let (p, root_name) =
              match maybe_root_name with
              | Ok (p, _, root_name) -&gt;
                  (p, root_name)
              | Error _ -&gt;
                  (p, None)
            in
            ok (p, s, c, root_name)
          else
            (* only one field annot is allowed to set the root entrypoint name *)
            maybe_root_name
            &gt;&gt;? fun (p, pannot, root_name) -&gt;
            Script_ir_annot.error_unexpected_annot ploc pannot
            &gt;&gt;? fun () -&gt;
            Script_ir_annot.error_unexpected_annot cloc carrot
            &gt;&gt;? fun () -&gt;
            Script_ir_annot.error_unexpected_annot sloc sannot
            &gt;&gt;? fun () -&gt; ok (p, s, c, root_name) )

let parse_contract :
    type arg.
    legacy:bool -&gt;
    context -&gt;
    Script.location -&gt;
    arg ty -&gt;
    Contract.t -&gt;
    entrypoint:string -&gt;
    (context * arg typed_contract) tzresult Lwt.t =
 fun ~legacy ctxt loc arg contract ~entrypoint -&gt;
  Lwt.return @@ Gas.consume ctxt Typecheck_costs.contract_exists
  &gt;&gt;=? fun ctxt -&gt;
  Contract.exists ctxt contract
  &gt;&gt;=? function
  | false -&gt;
      fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_contract (loc, contract))</abbr>
  | true -&gt; (
      Lwt.return @@ Gas.consume ctxt Typecheck_costs.get_script
      &gt;&gt;=? fun ctxt -&gt;
      trace <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_contract (loc, contract))</abbr>
      @@ Contract.get_script_code ctxt contract
      &gt;&gt;=? fun (ctxt, code) -&gt;
      match code with
      | None -&gt;
          Lwt.return
            ( ty_eq ctxt arg (Unit_t None)
            &gt;&gt;? fun (Eq, ctxt) -&gt;
            match entrypoint with
            | &quot;default&quot; -&gt;
                let contract : arg typed_contract =
                  (arg, (contract, entrypoint))
                in
                ok (ctxt, contract)
            | entrypoint -&gt;
                error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(No_such_entrypoint entrypoint)</abbr> )
      | Some code -&gt;
          Script.force_decode_in_context ctxt code
          &gt;&gt;=? fun (code, ctxt) -&gt;
          Lwt.return
            ( parse_toplevel ~legacy:true code
            &gt;&gt;? fun (arg_type, _, _, root_name) -&gt;
            parse_parameter_ty ctxt ~legacy:true arg_type
            &gt;&gt;? fun (Ex_ty targ, ctxt) -&gt;
            let return ctxt targ entrypoint =
              merge_types ~legacy ctxt loc targ arg
              &gt;&gt;? fun (arg, ctxt) -&gt;
              let contract : arg typed_contract =
                (arg, (contract, entrypoint))
              in
              ok (ctxt, contract)
            in
            find_entrypoint_for_type
              ~full:targ
              ~expected:arg
              ~root_name
              entrypoint
              ctxt
            &gt;&gt;? fun (ctxt, entrypoint, targ) -&gt;
            merge_types ~legacy ctxt loc targ arg
            &gt;&gt;? fun (targ, ctxt) -&gt; return ctxt targ entrypoint ) )

let[@coq_struct &quot;ty&quot;] rec parse_data :
    type a.
    ?type_logger:type_logger -&gt;
    context -&gt;
    legacy:bool -&gt;
    a ty -&gt;
    Script.node -&gt;
    (a * context) tzresult Lwt.t =
 fun ?type_logger ctxt ~legacy ty script_data -&gt;
  Lwt.return (Gas.consume ctxt Typecheck_costs.cycle)
  &gt;&gt;=? fun ctxt -&gt;
  let error () =
    Lwt.return (serialize_ty_for_error ctxt ty)
    &gt;&gt;|? fun (ty, _ctxt) -&gt;
    <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_constant (location script_data, strip_locations script_data, ty)</abbr>
  in
  let traced body = trace_eval error body in
  let parse_items ?type_logger loc ctxt expr key_type value_type items
      item_wrapper =
    let length = List.length items in
    fold_left_s
      (fun (last_value, map, ctxt) item -&gt;
        Lwt.return (Gas.consume ctxt (Typecheck_costs.map_element length))
        &gt;&gt;=? fun ctxt -&gt;
        match item with
        | Prim (_, D_Elt, [k; v], _) -&gt;
            parse_comparable_data ?type_logger ctxt key_type k
            &gt;&gt;=? fun (k, ctxt) -&gt;
            parse_data ?type_logger ctxt ~legacy value_type v
            &gt;&gt;=? fun (v, ctxt) -&gt;
            ( match last_value with
            | Some value -&gt;
                if Compare.Int.(0 &lt;= compare_comparable key_type value k) then
                  if Compare.Int.(0 = compare_comparable key_type value k) then
                    fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Duplicate_map_keys (loc, strip_locations expr))</abbr>
                  else fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Unordered_map_keys (loc, strip_locations expr))</abbr>
                else return_unit
            | None -&gt;
                return_unit )
            &gt;&gt;=? fun () -&gt;
            return (Some k, map_update k (Some (item_wrapper v)) map, ctxt)
        | Prim (loc, D_Elt, l, _) -&gt;
            fail @@ <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_arity (loc, D_Elt, 2, List.length l)</abbr>
        | Prim (loc, name, _, _) -&gt;
            fail @@ <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_primitive (loc, [D_Elt], name)</abbr>
        | Int _ | String _ | Bytes _ | Seq _ -&gt;
            error () &gt;&gt;=? fail)
      (None, empty_map key_type, ctxt)
      items
    |&gt; traced
    &gt;&gt;|? fun (_, items, ctxt) -&gt; (items, ctxt)
  in
  match[@coq_match_gadt_with_result] (ty, script_data) with
  (* Unit *)
  | (Unit_t _, Prim (loc, D_Unit, [], annot)) -&gt;
      (if legacy then return () else fail_unexpected_annot loc annot)
      &gt;&gt;=? fun () -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.unit)
      &gt;&gt;|? fun ctxt -&gt; ((() : a), ctxt)
  | (Unit_t _, Prim (loc, D_Unit, l, _)) -&gt;
      (traced [@coq_implicit &quot;(B := unit)&quot;])
        (fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_arity (loc, D_Unit, 0, List.length l))</abbr>)
  | (Unit_t _, expr) -&gt;
      (traced [@coq_implicit &quot;(B := unit)&quot;])
        (fail (unexpected expr [] Constant_namespace [D_Unit]))
  (* Booleans *)
  | (Bool_t _, Prim (loc, D_True, [], annot)) -&gt;
      (if legacy then return () else fail_unexpected_annot loc annot)
      &gt;&gt;=? fun () -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.bool)
      &gt;&gt;|? fun ctxt -&gt; (true, ctxt)
  | (Bool_t _, Prim (loc, D_False, [], annot)) -&gt;
      (if legacy then return () else fail_unexpected_annot loc annot)
      &gt;&gt;=? fun () -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.bool)
      &gt;&gt;|? fun ctxt -&gt; (false, ctxt)
  | (Bool_t _, Prim (loc, ((D_True | D_False) as c), l, _)) -&gt;
      (traced [@coq_implicit &quot;(B := unit)&quot;])
        (fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_arity (loc, c, 0, List.length l))</abbr>)
  | (Bool_t _, expr) -&gt;
      (traced [@coq_implicit &quot;(B := unit)&quot;])
        (fail (unexpected expr [] Constant_namespace [D_True; D_False]))
  (* Strings *)
  | (String_t _, String (_, v)) -&gt;
      Lwt.return (Gas.consume ctxt (Typecheck_costs.string (String.length v)))
      &gt;&gt;=? fun ctxt -&gt;
      let rec check_printable_ascii i =
        if Compare.Int.(i &lt; 0) then true
        else
          match v.[i] with
          | '\n' | '\x20' .. '\x7E' -&gt;
              check_printable_ascii (i - 1)
          | _ -&gt;
              false
      in
      if check_printable_ascii (String.length v - 1) then return (v, ctxt)
      else error () &gt;&gt;=? fail
  | (String_t _, expr) -&gt;
      (traced [@coq_implicit &quot;(B := unit)&quot;])
        (fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_kind (location expr, [String_kind], kind expr))</abbr>)
  (* Byte sequences *)
  | (Bytes_t _, Bytes (_, v)) -&gt;
      Lwt.return (Gas.consume ctxt (Typecheck_costs.string (MBytes.length v)))
      &gt;&gt;=? fun ctxt -&gt; return (v, ctxt)
  | (Bytes_t _, expr) -&gt;
      (traced [@coq_implicit &quot;(B := unit)&quot;])
        (fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_kind (location expr, [Bytes_kind], kind expr))</abbr>)
  (* Integers *)
  | (Int_t _, Int (_, v)) -&gt;
      Lwt.return (Gas.consume ctxt (Typecheck_costs.z v))
      &gt;&gt;=? fun ctxt -&gt; return (Script_int.of_zint v, ctxt)
  | (Nat_t _, Int (_, v)) -&gt;
      Lwt.return (Gas.consume ctxt (Typecheck_costs.z v))
      &gt;&gt;=? fun ctxt -&gt;
      let v = Script_int.of_zint v in
      if Compare.Int.(Script_int.compare v Script_int.zero &gt;= 0) then
        return (Script_int.abs v, ctxt)
      else error () &gt;&gt;=? fail
  | (Int_t _, expr) -&gt;
      (traced [@coq_implicit &quot;(B := unit)&quot;])
        (fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_kind (location expr, [Int_kind], kind expr))</abbr>)
  | (Nat_t _, expr) -&gt;
      (traced [@coq_implicit &quot;(B := unit)&quot;])
        (fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_kind (location expr, [Int_kind], kind expr))</abbr>)
  (* Tez amounts *)
  | (Mutez_t _, Int (_, v)) -&gt; (
      Lwt.return
        ( Gas.consume ctxt Typecheck_costs.tez
        &gt;&gt;? fun ctxt -&gt;
        Gas.consume ctxt Michelson_v1_gas.Cost_of.Legacy.z_to_int64 )
      &gt;&gt;=? fun ctxt -&gt;
      <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
        match Tez.of_mutez (Z.to_int64 v) with
        | None -&gt;
            raise </abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Values of extensible types are ignored.

They are sent to a unit type.">Exit</abbr><abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">
        | Some tez -&gt;
            return (tez, ctxt)
      with _ -&gt; error () &gt;&gt;=? fail</abbr> )
  | (Mutez_t _, expr) -&gt;
      (traced [@coq_implicit &quot;(B := unit)&quot;])
        (fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_kind (location expr, [Int_kind], kind expr))</abbr>)
  (* Timestamps *)
  | (Timestamp_t _, Int (_, v))
  (* As unparsed with [Optimized] or out of bounds [Readable]. *) -&gt;
      Lwt.return (Gas.consume ctxt (Typecheck_costs.z v))
      &gt;&gt;=? fun ctxt -&gt; return (Script_timestamp.of_zint v, ctxt)
  | (Timestamp_t _, String (_, s)) (* As unparsed with [Redable]. *) -&gt; (
      Lwt.return (Gas.consume ctxt Typecheck_costs.string_timestamp)
      &gt;&gt;=? fun ctxt -&gt;
      match Script_timestamp.of_string s with
      | Some v -&gt;
          return (v, ctxt)
      | None -&gt;
          error () &gt;&gt;=? fail )
  | (Timestamp_t _, expr) -&gt;
      (traced [@coq_implicit &quot;(B := unit)&quot;])
        (fail
           <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_kind (location expr, [String_kind; Int_kind], kind expr))</abbr>)
  (* IDs *)
  | (Key_t _, Bytes (_, bytes)) -&gt; (
      (* As unparsed with [Optimized]. *)
      Lwt.return (Gas.consume ctxt Typecheck_costs.key)
      &gt;&gt;=? fun ctxt -&gt;
      match
        Data_encoding.Binary.of_bytes Signature.Public_key.encoding bytes
      with
      | Some k -&gt;
          return (k, ctxt)
      | None -&gt;
          error () &gt;&gt;=? fail )
  | (Key_t _, String (_, s)) -&gt; (
      (* As unparsed with [Readable]. *)
      Lwt.return (Gas.consume ctxt Typecheck_costs.key)
      &gt;&gt;=? fun ctxt -&gt;
      match Signature.Public_key.of_b58check_opt s with
      | Some k -&gt;
          return (k, ctxt)
      | None -&gt;
          error () &gt;&gt;=? fail )
  | (Key_t _, expr) -&gt;
      (traced [@coq_implicit &quot;(B := unit)&quot;])
        (fail
           <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_kind (location expr, [String_kind; Bytes_kind], kind expr))</abbr>)
  | (Key_hash_t _, Bytes (_, bytes)) -&gt; (
      (* As unparsed with [Optimized]. *)
      Lwt.return (Gas.consume ctxt Typecheck_costs.key_hash)
      &gt;&gt;=? fun ctxt -&gt;
      match
        Data_encoding.Binary.of_bytes Signature.Public_key_hash.encoding bytes
      with
      | Some k -&gt;
          return (k, ctxt)
      | None -&gt;
          error () &gt;&gt;=? fail )
  | (Key_hash_t _, String (_, s)) (* As unparsed with [Readable]. *) -&gt; (
      Lwt.return (Gas.consume ctxt Typecheck_costs.key_hash)
      &gt;&gt;=? fun ctxt -&gt;
      match Signature.Public_key_hash.of_b58check_opt s with
      | Some k -&gt;
          return (k, ctxt)
      | None -&gt;
          error () &gt;&gt;=? fail )
  | (Key_hash_t _, expr) -&gt;
      (traced [@coq_implicit &quot;(B := unit)&quot;])
        (fail
           <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_kind (location expr, [String_kind; Bytes_kind], kind expr))</abbr>)
  (* Signatures *)
  | (Signature_t _, Bytes (_, bytes)) (* As unparsed with [Optimized]. *) -&gt; (
      Lwt.return (Gas.consume ctxt Typecheck_costs.signature)
      &gt;&gt;=? fun ctxt -&gt;
      match Data_encoding.Binary.of_bytes Signature.encoding bytes with
      | Some k -&gt;
          return (k, ctxt)
      | None -&gt;
          error () &gt;&gt;=? fail )
  | (Signature_t _, String (_, s)) (* As unparsed with [Readable]. *) -&gt; (
      Lwt.return (Gas.consume ctxt Typecheck_costs.signature)
      &gt;&gt;=? fun ctxt -&gt;
      match Signature.of_b58check_opt s with
      | Some s -&gt;
          return (s, ctxt)
      | None -&gt;
          error () &gt;&gt;=? fail )
  | (Signature_t _, expr) -&gt;
      (traced [@coq_implicit &quot;(B := unit)&quot;])
        (fail
           <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_kind (location expr, [String_kind; Bytes_kind], kind expr))</abbr>)
  (* Operations *)
  | (Operation_t _, _) -&gt;
      (* operations cannot appear in parameters or storage,
           the protocol should never parse the bytes of an operation *)
      <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
  (* Chain_ids *)
  | (Chain_id_t _, Bytes (_, bytes)) -&gt; (
      Lwt.return (Gas.consume ctxt Typecheck_costs.chain_id)
      &gt;&gt;=? fun ctxt -&gt;
      match Data_encoding.Binary.of_bytes Chain_id.encoding bytes with
      | Some k -&gt;
          return (k, ctxt)
      | None -&gt;
          error () &gt;&gt;=? fail )
  | (Chain_id_t _, String (_, s)) -&gt; (
      Lwt.return (Gas.consume ctxt Typecheck_costs.chain_id)
      &gt;&gt;=? fun ctxt -&gt;
      match Chain_id.of_b58check_opt s with
      | Some s -&gt;
          return (s, ctxt)
      | None -&gt;
          error () &gt;&gt;=? fail )
  | (Chain_id_t _, expr) -&gt;
      (traced [@coq_implicit &quot;(B := unit)&quot;])
        (fail
           <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_kind (location expr, [String_kind; Bytes_kind], kind expr))</abbr>)
  (* Addresses *)
  | (Address_t _, Bytes (loc, bytes)) (* As unparsed with [O[ptimized]. *) -&gt; (
      Lwt.return (Gas.consume ctxt Typecheck_costs.contract)
      &gt;&gt;=? fun ctxt -&gt;
      match
        Data_encoding.Binary.of_bytes
          Data_encoding.(tup2 Contract.encoding Variable.string)
          bytes
      with
      | Some (c, entrypoint) -&gt;
          if Compare.Int.(String.length entrypoint &gt; 31) then
            fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Entrypoint_name_too_long entrypoint)</abbr>
          else
            ( match entrypoint with
            | &quot;&quot; -&gt;
                return &quot;default&quot;
            | &quot;default&quot; -&gt;
                fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Unexpected_annotation loc)</abbr>
            | name -&gt;
                return name )
            &gt;&gt;=? fun entrypoint -&gt; return ((c, entrypoint), ctxt)
      | None -&gt;
          error () &gt;&gt;=? fail )
  | (Address_t _, String (loc, s)) (* As unparsed with [Readable]. *) -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.contract)
      &gt;&gt;=? fun ctxt -&gt;
      ( match String.index_opt s '%' with
      | None -&gt;
          return (s, &quot;default&quot;)
      | Some pos -&gt; (
          let len = String.length s - pos - 1 in
          let name = String.sub s (pos + 1) len in
          if Compare.Int.(len &gt; 31) then fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Entrypoint_name_too_long name)</abbr>
          else
            match (String.sub s 0 pos, name) with
            | (_, &quot;default&quot;) -&gt;
                traced (fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Unexpected_annotation loc)</abbr>)
            | addr_and_name -&gt;
                return addr_and_name ) )
      &gt;&gt;=? fun (addr, entrypoint) -&gt;
      Lwt.return (Contract.of_b58check addr)
      &gt;&gt;=? fun c -&gt; return ((c, entrypoint), ctxt)
  | (Address_t _, expr) -&gt;
      (traced [@coq_implicit &quot;(B := unit)&quot;])
        (fail
           <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_kind (location expr, [String_kind; Bytes_kind], kind expr))</abbr>)
  (* Contracts *)
  | (Contract_t (ty, _), Bytes (loc, bytes))
  (* As unparsed with [Optimized]. *) -&gt; (
      Lwt.return (Gas.consume ctxt Typecheck_costs.contract)
      &gt;&gt;=? fun ctxt -&gt;
      match
        Data_encoding.Binary.of_bytes
          Data_encoding.(tup2 Contract.encoding Variable.string)
          bytes
      with
      | Some (c, entrypoint) -&gt;
          if Compare.Int.(String.length entrypoint &gt; 31) then
            fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Entrypoint_name_too_long entrypoint)</abbr>
          else
            ( match entrypoint with
            | &quot;&quot; -&gt;
                return &quot;default&quot;
            | &quot;default&quot; -&gt;
                traced (fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Unexpected_annotation loc)</abbr>)
            | name -&gt;
                return name )
            &gt;&gt;=? fun entrypoint -&gt;
            traced (parse_contract ~legacy ctxt loc ty c ~entrypoint)
            &gt;&gt;=? fun (ctxt, _) -&gt; return ((ty, (c, entrypoint)), ctxt)
      | None -&gt;
          error () &gt;&gt;=? fail )
  | (Contract_t (ty, _), String (loc, s)) (* As unparsed with [Readable]. *) -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.contract)
      &gt;&gt;=? fun ctxt -&gt;
      ( match String.index_opt s '%' with
      | None -&gt;
          return (s, &quot;default&quot;)
      | Some pos -&gt; (
          let len = String.length s - pos - 1 in
          let name = String.sub s (pos + 1) len in
          if Compare.Int.(len &gt; 31) then fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Entrypoint_name_too_long name)</abbr>
          else
            match (String.sub s 0 pos, name) with
            | (_, &quot;default&quot;) -&gt;
                traced (fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Unexpected_annotation loc)</abbr>)
            | addr_and_name -&gt;
                return addr_and_name ) )
      &gt;&gt;=? fun (addr, entrypoint) -&gt;
      traced (Lwt.return (Contract.of_b58check addr))
      &gt;&gt;=? fun c -&gt;
      parse_contract ~legacy ctxt loc ty c ~entrypoint
      &gt;&gt;=? fun (ctxt, _) -&gt; return ((ty, (c, entrypoint)), ctxt)
  | (Contract_t _, expr) -&gt;
      (traced [@coq_implicit &quot;(B := unit)&quot;])
        (fail
           <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_kind (location expr, [String_kind; Bytes_kind], kind expr))</abbr>)
  (* Pairs *)
  | (Pair_t ((ta, _, _), (tb, _, _), _, _), Prim (loc, D_Pair, [va; vb], annot))
    -&gt;
      (if legacy then return () else fail_unexpected_annot loc annot)
      &gt;&gt;=? fun () -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.pair)
      &gt;&gt;=? fun ctxt -&gt;
      traced
      @@ (parse_data [@coq_implicit &quot;(a := unit)&quot;])
           ?type_logger
           ctxt
           ~legacy
           ta
           va
      &gt;&gt;=? fun (va, ctxt) -&gt;
      (parse_data [@coq_implicit &quot;(a := unit)&quot;])
        ?type_logger
        ctxt
        ~legacy
        tb
        vb
      &gt;&gt;=? fun (vb, ctxt) -&gt; return ((va, vb), ctxt)
  | (Pair_t _, Prim (loc, D_Pair, l, _)) -&gt;
      (fail [@coq_implicit &quot;(a := unit)&quot;])
      @@ <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_arity (loc, D_Pair, 2, List.length l)</abbr>
  | (Pair_t _, expr) -&gt;
      (traced [@coq_implicit &quot;(B := unit)&quot;])
        (fail (unexpected expr [] Constant_namespace [D_Pair]))
  (* Unions *)
  | (Union_t ((tl, _), _, _, _), Prim (loc, D_Left, [v], annot)) -&gt;
      (if legacy then return () else fail_unexpected_annot loc annot)
      &gt;&gt;=? fun () -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.union)
      &gt;&gt;=? fun ctxt -&gt;
      traced
      @@ (parse_data [@coq_implicit &quot;(a := unit)&quot;])
           ?type_logger
           ctxt
           ~legacy
           tl
           v
      &gt;&gt;=? fun (v, ctxt) -&gt; return ((L v [@coq_implicit &quot;(b := unit)&quot;]), ctxt)
  | (Union_t _, Prim (loc, D_Left, l, _)) -&gt;
      (fail [@coq_implicit &quot;(a := unit)&quot;])
      @@ <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_arity (loc, D_Left, 1, List.length l)</abbr>
  | (Union_t (_, (tr, _), _, _), Prim (loc, D_Right, [v], annot)) -&gt;
      fail_unexpected_annot loc annot
      &gt;&gt;=? fun () -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.union)
      &gt;&gt;=? fun ctxt -&gt;
      traced
      @@ (parse_data [@coq_implicit &quot;(a := unit)&quot;])
           ?type_logger
           ctxt
           ~legacy
           tr
           v
      &gt;&gt;=? fun (v, ctxt) -&gt; return ((R v [@coq_implicit &quot;(a := unit)&quot;]), ctxt)
  | (Union_t _, Prim (loc, D_Right, l, _)) -&gt;
      (fail [@coq_implicit &quot;(a := unit)&quot;])
      @@ <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_arity (loc, D_Right, 1, List.length l)</abbr>
  | (Union_t _, expr) -&gt;
      (traced [@coq_implicit &quot;(B := unit)&quot;])
        (fail (unexpected expr [] Constant_namespace [D_Left; D_Right]))
  (* Lambdas *)
  | (Lambda_t (ta, tr, _ty_name), (Seq (_loc, _) as script_instr)) -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.lambda)
      &gt;&gt;=? fun ctxt -&gt;
      traced
      @@ parse_returning
           Lambda
           ?type_logger
           ctxt
           ~legacy
           (ta, Some (Var_annot &quot;@arg&quot;))
           tr
           script_instr
  | (Lambda_t _, expr) -&gt;
      (traced [@coq_implicit &quot;(B := unit)&quot;])
        (fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_kind (location expr, [Seq_kind], kind expr))</abbr>)
  (* Options *)
  | (Option_t (t, _, _), Prim (loc, D_Some, [v], annot)) -&gt;
      (if legacy then return () else fail_unexpected_annot loc annot)
      &gt;&gt;=? fun () -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.some)
      &gt;&gt;=? fun ctxt -&gt;
      traced
      @@ (parse_data [@coq_implicit &quot;(a := unit)&quot;])
           ?type_logger
           ctxt
           ~legacy
           t
           v
      &gt;&gt;=? fun (v, ctxt) -&gt; return (Some v, ctxt)
  | (Option_t _, Prim (loc, D_Some, l, _)) -&gt;
      (fail [@coq_implicit &quot;(a := unit)&quot;])
      @@ <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_arity (loc, D_Some, 1, List.length l)</abbr>
  | (Option_t (_, _, _), Prim (loc, D_None, [], annot)) -&gt;
      (if legacy then return () else fail_unexpected_annot loc annot)
      &gt;&gt;=? fun () -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.none)
      &gt;&gt;=? fun ctxt -&gt; return ((None [@coq_implicit &quot;(A := unit)&quot;]), ctxt)
  | (Option_t _, Prim (loc, D_None, l, _)) -&gt;
      (fail [@coq_implicit &quot;(a := unit)&quot;])
      @@ <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_arity (loc, D_None, 0, List.length l)</abbr>
  | (Option_t _, expr) -&gt;
      (traced [@coq_implicit &quot;(B := unit)&quot;])
        (fail (unexpected expr [] Constant_namespace [D_Some; D_None]))
  (* Lists *)
  | (List_t (t, _ty_name, _), Seq (_loc, items)) -&gt;
      traced
      @@ fold_right_s
           (fun v (rest, ctxt) -&gt;
             Lwt.return (Gas.consume ctxt Typecheck_costs.list_element)
             &gt;&gt;=? fun ctxt -&gt;
             (parse_data [@coq_implicit &quot;(a := unit)&quot;])
               ?type_logger
               ctxt
               ~legacy
               t
               v
             &gt;&gt;=? fun (v, ctxt) -&gt; return (v :: rest, ctxt))
           items
           ([], ctxt)
  | (List_t _, expr) -&gt;
      (traced [@coq_implicit &quot;(B := unit)&quot;])
        (fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_kind (location expr, [Seq_kind], kind expr))</abbr>)
  (* Sets *)
  | (Set_t (t, _ty_name), (Seq (loc, vs) as expr)) -&gt;
      let length = List.length vs in
      traced
      @@ fold_left_s
           (fun (last_value, set, ctxt) v -&gt;
             Lwt.return (Gas.consume ctxt (Typecheck_costs.set_element length))
             &gt;&gt;=? fun ctxt -&gt;
             (parse_comparable_data [@coq_implicit &quot;(a := unit)&quot;])
               ?type_logger
               ctxt
               t
               v
             &gt;&gt;=? fun (v, ctxt) -&gt;
             ( match last_value with
             | Some value -&gt;
                 if Compare.Int.(0 &lt;= compare_comparable t value v) then
                   if Compare.Int.(0 = compare_comparable t value v) then
                     fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Duplicate_set_values (loc, strip_locations expr))</abbr>
                   else fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Unordered_set_values (loc, strip_locations expr))</abbr>
                 else return_unit
             | None -&gt;
                 return_unit )
             &gt;&gt;=? fun () -&gt;
             Lwt.return
               (Gas.consume
                  ctxt
                  (Michelson_v1_gas.Cost_of.Legacy.set_update v false set))
             &gt;&gt;=? fun ctxt -&gt; return (Some v, set_update v true set, ctxt))
           (None, empty_set t, ctxt)
           vs
      &gt;&gt;|? fun (_, set, ctxt) -&gt; (set, ctxt)
  | (Set_t _, expr) -&gt;
      (traced [@coq_implicit &quot;(B := unit)&quot;])
        (fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_kind (location expr, [Seq_kind], kind expr))</abbr>)
  (* Maps *)
  | (Map_t (tk, tv, _ty_name, _), (Seq (loc, vs) as expr)) -&gt;
      (parse_items [@coq_implicit &quot;(D := option unit) (E := unit)&quot;])
        ?type_logger
        loc
        ctxt
        expr
        tk
        tv
        vs
        (fun x -&gt; x)
  | (Map_t _, expr) -&gt;
      (traced [@coq_implicit &quot;(B := unit)&quot;])
        (fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_kind (location expr, [Seq_kind], kind expr))</abbr>)
  | (Big_map_t (tk, tv, _ty_name), (Seq (loc, vs) as expr)) -&gt;
      (parse_items [@coq_implicit &quot;(D := option unit) (E := unit)&quot;])
        ?type_logger
        loc
        ctxt
        expr
        tk
        tv
        vs
        (fun x -&gt; Some x)
      &gt;&gt;|? fun (diff, ctxt) -&gt;
      ( {
          id = (None [@coq_implicit &quot;(A := unit)&quot;]);
          diff;
          key_type = ty_of_comparable_ty tk;
          value_type = tv;
        },
        ctxt )
  | (Big_map_t (tk, tv, _ty_name), Int (loc, id)) -&gt; (
      Big_map.exists ctxt id
      &gt;&gt;=? function
      | (_, None) -&gt;
          traced (fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_big_map (loc, id))</abbr>)
      | (ctxt, Some (btk, btv)) -&gt;
          Lwt.return
            ( parse_comparable_ty ctxt (Micheline.root btk)
            &gt;&gt;? fun (Ex_comparable_ty btk, ctxt) -&gt;
            parse_packable_ty ctxt ~legacy (Micheline.root btv)
            &gt;&gt;? fun (Ex_ty btv, ctxt) -&gt;
            comparable_ty_eq ctxt tk btk
            &gt;&gt;? fun Eq -&gt;
            ty_eq ctxt tv btv
            &gt;&gt;? fun (Eq, ctxt) -&gt;
            ok
              ( {
                  id = Some id;
                  diff =
                    (empty_map [@coq_implicit &quot;(a := unit) (b := unit)&quot;]) tk;
                  key_type = ty_of_comparable_ty tk;
                  value_type = tv;
                },
                ctxt ) ) )
  | (Big_map_t (_tk, _tv, _), expr) -&gt;
      (traced [@coq_implicit &quot;(B := unit)&quot;])
        (fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_kind (location expr, [Seq_kind; Int_kind], kind expr))</abbr>)

and parse_comparable_data :
    type a.
    ?type_logger:type_logger -&gt;
    context -&gt;
    a comparable_ty -&gt;
    Script.node -&gt;
    (a * context) tzresult Lwt.t =
 fun ?type_logger ctxt ty script_data -&gt;
  parse_data
    ?type_logger
    ctxt
    ~legacy:false
    (ty_of_comparable_ty ty)
    script_data

and parse_returning :
    type arg ret.
    ?type_logger:type_logger -&gt;
    tc_context -&gt;
    context -&gt;
    legacy:bool -&gt;
    arg ty * var_annot option -&gt;
    ret ty -&gt;
    Script.node -&gt;
    ((arg, ret) lambda * context) tzresult Lwt.t =
 fun ?type_logger tc_context ctxt ~legacy (arg, arg_annot) ret script_instr -&gt;
  parse_instr
    ?type_logger
    tc_context
    ctxt
    ~legacy
    script_instr
    (Item_t (arg, Empty_t, arg_annot))
  &gt;&gt;=? function
  | (Typed ({loc; aft = Item_t (ty, Empty_t, _) as stack_ty; _} as descr), ctxt)
    -&gt;
      trace_eval
        (fun () -&gt;
          Lwt.return (serialize_ty_for_error ctxt ret)
          &gt;&gt;=? fun (ret, ctxt) -&gt;
          serialize_stack_for_error ctxt stack_ty
          &gt;&gt;|? fun (stack_ty, _ctxt) -&gt; <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Bad_return (loc, stack_ty, ret)</abbr>)
        ( Lwt.return (ty_eq ctxt ty ret)
        &gt;&gt;=? fun (Eq, ctxt) -&gt;
        Lwt.return (merge_types ~legacy ctxt loc ty ret)
        &gt;&gt;=? fun (_ret, ctxt) -&gt;
        return (({lam = (descr, script_instr)} : (arg, ret) lambda), ctxt) )
  | (Typed {loc; aft = stack_ty; _}, ctxt) -&gt;
      Lwt.return (serialize_ty_for_error ctxt ret)
      &gt;&gt;=? fun (ret, ctxt) -&gt;
      serialize_stack_for_error ctxt stack_ty
      &gt;&gt;=? fun (stack_ty, _ctxt) -&gt; fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Bad_return (loc, stack_ty, ret))</abbr>
  | (Failed {descr}, ctxt) -&gt;
      return
        ( ( {lam = (descr (Item_t (ret, Empty_t, None)), script_instr)}
            : (arg, ret) lambda ),
          ctxt )

and parse_instr :
    type bef.
    ?type_logger:type_logger -&gt;
    tc_context -&gt;
    context -&gt;
    legacy:bool -&gt;
    Script.node -&gt;
    bef stack_ty -&gt;
    (bef judgement * context) tzresult Lwt.t =
 fun ?type_logger tc_context ctxt ~legacy script_instr stack_ty -&gt;
  let _check_item check loc name n m =
    trace_eval (fun () -&gt;
        serialize_stack_for_error ctxt stack_ty
        &gt;&gt;|? fun (stack_ty, _ctxt) -&gt; <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Bad_stack (loc, name, m, stack_ty)</abbr>)
    @@ trace <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Bad_stack_item n)</abbr> @@ Lwt.return check
  in
  let check_item_ty (type a b) ctxt (exp : a ty) (got : b ty) loc name n m :
      ((a, b) eq * a ty * context) tzresult Lwt.t =
    trace_eval (fun () -&gt;
        serialize_stack_for_error ctxt stack_ty
        &gt;&gt;|? fun (stack_ty, _ctxt) -&gt; <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Bad_stack (loc, name, m, stack_ty)</abbr>)
    @@ trace <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Bad_stack_item n)</abbr>
    @@ Lwt.return
         ( ty_eq ctxt exp got
         &gt;&gt;? fun (Eq, ctxt) -&gt;
         merge_types ~legacy ctxt loc exp got
         &gt;&gt;? fun (ty, ctxt) -&gt; ok ((Eq : (a, b) eq), (ty : a ty), ctxt) )
  in
  let check_item_comparable_ty (type a b) (exp : a comparable_ty)
      (got : b comparable_ty) loc name n m :
      ((a, b) eq * a comparable_ty) tzresult Lwt.t =
    trace_eval (fun () -&gt;
        serialize_stack_for_error ctxt stack_ty
        &gt;&gt;|? fun (stack_ty, _ctxt) -&gt; <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Bad_stack (loc, name, m, stack_ty)</abbr>)
    @@ trace <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Bad_stack_item n)</abbr>
    @@ Lwt.return
         ( comparable_ty_eq ctxt exp got
         &gt;&gt;? fun Eq -&gt;
         merge_comparable_types ~legacy exp got
         &gt;&gt;? fun ty -&gt; ok ((Eq : (a, b) eq), (ty : a comparable_ty)) )
  in
  let log_stack ctxt loc stack_ty aft =
    match (type_logger, script_instr) with
    | (None, _) | (Some _, (Seq (-1, _) | Int _ | String _ | Bytes _)) -&gt;
        return_unit
    | (Some log, (Prim _ | Seq _)) -&gt;
        (* Unparsing for logging done in an unlimited context as this
             is used only by the client and not the protocol *)
        let ctxt = Gas.set_unlimited ctxt in
        unparse_stack ctxt stack_ty
        &gt;&gt;=? fun (stack_ty, _) -&gt;
        unparse_stack ctxt aft
        &gt;&gt;=? fun (aft, _) -&gt; <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">log loc stack_ty aft</abbr> ; return_unit
  in
  let outer_return = return in
  let return :
      type bef.
      context -&gt; bef judgement -&gt; (bef judgement * context) tzresult Lwt.t =
   fun ctxt judgement -&gt;
    match judgement with
    | Typed {instr; loc; aft; _} -&gt;
        let maximum_type_size = Constants.michelson_maximum_type_size ctxt in
        let type_size =
          type_size_of_stack_head
            aft
            ~up_to:(number_of_generated_growing_types instr)
        in
        if Compare.Int.(type_size &gt; maximum_type_size) then
          fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Type_too_large (loc, type_size, maximum_type_size))</abbr>
        else return (judgement, ctxt)
    | Failed _ -&gt;
        return (judgement, ctxt)
  in
  let typed ctxt loc instr aft =
    log_stack ctxt loc stack_ty aft
    &gt;&gt;=? fun () -&gt;
    Lwt.return @@ Gas.consume ctxt (Typecheck_costs.instr instr)
    &gt;&gt;=? fun ctxt -&gt; return ctxt (Typed {loc; instr; bef = stack_ty; aft})
  in
  Lwt.return @@ Gas.consume ctxt Typecheck_costs.cycle
  &gt;&gt;=? fun ctxt -&gt;
  match (script_instr, stack_ty) with
  (* stack ops *)
  | (Prim (loc, I_DROP, [], annot), Item_t (_, rest, _)) -&gt;
      ( fail_unexpected_annot loc annot &gt;&gt;=? fun () -&gt; typed ctxt loc Drop rest
        : (bef judgement * context) tzresult Lwt.t )
  | (Prim (loc, I_DROP, [n], result_annot), whole_stack) -&gt;
      Lwt.return (parse_int32 n)
      &gt;&gt;=? fun whole_n -&gt;
      let rec make_proof_argument :
          type tstk.
          int -&gt; tstk stack_ty -&gt; tstk dropn_proof_argument tzresult Lwt.t =
       fun n stk -&gt;
        match (Compare.Int.(n = 0), stk) with
        | (true, rest) -&gt;
            outer_return @@ Dropn_proof_argument (Rest, rest, rest)
        | (false, Item_t (v, rest, annot)) -&gt;
            make_proof_argument (n - 1) rest
            &gt;&gt;=? fun (Dropn_proof_argument (n', stack_after_drops, aft')) -&gt;
            outer_return
            @@ Dropn_proof_argument
                 (Prefix n', stack_after_drops, Item_t (v, aft', annot))
        | (_, _) -&gt;
            serialize_stack_for_error ctxt whole_stack
            &gt;&gt;=? fun (whole_stack, _ctxt) -&gt;
            fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Bad_stack (loc, I_DROP, whole_n, whole_stack))</abbr>
      in
      fail_unexpected_annot loc result_annot
      &gt;&gt;=? fun () -&gt;
      make_proof_argument whole_n whole_stack
      &gt;&gt;=? fun (Dropn_proof_argument (n', stack_after_drops, _aft)) -&gt;
      typed ctxt loc (Dropn (whole_n, n')) stack_after_drops
  | (Prim (loc, I_DROP, (_ :: _ :: _ as l), _), _) -&gt;
      (* Technically, the arities 0 and 1 are allowed but the error only mentions 1.
           However, DROP is equivalent to DROP 1 so hinting at an arity of 1 makes sense. *)
      fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_arity (loc, I_DROP, 1, List.length l))</abbr>
  | (Prim (loc, I_DUP, [], annot), Item_t (v, rest, stack_annot)) -&gt;
      parse_var_annot loc annot ~default:stack_annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Dup (Item_t (v, Item_t (v, rest, stack_annot), annot))
  | (Prim (loc, I_DIG, [n], result_annot), stack) -&gt;
      let rec make_proof_argument :
          type tstk.
          int -&gt; tstk stack_ty -&gt; tstk dig_proof_argument tzresult Lwt.t =
       fun n stk -&gt;
        match (Compare.Int.(n = 0), stk) with
        | (true, Item_t (v, rest, annot)) -&gt;
            outer_return @@ Dig_proof_argument (Rest, (v, annot), rest)
        | (false, Item_t (v, rest, annot)) -&gt;
            make_proof_argument (n - 1) rest
            &gt;&gt;=? fun (Dig_proof_argument (n', (x, xv), aft')) -&gt;
            outer_return
            @@ Dig_proof_argument (Prefix n', (x, xv), Item_t (v, aft', annot))
        | (_, _) -&gt;
            serialize_stack_for_error ctxt stack
            &gt;&gt;=? fun (whole_stack, _ctxt) -&gt;
            fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Bad_stack (loc, I_DIG, 1, whole_stack))</abbr>
      in
      Lwt.return (parse_int32 n)
      &gt;&gt;=? fun n -&gt;
      fail_unexpected_annot loc result_annot
      &gt;&gt;=? fun () -&gt;
      make_proof_argument n stack
      &gt;&gt;=? fun (Dig_proof_argument (n', (x, stack_annot), aft)) -&gt;
      typed ctxt loc (Dig (n, n')) (Item_t (x, aft, stack_annot))
  | (Prim (loc, I_DIG, (([] | _ :: _ :: _) as l), _), _) -&gt;
      fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_arity (loc, I_DIG, 1, List.length l))</abbr>
  | (Prim (loc, I_DUG, [n], result_annot), Item_t (x, whole_stack, stack_annot))
    -&gt;
      Lwt.return (parse_int32 n)
      &gt;&gt;=? fun whole_n -&gt;
      let rec make_proof_argument :
          type tstk x_t.
          int -&gt;
          x_t ty -&gt;
          var_annot option -&gt;
          tstk stack_ty -&gt;
          (tstk, x_t) dug_proof_argument tzresult Lwt.t =
       fun n x stack_annot stk -&gt;
        match (Compare.Int.(n = 0), stk) with
        | (true, rest) -&gt;
            outer_return
            @@ Dug_proof_argument (Rest, (), Item_t (x, rest, stack_annot))
        | (false, Item_t (v, rest, annot)) -&gt;
            make_proof_argument (n - 1) x stack_annot rest
            &gt;&gt;=? fun (Dug_proof_argument (n', (), aft')) -&gt;
            outer_return
            @@ Dug_proof_argument (Prefix n', (), Item_t (v, aft', annot))
        | (_, _) -&gt;
            serialize_stack_for_error ctxt whole_stack
            &gt;&gt;=? fun (whole_stack, _ctxt) -&gt;
            fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Bad_stack (loc, I_DUG, whole_n, whole_stack))</abbr>
      in
      fail_unexpected_annot loc result_annot
      &gt;&gt;=? fun () -&gt;
      make_proof_argument whole_n x stack_annot whole_stack
      &gt;&gt;=? fun (Dug_proof_argument (n', (), aft)) -&gt;
      typed ctxt loc (Dug (whole_n, n')) aft
  | (Prim (loc, I_DUG, [_], result_annot), (Empty_t as stack)) -&gt;
      fail_unexpected_annot loc result_annot
      &gt;&gt;=? fun () -&gt;
      serialize_stack_for_error ctxt stack
      &gt;&gt;=? fun (stack, _ctxt) -&gt; fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Bad_stack (loc, I_DUG, 1, stack))</abbr>
  | (Prim (loc, I_DUG, (([] | _ :: _ :: _) as l), _), _) -&gt;
      fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_arity (loc, I_DUG, 1, List.length l))</abbr>
  | ( Prim (loc, I_SWAP, [], annot),
      Item_t (v, Item_t (w, rest, stack_annot), cur_top_annot) ) -&gt;
      fail_unexpected_annot loc annot
      &gt;&gt;=? fun () -&gt;
      typed
        ctxt
        loc
        Swap
        (Item_t (w, Item_t (v, rest, cur_top_annot), stack_annot))
  | (Prim (loc, I_PUSH, [t; d], annot), stack) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ parse_packable_ty ctxt ~legacy t
      &gt;&gt;=? fun (Ex_ty t, ctxt) -&gt;
      (parse_data [@coq_implicit &quot;(a := unit)&quot;]) ?type_logger ctxt ~legacy t d
      &gt;&gt;=? fun (v, ctxt) -&gt; typed ctxt loc (Const v) (Item_t (t, stack, annot))
  | (Prim (loc, I_UNIT, [], annot), stack) -&gt;
      parse_var_type_annot loc annot
      &gt;&gt;=? fun (annot, ty_name) -&gt;
      typed ctxt loc (Const ()) (Item_t (Unit_t ty_name, stack, annot))
  (* options *)
  | (Prim (loc, I_SOME, [], annot), Item_t (t, rest, _)) -&gt;
      parse_var_type_annot loc annot
      &gt;&gt;=? fun (annot, ty_name) -&gt;
      typed
        ctxt
        loc
        Cons_some
        (Item_t (Option_t (t, ty_name, has_big_map t), rest, annot))
  | (Prim (loc, I_NONE, [t], annot), stack) -&gt;
      Lwt.return @@ parse_any_ty ctxt ~legacy t
      &gt;&gt;=? fun (Ex_ty t, ctxt) -&gt;
      parse_var_type_annot loc annot
      &gt;&gt;=? fun (annot, ty_name) -&gt;
      typed
        ctxt
        loc
        (Cons_none t)
        (Item_t (Option_t (t, ty_name, has_big_map t), stack, annot))
  | ( Prim (loc, I_IF_NONE, [bt; bf], annot),
      (Item_t (Option_t (t, _, _), rest, option_annot) as bef) ) -&gt;
      check_kind [Seq_kind] bt
      &gt;&gt;=? fun () -&gt;
      check_kind [Seq_kind] bf
      &gt;&gt;=? fun () -&gt;
      fail_unexpected_annot loc annot
      &gt;&gt;=? fun () -&gt;
      let annot = gen_access_annot option_annot default_some_annot in
      parse_instr ?type_logger tc_context ctxt ~legacy bt rest
      &gt;&gt;=? fun (btr, ctxt) -&gt;
      parse_instr
        ?type_logger
        tc_context
        ctxt
        ~legacy
        bf
        (Item_t (t, rest, annot))
      &gt;&gt;=? fun (bfr, ctxt) -&gt;
      let branch ibt ibf =
        {loc; instr = If_none (ibt, ibf); bef; aft = ibt.aft}
      in
      merge_branches ~legacy ctxt loc btr bfr {branch}
      &gt;&gt;=? fun (judgement, ctxt) -&gt; return ctxt judgement
  (* pairs *)
  | ( Prim (loc, I_PAIR, [], annot),
      Item_t (a, Item_t (b, rest, snd_annot), fst_annot) ) -&gt;
      parse_constr_annot
        loc
        annot
        ~if_special_first:(var_to_field_annot fst_annot)
        ~if_special_second:(var_to_field_annot snd_annot)
      &gt;&gt;=? fun (annot, ty_name, l_field, r_field) -&gt;
      typed
        ctxt
        loc
        Cons_pair
        (Item_t
           ( Pair_t
               ( (a, l_field, fst_annot),
                 (b, r_field, snd_annot),
                 ty_name,
                 has_big_map a || has_big_map b ),
             rest,
             annot ))
  | ( Prim (loc, I_CAR, [], annot),
      Item_t
        (Pair_t ((a, expected_field_annot, a_annot), _, _, _), rest, pair_annot)
    ) -&gt;
      parse_destr_annot
        loc
        annot
        ~pair_annot
        ~value_annot:a_annot
        ~field_name:expected_field_annot
        ~default_accessor:default_car_annot
      &gt;&gt;=? fun (annot, field_annot) -&gt;
      Lwt.return @@ check_correct_field field_annot expected_field_annot
      &gt;&gt;=? fun () -&gt; typed ctxt loc Car (Item_t (a, rest, annot))
  | ( Prim (loc, I_CDR, [], annot),
      Item_t
        (Pair_t (_, (b, expected_field_annot, b_annot), _, _), rest, pair_annot)
    ) -&gt;
      parse_destr_annot
        loc
        annot
        ~pair_annot
        ~value_annot:b_annot
        ~field_name:expected_field_annot
        ~default_accessor:default_cdr_annot
      &gt;&gt;=? fun (annot, field_annot) -&gt;
      Lwt.return @@ check_correct_field field_annot expected_field_annot
      &gt;&gt;=? fun () -&gt; typed ctxt loc Cdr (Item_t (b, rest, annot))
  (* unions *)
  | (Prim (loc, I_LEFT, [tr], annot), Item_t (tl, rest, stack_annot)) -&gt;
      Lwt.return @@ parse_any_ty ctxt ~legacy tr
      &gt;&gt;=? fun (Ex_ty tr, ctxt) -&gt;
      parse_constr_annot
        loc
        annot
        ~if_special_first:(var_to_field_annot stack_annot)
      &gt;&gt;=? fun (annot, tname, l_field, r_field) -&gt;
      typed
        ctxt
        loc
        Left
        (Item_t
           ( Union_t
               ( (tl, l_field),
                 (tr, r_field),
                 tname,
                 has_big_map tl || has_big_map tr ),
             rest,
             annot ))
  | (Prim (loc, I_RIGHT, [tl], annot), Item_t (tr, rest, stack_annot)) -&gt;
      Lwt.return @@ parse_any_ty ctxt ~legacy tl
      &gt;&gt;=? fun (Ex_ty tl, ctxt) -&gt;
      parse_constr_annot
        loc
        annot
        ~if_special_second:(var_to_field_annot stack_annot)
      &gt;&gt;=? fun (annot, tname, l_field, r_field) -&gt;
      typed
        ctxt
        loc
        Right
        (Item_t
           ( Union_t
               ( (tl, l_field),
                 (tr, r_field),
                 tname,
                 has_big_map tl || has_big_map tr ),
             rest,
             annot ))
  | ( Prim (loc, I_IF_LEFT, [bt; bf], annot),
      ( Item_t (Union_t ((tl, l_field), (tr, r_field), _, _), rest, union_annot)
      as bef ) ) -&gt;
      check_kind [Seq_kind] bt
      &gt;&gt;=? fun () -&gt;
      check_kind [Seq_kind] bf
      &gt;&gt;=? fun () -&gt;
      fail_unexpected_annot loc annot
      &gt;&gt;=? fun () -&gt;
      let left_annot =
        gen_access_annot union_annot l_field ~default:default_left_annot
      in
      let right_annot =
        gen_access_annot union_annot r_field ~default:default_right_annot
      in
      parse_instr
        ?type_logger
        tc_context
        ctxt
        ~legacy
        bt
        (Item_t (tl, rest, left_annot))
      &gt;&gt;=? fun (btr, ctxt) -&gt;
      parse_instr
        ?type_logger
        tc_context
        ctxt
        ~legacy
        bf
        (Item_t (tr, rest, right_annot))
      &gt;&gt;=? fun (bfr, ctxt) -&gt;
      let branch ibt ibf =
        {loc; instr = If_left (ibt, ibf); bef; aft = ibt.aft}
      in
      merge_branches ~legacy ctxt loc btr bfr {branch}
      &gt;&gt;=? fun (judgement, ctxt) -&gt; return ctxt judgement
  (* lists *)
  | (Prim (loc, I_NIL, [t], annot), stack) -&gt;
      Lwt.return @@ parse_any_ty ctxt ~legacy t
      &gt;&gt;=? fun (Ex_ty t, ctxt) -&gt;
      parse_var_type_annot loc annot
      &gt;&gt;=? fun (annot, ty_name) -&gt;
      typed
        ctxt
        loc
        Nil
        (Item_t (List_t (t, ty_name, has_big_map t), stack, annot))
  | ( Prim (loc, I_CONS, [], annot),
      Item_t (tv, Item_t (List_t (t, ty_name, has_big_map), rest, _), _) ) -&gt;
      check_item_ty ctxt tv t loc I_CONS 1 2
      &gt;&gt;=? fun (Eq, t, ctxt) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Cons_list
        (Item_t (List_t (t, ty_name, has_big_map), rest, annot))
  | ( Prim (loc, I_IF_CONS, [bt; bf], annot),
      (Item_t (List_t (t, ty_name, has_big_map), rest, list_annot) as bef) ) -&gt;
      check_kind [Seq_kind] bt
      &gt;&gt;=? fun () -&gt;
      check_kind [Seq_kind] bf
      &gt;&gt;=? fun () -&gt;
      fail_unexpected_annot loc annot
      &gt;&gt;=? fun () -&gt;
      let hd_annot = gen_access_annot list_annot default_hd_annot in
      let tl_annot = gen_access_annot list_annot default_tl_annot in
      parse_instr
        ?type_logger
        tc_context
        ctxt
        ~legacy
        bt
        (Item_t
           ( t,
             Item_t (List_t (t, ty_name, has_big_map), rest, tl_annot),
             hd_annot ))
      &gt;&gt;=? fun (btr, ctxt) -&gt;
      parse_instr ?type_logger tc_context ctxt ~legacy bf rest
      &gt;&gt;=? fun (bfr, ctxt) -&gt;
      let branch ibt ibf =
        {loc; instr = If_cons (ibt, ibf); bef; aft = ibt.aft}
      in
      merge_branches ~legacy ctxt loc btr bfr {branch}
      &gt;&gt;=? fun (judgement, ctxt) -&gt; return ctxt judgement
  | (Prim (loc, I_SIZE, [], annot), Item_t (List_t _, rest, _)) -&gt;
      parse_var_type_annot loc annot
      &gt;&gt;=? fun (annot, tname) -&gt;
      typed ctxt loc List_size (Item_t (Nat_t tname, rest, annot))
  | ( Prim (loc, I_MAP, [body], annot),
      Item_t (List_t (elt, _, _), starting_rest, list_annot) ) -&gt; (
      check_kind [Seq_kind] body
      &gt;&gt;=? fun () -&gt;
      parse_var_type_annot loc annot
      &gt;&gt;=? fun (ret_annot, list_ty_name) -&gt;
      let elt_annot = gen_access_annot list_annot default_elt_annot in
      parse_instr
        ?type_logger
        tc_context
        ctxt
        ~legacy
        body
        (Item_t (elt, starting_rest, elt_annot))
      &gt;&gt;=? fun (judgement, ctxt) -&gt;
      match judgement with
      | Typed ({aft = Item_t (ret, rest, _); _} as ibody) -&gt;
          let invalid_map_body () =
            serialize_stack_for_error ctxt ibody.aft
            &gt;&gt;|? fun (aft, _ctxt) -&gt; <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_map_body (loc, aft)</abbr>
          in
          trace_eval
            invalid_map_body
            ( Lwt.return @@ stack_ty_eq ctxt 1 rest starting_rest
            &gt;&gt;=? fun (Eq, ctxt) -&gt;
            Lwt.return @@ merge_stacks ~legacy loc ctxt rest starting_rest
            &gt;&gt;=? fun (rest, ctxt) -&gt;
            typed
              ctxt
              loc
              (List_map ibody)
              (Item_t
                 (List_t (ret, list_ty_name, has_big_map ret), rest, ret_annot))
            )
      | Typed {aft; _} -&gt;
          serialize_stack_for_error ctxt aft
          &gt;&gt;=? fun (aft, _ctxt) -&gt; fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_map_body (loc, aft))</abbr>
      | Failed _ -&gt;
          fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_map_block_fail loc)</abbr> )
  | ( Prim (loc, I_ITER, [body], annot),
      Item_t (List_t (elt, _, _), rest, list_annot) ) -&gt; (
      check_kind [Seq_kind] body
      &gt;&gt;=? fun () -&gt;
      fail_unexpected_annot loc annot
      &gt;&gt;=? fun () -&gt;
      let elt_annot = gen_access_annot list_annot default_elt_annot in
      parse_instr
        ?type_logger
        tc_context
        ctxt
        ~legacy
        body
        (Item_t (elt, rest, elt_annot))
      &gt;&gt;=? fun (judgement, ctxt) -&gt;
      match judgement with
      | Typed ({aft; _} as ibody) -&gt;
          let invalid_iter_body () =
            serialize_stack_for_error ctxt ibody.aft
            &gt;&gt;=? fun (aft, ctxt) -&gt;
            serialize_stack_for_error ctxt rest
            &gt;&gt;|? fun (rest, _ctxt) -&gt; <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_iter_body (loc, rest, aft)</abbr>
          in
          trace_eval
            invalid_iter_body
            ( Lwt.return @@ stack_ty_eq ctxt 1 aft rest
            &gt;&gt;=? fun (Eq, ctxt) -&gt;
            Lwt.return @@ merge_stacks ~legacy loc ctxt aft rest
            &gt;&gt;=? fun (rest, ctxt) -&gt; typed ctxt loc (List_iter ibody) rest )
      | Failed {descr} -&gt;
          typed ctxt loc (List_iter (descr rest)) rest )
  (* sets *)
  | (Prim (loc, I_EMPTY_SET, [t], annot), rest) -&gt;
      Lwt.return @@ parse_comparable_ty ctxt t
      &gt;&gt;=? fun (Ex_comparable_ty t, ctxt) -&gt;
      parse_var_type_annot loc annot
      &gt;&gt;=? fun (annot, tname) -&gt;
      typed ctxt loc (Empty_set t) (Item_t (Set_t (t, tname), rest, annot))
  | ( Prim (loc, I_ITER, [body], annot),
      Item_t (Set_t (comp_elt, _), rest, set_annot) ) -&gt; (
      check_kind [Seq_kind] body
      &gt;&gt;=? fun () -&gt;
      fail_unexpected_annot loc annot
      &gt;&gt;=? fun () -&gt;
      let elt_annot = gen_access_annot set_annot default_elt_annot in
      let elt = ty_of_comparable_ty comp_elt in
      parse_instr
        ?type_logger
        tc_context
        ctxt
        ~legacy
        body
        (Item_t (elt, rest, elt_annot))
      &gt;&gt;=? fun (judgement, ctxt) -&gt;
      match judgement with
      | Typed ({aft; _} as ibody) -&gt;
          let invalid_iter_body () =
            serialize_stack_for_error ctxt ibody.aft
            &gt;&gt;=? fun (aft, ctxt) -&gt;
            serialize_stack_for_error ctxt rest
            &gt;&gt;|? fun (rest, _ctxt) -&gt; <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_iter_body (loc, rest, aft)</abbr>
          in
          trace_eval
            invalid_iter_body
            ( Lwt.return @@ stack_ty_eq ctxt 1 aft rest
            &gt;&gt;=? fun (Eq, ctxt) -&gt;
            Lwt.return @@ merge_stacks ~legacy loc ctxt aft rest
            &gt;&gt;=? fun (rest, ctxt) -&gt; typed ctxt loc (Set_iter ibody) rest )
      | Failed {descr} -&gt;
          typed ctxt loc (Set_iter (descr rest)) rest )
  | ( Prim (loc, I_MEM, [], annot),
      Item_t (v, Item_t (Set_t (elt, _), rest, _), _) ) -&gt;
      let elt = ty_of_comparable_ty elt in
      parse_var_type_annot loc annot
      &gt;&gt;=? fun (annot, tname) -&gt;
      check_item_ty ctxt elt v loc I_MEM 1 2
      &gt;&gt;=? fun (Eq, _, ctxt) -&gt;
      typed ctxt loc Set_mem (Item_t (Bool_t tname, rest, annot))
  | ( Prim (loc, I_UPDATE, [], annot),
      Item_t
        ( v,
          Item_t (Bool_t _, Item_t (Set_t (elt, tname), rest, set_annot), _),
          _ ) ) -&gt; (
    match comparable_ty_of_ty v with
    | None -&gt;
        unparse_ty ctxt v
        &gt;&gt;=? fun (v, _ctxt) -&gt;
        fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Comparable_type_expected (loc, Micheline.strip_locations v))</abbr>
    | Some v -&gt;
        parse_var_annot loc annot ~default:set_annot
        &gt;&gt;=? fun annot -&gt;
        check_item_comparable_ty elt v loc I_UPDATE 1 3
        &gt;&gt;=? fun (Eq, elt) -&gt;
        typed ctxt loc Set_update (Item_t (Set_t (elt, tname), rest, annot)) )
  | (Prim (loc, I_SIZE, [], annot), Item_t (Set_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Set_size (Item_t (Nat_t None, rest, annot))
  (* maps *)
  | (Prim (loc, I_EMPTY_MAP, [tk; tv], annot), stack) -&gt;
      Lwt.return @@ parse_comparable_ty ctxt tk
      &gt;&gt;=? fun (Ex_comparable_ty tk, ctxt) -&gt;
      Lwt.return @@ parse_any_ty ctxt ~legacy tv
      &gt;&gt;=? fun (Ex_ty tv, ctxt) -&gt;
      parse_var_type_annot loc annot
      &gt;&gt;=? fun (annot, ty_name) -&gt;
      typed
        ctxt
        loc
        (Empty_map (tk, tv))
        (Item_t (Map_t (tk, tv, ty_name, has_big_map tv), stack, annot))
  | ( Prim (loc, I_MAP, [body], annot),
      Item_t (Map_t (ck, elt, _, _), starting_rest, _map_annot) ) -&gt; (
      let k = ty_of_comparable_ty ck in
      check_kind [Seq_kind] body
      &gt;&gt;=? fun () -&gt;
      parse_var_type_annot loc annot
      &gt;&gt;=? fun (ret_annot, ty_name) -&gt;
      let k_name = field_to_var_annot default_key_annot in
      let e_name = field_to_var_annot default_elt_annot in
      parse_instr
        ?type_logger
        tc_context
        ctxt
        ~legacy
        body
        (Item_t
           ( Pair_t
               ((k, None, k_name), (elt, None, e_name), None, has_big_map elt),
             starting_rest,
             None ))
      &gt;&gt;=? fun (judgement, ctxt) -&gt;
      match judgement with
      | Typed ({aft = Item_t (ret, rest, _); _} as ibody) -&gt;
          let invalid_map_body () =
            serialize_stack_for_error ctxt ibody.aft
            &gt;&gt;|? fun (aft, _ctxt) -&gt; <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_map_body (loc, aft)</abbr>
          in
          trace_eval
            invalid_map_body
            ( Lwt.return @@ stack_ty_eq ctxt 1 rest starting_rest
            &gt;&gt;=? fun (Eq, ctxt) -&gt;
            Lwt.return @@ merge_stacks ~legacy loc ctxt rest starting_rest
            &gt;&gt;=? fun (rest, ctxt) -&gt;
            typed
              ctxt
              loc
              (Map_map ibody)
              (Item_t
                 (Map_t (ck, ret, ty_name, has_big_map ret), rest, ret_annot))
            )
      | Typed {aft; _} -&gt;
          serialize_stack_for_error ctxt aft
          &gt;&gt;=? fun (aft, _ctxt) -&gt; fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_map_body (loc, aft))</abbr>
      | Failed _ -&gt;
          fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_map_block_fail loc)</abbr> )
  | ( Prim (loc, I_ITER, [body], annot),
      Item_t (Map_t (comp_elt, element_ty, _, _), rest, _map_annot) ) -&gt; (
      check_kind [Seq_kind] body
      &gt;&gt;=? fun () -&gt;
      fail_unexpected_annot loc annot
      &gt;&gt;=? fun () -&gt;
      let k_name = field_to_var_annot default_key_annot in
      let e_name = field_to_var_annot default_elt_annot in
      let key = ty_of_comparable_ty comp_elt in
      parse_instr
        ?type_logger
        tc_context
        ctxt
        ~legacy
        body
        (Item_t
           ( Pair_t
               ( (key, None, k_name),
                 (element_ty, None, e_name),
                 None,
                 has_big_map element_ty ),
             rest,
             None ))
      &gt;&gt;=? fun (judgement, ctxt) -&gt;
      match judgement with
      | Typed ({aft; _} as ibody) -&gt;
          let invalid_iter_body () =
            serialize_stack_for_error ctxt ibody.aft
            &gt;&gt;=? fun (aft, ctxt) -&gt;
            serialize_stack_for_error ctxt rest
            &gt;&gt;|? fun (rest, _ctxt) -&gt; <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Invalid_iter_body (loc, rest, aft)</abbr>
          in
          trace_eval
            invalid_iter_body
            ( Lwt.return @@ stack_ty_eq ctxt 1 aft rest
            &gt;&gt;=? fun (Eq, ctxt) -&gt;
            Lwt.return @@ merge_stacks ~legacy loc ctxt aft rest
            &gt;&gt;=? fun (rest, ctxt) -&gt; typed ctxt loc (Map_iter ibody) rest )
      | Failed {descr} -&gt;
          typed ctxt loc (Map_iter (descr rest)) rest )
  | ( Prim (loc, I_MEM, [], annot),
      Item_t (vk, Item_t (Map_t (ck, _, _, _), rest, _), _) ) -&gt;
      let k = ty_of_comparable_ty ck in
      check_item_ty ctxt vk k loc I_MEM 1 2
      &gt;&gt;=? fun (Eq, _, ctxt) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Map_mem (Item_t (Bool_t None, rest, annot))
  | ( Prim (loc, I_GET, [], annot),
      Item_t (vk, Item_t (Map_t (ck, elt, _, has_big_map), rest, _), _) ) -&gt;
      let k = ty_of_comparable_ty ck in
      check_item_ty ctxt vk k loc I_GET 1 2
      &gt;&gt;=? fun (Eq, _, ctxt) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Map_get
        (Item_t (Option_t (elt, None, has_big_map), rest, annot))
  | ( Prim (loc, I_UPDATE, [], annot),
      Item_t
        ( vk,
          Item_t
            ( Option_t (vv, _, _),
              Item_t (Map_t (ck, v, map_name, has_big_map), rest, map_annot),
              _ ),
          _ ) ) -&gt;
      let k = ty_of_comparable_ty ck in
      check_item_ty ctxt vk k loc I_UPDATE 1 3
      &gt;&gt;=? fun (Eq, _, ctxt) -&gt;
      check_item_ty ctxt vv v loc I_UPDATE 2 3
      &gt;&gt;=? fun (Eq, v, ctxt) -&gt;
      parse_var_annot loc annot ~default:map_annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Map_update
        (Item_t (Map_t (ck, v, map_name, has_big_map), rest, annot))
  | (Prim (loc, I_SIZE, [], annot), Item_t (Map_t (_, _, _, _), rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Map_size (Item_t (Nat_t None, rest, annot))
  (* big_map *)
  | (Prim (loc, I_EMPTY_BIG_MAP, [tk; tv], annot), stack) -&gt;
      Lwt.return @@ parse_comparable_ty ctxt tk
      &gt;&gt;=? fun (Ex_comparable_ty tk, ctxt) -&gt;
      Lwt.return @@ parse_packable_ty ctxt ~legacy tv
      &gt;&gt;=? fun (Ex_ty tv, ctxt) -&gt;
      parse_var_type_annot loc annot
      &gt;&gt;=? fun (annot, ty_name) -&gt;
      typed
        ctxt
        loc
        (Empty_big_map (tk, tv))
        (Item_t (Big_map_t (tk, tv, ty_name), stack, annot))
  | ( Prim (loc, I_MEM, [], annot),
      Item_t (set_key, Item_t (Big_map_t (map_key, _, _), rest, _), _) ) -&gt;
      let k = ty_of_comparable_ty map_key in
      check_item_ty ctxt set_key k loc I_MEM 1 2
      &gt;&gt;=? fun (Eq, _, ctxt) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Big_map_mem (Item_t (Bool_t None, rest, annot))
  | ( Prim (loc, I_GET, [], annot),
      Item_t (vk, Item_t (Big_map_t (ck, elt, _), rest, _), _) ) -&gt;
      let k = ty_of_comparable_ty ck in
      check_item_ty ctxt vk k loc I_GET 1 2
      &gt;&gt;=? fun (Eq, _, ctxt) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Big_map_get
        (Item_t (Option_t (elt, None, has_big_map elt), rest, annot))
  | ( Prim (loc, I_UPDATE, [], annot),
      Item_t
        ( set_key,
          Item_t
            ( Option_t (set_value, _, _),
              Item_t (Big_map_t (map_key, map_value, map_name), rest, map_annot),
              _ ),
          _ ) ) -&gt;
      let k = ty_of_comparable_ty map_key in
      check_item_ty ctxt set_key k loc I_UPDATE 1 3
      &gt;&gt;=? fun (Eq, _, ctxt) -&gt;
      check_item_ty ctxt set_value map_value loc I_UPDATE 2 3
      &gt;&gt;=? fun (Eq, map_value, ctxt) -&gt;
      parse_var_annot loc annot ~default:map_annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Big_map_update
        (Item_t (Big_map_t (map_key, map_value, map_name), rest, annot))
  (* control *)
  | (Seq (loc, []), stack) -&gt;
      typed ctxt loc Nop stack
  | (Seq (loc, [single]), stack) -&gt; (
      parse_instr ?type_logger tc_context ctxt ~legacy single stack
      &gt;&gt;=? fun (judgement, ctxt) -&gt;
      match judgement with
      | Typed ({aft; _} as instr) -&gt;
          let nop = {bef = aft; loc; aft; instr = Nop} in
          typed ctxt loc (Seq (instr, nop)) aft
      | Failed {descr; _} -&gt;
          let descr aft =
            let nop = {bef = aft; loc; aft; instr = Nop} in
            let descr = descr aft in
            {descr with instr = Seq (descr, nop)}
          in
          return ctxt (Failed {descr}) )
  | (Seq (loc, hd :: tl), stack) -&gt; (
      parse_instr ?type_logger tc_context ctxt ~legacy hd stack
      &gt;&gt;=? fun (judgement, ctxt) -&gt;
      match judgement with
      | Failed _ -&gt;
          fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Fail_not_in_tail_position (Micheline.location hd))</abbr>
      | Typed ({aft = middle; _} as ihd) -&gt; (
          parse_instr
            ?type_logger
            tc_context
            ctxt
            ~legacy
            (Seq (-1, tl))
            middle
          &gt;&gt;=? fun (judgement, ctxt) -&gt;
          match judgement with
          | Failed {descr} -&gt;
              let descr ret =
                {loc; instr = Seq (ihd, descr ret); bef = stack; aft = ret}
              in
              return ctxt (Failed {descr})
          | Typed itl -&gt;
              typed ctxt loc (Seq (ihd, itl)) itl.aft ) )
  | (Prim (loc, I_IF, [bt; bf], annot), (Item_t (Bool_t _, rest, _) as bef)) -&gt;
      check_kind [Seq_kind] bt
      &gt;&gt;=? fun () -&gt;
      check_kind [Seq_kind] bf
      &gt;&gt;=? fun () -&gt;
      fail_unexpected_annot loc annot
      &gt;&gt;=? fun () -&gt;
      parse_instr ?type_logger tc_context ctxt ~legacy bt rest
      &gt;&gt;=? fun (btr, ctxt) -&gt;
      parse_instr ?type_logger tc_context ctxt ~legacy bf rest
      &gt;&gt;=? fun (bfr, ctxt) -&gt;
      let branch ibt ibf = {loc; instr = If (ibt, ibf); bef; aft = ibt.aft} in
      merge_branches ~legacy ctxt loc btr bfr {branch}
      &gt;&gt;=? fun (judgement, ctxt) -&gt; return ctxt judgement
  | ( Prim (loc, I_LOOP, [body], annot),
      (Item_t (Bool_t _, rest, _stack_annot) as stack) ) -&gt; (
      check_kind [Seq_kind] body
      &gt;&gt;=? fun () -&gt;
      fail_unexpected_annot loc annot
      &gt;&gt;=? fun () -&gt;
      parse_instr ?type_logger tc_context ctxt ~legacy body rest
      &gt;&gt;=? fun (judgement, ctxt) -&gt;
      match judgement with
      | Typed ibody -&gt;
          let unmatched_branches () =
            serialize_stack_for_error ctxt ibody.aft
            &gt;&gt;=? fun (aft, ctxt) -&gt;
            serialize_stack_for_error ctxt stack
            &gt;&gt;|? fun (stack, _ctxt) -&gt; <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Unmatched_branches (loc, aft, stack)</abbr>
          in
          trace_eval
            unmatched_branches
            ( Lwt.return @@ stack_ty_eq ctxt 1 ibody.aft stack
            &gt;&gt;=? fun (Eq, ctxt) -&gt;
            Lwt.return @@ merge_stacks ~legacy loc ctxt ibody.aft stack
            &gt;&gt;=? fun (_stack, ctxt) -&gt; typed ctxt loc (Loop ibody) rest )
      | Failed {descr} -&gt;
          let ibody = descr stack in
          typed ctxt loc (Loop ibody) rest )
  | ( Prim (loc, I_LOOP_LEFT, [body], annot),
      ( Item_t (Union_t ((tl, l_field), (tr, _), _, _), rest, union_annot) as
      stack ) ) -&gt; (
      check_kind [Seq_kind] body
      &gt;&gt;=? fun () -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      let l_annot =
        gen_access_annot union_annot l_field ~default:default_left_annot
      in
      parse_instr
        ?type_logger
        tc_context
        ctxt
        ~legacy
        body
        (Item_t (tl, rest, l_annot))
      &gt;&gt;=? fun (judgement, ctxt) -&gt;
      match judgement with
      | Typed ibody -&gt;
          let unmatched_branches () =
            serialize_stack_for_error ctxt ibody.aft
            &gt;&gt;=? fun (aft, ctxt) -&gt;
            serialize_stack_for_error ctxt stack
            &gt;&gt;|? fun (stack, _ctxt) -&gt; <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Unmatched_branches (loc, aft, stack)</abbr>
          in
          trace_eval
            unmatched_branches
            ( Lwt.return @@ stack_ty_eq ctxt 1 ibody.aft stack
            &gt;&gt;=? fun (Eq, ctxt) -&gt;
            Lwt.return @@ merge_stacks ~legacy loc ctxt ibody.aft stack
            &gt;&gt;=? fun (_stack, ctxt) -&gt;
            typed ctxt loc (Loop_left ibody) (Item_t (tr, rest, annot)) )
      | Failed {descr} -&gt;
          let ibody = descr stack in
          typed ctxt loc (Loop_left ibody) (Item_t (tr, rest, annot)) )
  | (Prim (loc, I_LAMBDA, [arg; ret; code], annot), stack) -&gt;
      Lwt.return @@ parse_any_ty ctxt ~legacy arg
      &gt;&gt;=? fun (Ex_ty arg, ctxt) -&gt;
      Lwt.return @@ parse_any_ty ctxt ~legacy ret
      &gt;&gt;=? fun (Ex_ty ret, ctxt) -&gt;
      check_kind [Seq_kind] code
      &gt;&gt;=? fun () -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      parse_returning
        Lambda
        ?type_logger
        ctxt
        ~legacy
        (arg, default_arg_annot)
        ret
        code
      &gt;&gt;=? fun (lambda, ctxt) -&gt;
      typed
        ctxt
        loc
        (Lambda lambda)
        (Item_t (Lambda_t (arg, ret, None), stack, annot))
  | ( Prim (loc, I_EXEC, [], annot),
      Item_t (arg, Item_t (Lambda_t (param, ret, _), rest, _), _) ) -&gt;
      check_item_ty ctxt arg param loc I_EXEC 1 2
      &gt;&gt;=? fun (Eq, _, ctxt) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt; typed ctxt loc Exec (Item_t (ret, rest, annot))
  | ( Prim (loc, I_APPLY, [], annot),
      Item_t
        ( capture,
          Item_t
            ( Lambda_t
                ( Pair_t ((capture_ty, _, _), (arg_ty, _, _), lam_annot, _),
                  ret,
                  _ ),
              rest,
              _ ),
          _ ) ) -&gt;
      Lwt.return @@ check_packable ~legacy:false loc capture_ty
      &gt;&gt;=? fun () -&gt;
      check_item_ty ctxt capture capture_ty loc I_APPLY 1 2
      &gt;&gt;=? fun (Eq, capture_ty, ctxt) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        (Apply capture_ty)
        (Item_t (Lambda_t (arg_ty, ret, lam_annot), rest, annot))
  | (Prim (loc, I_DIP, [code], annot), Item_t (v, rest, stack_annot)) -&gt; (
      fail_unexpected_annot loc annot
      &gt;&gt;=? fun () -&gt;
      check_kind [Seq_kind] code
      &gt;&gt;=? fun () -&gt;
      parse_instr
        ?type_logger
        (add_dip v stack_annot tc_context)
        ctxt
        ~legacy
        code
        rest
      &gt;&gt;=? fun (judgement, ctxt) -&gt;
      match judgement with
      | Typed descr -&gt;
          typed ctxt loc (Dip descr) (Item_t (v, descr.aft, stack_annot))
      | Failed _ -&gt;
          fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Fail_not_in_tail_position loc)</abbr> )
  | (Prim (loc, I_DIP, [n; code], result_annot), stack)
    when match parse_int32 n with Ok _ -&gt; true | Error _ -&gt; false -&gt;
      let rec make_proof_argument :
          type tstk.
          int
          (* -&gt; (fbef stack_ty -&gt; (fbef judgement * context) tzresult Lwt.t) *) -&gt;
          tc_context -&gt;
          tstk stack_ty -&gt;
          tstk dipn_proof_argument tzresult Lwt.t =
       fun n inner_tc_context stk -&gt;
        match (Compare.Int.(n = 0), stk) with
        | (true, rest) -&gt; (
            parse_instr ?type_logger inner_tc_context ctxt ~legacy code rest
            &gt;&gt;=? fun (judgement, ctxt) -&gt;
            match judgement with
            | Typed descr -&gt;
                outer_return
                @@ Dipn_proof_argument (Rest, (ctxt, descr), descr.aft)
            | Failed _ -&gt;
                fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Fail_not_in_tail_position loc)</abbr> )
        | (false, Item_t (v, rest, annot)) -&gt;
            make_proof_argument (n - 1) (add_dip v annot tc_context) rest
            &gt;&gt;=? fun (Dipn_proof_argument (n', descr, aft')) -&gt;
            outer_return
            @@ Dipn_proof_argument (Prefix n', descr, Item_t (v, aft', annot))
        | (_, _) -&gt;
            serialize_stack_for_error ctxt stack
            &gt;&gt;=? fun (whole_stack, _ctxt) -&gt;
            fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Bad_stack (loc, I_DIP, 1, whole_stack))</abbr>
      in
      Lwt.return (parse_int32 n)
      &gt;&gt;=? fun n -&gt;
      fail_unexpected_annot loc result_annot
      &gt;&gt;=? fun () -&gt;
      make_proof_argument n tc_context stack
      &gt;&gt;=? fun (Dipn_proof_argument (n', (new_ctxt, descr), aft)) -&gt;
      (* TODO: which context should be used in the next line? new_ctxt or the old ctxt? *)
      typed new_ctxt loc (Dipn (n, n', descr)) aft
  | (Prim (loc, I_DIP, (([] | _ :: _ :: _ :: _) as l), _), _) -&gt;
      (* Technically, the arities 1 and 2 are allowed but the error only mentions 2.
           However, DIP {code} is equivalent to DIP 1 {code} so hinting at an arity of 2 makes sense. *)
      fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_arity (loc, I_DIP, 2, List.length l))</abbr>
  | (Prim (loc, I_FAILWITH, [], annot), Item_t (v, _rest, _)) -&gt;
      fail_unexpected_annot loc annot
      &gt;&gt;=? fun () -&gt;
      let descr aft = {loc; instr = Failwith v; bef = stack_ty; aft} in
      log_stack ctxt loc stack_ty Empty_t
      &gt;&gt;=? fun () -&gt; return ctxt (Failed {descr})
  (* timestamp operations *)
  | ( Prim (loc, I_ADD, [], annot),
      Item_t (Timestamp_t tname, Item_t (Int_t _, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Add_timestamp_to_seconds
        (Item_t (Timestamp_t tname, rest, annot))
  | ( Prim (loc, I_ADD, [], annot),
      Item_t (Int_t _, Item_t (Timestamp_t tname, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Add_seconds_to_timestamp
        (Item_t (Timestamp_t tname, rest, annot))
  | ( Prim (loc, I_SUB, [], annot),
      Item_t (Timestamp_t tname, Item_t (Int_t _, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Sub_timestamp_seconds
        (Item_t (Timestamp_t tname, rest, annot))
  | ( Prim (loc, I_SUB, [], annot),
      Item_t (Timestamp_t tn1, Item_t (Timestamp_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Diff_timestamps (Item_t (Int_t tname, rest, annot))
  (* string operations *)
  | ( Prim (loc, I_CONCAT, [], annot),
      Item_t (String_t tn1, Item_t (String_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Concat_string_pair (Item_t (String_t tname, rest, annot))
  | ( Prim (loc, I_CONCAT, [], annot),
      Item_t (List_t (String_t tname, _, _), rest, list_annot) ) -&gt;
      parse_var_annot ~default:list_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Concat_string (Item_t (String_t tname, rest, annot))
  | ( Prim (loc, I_SLICE, [], annot),
      Item_t
        ( Nat_t _,
          Item_t (Nat_t _, Item_t (String_t tname, rest, string_annot), _),
          _ ) ) -&gt;
      parse_var_annot
        ~default:(gen_access_annot string_annot default_slice_annot)
        loc
        annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Slice_string
        (Item_t (Option_t (String_t tname, None, false), rest, annot))
  | (Prim (loc, I_SIZE, [], annot), Item_t (String_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc String_size (Item_t (Nat_t None, rest, annot))
  (* bytes operations *)
  | ( Prim (loc, I_CONCAT, [], annot),
      Item_t (Bytes_t tn1, Item_t (Bytes_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Concat_bytes_pair (Item_t (Bytes_t tname, rest, annot))
  | ( Prim (loc, I_CONCAT, [], annot),
      Item_t (List_t (Bytes_t tname, _, _), rest, list_annot) ) -&gt;
      parse_var_annot ~default:list_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Concat_bytes (Item_t (Bytes_t tname, rest, annot))
  | ( Prim (loc, I_SLICE, [], annot),
      Item_t
        ( Nat_t _,
          Item_t (Nat_t _, Item_t (Bytes_t tname, rest, bytes_annot), _),
          _ ) ) -&gt;
      parse_var_annot
        ~default:(gen_access_annot bytes_annot default_slice_annot)
        loc
        annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Slice_bytes
        (Item_t (Option_t (Bytes_t tname, None, false), rest, annot))
  | (Prim (loc, I_SIZE, [], annot), Item_t (Bytes_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Bytes_size (Item_t (Nat_t None, rest, annot))
  (* currency operations *)
  | ( Prim (loc, I_ADD, [], annot),
      Item_t (Mutez_t tn1, Item_t (Mutez_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Add_tez (Item_t (Mutez_t tname, rest, annot))
  | ( Prim (loc, I_SUB, [], annot),
      Item_t (Mutez_t tn1, Item_t (Mutez_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Sub_tez (Item_t (Mutez_t tname, rest, annot))
  | ( Prim (loc, I_MUL, [], annot),
      Item_t (Mutez_t tname, Item_t (Nat_t _, rest, _), _) ) -&gt;
      (* no type name check *)
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Mul_teznat (Item_t (Mutez_t tname, rest, annot))
  | ( Prim (loc, I_MUL, [], annot),
      Item_t (Nat_t _, Item_t (Mutez_t tname, rest, _), _) ) -&gt;
      (* no type name check *)
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Mul_nattez (Item_t (Mutez_t tname, rest, annot))
  (* boolean operations *)
  | ( Prim (loc, I_OR, [], annot),
      Item_t (Bool_t tn1, Item_t (Bool_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt; typed ctxt loc Or (Item_t (Bool_t tname, rest, annot))
  | ( Prim (loc, I_AND, [], annot),
      Item_t (Bool_t tn1, Item_t (Bool_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt; typed ctxt loc And (Item_t (Bool_t tname, rest, annot))
  | ( Prim (loc, I_XOR, [], annot),
      Item_t (Bool_t tn1, Item_t (Bool_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt; typed ctxt loc Xor (Item_t (Bool_t tname, rest, annot))
  | (Prim (loc, I_NOT, [], annot), Item_t (Bool_t tname, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt; typed ctxt loc Not (Item_t (Bool_t tname, rest, annot))
  (* integer operations *)
  | (Prim (loc, I_ABS, [], annot), Item_t (Int_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Abs_int (Item_t (Nat_t None, rest, annot))
  | (Prim (loc, I_ISNAT, [], annot), Item_t (Int_t _, rest, int_annot)) -&gt;
      parse_var_annot loc annot ~default:int_annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Is_nat
        (Item_t (Option_t (Nat_t None, None, false), rest, annot))
  | (Prim (loc, I_INT, [], annot), Item_t (Nat_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Int_nat (Item_t (Int_t None, rest, annot))
  | (Prim (loc, I_NEG, [], annot), Item_t (Int_t tname, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Neg_int (Item_t (Int_t tname, rest, annot))
  | (Prim (loc, I_NEG, [], annot), Item_t (Nat_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Neg_nat (Item_t (Int_t None, rest, annot))
  | ( Prim (loc, I_ADD, [], annot),
      Item_t (Int_t tn1, Item_t (Int_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Add_intint (Item_t (Int_t tname, rest, annot))
  | ( Prim (loc, I_ADD, [], annot),
      Item_t (Int_t tname, Item_t (Nat_t _, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Add_intnat (Item_t (Int_t tname, rest, annot))
  | ( Prim (loc, I_ADD, [], annot),
      Item_t (Nat_t _, Item_t (Int_t tname, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Add_natint (Item_t (Int_t tname, rest, annot))
  | ( Prim (loc, I_ADD, [], annot),
      Item_t (Nat_t tn1, Item_t (Nat_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Add_natnat (Item_t (Nat_t tname, rest, annot))
  | ( Prim (loc, I_SUB, [], annot),
      Item_t (Int_t tn1, Item_t (Int_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Sub_int (Item_t (Int_t tname, rest, annot))
  | ( Prim (loc, I_SUB, [], annot),
      Item_t (Int_t tname, Item_t (Nat_t _, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Sub_int (Item_t (Int_t tname, rest, annot))
  | ( Prim (loc, I_SUB, [], annot),
      Item_t (Nat_t _, Item_t (Int_t tname, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Sub_int (Item_t (Int_t tname, rest, annot))
  | ( Prim (loc, I_SUB, [], annot),
      Item_t (Nat_t tn1, Item_t (Nat_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun _tname -&gt;
      typed ctxt loc Sub_int (Item_t (Int_t None, rest, annot))
  | ( Prim (loc, I_MUL, [], annot),
      Item_t (Int_t tn1, Item_t (Int_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Mul_intint (Item_t (Int_t tname, rest, annot))
  | ( Prim (loc, I_MUL, [], annot),
      Item_t (Int_t tname, Item_t (Nat_t _, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Mul_intnat (Item_t (Int_t tname, rest, annot))
  | ( Prim (loc, I_MUL, [], annot),
      Item_t (Nat_t _, Item_t (Int_t tname, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Mul_natint (Item_t (Int_t tname, rest, annot))
  | ( Prim (loc, I_MUL, [], annot),
      Item_t (Nat_t tn1, Item_t (Nat_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Mul_natnat (Item_t (Nat_t tname, rest, annot))
  | ( Prim (loc, I_EDIV, [], annot),
      Item_t (Mutez_t tname, Item_t (Nat_t _, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Ediv_teznat
        (Item_t
           ( Option_t
               ( Pair_t
                   ( (Mutez_t tname, None, None),
                     (Mutez_t tname, None, None),
                     None,
                     false ),
                 None,
                 false ),
             rest,
             annot ))
  | ( Prim (loc, I_EDIV, [], annot),
      Item_t (Mutez_t tn1, Item_t (Mutez_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed
        ctxt
        loc
        Ediv_tez
        (Item_t
           ( Option_t
               ( Pair_t
                   ( (Nat_t None, None, None),
                     (Mutez_t tname, None, None),
                     None,
                     false ),
                 None,
                 false ),
             rest,
             annot ))
  | ( Prim (loc, I_EDIV, [], annot),
      Item_t (Int_t tn1, Item_t (Int_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed
        ctxt
        loc
        Ediv_intint
        (Item_t
           ( Option_t
               ( Pair_t
                   ( (Int_t tname, None, None),
                     (Nat_t None, None, None),
                     None,
                     false ),
                 None,
                 false ),
             rest,
             annot ))
  | ( Prim (loc, I_EDIV, [], annot),
      Item_t (Int_t tname, Item_t (Nat_t _, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Ediv_intnat
        (Item_t
           ( Option_t
               ( Pair_t
                   ( (Int_t tname, None, None),
                     (Nat_t None, None, None),
                     None,
                     false ),
                 None,
                 false ),
             rest,
             annot ))
  | ( Prim (loc, I_EDIV, [], annot),
      Item_t (Nat_t tname, Item_t (Int_t _, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Ediv_natint
        (Item_t
           ( Option_t
               ( Pair_t
                   ( (Int_t None, None, None),
                     (Nat_t tname, None, None),
                     None,
                     false ),
                 None,
                 false ),
             rest,
             annot ))
  | ( Prim (loc, I_EDIV, [], annot),
      Item_t (Nat_t tn1, Item_t (Nat_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed
        ctxt
        loc
        Ediv_natnat
        (Item_t
           ( Option_t
               ( Pair_t
                   ( (Nat_t tname, None, None),
                     (Nat_t tname, None, None),
                     None,
                     false ),
                 None,
                 false ),
             rest,
             annot ))
  | ( Prim (loc, I_LSL, [], annot),
      Item_t (Nat_t tn1, Item_t (Nat_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Lsl_nat (Item_t (Nat_t tname, rest, annot))
  | ( Prim (loc, I_LSR, [], annot),
      Item_t (Nat_t tn1, Item_t (Nat_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Lsr_nat (Item_t (Nat_t tname, rest, annot))
  | ( Prim (loc, I_OR, [], annot),
      Item_t (Nat_t tn1, Item_t (Nat_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Or_nat (Item_t (Nat_t tname, rest, annot))
  | ( Prim (loc, I_AND, [], annot),
      Item_t (Nat_t tn1, Item_t (Nat_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc And_nat (Item_t (Nat_t tname, rest, annot))
  | ( Prim (loc, I_AND, [], annot),
      Item_t (Int_t _, Item_t (Nat_t tname, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc And_int_nat (Item_t (Nat_t tname, rest, annot))
  | ( Prim (loc, I_XOR, [], annot),
      Item_t (Nat_t tn1, Item_t (Nat_t tn2, rest, _), _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ merge_type_annot ~legacy tn1 tn2
      &gt;&gt;=? fun tname -&gt;
      typed ctxt loc Xor_nat (Item_t (Nat_t tname, rest, annot))
  | (Prim (loc, I_NOT, [], annot), Item_t (Int_t tname, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Not_int (Item_t (Int_t tname, rest, annot))
  | (Prim (loc, I_NOT, [], annot), Item_t (Nat_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Not_nat (Item_t (Int_t None, rest, annot))
  (* comparison *)
  | (Prim (loc, I_COMPARE, [], annot), Item_t (t1, Item_t (t2, rest, _), _))
    -&gt; (
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      check_item_ty ctxt t1 t2 loc I_COMPARE 1 2
      &gt;&gt;=? fun (Eq, t, ctxt) -&gt;
      match comparable_ty_of_ty t with
      | None -&gt;
          Lwt.return (serialize_ty_for_error ctxt t)
          &gt;&gt;=? fun (t, _ctxt) -&gt; fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Comparable_type_expected (loc, t))</abbr>
      | Some key -&gt;
          typed ctxt loc (Compare key) (Item_t (Int_t None, rest, annot)) )
  (* comparators *)
  | (Prim (loc, I_EQ, [], annot), Item_t (Int_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt; typed ctxt loc Eq (Item_t (Bool_t None, rest, annot))
  | (Prim (loc, I_NEQ, [], annot), Item_t (Int_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt; typed ctxt loc Neq (Item_t (Bool_t None, rest, annot))
  | (Prim (loc, I_LT, [], annot), Item_t (Int_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt; typed ctxt loc Lt (Item_t (Bool_t None, rest, annot))
  | (Prim (loc, I_GT, [], annot), Item_t (Int_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt; typed ctxt loc Gt (Item_t (Bool_t None, rest, annot))
  | (Prim (loc, I_LE, [], annot), Item_t (Int_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt; typed ctxt loc Le (Item_t (Bool_t None, rest, annot))
  | (Prim (loc, I_GE, [], annot), Item_t (Int_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt; typed ctxt loc Ge (Item_t (Bool_t None, rest, annot))
  (* annotations *)
  | (Prim (loc, I_CAST, [cast_t], annot), Item_t (t, stack, item_annot)) -&gt;
      parse_var_annot loc annot ~default:item_annot
      &gt;&gt;=? fun annot -&gt;
      Lwt.return @@ parse_any_ty ctxt ~legacy cast_t
      &gt;&gt;=? fun (Ex_ty cast_t, ctxt) -&gt;
      Lwt.return @@ ty_eq ctxt cast_t t
      &gt;&gt;=? fun (Eq, ctxt) -&gt;
      Lwt.return @@ merge_types ~legacy ctxt loc cast_t t
      &gt;&gt;=? fun (_, ctxt) -&gt; typed ctxt loc Nop (Item_t (cast_t, stack, annot))
  | (Prim (loc, I_RENAME, [], annot), Item_t (t, stack, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      (* can erase annot *)
      typed ctxt loc Nop (Item_t (t, stack, annot))
  (* packing *)
  | (Prim (loc, I_PACK, [], annot), Item_t (t, rest, unpacked_annot)) -&gt;
      Lwt.return
        (check_packable
           ~legacy:true
           (* allow to pack contracts for hash/signature checks *) loc
           t)
      &gt;&gt;=? fun () -&gt;
      parse_var_annot
        loc
        annot
        ~default:(gen_access_annot unpacked_annot default_pack_annot)
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc (Pack t) (Item_t (Bytes_t None, rest, annot))
  | (Prim (loc, I_UNPACK, [ty], annot), Item_t (Bytes_t _, rest, packed_annot))
    -&gt;
      Lwt.return @@ parse_packable_ty ctxt ~legacy ty
      &gt;&gt;=? fun (Ex_ty t, ctxt) -&gt;
      parse_var_type_annot loc annot
      &gt;&gt;=? fun (annot, ty_name) -&gt;
      let annot =
        default_annot
          annot
          ~default:(gen_access_annot packed_annot default_unpack_annot)
      in
      typed
        ctxt
        loc
        (Unpack t)
        (Item_t
           ( Option_t (t, ty_name, false (* cannot unpack big_maps *)),
             rest,
             annot ))
  (* protocol *)
  | ( Prim (loc, I_ADDRESS, [], annot),
      Item_t (Contract_t _, rest, contract_annot) ) -&gt;
      parse_var_annot
        loc
        annot
        ~default:(gen_access_annot contract_annot default_addr_annot)
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Address (Item_t (Address_t None, rest, annot))
  | ( Prim (loc, I_CONTRACT, [ty], annot),
      Item_t (Address_t _, rest, addr_annot) ) -&gt;
      Lwt.return @@ parse_parameter_ty ctxt ~legacy ty
      &gt;&gt;=? fun (Ex_ty t, ctxt) -&gt;
      parse_entrypoint_annot
        loc
        annot
        ~default:(gen_access_annot addr_annot default_contract_annot)
      &gt;&gt;=? fun (annot, entrypoint) -&gt;
      ( Lwt.return
      @@
      match entrypoint with
      | None -&gt;
          Ok &quot;default&quot;
      | Some (Field_annot &quot;default&quot;) -&gt;
          error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Unexpected_annotation loc)</abbr>
      | Some (Field_annot entrypoint) -&gt;
          if Compare.Int.(String.length entrypoint &gt; 31) then
            error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Entrypoint_name_too_long entrypoint)</abbr>
          else Ok entrypoint )
      &gt;&gt;=? fun entrypoint -&gt;
      typed
        ctxt
        loc
        (Contract (t, entrypoint))
        (Item_t (Option_t (Contract_t (t, None), None, false), rest, annot))
  | ( Prim (loc, I_TRANSFER_TOKENS, [], annot),
      Item_t (p, Item_t (Mutez_t _, Item_t (Contract_t (cp, _), rest, _), _), _)
    ) -&gt;
      check_item_ty ctxt p cp loc I_TRANSFER_TOKENS 1 4
      &gt;&gt;=? fun (Eq, _, ctxt) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Transfer_tokens (Item_t (Operation_t None, rest, annot))
  | ( Prim (loc, I_SET_DELEGATE, [], annot),
      Item_t (Option_t (Key_hash_t _, _, _), rest, _) ) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Set_delegate (Item_t (Operation_t None, rest, annot))
  | ( Prim (loc, I_CREATE_ACCOUNT, [], annot),
      Item_t
        ( Key_hash_t _,
          Item_t
            ( Option_t (Key_hash_t _, _, _),
              Item_t (Bool_t _, Item_t (Mutez_t _, rest, _), _),
              _ ),
          _ ) ) -&gt;
      if legacy then
        (* For existing contracts, this instruction is still allowed *)
        parse_two_var_annot loc annot
        &gt;&gt;=? fun (op_annot, addr_annot) -&gt;
        typed
          ctxt
          loc
          Create_account
          (Item_t
             ( Operation_t None,
               Item_t (Address_t None, rest, addr_annot),
               op_annot ))
      else
        (* For new contracts this instruction is not allowed anymore *)
        fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Deprecated_instruction I_CREATE_ACCOUNT)</abbr>
  | (Prim (loc, I_IMPLICIT_ACCOUNT, [], annot), Item_t (Key_hash_t _, rest, _))
    -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed
        ctxt
        loc
        Implicit_account
        (Item_t (Contract_t (Unit_t None, None), rest, annot))
  | ( Prim (loc, I_CREATE_CONTRACT, [(Seq _ as code)], annot),
      Item_t
        ( Key_hash_t _,
          Item_t
            ( Option_t (Key_hash_t _, _, _),
              Item_t
                ( Bool_t _,
                  Item_t
                    ( Bool_t _,
                      Item_t (Mutez_t _, Item_t (ginit, rest, _), _),
                      _ ),
                  _ ),
              _ ),
          _ ) ) -&gt;
      if legacy then
        (* For existing contracts, this instruction is still allowed *)
        parse_two_var_annot loc annot
        &gt;&gt;=? fun (op_annot, addr_annot) -&gt;
        let cannonical_code = fst @@ Micheline.extract_locations code in
        Lwt.return @@ parse_toplevel ~legacy cannonical_code
        &gt;&gt;=? fun (arg_type, storage_type, code_field, root_name) -&gt;
        trace
          <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Ill_formed_type
             (Some &quot;parameter&quot;, cannonical_code, location arg_type))</abbr>
          (Lwt.return @@ parse_parameter_ty ctxt ~legacy arg_type)
        &gt;&gt;=? fun (Ex_ty arg_type, ctxt) -&gt;
        ( if legacy then Error_monad.return ()
        else Lwt.return (well_formed_entrypoints ~root_name arg_type) )
        &gt;&gt;=? fun () -&gt;
        trace
          <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Ill_formed_type
             (Some &quot;storage&quot;, cannonical_code, location storage_type))</abbr>
          (Lwt.return @@ parse_storage_ty ctxt ~legacy storage_type)
        &gt;&gt;=? fun (Ex_ty storage_type, ctxt) -&gt;
        let arg_annot =
          default_annot
            (type_to_var_annot (name_of_ty arg_type))
            ~default:default_param_annot
        in
        let storage_annot =
          default_annot
            (type_to_var_annot (name_of_ty storage_type))
            ~default:default_storage_annot
        in
        let arg_type_full =
          Pair_t
            ( (arg_type, None, arg_annot),
              (storage_type, None, storage_annot),
              None,
              has_big_map arg_type || has_big_map storage_type )
        in
        let ret_type_full =
          Pair_t
            ( (List_t (Operation_t None, None, false), None, None),
              (storage_type, None, None),
              None,
              has_big_map storage_type )
        in
        trace
          <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Ill_typed_contract (cannonical_code, []))</abbr>
          (parse_returning
             (Toplevel
                {
                  storage_type;
                  param_type = arg_type;
                  root_name;
                  legacy_create_contract_literal = true;
                })
             ctxt
             ~legacy
             ?type_logger
             (arg_type_full, None)
             ret_type_full
             code_field)
        &gt;&gt;=? fun [@coq_match_with_default] ( ( { lam =
                                                   ( { bef =
                                                         Item_t
                                                           (arg, Empty_t, _);
                                                       aft =
                                                         Item_t
                                                           (ret, Empty_t, _);
                                                       _ },
                                                     _ ) } as lambda ),
                                             ctxt ) -&gt;
        Lwt.return @@ ty_eq ctxt arg arg_type_full
        &gt;&gt;=? fun (Eq, ctxt) -&gt;
        Lwt.return @@ merge_types ~legacy ctxt loc arg arg_type_full
        &gt;&gt;=? fun (_, ctxt) -&gt;
        Lwt.return @@ ty_eq ctxt ret ret_type_full
        &gt;&gt;=? fun (Eq, ctxt) -&gt;
        Lwt.return @@ merge_types ~legacy ctxt loc ret ret_type_full
        &gt;&gt;=? fun (_, ctxt) -&gt;
        Lwt.return @@ ty_eq ctxt storage_type ginit
        &gt;&gt;=? fun (Eq, ctxt) -&gt;
        Lwt.return @@ merge_types ~legacy ctxt loc storage_type ginit
        &gt;&gt;=? fun (_, ctxt) -&gt;
        typed
          ctxt
          loc
          (Create_contract (storage_type, arg_type, lambda, root_name))
          (Item_t
             ( Operation_t None,
               Item_t (Address_t None, rest, addr_annot),
               op_annot ))
      else
        (* For new contracts this instruction is not allowed anymore *)
        fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Deprecated_instruction I_CREATE_CONTRACT)</abbr>
  | ( Prim (loc, I_CREATE_CONTRACT, [(Seq _ as code)], annot),
      (* Removed the instruction's arguments manager, spendable and delegatable *)
    Item_t
      ( Option_t (Key_hash_t _, _, _),
        Item_t (Mutez_t _, Item_t (ginit, rest, _), _),
        _ ) ) -&gt;
      parse_two_var_annot loc annot
      &gt;&gt;=? fun (op_annot, addr_annot) -&gt;
      let cannonical_code = fst @@ Micheline.extract_locations code in
      Lwt.return @@ parse_toplevel ~legacy cannonical_code
      &gt;&gt;=? fun (arg_type, storage_type, code_field, root_name) -&gt;
      trace
        <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Ill_formed_type (Some &quot;parameter&quot;, cannonical_code, location arg_type))</abbr>
        (Lwt.return @@ parse_parameter_ty ctxt ~legacy arg_type)
      &gt;&gt;=? fun (Ex_ty arg_type, ctxt) -&gt;
      ( if legacy then Error_monad.return ()
      else Lwt.return (well_formed_entrypoints ~root_name arg_type) )
      &gt;&gt;=? fun () -&gt;
      trace
        <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Ill_formed_type
           (Some &quot;storage&quot;, cannonical_code, location storage_type))</abbr>
        (Lwt.return @@ parse_storage_ty ctxt ~legacy storage_type)
      &gt;&gt;=? fun (Ex_ty storage_type, ctxt) -&gt;
      let arg_annot =
        default_annot
          (type_to_var_annot (name_of_ty arg_type))
          ~default:default_param_annot
      in
      let storage_annot =
        default_annot
          (type_to_var_annot (name_of_ty storage_type))
          ~default:default_storage_annot
      in
      let arg_type_full =
        Pair_t
          ( (arg_type, None, arg_annot),
            (storage_type, None, storage_annot),
            None,
            has_big_map arg_type || has_big_map storage_type )
      in
      let ret_type_full =
        Pair_t
          ( (List_t (Operation_t None, None, false), None, None),
            (storage_type, None, None),
            None,
            has_big_map storage_type )
      in
      trace
        <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Ill_typed_contract (cannonical_code, []))</abbr>
        (parse_returning
           (Toplevel
              {
                storage_type;
                param_type = arg_type;
                root_name;
                legacy_create_contract_literal = false;
              })
           ctxt
           ~legacy
           ?type_logger
           (arg_type_full, None)
           ret_type_full
           code_field)
      &gt;&gt;=? fun [@coq_match_with_default] ( ( { lam =
                                                 ( { bef =
                                                       Item_t (arg, Empty_t, _);
                                                     aft =
                                                       Item_t (ret, Empty_t, _);
                                                     _ },
                                                   _ ) } as lambda ),
                                           ctxt ) -&gt;
      Lwt.return @@ ty_eq ctxt arg arg_type_full
      &gt;&gt;=? fun (Eq, ctxt) -&gt;
      Lwt.return @@ merge_types ~legacy ctxt loc arg arg_type_full
      &gt;&gt;=? fun (_, ctxt) -&gt;
      Lwt.return @@ ty_eq ctxt ret ret_type_full
      &gt;&gt;=? fun (Eq, ctxt) -&gt;
      Lwt.return @@ merge_types ~legacy ctxt loc ret ret_type_full
      &gt;&gt;=? fun (_, ctxt) -&gt;
      Lwt.return @@ ty_eq ctxt storage_type ginit
      &gt;&gt;=? fun (Eq, ctxt) -&gt;
      Lwt.return @@ merge_types ~legacy ctxt loc storage_type ginit
      &gt;&gt;=? fun (_, ctxt) -&gt;
      typed
        ctxt
        loc
        (Create_contract_2 (storage_type, arg_type, lambda, root_name))
        (Item_t
           ( Operation_t None,
             Item_t (Address_t None, rest, addr_annot),
             op_annot ))
  | (Prim (loc, I_NOW, [], annot), stack) -&gt;
      parse_var_annot loc annot ~default:default_now_annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Now (Item_t (Timestamp_t None, stack, annot))
  | (Prim (loc, I_AMOUNT, [], annot), stack) -&gt;
      parse_var_annot loc annot ~default:default_amount_annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Amount (Item_t (Mutez_t None, stack, annot))
  | (Prim (loc, I_CHAIN_ID, [], annot), stack) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc ChainId (Item_t (Chain_id_t None, stack, annot))
  | (Prim (loc, I_BALANCE, [], annot), stack) -&gt;
      parse_var_annot loc annot ~default:default_balance_annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Balance (Item_t (Mutez_t None, stack, annot))
  | (Prim (loc, I_HASH_KEY, [], annot), Item_t (Key_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Hash_key (Item_t (Key_hash_t None, rest, annot))
  | ( Prim (loc, I_CHECK_SIGNATURE, [], annot),
      Item_t
        (Key_t _, Item_t (Signature_t _, Item_t (Bytes_t _, rest, _), _), _) )
    -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Check_signature (Item_t (Bool_t None, rest, annot))
  | (Prim (loc, I_BLAKE2B, [], annot), Item_t (Bytes_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Blake2b (Item_t (Bytes_t None, rest, annot))
  | (Prim (loc, I_SHA256, [], annot), Item_t (Bytes_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Sha256 (Item_t (Bytes_t None, rest, annot))
  | (Prim (loc, I_SHA512, [], annot), Item_t (Bytes_t _, rest, _)) -&gt;
      parse_var_annot loc annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Sha512 (Item_t (Bytes_t None, rest, annot))
  | (Prim (loc, I_STEPS_TO_QUOTA, [], annot), stack) -&gt;
      if legacy then
        (* For existing contracts, this instruction is still allowed *)
        parse_var_annot loc annot ~default:default_steps_annot
        &gt;&gt;=? fun annot -&gt;
        typed ctxt loc Steps_to_quota (Item_t (Nat_t None, stack, annot))
      else
        (* For new contracts this instruction is not allowed anymore *)
        fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Deprecated_instruction I_STEPS_TO_QUOTA)</abbr>
  | (Prim (loc, I_SOURCE, [], annot), stack) -&gt;
      parse_var_annot loc annot ~default:default_source_annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Source (Item_t (Address_t None, stack, annot))
  | (Prim (loc, I_SENDER, [], annot), stack) -&gt;
      parse_var_annot loc annot ~default:default_sender_annot
      &gt;&gt;=? fun annot -&gt;
      typed ctxt loc Sender (Item_t (Address_t None, stack, annot))
  | (Prim (loc, I_SELF, [], annot), stack) -&gt;
      parse_entrypoint_annot loc annot ~default:default_self_annot
      &gt;&gt;=? fun (annot, entrypoint) -&gt;
      let entrypoint =
        Option.unopt_map
          ~f:(fun (Field_annot annot) -&gt; annot)
          ~default:&quot;default&quot;
          entrypoint
      in
      let rec get_toplevel_type :
          tc_context -&gt; (bef judgement * context) tzresult Lwt.t = function
        | Lambda -&gt;
            fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Self_in_lambda loc)</abbr>
        | Dip (_, prev) -&gt;
            get_toplevel_type prev
        | Toplevel
            {param_type; root_name; legacy_create_contract_literal = false} -&gt;
            Lwt.return (find_entrypoint param_type ~root_name entrypoint)
            &gt;&gt;=? fun (_, Ex_ty param_type) -&gt;
            typed
              ctxt
              loc
              (Self (param_type, entrypoint))
              (Item_t (Contract_t (param_type, None), stack, annot))
        | Toplevel
            {param_type; root_name = _; legacy_create_contract_literal = true}
          -&gt;
            typed
              ctxt
              loc
              (Self (param_type, &quot;default&quot;))
              (Item_t (Contract_t (param_type, None), stack, annot))
      in
      get_toplevel_type tc_context
  (* Primitive parsing errors *)
  | ( Prim
        ( loc,
          ( ( I_DUP
            | I_SWAP
            | I_SOME
            | I_UNIT
            | I_PAIR
            | I_CAR
            | I_CDR
            | I_CONS
            | I_CONCAT
            | I_SLICE
            | I_MEM
            | I_UPDATE
            | I_MAP
            | I_GET
            | I_EXEC
            | I_FAILWITH
            | I_SIZE
            | I_ADD
            | I_SUB
            | I_MUL
            | I_EDIV
            | I_OR
            | I_AND
            | I_XOR
            | I_NOT
            | I_ABS
            | I_NEG
            | I_LSL
            | I_LSR
            | I_COMPARE
            | I_EQ
            | I_NEQ
            | I_LT
            | I_GT
            | I_LE
            | I_GE
            | I_TRANSFER_TOKENS
            | I_CREATE_ACCOUNT
            | I_SET_DELEGATE
            | I_NOW
            | I_IMPLICIT_ACCOUNT
            | I_AMOUNT
            | I_BALANCE
            | I_CHECK_SIGNATURE
            | I_HASH_KEY
            | I_SOURCE
            | I_SENDER
            | I_BLAKE2B
            | I_SHA256
            | I_SHA512
            | I_STEPS_TO_QUOTA
            | I_ADDRESS ) as name ),
          (_ :: _ as l),
          _ ),
      _ ) -&gt;
      fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_arity (loc, name, 0, List.length l))</abbr>
  | ( Prim
        ( loc,
          ( ( I_NONE
            | I_LEFT
            | I_RIGHT
            | I_NIL
            | I_ITER
            | I_EMPTY_SET
            | I_LOOP
            | I_LOOP_LEFT
            | I_CONTRACT ) as name ),
          (([] | _ :: _ :: _) as l),
          _ ),
      _ )
  | (Prim (loc, (I_MAP as name), ([] as l), _), _)
  | (Prim (loc, (I_DIP as name), (_ :: _ :: _ as l), _), _) -&gt;
      fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_arity (loc, name, 1, List.length l))</abbr>
  | ( Prim
        ( loc,
          ( (I_PUSH | I_IF_NONE | I_IF_LEFT | I_IF_CONS | I_EMPTY_MAP | I_IF)
          as name ),
          (([] | [_] | _ :: _ :: _ :: _) as l),
          _ ),
      _ ) -&gt;
      fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_arity (loc, name, 2, List.length l))</abbr>
  | (Prim (loc, I_LAMBDA, (([] | [_] | _ :: _ :: _ :: _ :: _) as l), _), _) -&gt;
      fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_arity (loc, I_LAMBDA, 3, List.length l))</abbr>
  (* Stack errors *)
  | ( Prim
        ( loc,
          ( ( I_ADD
            | I_SUB
            | I_MUL
            | I_EDIV
            | I_AND
            | I_OR
            | I_XOR
            | I_LSL
            | I_LSR ) as name ),
          [],
          _ ),
      Item_t (ta, Item_t (tb, _, _), _) ) -&gt;
      Lwt.return @@ serialize_ty_for_error ctxt ta
      &gt;&gt;=? fun (ta, ctxt) -&gt;
      Lwt.return @@ serialize_ty_for_error ctxt tb
      &gt;&gt;=? fun (tb, _ctxt) -&gt; fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Undefined_binop (loc, name, ta, tb))</abbr>
  | ( Prim
        ( loc,
          ( ( I_NEG
            | I_ABS
            | I_NOT
            | I_CONCAT
            | I_SIZE
            | I_EQ
            | I_NEQ
            | I_LT
            | I_GT
            | I_LE
            | I_GE ) as name ),
          [],
          _ ),
      Item_t (t, _, _) ) -&gt;
      Lwt.return @@ serialize_ty_for_error ctxt t
      &gt;&gt;=? fun (t, _ctxt) -&gt; fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Undefined_unop (loc, name, t))</abbr>
  | (Prim (loc, ((I_UPDATE | I_SLICE) as name), [], _), stack) -&gt;
      serialize_stack_for_error ctxt stack
      &gt;&gt;=? fun (stack, _ctxt) -&gt; fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Bad_stack (loc, name, 3, stack))</abbr>
  | (Prim (loc, I_CREATE_CONTRACT, _, _), stack) -&gt;
      serialize_stack_for_error ctxt stack
      &gt;&gt;=? fun (stack, _ctxt) -&gt;
      fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Bad_stack (loc, I_CREATE_CONTRACT, 7, stack))</abbr>
  | (Prim (loc, I_CREATE_ACCOUNT, [], _), stack) -&gt;
      serialize_stack_for_error ctxt stack
      &gt;&gt;=? fun (stack, _ctxt) -&gt;
      fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Bad_stack (loc, I_CREATE_ACCOUNT, 4, stack))</abbr>
  | (Prim (loc, I_TRANSFER_TOKENS, [], _), stack) -&gt;
      serialize_stack_for_error ctxt stack
      &gt;&gt;=? fun (stack, _ctxt) -&gt;
      fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Bad_stack (loc, I_TRANSFER_TOKENS, 4, stack))</abbr>
  | ( Prim
        ( loc,
          ( ( I_DROP
            | I_DUP
            | I_CAR
            | I_CDR
            | I_SOME
            | I_BLAKE2B
            | I_SHA256
            | I_SHA512
            | I_DIP
            | I_IF_NONE
            | I_LEFT
            | I_RIGHT
            | I_IF_LEFT
            | I_IF
            | I_LOOP
            | I_IF_CONS
            | I_IMPLICIT_ACCOUNT
            | I_NEG
            | I_ABS
            | I_INT
            | I_NOT
            | I_HASH_KEY
            | I_EQ
            | I_NEQ
            | I_LT
            | I_GT
            | I_LE
            | I_GE ) as name ),
          _,
          _ ),
      stack ) -&gt;
      serialize_stack_for_error ctxt stack
      &gt;&gt;=? fun (stack, _ctxt) -&gt; fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Bad_stack (loc, name, 1, stack))</abbr>
  | ( Prim
        ( loc,
          ( ( I_SWAP
            | I_PAIR
            | I_CONS
            | I_GET
            | I_MEM
            | I_EXEC
            | I_CHECK_SIGNATURE
            | I_ADD
            | I_SUB
            | I_MUL
            | I_EDIV
            | I_AND
            | I_OR
            | I_XOR
            | I_LSL
            | I_LSR ) as name ),
          _,
          _ ),
      stack ) -&gt;
      serialize_stack_for_error ctxt stack
      &gt;&gt;=? fun (stack, _ctxt) -&gt; fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Bad_stack (loc, name, 2, stack))</abbr>
  (* Generic parsing errors *)
  | (expr, _) -&gt;
      fail
      @@ unexpected
           expr
           [Seq_kind]
           Instr_namespace
           [ I_DROP;
             I_DUP;
             I_DIG;
             I_DUG;
             I_SWAP;
             I_SOME;
             I_UNIT;
             I_PAIR;
             I_CAR;
             I_CDR;
             I_CONS;
             I_MEM;
             I_UPDATE;
             I_MAP;
             I_ITER;
             I_GET;
             I_EXEC;
             I_FAILWITH;
             I_SIZE;
             I_CONCAT;
             I_ADD;
             I_SUB;
             I_MUL;
             I_EDIV;
             I_OR;
             I_AND;
             I_XOR;
             I_NOT;
             I_ABS;
             I_INT;
             I_NEG;
             I_LSL;
             I_LSR;
             I_COMPARE;
             I_EQ;
             I_NEQ;
             I_LT;
             I_GT;
             I_LE;
             I_GE;
             I_TRANSFER_TOKENS;
             I_CREATE_ACCOUNT;
             I_CREATE_CONTRACT;
             I_NOW;
             I_AMOUNT;
             I_BALANCE;
             I_IMPLICIT_ACCOUNT;
             I_CHECK_SIGNATURE;
             I_BLAKE2B;
             I_SHA256;
             I_SHA512;
             I_HASH_KEY;
             I_STEPS_TO_QUOTA;
             I_PUSH;
             I_NONE;
             I_LEFT;
             I_RIGHT;
             I_NIL;
             I_EMPTY_SET;
             I_DIP;
             I_LOOP;
             I_IF_NONE;
             I_IF_LEFT;
             I_IF_CONS;
             I_EMPTY_MAP;
             I_IF;
             I_SOURCE;
             I_SENDER;
             I_SELF;
             I_LAMBDA ]

(* Same as the one above, but does not fail when the contact is missing or
   if the expected type doesn't match the actual one. In that case None is
   returned and some overapproximation of the typechecking gas is consumed.
   This can still fail on gas exhaustion. *)
let parse_contract_for_script :
    type arg.
    legacy:bool -&gt;
    context -&gt;
    Script.location -&gt;
    arg ty -&gt;
    Contract.t -&gt;
    entrypoint:string -&gt;
    (context * arg typed_contract option) tzresult Lwt.t =
 fun ~legacy ctxt loc arg contract ~entrypoint -&gt;
  Lwt.return @@ Gas.consume ctxt Typecheck_costs.contract_exists
  &gt;&gt;=? fun ctxt -&gt;
  Contract.exists ctxt contract
  &gt;&gt;=? function
  | false -&gt;
      return (ctxt, None)
  | true -&gt; (
      Lwt.return @@ Gas.consume ctxt Typecheck_costs.get_script
      &gt;&gt;=? fun ctxt -&gt;
      trace <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_contract (loc, contract))</abbr>
      @@ Contract.get_script_code ctxt contract
      &gt;&gt;=? fun (ctxt, code) -&gt;
      match code with
      (* can only fail because of gas *)
      | None -&gt; (
        match entrypoint with
        | &quot;default&quot; -&gt;
            Lwt.return
              ( match ty_eq ctxt arg (Unit_t None) with
              | Ok (Eq, ctxt) -&gt;
                  let contract : arg typed_contract =
                    (arg, (contract, entrypoint))
                  in
                  ok (ctxt, Some contract)
              | Error _ -&gt;
                  Gas.consume ctxt Typecheck_costs.cycle
                  &gt;&gt;? fun ctxt -&gt; ok (ctxt, None) )
        | _ -&gt;
            return (ctxt, None) )
      | Some code -&gt;
          Script.force_decode_in_context ctxt code
          &gt;&gt;=? fun (code, ctxt) -&gt;
          (* can only fail because of gas *)
          Lwt.return
            ( match parse_toplevel ~legacy:true code with
            | Error _ -&gt;
                error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_contract (loc, contract))</abbr>
            | Ok (arg_type, _, _, root_name) -&gt; (
              match parse_parameter_ty ctxt ~legacy:true arg_type with
              | Error _ -&gt;
                  error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Invalid_contract (loc, contract))</abbr>
              | Ok (Ex_ty targ, ctxt) -&gt; (
                  let result =
                    find_entrypoint_for_type
                      ~full:targ
                      ~expected:arg
                      ~root_name
                      entrypoint
                      ctxt
                    &gt;&gt;? fun (ctxt, entrypoint, targ) -&gt;
                    merge_types ~legacy ctxt loc targ arg
                    &gt;&gt;? fun (targ, ctxt) -&gt;
                    merge_types ~legacy ctxt loc targ arg
                    &gt;&gt;? fun (arg, ctxt) -&gt;
                    let contract : arg typed_contract =
                      (arg, (contract, entrypoint))
                    in
                    ok (ctxt, Some contract)
                  in
                  match result with
                  | Ok res -&gt;
                      ok res
                  | Error _ -&gt;
                      (* overapproximation by checking if targ = targ,
                                                       can only fail because of gas *)
                      ty_eq ctxt targ targ
                      &gt;&gt;? fun (Eq, ctxt) -&gt;
                      merge_types ~legacy ctxt loc targ targ
                      &gt;&gt;? fun (_, ctxt) -&gt; ok (ctxt, None) ) ) ) )

let parse_script :
    ?type_logger:type_logger -&gt;
    context -&gt;
    legacy:bool -&gt;
    Script.t -&gt;
    (ex_script * context) tzresult Lwt.t =
 fun ?type_logger ctxt ~legacy {code; storage} -&gt;
  Script.force_decode_in_context ctxt code
  &gt;&gt;=? fun (code, ctxt) -&gt;
  Script.force_decode_in_context ctxt storage
  &gt;&gt;=? fun (storage, ctxt) -&gt;
  Lwt.return @@ parse_toplevel ~legacy code
  &gt;&gt;=? fun (arg_type, storage_type, code_field, root_name) -&gt;
  trace
    <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Ill_formed_type (Some &quot;parameter&quot;, code, location arg_type))</abbr>
    (Lwt.return (parse_parameter_ty ctxt ~legacy arg_type))
  &gt;&gt;=? fun (Ex_ty arg_type, ctxt) -&gt;
  ( if legacy then return ()
  else Lwt.return (well_formed_entrypoints ~root_name arg_type) )
  &gt;&gt;=? fun () -&gt;
  trace
    <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Ill_formed_type (Some &quot;storage&quot;, code, location storage_type))</abbr>
    (Lwt.return (parse_storage_ty ctxt ~legacy storage_type))
  &gt;&gt;=? fun (Ex_ty storage_type, ctxt) -&gt;
  let arg_annot =
    default_annot
      (type_to_var_annot (name_of_ty arg_type))
      ~default:default_param_annot
  in
  let storage_annot =
    default_annot
      (type_to_var_annot (name_of_ty storage_type))
      ~default:default_storage_annot
  in
  let arg_type_full =
    Pair_t
      ( (arg_type, None, arg_annot),
        (storage_type, None, storage_annot),
        None,
        has_big_map arg_type || has_big_map storage_type )
  in
  let ret_type_full =
    Pair_t
      ( (List_t (Operation_t None, None, false), None, None),
        (storage_type, None, None),
        None,
        has_big_map storage_type )
  in
  trace_eval
    (fun () -&gt;
      Lwt.return @@ serialize_ty_for_error ctxt storage_type
      &gt;&gt;|? fun (storage_type, _ctxt) -&gt;
      <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Ill_typed_data (None, storage, storage_type)</abbr>)
    (parse_data ?type_logger ctxt ~legacy storage_type (root storage))
  &gt;&gt;=? fun (storage, ctxt) -&gt;
  trace
    <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Ill_typed_contract (code, []))</abbr>
    (parse_returning
       (Toplevel
          {
            storage_type;
            param_type = arg_type;
            root_name;
            legacy_create_contract_literal = false;
          })
       ctxt
       ~legacy
       ?type_logger
       (arg_type_full, None)
       ret_type_full
       code_field)
  &gt;&gt;=? fun (code, ctxt) -&gt;
  return
    ( (Ex_script {code; arg_type; storage; storage_type; root_name} [@coq_implicit
                                                                      &quot;(c := \
                                                                       unit)&quot;]),
      ctxt )

let typecheck_code :
    context -&gt; Script.expr -&gt; (type_map * context) tzresult Lwt.t =
 fun ctxt code -&gt;
  let legacy = false in
  Lwt.return @@ parse_toplevel ~legacy code
  &gt;&gt;=? fun (arg_type, storage_type, code_field, root_name) -&gt;
  let type_map = ref [] in
  trace
    <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Ill_formed_type (Some &quot;parameter&quot;, code, location arg_type))</abbr>
    (Lwt.return (parse_parameter_ty ctxt ~legacy arg_type))
  &gt;&gt;=? fun (Ex_ty arg_type, ctxt) -&gt;
  ( if legacy then return ()
  else Lwt.return (well_formed_entrypoints ~root_name arg_type) )
  &gt;&gt;=? fun () -&gt;
  trace
    <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Ill_formed_type (Some &quot;storage&quot;, code, location storage_type))</abbr>
    (Lwt.return (parse_storage_ty ctxt ~legacy storage_type))
  &gt;&gt;=? fun (Ex_ty storage_type, ctxt) -&gt;
  let arg_annot =
    default_annot
      (type_to_var_annot (name_of_ty arg_type))
      ~default:default_param_annot
  in
  let storage_annot =
    default_annot
      (type_to_var_annot (name_of_ty storage_type))
      ~default:default_storage_annot
  in
  let arg_type_full =
    Pair_t
      ( (arg_type, None, arg_annot),
        (storage_type, None, storage_annot),
        None,
        has_big_map arg_type || has_big_map storage_type )
  in
  let ret_type_full =
    Pair_t
      ( (List_t (Operation_t None, None, false), None, None),
        (storage_type, None, None),
        None,
        has_big_map storage_type )
  in
  let result =
    parse_returning
      (Toplevel
         {
           storage_type;
           param_type = arg_type;
           root_name;
           legacy_create_contract_literal = false;
         })
      ctxt
      ~legacy
      ~type_logger:(fun loc bef aft -&gt;
        type_map := (loc, (bef, aft)) :: !type_map)
      (arg_type_full, None)
      ret_type_full
      code_field
  in
  trace <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Ill_typed_contract (code, !type_map))</abbr> result
  &gt;&gt;=? fun ({lam = _}, ctxt) -&gt; return (!type_map, ctxt)

let typecheck_data :
    ?type_logger:type_logger -&gt;
    context -&gt;
    Script.expr * Script.expr -&gt;
    context tzresult Lwt.t =
 fun ?type_logger ctxt (data, exp_ty) -&gt;
  let legacy = false in
  trace
    <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Ill_formed_type (None, exp_ty, 0))</abbr>
    (Lwt.return @@ parse_packable_ty ctxt ~legacy (root exp_ty))
  &gt;&gt;=? fun (Ex_ty exp_ty, ctxt) -&gt;
  trace_eval
    (fun () -&gt;
      Lwt.return @@ serialize_ty_for_error ctxt exp_ty
      &gt;&gt;|? fun (exp_ty, _ctxt) -&gt; <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Ill_typed_data (None, data, exp_ty)</abbr>)
    ((parse_data [@coq_implicit &quot;(a := unit)&quot;])
       ?type_logger
       ctxt
       ~legacy
       exp_ty
       (root data))
  &gt;&gt;=? fun (_, ctxt) -&gt; return ctxt

module Entrypoints_map = Map.Make (String)

let list_entrypoints (type full) (full : full ty) ctxt ~root_name =
  let merge path annot (type t) (ty : t ty) reachable
      ((unreachables, all) as acc) =
    match annot with
    | None | Some (Field_annot &quot;&quot;) -&gt; (
        ok
        @@
        if reachable then acc
        else
          match ty with
          | Union_t _ -&gt;
              acc
          | _ -&gt;
              (List.rev path :: unreachables, all) )
    | Some (Field_annot name) -&gt;
        if Compare.Int.(String.length name &gt; 31) then
          ok (List.rev path :: unreachables, all)
        else if Entrypoints_map.mem name all then
          ok (List.rev path :: unreachables, all)
        else
          unparse_ty_no_lwt ctxt ty
          &gt;&gt;? fun (unparsed_ty, _) -&gt;
          ok
            ( unreachables,
              Entrypoints_map.add name (List.rev path, unparsed_ty) all )
  in
  let rec fold_tree :
      type t.
      t ty -&gt;
      prim list -&gt;
      bool -&gt;
      prim list list * (prim list * Script.node) Entrypoints_map.t -&gt;
      (prim list list * (prim list * Script.node) Entrypoints_map.t) tzresult =
   fun t path reachable acc -&gt;
    match t with
    | Union_t ((tl, al), (tr, ar), _, _) -&gt;
        merge (D_Left :: path) al tl reachable acc
        &gt;&gt;? fun acc -&gt;
        merge (D_Right :: path) ar tr reachable acc
        &gt;&gt;? fun acc -&gt;
        fold_tree
          tl
          (D_Left :: path)
          (match al with Some _ -&gt; true | None -&gt; reachable)
          acc
        &gt;&gt;? fun acc -&gt;
        fold_tree
          tr
          (D_Right :: path)
          (match ar with Some _ -&gt; true | None -&gt; reachable)
          acc
    | _ -&gt;
        ok acc
  in
  unparse_ty_no_lwt ctxt full
  &gt;&gt;? fun (unparsed_full, _) -&gt;
  let (init, reachable) =
    match root_name with
    | None | Some &quot;&quot; -&gt;
        (Entrypoints_map.empty, false)
    | Some name -&gt;
        (Entrypoints_map.singleton name (([] : prim list), unparsed_full), true)
  in
  fold_tree full [] reachable ([], init)

(* ---- Unparsing (Typed IR -&gt; Untyped expressions) --------------------------*)

let[@coq_struct &quot;ty&quot;] rec unparse_data :
    type a.
    context -&gt;
    unparsing_mode -&gt;
    a ty -&gt;
    a -&gt;
    (Script.node * context) tzresult Lwt.t =
 fun ctxt mode ty a -&gt;
  Lwt.return (Gas.consume ctxt Unparse_costs.cycle)
  &gt;&gt;=? fun ctxt -&gt;
  match[@coq_match_gadt] (ty, a) with
  | (Unit_t _, ()) -&gt;
      Lwt.return (Gas.consume ctxt Unparse_costs.unit)
      &gt;&gt;=? fun ctxt -&gt; return (Prim (-1, D_Unit, [], []), ctxt)
  | (Int_t _, (v : Script_int.num)) -&gt;
      Lwt.return (Gas.consume ctxt (Unparse_costs.int v))
      &gt;&gt;=? fun ctxt -&gt; return (Int (-1, Script_int.to_zint v), ctxt)
  | (Nat_t _, (v : Script_int.num)) -&gt;
      Lwt.return (Gas.consume ctxt (Unparse_costs.int v))
      &gt;&gt;=? fun ctxt -&gt; return (Int (-1, Script_int.to_zint v), ctxt)
  | (String_t _, (s : string)) -&gt;
      Lwt.return (Gas.consume ctxt (Unparse_costs.string s))
      &gt;&gt;=? fun ctxt -&gt; return (String (-1, s), ctxt)
  | (Bytes_t _, (s : MBytes.t)) -&gt;
      Lwt.return (Gas.consume ctxt (Unparse_costs.bytes s))
      &gt;&gt;=? fun ctxt -&gt; return (Bytes (-1, s), ctxt)
  | (Bool_t _, (b : bool)) -&gt;
      Lwt.return (Gas.consume ctxt Unparse_costs.bool)
      &gt;&gt;=? fun ctxt -&gt;
      if b then return (Prim (-1, D_True, [], []), ctxt)
      else return (Prim (-1, D_False, [], []), ctxt)
  | (Timestamp_t _, (t : Script_timestamp.t)) -&gt; (
      Lwt.return (Gas.consume ctxt (Unparse_costs.timestamp t))
      &gt;&gt;=? fun ctxt -&gt;
      match mode with
      | Optimized -&gt;
          return (Int (-1, Script_timestamp.to_zint t), ctxt)
      | Readable -&gt; (
        match Script_timestamp.to_notation t with
        | None -&gt;
            return (Int (-1, Script_timestamp.to_zint t), ctxt)
        | Some s -&gt;
            return (String (-1, s), ctxt) ) )
  | (Address_t _, (a : address)) -&gt; (
      let (c, entrypoint) = a in
      Lwt.return (Gas.consume ctxt Unparse_costs.contract)
      &gt;&gt;=? fun ctxt -&gt;
      match mode with
      | Optimized -&gt;
          let entrypoint =
            match entrypoint with &quot;default&quot; -&gt; &quot;&quot; | name -&gt; name
          in
          let bytes =
            Data_encoding.Binary.to_bytes_exn
              Data_encoding.(tup2 Contract.encoding Variable.string)
              (c, entrypoint)
          in
          return (Bytes (-1, bytes), ctxt)
      | Readable -&gt;
          let notation =
            match entrypoint with
            | &quot;default&quot; -&gt;
                Contract.to_b58check c
            | entrypoint -&gt;
                Contract.to_b58check c ^ &quot;%&quot; ^ entrypoint
          in
          return (String (-1, notation), ctxt) )
  | (Contract_t _, (a : _ typed_contract)) -&gt; (
      let (_, (c, entrypoint)) = a in
      Lwt.return (Gas.consume ctxt Unparse_costs.contract)
      &gt;&gt;=? fun ctxt -&gt;
      match mode with
      | Optimized -&gt;
          let entrypoint =
            match entrypoint with &quot;default&quot; -&gt; &quot;&quot; | name -&gt; name
          in
          let bytes =
            Data_encoding.Binary.to_bytes_exn
              Data_encoding.(tup2 Contract.encoding Variable.string)
              (c, entrypoint)
          in
          return (Bytes (-1, bytes), ctxt)
      | Readable -&gt;
          let notation =
            match entrypoint with
            | &quot;default&quot; -&gt;
                Contract.to_b58check c
            | entrypoint -&gt;
                Contract.to_b58check c ^ &quot;%&quot; ^ entrypoint
          in
          return (String (-1, notation), ctxt) )
  | (Signature_t _, (s : signature)) -&gt; (
      Lwt.return (Gas.consume ctxt Unparse_costs.signature)
      &gt;&gt;=? fun ctxt -&gt;
      match mode with
      | Optimized -&gt;
          let bytes = Data_encoding.Binary.to_bytes_exn Signature.encoding s in
          return (Bytes (-1, bytes), ctxt)
      | Readable -&gt;
          return (String (-1, Signature.to_b58check s), ctxt) )
  | (Mutez_t _, (v : Tez.t)) -&gt;
      Lwt.return (Gas.consume ctxt Unparse_costs.tez)
      &gt;&gt;=? fun ctxt -&gt; return (Int (-1, Z.of_int64 (Tez.to_mutez v)), ctxt)
  | (Key_t _, (k : public_key)) -&gt; (
      Lwt.return (Gas.consume ctxt Unparse_costs.key)
      &gt;&gt;=? fun ctxt -&gt;
      match mode with
      | Optimized -&gt;
          let bytes =
            Data_encoding.Binary.to_bytes_exn Signature.Public_key.encoding k
          in
          return (Bytes (-1, bytes), ctxt)
      | Readable -&gt;
          return (String (-1, Signature.Public_key.to_b58check k), ctxt) )
  | (Key_hash_t _, (k : public_key_hash)) -&gt; (
      Lwt.return (Gas.consume ctxt Unparse_costs.key_hash)
      &gt;&gt;=? fun ctxt -&gt;
      match mode with
      | Optimized -&gt;
          let bytes =
            Data_encoding.Binary.to_bytes_exn
              Signature.Public_key_hash.encoding
              k
          in
          return (Bytes (-1, bytes), ctxt)
      | Readable -&gt;
          return (String (-1, Signature.Public_key_hash.to_b58check k), ctxt) )
  | (Operation_t _, (a : operation)) -&gt;
      let (op, _big_map_diff) = a in
      let bytes =
        Data_encoding.Binary.to_bytes_exn
          Operation.internal_operation_encoding
          op
      in
      Lwt.return (Gas.consume ctxt (Unparse_costs.operation bytes))
      &gt;&gt;=? fun ctxt -&gt; return (Bytes (-1, bytes), ctxt)
  | (Chain_id_t _, (chain_id : Chain_id.t)) -&gt;
      let bytes =
        Data_encoding.Binary.to_bytes_exn Chain_id.encoding chain_id
      in
      Lwt.return (Gas.consume ctxt (Unparse_costs.chain_id bytes))
      &gt;&gt;=? fun ctxt -&gt; return (Bytes (-1, bytes), ctxt)
  | (Pair_t ((tl, _, _), (tr, _, _), _, _), (a : _ * _)) -&gt;
      let (l, r) = a in
      Lwt.return (Gas.consume ctxt Unparse_costs.pair)
      &gt;&gt;=? fun ctxt -&gt;
      unparse_data ctxt mode tl l
      &gt;&gt;=? fun (l, ctxt) -&gt;
      unparse_data ctxt mode tr r
      &gt;&gt;=? fun (r, ctxt) -&gt; return (Prim (-1, D_Pair, [l; r], []), ctxt)
  | (Union_t ((tl, _), (tr, _), _, _), (a : (_, _) union)) -&gt; (
      Lwt.return (Gas.consume ctxt Unparse_costs.union)
      &gt;&gt;=? fun ctxt -&gt;
      match a with
      | L l -&gt;
          unparse_data ctxt mode tl l
          &gt;&gt;=? fun (l, ctxt) -&gt; return (Prim (-1, D_Left, [l], []), ctxt)
      | R r -&gt;
          unparse_data ctxt mode tr r
          &gt;&gt;=? fun (r, ctxt) -&gt; return (Prim (-1, D_Right, [r], []), ctxt) )
  | (Option_t (t, _, _), (a : _ option)) -&gt; (
    match a with
    | Some v -&gt;
        Lwt.return (Gas.consume ctxt Unparse_costs.some)
        &gt;&gt;=? fun ctxt -&gt;
        unparse_data ctxt mode t v
        &gt;&gt;=? fun (v, ctxt) -&gt; return (Prim (-1, D_Some, [v], []), ctxt)
    | None -&gt;
        Lwt.return (Gas.consume ctxt Unparse_costs.none)
        &gt;&gt;=? fun ctxt -&gt; return (Prim (-1, D_None, [], []), ctxt) )
  | (List_t (t, _, _), (items : _ list)) -&gt;
      fold_left_s
        (fun (l, ctxt) element -&gt;
          Lwt.return (Gas.consume ctxt Unparse_costs.list_element)
          &gt;&gt;=? fun ctxt -&gt;
          unparse_data ctxt mode t element
          &gt;&gt;=? fun (unparsed, ctxt) -&gt; return (unparsed :: l, ctxt))
        ([], ctxt)
        items
      &gt;&gt;=? fun (items, ctxt) -&gt;
      return (Micheline.Seq (-1, List.rev items), ctxt)
  | (Set_t (t, _), (set : _ set)) -&gt;
      let t = ty_of_comparable_ty t in
      fold_left_s
        (fun (l, ctxt) item -&gt;
          Lwt.return (Gas.consume ctxt Unparse_costs.set_element)
          &gt;&gt;=? fun ctxt -&gt;
          unparse_data ctxt mode t item
          &gt;&gt;=? fun (item, ctxt) -&gt; return (item :: l, ctxt))
        ([], ctxt)
        (set_fold (fun e acc -&gt; e :: acc) set [])
      &gt;&gt;=? fun (items, ctxt) -&gt; return (Micheline.Seq (-1, items), ctxt)
  | (Map_t (kt, vt, _, _), (map : (_, _) map)) -&gt;
      let kt = ty_of_comparable_ty kt in
      fold_left_s
        (fun (l, ctxt) (k, v) -&gt;
          Lwt.return (Gas.consume ctxt Unparse_costs.map_element)
          &gt;&gt;=? fun ctxt -&gt;
          unparse_data ctxt mode kt k
          &gt;&gt;=? fun (key, ctxt) -&gt;
          unparse_data ctxt mode vt v
          &gt;&gt;=? fun (value, ctxt) -&gt;
          return (Prim (-1, D_Elt, [key; value], []) :: l, ctxt))
        ([], ctxt)
        (map_fold (fun k v acc -&gt; (k, v) :: acc) map [])
      &gt;&gt;=? fun (items, ctxt) -&gt; return (Micheline.Seq (-1, items), ctxt)
  | (Big_map_t (kt, vt, _), (a : (_, _) big_map)) -&gt; (
      let {id; diff = (module Diff); _} = a in
      match id with
      | None -&gt;
          (* this branch is to allow roundtrip of big map literals *)
          let kt = ty_of_comparable_ty kt in
          fold_left_s
            (fun (l, ctxt) (k, v) -&gt;
              Lwt.return (Gas.consume ctxt Unparse_costs.map_element)
              &gt;&gt;=? fun ctxt -&gt;
              unparse_data ctxt mode kt k
              &gt;&gt;=? fun (key, ctxt) -&gt;
              unparse_data ctxt mode vt v
              &gt;&gt;=? fun (value, ctxt) -&gt;
              return (Prim (-1, D_Elt, [key; value], []) :: l, ctxt))
            ([], ctxt)
            (Diff.OPS.fold
               (fun k v acc -&gt;
                 match v with None -&gt; acc | Some v -&gt; (k, v) :: acc)
               (fst Diff.boxed)
               [])
          &gt;&gt;=? fun (items, ctxt) -&gt; return (Micheline.Seq (-1, items), ctxt)
      | Some id -&gt;
          if Compare.Int.(Diff.OPS.cardinal (fst Diff.boxed) = 0) then
            return (Micheline.Int (-1, id), ctxt)
          else
            (* this can only be the result of an execution and the map
         must have been flushed at this point *)
            <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr> )
  | (Lambda_t _, (a : (_, _) lambda)) -&gt;
      let {lam = (_, original_code)} = a in
      unparse_code ctxt mode original_code

(* Gas accounting may not be perfect in this function, as it is only called by RPCs. *)
and unparse_code ctxt mode =
  let legacy = true in
  function
  | Prim (loc, I_PUSH, [ty; data], annot) -&gt;
      Lwt.return (parse_packable_ty ctxt ~legacy ty)
      &gt;&gt;=? fun (Ex_ty t, ctxt) -&gt;
      (parse_data [@coq_implicit &quot;(a := unit)&quot;]) ctxt ~legacy t data
      &gt;&gt;=? fun (data, ctxt) -&gt;
      unparse_data ctxt mode t data
      &gt;&gt;=? fun (data, ctxt) -&gt;
      Lwt.return (Gas.consume ctxt (Unparse_costs.prim_cost 2 annot))
      &gt;&gt;=? fun ctxt -&gt; return (Prim (loc, I_PUSH, [ty; data], annot), ctxt)
  | Seq (loc, items) -&gt;
      fold_left_s
        (fun (l, ctxt) item -&gt;
          unparse_code ctxt mode item
          &gt;&gt;=? fun (item, ctxt) -&gt; return (item :: l, ctxt))
        ([], ctxt)
        items
      &gt;&gt;=? fun (items, ctxt) -&gt;
      Lwt.return
        (Gas.consume ctxt (Unparse_costs.seq_cost (List.length items)))
      &gt;&gt;=? fun ctxt -&gt; return (Micheline.Seq (loc, List.rev items), ctxt)
  | Prim (loc, prim, items, annot) -&gt;
      fold_left_s
        (fun (l, ctxt) item -&gt;
          unparse_code ctxt mode item
          &gt;&gt;=? fun (item, ctxt) -&gt; return (item :: l, ctxt))
        ([], ctxt)
        items
      &gt;&gt;=? fun (items, ctxt) -&gt;
      Lwt.return (Gas.consume ctxt (Unparse_costs.prim_cost 3 annot))
      &gt;&gt;=? fun ctxt -&gt; return (Prim (loc, prim, List.rev items, annot), ctxt)
  | (Int _ | String _ | Bytes _) as atom -&gt;
      return (atom, ctxt)

(* Gas accounting may not be perfect in this function, as it is only called by RPCs. *)
let unparse_script ctxt mode {code; arg_type; storage; storage_type; root_name}
    =
  let {lam = (_, original_code)} = code in
  unparse_code ctxt mode original_code
  &gt;&gt;=? fun (code, ctxt) -&gt;
  unparse_data ctxt mode storage_type storage
  &gt;&gt;=? fun (storage, ctxt) -&gt;
  unparse_ty ctxt arg_type
  &gt;&gt;=? fun (arg_type, ctxt) -&gt;
  unparse_ty ctxt storage_type
  &gt;&gt;=? fun (storage_type, ctxt) -&gt;
  let arg_type =
    add_field_annot
      (Option.map ~f:(fun n -&gt; Field_annot n) root_name)
      None
      arg_type
  in
  let open Micheline in
  let code =
    Seq
      ( -1,
        [ Prim (-1, K_parameter, [arg_type], []);
          Prim (-1, K_storage, [storage_type], []);
          Prim (-1, K_code, [code], []) ] )
  in
  Lwt.return
    ( Gas.consume ctxt (Unparse_costs.seq_cost 3)
    &gt;&gt;? fun ctxt -&gt;
    Gas.consume ctxt (Unparse_costs.prim_cost 1 [])
    &gt;&gt;? fun ctxt -&gt;
    Gas.consume ctxt (Unparse_costs.prim_cost 1 [])
    &gt;&gt;? fun ctxt -&gt; Gas.consume ctxt (Unparse_costs.prim_cost 1 []) )
  &gt;&gt;=? fun ctxt -&gt;
  return
    ( {
        code = lazy_expr (strip_locations code);
        storage = lazy_expr (strip_locations storage);
      },
      ctxt )

let pack_data ctxt typ data =
  unparse_data ctxt Optimized typ data
  &gt;&gt;=? fun (unparsed, ctxt) -&gt;
  let bytes =
    Data_encoding.Binary.to_bytes_exn
      expr_encoding
      (Micheline.strip_locations unparsed)
  in
  Lwt.return @@ Gas.consume ctxt (Script.serialized_cost bytes)
  &gt;&gt;=? fun ctxt -&gt;
  let bytes = MBytes.concat &quot;&quot; [MBytes.of_string &quot;\005&quot;; bytes] in
  Lwt.return @@ Gas.consume ctxt (Script.serialized_cost bytes)
  &gt;&gt;=? fun ctxt -&gt; return (bytes, ctxt)

let hash_data ctxt typ data =
  pack_data ctxt typ data
  &gt;&gt;=? fun (bytes, ctxt) -&gt;
  Lwt.return
  @@ Gas.consume
       ctxt
       (Michelson_v1_gas.Cost_of.Legacy.hash bytes Script_expr_hash.size)
  &gt;&gt;=? fun ctxt -&gt; return (Script_expr_hash.(hash_bytes [bytes]), ctxt)

(* ---------------- Big map -------------------------------------------------*)

let empty_big_map tk tv =
  {
    id = None;
    diff = empty_map tk;
    key_type = ty_of_comparable_ty tk;
    value_type = tv;
  }

let big_map_mem ctxt key {id; diff; key_type; _} =
  match (map_get key diff, id) with
  | (None, None) -&gt;
      return (false, ctxt)
  | (None, Some id) -&gt;
      hash_data ctxt key_type key
      &gt;&gt;=? fun (hash, ctxt) -&gt;
      Alpha_context.Big_map.mem ctxt id hash
      &gt;&gt;=? fun (ctxt, res) -&gt; return (res, ctxt)
  | (Some None, _) -&gt;
      return (false, ctxt)
  | (Some (Some _), _) -&gt;
      return (true, ctxt)

let big_map_get ctxt key {id; diff; key_type; value_type} =
  match (map_get key diff, id) with
  | (Some x, _) -&gt;
      return (x, ctxt)
  | (None, None) -&gt;
      return (None, ctxt)
  | (None, Some id) -&gt; (
      hash_data ctxt key_type key
      &gt;&gt;=? fun (hash, ctxt) -&gt;
      Alpha_context.Big_map.get_opt ctxt id hash
      &gt;&gt;=? function
      | (ctxt, None) -&gt;
          return (None, ctxt)
      | (ctxt, Some value) -&gt;
          parse_data ctxt ~legacy:true value_type (Micheline.root value)
          &gt;&gt;=? fun (x, ctxt) -&gt; return (Some x, ctxt) )

let big_map_update key value ({diff; _} as map) =
  {map with diff = map_set key value diff}

module Ids = Set.Make (Compare.Z)

type big_map_ids = Ids.t

let no_big_map_id = Ids.empty

let diff_of_big_map ctxt fresh mode ~ids {id; key_type; value_type; diff} =
  Lwt.return
    (Gas.consume ctxt (Michelson_v1_gas.Cost_of.Legacy.map_to_list diff))
  &gt;&gt;=? fun ctxt -&gt;
  ( match id with
  | Some id -&gt;
      if Ids.mem id ids then
        fresh ctxt
        &gt;&gt;=? fun (ctxt, duplicate) -&gt;
        return (ctxt, [Contract.Copy (id, duplicate)], duplicate)
      else
        (* The first occurence encountered of a big_map reuses the
             ID. This way, the payer is only charged for the diff.
             For this to work, this diff has to be put at the end of
             the global diff, otherwise the duplicates will use the
             updated version as a base. This is true because we add
             this diff first in the accumulator of
             `extract_big_map_updates`, and this accumulator is not
             reversed before being flattened. *)
        return (ctxt, [], id)
  | None -&gt;
      fresh ctxt
      &gt;&gt;=? fun (ctxt, id) -&gt;
      unparse_ty ctxt key_type
      &gt;&gt;=? fun (kt, ctxt) -&gt;
      unparse_ty ctxt value_type
      &gt;&gt;=? fun (kv, ctxt) -&gt;
      return
        ( ctxt,
          [ Contract.Alloc
              {
                big_map = id;
                key_type = Micheline.strip_locations kt;
                value_type = Micheline.strip_locations kv;
              } ],
          id ) )
  &gt;&gt;=? fun (ctxt, init, big_map) -&gt;
  let pairs = map_fold (fun key value acc -&gt; (key, value) :: acc) diff [] in
  fold_left_s
    (fun (acc, ctxt) (key, value) -&gt;
      Lwt.return (Gas.consume ctxt Typecheck_costs.cycle)
      &gt;&gt;=? fun ctxt -&gt;
      hash_data ctxt key_type key
      &gt;&gt;=? fun (diff_key_hash, ctxt) -&gt;
      unparse_data ctxt mode key_type key
      &gt;&gt;=? fun (key_node, ctxt) -&gt;
      let diff_key = Micheline.strip_locations key_node in
      ( match value with
      | None -&gt;
          return (None, ctxt)
      | Some x -&gt;
          unparse_data ctxt mode value_type x
          &gt;&gt;=? fun (node, ctxt) -&gt;
          return (Some (Micheline.strip_locations node), ctxt) )
      &gt;&gt;=? fun (diff_value, ctxt) -&gt;
      let diff_item =
        Contract.Update {big_map; diff_key; diff_key_hash; diff_value}
      in
      return (diff_item :: acc, ctxt))
    ([], ctxt)
    pairs
  &gt;&gt;=? fun (diff, ctxt) -&gt; return (init @ diff, big_map, ctxt)

let rec extract_big_map_updates :
    type a.
    context -&gt;
    (context -&gt; (context * Big_map.id) tzresult Lwt.t) -&gt;
    unparsing_mode -&gt;
    Ids.t -&gt;
    Contract.big_map_diff list -&gt;
    a ty -&gt;
    a -&gt;
    (context * a * Ids.t * Contract.big_map_diff list) tzresult Lwt.t =
 fun ctxt fresh mode ids acc ty x -&gt;
  match[@coq_match_gadt_with_result] (ty, x) with
  | (Big_map_t (_, _, _), (map : (_, _) big_map)) -&gt;
      diff_of_big_map ctxt fresh mode ids map
      &gt;&gt;=? fun (diff, id, ctxt) -&gt;
      let (module Map) = map.diff in
      let map = {map with diff = empty_map Map.key_ty; id = Some id} in
      return (ctxt, map, Ids.add id ids, diff :: acc)
  | (Pair_t ((tyl, _, _), (tyr, _, _), _, true), (x : _ * _)) -&gt;
      let (xl, xr) = x in
      Lwt.return (Gas.consume ctxt Typecheck_costs.cycle)
      &gt;&gt;=? fun ctxt -&gt;
      extract_big_map_updates ctxt fresh mode ids acc tyl xl
      &gt;&gt;=? fun (ctxt, xl, ids, acc) -&gt;
      extract_big_map_updates ctxt fresh mode ids acc tyr xr
      &gt;&gt;=? fun (ctxt, xr, ids, acc) -&gt; return (ctxt, (xl, xr), ids, acc)
  | (Union_t ((ty_l, _), (ty_r, _), _, true), (x : (_, _) union)) -&gt; (
      Lwt.return (Gas.consume ctxt Typecheck_costs.cycle)
      &gt;&gt;=? fun ctxt -&gt;
      match x with
      | L x -&gt;
          extract_big_map_updates ctxt fresh mode ids acc ty_l x
          &gt;&gt;=? fun (ctxt, x, ids, acc) -&gt; return (ctxt, L x, ids, acc)
      | R x -&gt;
          extract_big_map_updates ctxt fresh mode ids acc ty_r x
          &gt;&gt;=? fun (ctxt, x, ids, acc) -&gt; return (ctxt, R x, ids, acc) )
  | (Option_t (ty, _, true), (x : _ option)) -&gt; (
    match x with
    | Some x -&gt;
        Lwt.return (Gas.consume ctxt Typecheck_costs.cycle)
        &gt;&gt;=? fun ctxt -&gt;
        extract_big_map_updates ctxt fresh mode ids acc ty x
        &gt;&gt;=? fun (ctxt, x, ids, acc) -&gt; return (ctxt, Some x, ids, acc)
    | None -&gt;
        return (ctxt, None, ids, acc) )
  | (List_t (ty, _, true), (l : _ list)) -&gt;
      fold_left_s
        (fun (ctxt, l, ids, acc) x -&gt;
          Lwt.return (Gas.consume ctxt Typecheck_costs.cycle)
          &gt;&gt;=? fun ctxt -&gt;
          extract_big_map_updates ctxt fresh mode ids acc ty x
          &gt;&gt;=? fun (ctxt, x, ids, acc) -&gt; return (ctxt, x :: l, ids, acc))
        (ctxt, [], ids, acc)
        l
      &gt;&gt;=? fun (ctxt, l, ids, acc) -&gt; return (ctxt, List.rev l, ids, acc)
  | (Map_t (_, ty, _, true), (m : (_, _) map)) -&gt;
      let (module M) = m in
      Lwt.return
        (Gas.consume ctxt (Michelson_v1_gas.Cost_of.Legacy.map_to_list m))
      &gt;&gt;=? fun ctxt -&gt;
      fold_left_s
        (fun (ctxt, m, ids, acc) (k, x) -&gt;
          Lwt.return (Gas.consume ctxt Typecheck_costs.cycle)
          &gt;&gt;=? fun ctxt -&gt;
          extract_big_map_updates ctxt fresh mode ids acc ty x
          &gt;&gt;=? fun (ctxt, x, ids, acc) -&gt;
          return (ctxt, M.OPS.add k x m, ids, acc))
        (ctxt, M.OPS.empty, ids, acc)
        (M.OPS.bindings (fst M.boxed))
      &gt;&gt;=? fun (ctxt, m, ids, acc) -&gt;
      let module M : Boxed_map with type key = M.key and type value = M.value =
      struct
        module OPS = M.OPS

        type key = M.key

        type value = M.value

        let key_ty = M.key_ty

        let boxed = (m, snd M.boxed)
      end in
      (return [@coq_implicit
                &quot;(a := context * Script_typed_ir.map __8 __9 * big_map_ids * \
                 list Contract.big_map_diff)&quot;])
        (ctxt, ((module M) : (_, _) map), ids, acc)
  | (List_t (_, _, false), v) -&gt;
      return (ctxt, v, ids, acc)
  | (Map_t (_, _, _, false), v) -&gt;
      return (ctxt, v, ids, acc)
  | (Pair_t (_, _, _, false), v) -&gt;
      return (ctxt, v, ids, acc)
  | (Union_t (_, _, _, false), v) -&gt;
      return (ctxt, v, ids, acc)
  | (Option_t (_, _, false), v) -&gt;
      return (ctxt, v, ids, acc)
  | (Chain_id_t _, v) -&gt;
      return (ctxt, v, ids, acc)
  | (Set_t (_, _), v) -&gt;
      return (ctxt, v, ids, acc)
  | (Unit_t _, v) -&gt;
      return (ctxt, v, ids, acc)
  | (Int_t _, v) -&gt;
      return (ctxt, v, ids, acc)
  | (Nat_t _, v) -&gt;
      return (ctxt, v, ids, acc)
  | (Signature_t _, v) -&gt;
      return (ctxt, v, ids, acc)
  | (String_t _, v) -&gt;
      return (ctxt, v, ids, acc)
  | (Bytes_t _, v) -&gt;
      return (ctxt, v, ids, acc)
  | (Mutez_t _, v) -&gt;
      return (ctxt, v, ids, acc)
  | (Key_hash_t _, v) -&gt;
      return (ctxt, v, ids, acc)
  | (Key_t _, v) -&gt;
      return (ctxt, v, ids, acc)
  | (Timestamp_t _, v) -&gt;
      return (ctxt, v, ids, acc)
  | (Address_t _, v) -&gt;
      return (ctxt, v, ids, acc)
  | (Bool_t _, v) -&gt;
      return (ctxt, v, ids, acc)
  | (Lambda_t (_, _, _), v) -&gt;
      return (ctxt, v, ids, acc)
  | (Contract_t (_, _), v) -&gt;
      return (ctxt, v, ids, acc)
  | (Operation_t _, _) -&gt;
      <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>

(* called only on parameters and storage, which cannot contain operations *)

let collect_big_maps ctxt ty x =
  let rec collect :
      type a. context -&gt; a ty -&gt; a -&gt; Ids.t -&gt; (Ids.t * context) tzresult =
   fun ctxt ty x acc -&gt;
    match[@coq_match_gadt] (ty, x) with
    | (Big_map_t (_, _, _), (x : (_, _) big_map)) -&gt; (
      match x with
      | {id = Some id} -&gt;
          Gas.consume ctxt Typecheck_costs.cycle
          &gt;&gt;? fun ctxt -&gt; ok (Ids.add id acc, ctxt)
      | {id = None} -&gt;
          ok (acc, ctxt) )
    | (Pair_t ((tyl, _, _), (tyr, _, _), _, true), (x : _ * _)) -&gt;
        let (xl, xr) = x in
        collect ctxt tyl xl acc &gt;&gt;? fun (acc, ctxt) -&gt; collect ctxt tyr xr acc
    | (Union_t ((ty_l, _), (ty_r, _), _, true), (x : (_, _) union)) -&gt; (
      match x with
      | L x -&gt;
          collect ctxt ty_l x acc
      | R x -&gt;
          collect ctxt ty_r x acc )
    | (Option_t (ty, _, true), (x : _ option)) -&gt; (
      match x with Some x -&gt; collect ctxt ty x acc | None -&gt; ok (acc, ctxt) )
    | (List_t (ty, _, true), (l : _ list)) -&gt;
        List.fold_left
          (fun acc x -&gt; acc &gt;&gt;? fun (acc, ctxt) -&gt; collect ctxt ty x acc)
          (ok (acc, ctxt))
          l
    | (Map_t (_, ty, _, true), (m : (_, _) map)) -&gt;
        map_fold
          (fun _ v acc -&gt; acc &gt;&gt;? fun (acc, ctxt) -&gt; collect ctxt ty v acc)
          m
          (ok (acc, ctxt))
    | (List_t (_, _, false), _) -&gt;
        ok (acc, ctxt)
    | (Map_t (_, _, _, false), _) -&gt;
        ok (acc, ctxt)
    | (Option_t (_, _, false), _) -&gt;
        ok (acc, ctxt)
    | (Union_t (_, _, _, false), _) -&gt;
        ok (acc, ctxt)
    | (Pair_t (_, _, _, false), _) -&gt;
        ok (acc, ctxt)
    | (Chain_id_t _, _) -&gt;
        ok (acc, ctxt)
    | (Set_t (_, _), _) -&gt;
        ok (acc, ctxt)
    | (Unit_t _, _) -&gt;
        ok (acc, ctxt)
    | (Int_t _, _) -&gt;
        ok (acc, ctxt)
    | (Nat_t _, _) -&gt;
        ok (acc, ctxt)
    | (Signature_t _, _) -&gt;
        ok (acc, ctxt)
    | (String_t _, _) -&gt;
        ok (acc, ctxt)
    | (Bytes_t _, _) -&gt;
        ok (acc, ctxt)
    | (Mutez_t _, _) -&gt;
        ok (acc, ctxt)
    | (Key_hash_t _, _) -&gt;
        ok (acc, ctxt)
    | (Key_t _, _) -&gt;
        ok (acc, ctxt)
    | (Timestamp_t _, _) -&gt;
        ok (acc, ctxt)
    | (Address_t _, _) -&gt;
        ok (acc, ctxt)
    | (Bool_t _, _) -&gt;
        ok (acc, ctxt)
    | (Lambda_t (_, _, _), _) -&gt;
        ok (acc, ctxt)
    | (Contract_t (_, _), _) -&gt;
        ok (acc, ctxt)
    | (Operation_t _, _) -&gt;
        <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
   (* called only on parameters and storage, which cannot contain operations *)
  in
  Lwt.return (collect ctxt ty x no_big_map_id)

let extract_big_map_diff ctxt mode ~temporary ~to_duplicate ~to_update ty v =
  let to_duplicate = Ids.diff to_duplicate to_update in
  let fresh =
    if temporary then fun c -&gt; return (Big_map.fresh_temporary c)
    else Big_map.fresh
  in
  extract_big_map_updates ctxt fresh mode to_duplicate [] ty v
  &gt;&gt;=? fun (ctxt, v, alive, diffs) -&gt;
  let diffs =
    if temporary then diffs
    else
      let dead = Ids.diff to_update alive in
      Ids.fold (fun id acc -&gt; Contract.Clear id :: acc) dead [] :: diffs
  in
  match diffs with
  | [] -&gt;
      return (v, None, ctxt)
  | diffs -&gt;
      return (v, Some (List.flatten diffs (* do not reverse *)), ctxt)

let list_of_big_map_ids ids = Ids.elements ids
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_ir_translator.ml"><code>Script_ir_translator.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Michelson_v1_gas.
Require Tezos.Script_expr_hash.
Require Tezos.Script_ir_annot.
Require Tezos.Script_tc_errors.
Require Tezos.Script_typed_ir.

Import Alpha_context.

Import Micheline.

Import Alpha_context.Script.

Import Script_typed_ir.

Import Script_tc_errors.

Import Script_ir_annot.

Module Typecheck_costs := Michelson_v1_gas.Cost_of.Typechecking.

Module Unparse_costs := Michelson_v1_gas.Cost_of.Unparse.

Inductive ex_comparable_ty : Set :=
| Ex_comparable_ty : Script_typed_ir.comparable_ty -&gt; ex_comparable_ty.

Inductive ex_ty : Set :=
| Ex_ty : Script_typed_ir.ty -&gt; ex_ty.

Inductive ex_stack_ty : Set :=
| Ex_stack_ty : Script_typed_ir.stack_ty -&gt; ex_stack_ty.

Module ConstructorRecords_tc_context.
  Module tc_context.
    Module Toplevel.
      Record record {storage_type param_type root_name
        legacy_create_contract_literal : Set} : Set := Build {
        storage_type : storage_type;
        param_type : param_type;
        root_name : root_name;
        legacy_create_contract_literal : legacy_create_contract_literal }.
      Arguments record : clear implicits.
      Definition with_storage_type
        {t_storage_type t_param_type t_root_name
          t_legacy_create_contract_literal} storage_type
        (r :
          record t_storage_type t_param_type t_root_name
            t_legacy_create_contract_literal) :=
        Build t_storage_type t_param_type t_root_name
          t_legacy_create_contract_literal storage_type r.(param_type)
          r.(root_name) r.(legacy_create_contract_literal).
      Definition with_param_type
        {t_storage_type t_param_type t_root_name
          t_legacy_create_contract_literal} param_type
        (r :
          record t_storage_type t_param_type t_root_name
            t_legacy_create_contract_literal) :=
        Build t_storage_type t_param_type t_root_name
          t_legacy_create_contract_literal r.(storage_type) param_type
          r.(root_name) r.(legacy_create_contract_literal).
      Definition with_root_name
        {t_storage_type t_param_type t_root_name
          t_legacy_create_contract_literal} root_name
        (r :
          record t_storage_type t_param_type t_root_name
            t_legacy_create_contract_literal) :=
        Build t_storage_type t_param_type t_root_name
          t_legacy_create_contract_literal r.(storage_type) r.(param_type)
          root_name r.(legacy_create_contract_literal).
      Definition with_legacy_create_contract_literal
        {t_storage_type t_param_type t_root_name
          t_legacy_create_contract_literal} legacy_create_contract_literal
        (r :
          record t_storage_type t_param_type t_root_name
            t_legacy_create_contract_literal) :=
        Build t_storage_type t_param_type t_root_name
          t_legacy_create_contract_literal r.(storage_type) r.(param_type)
          r.(root_name) legacy_create_contract_literal.
    End Toplevel.
    Definition Toplevel_skeleton := Toplevel.record.
  End tc_context.
End ConstructorRecords_tc_context.
Import ConstructorRecords_tc_context.

Reserved Notation &quot;'tc_context.Toplevel&quot;.

Inductive tc_context : Set :=
| Lambda : tc_context
| Dip : Script_typed_ir.stack_ty -&gt; tc_context -&gt; tc_context
| Toplevel : 'tc_context.Toplevel -&gt; tc_context

where &quot;'tc_context.Toplevel&quot; :=
  (tc_context.Toplevel_skeleton Script_typed_ir.ty Script_typed_ir.ty
    (option string) bool).

Module tc_context.
  Include ConstructorRecords_tc_context.tc_context.
  Definition Toplevel := 'tc_context.Toplevel.
End tc_context.

Inductive unparsing_mode : Set :=
| Optimized : unparsing_mode
| Readable : unparsing_mode.

Definition type_logger : Set :=
  int -&gt; list (Alpha_context.Script.expr * Alpha_context.Script.annot) -&gt;
  list (Alpha_context.Script.expr * Alpha_context.Script.annot) -&gt; unit.

Definition add_dip
  (ty : Script_typed_ir.ty) (annot : option Script_typed_ir.var_annot)
  (prev : tc_context) : tc_context :=
  match prev with
  | (Lambda | Toplevel _) =&gt;
    Dip (Script_typed_ir.Item_t ty Script_typed_ir.Empty_t annot) prev
  | Dip __stack_value _ =&gt;
    Dip (Script_typed_ir.Item_t ty __stack_value annot) prev
  end.

Fixpoint comparable_type_size (ty : Script_typed_ir.comparable_struct)
  {struct ty} : int :=
  match ty with
  | Script_typed_ir.Int_key _ =&gt; 1
  | Script_typed_ir.Nat_key _ =&gt; 1
  | Script_typed_ir.String_key _ =&gt; 1
  | Script_typed_ir.Bytes_key _ =&gt; 1
  | Script_typed_ir.Mutez_key _ =&gt; 1
  | Script_typed_ir.Bool_key _ =&gt; 1
  | Script_typed_ir.Key_hash_key _ =&gt; 1
  | Script_typed_ir.Timestamp_key _ =&gt; 1
  | Script_typed_ir.Address_key _ =&gt; 1
  | Script_typed_ir.Pair_key _ (__t_value, _) _ =&gt;
    Pervasives.op_plus 1 (comparable_type_size __t_value)
  end.

Fixpoint type_size (ty : Script_typed_ir.ty) {struct ty} : int :=
  match ty with
  | Script_typed_ir.Unit_t _ =&gt; 1
  | Script_typed_ir.Int_t _ =&gt; 1
  | Script_typed_ir.Nat_t _ =&gt; 1
  | Script_typed_ir.Signature_t _ =&gt; 1
  | Script_typed_ir.Bytes_t _ =&gt; 1
  | Script_typed_ir.String_t _ =&gt; 1
  | Script_typed_ir.Mutez_t _ =&gt; 1
  | Script_typed_ir.Key_hash_t _ =&gt; 1
  | Script_typed_ir.Key_t _ =&gt; 1
  | Script_typed_ir.Timestamp_t _ =&gt; 1
  | Script_typed_ir.Address_t _ =&gt; 1
  | Script_typed_ir.Bool_t _ =&gt; 1
  | Script_typed_ir.Operation_t _ =&gt; 1
  | Script_typed_ir.Pair_t (l, _, _) (__r_value, _, _) _ _ =&gt;
    Pervasives.op_plus (Pervasives.op_plus 1 (type_size l))
      (type_size __r_value)
  | Script_typed_ir.Union_t (l, _) (__r_value, _) _ _ =&gt;
    Pervasives.op_plus (Pervasives.op_plus 1 (type_size l))
      (type_size __r_value)
  | Script_typed_ir.Lambda_t arg ret _ =&gt;
    Pervasives.op_plus (Pervasives.op_plus 1 (type_size arg)) (type_size ret)
  | Script_typed_ir.Option_t __t_value _ _ =&gt;
    Pervasives.op_plus 1 (type_size __t_value)
  | Script_typed_ir.List_t __t_value _ _ =&gt;
    Pervasives.op_plus 1 (type_size __t_value)
  | Script_typed_ir.Set_t k _ =&gt; Pervasives.op_plus 1 (comparable_type_size k)
  | Script_typed_ir.Map_t k v _ _ =&gt;
    Pervasives.op_plus (Pervasives.op_plus 1 (comparable_type_size k))
      (type_size v)
  | Script_typed_ir.Big_map_t k v _ =&gt;
    Pervasives.op_plus (Pervasives.op_plus 1 (comparable_type_size k))
      (type_size v)
  | Script_typed_ir.Contract_t arg _ =&gt; Pervasives.op_plus 1 (type_size arg)
  | Script_typed_ir.Chain_id_t _ =&gt; 1
  end.

Fixpoint type_size_of_stack_head
  (__stack_value : Script_typed_ir.stack_ty) (up_to : int)
  {struct __stack_value} : int :=
  match __stack_value with
  | Script_typed_ir.Empty_t =&gt; 0
  | Script_typed_ir.Item_t head tail _annot =&gt;
    if (|Compare.Int|).(Compare.S.op_gt) up_to 0 then
      (|Compare.Int|).(Compare.S.max) (type_size head)
        (type_size_of_stack_head tail (Pervasives.op_minus up_to 1))
    else
      0
  end.

Definition number_of_generated_growing_types
  (function_parameter : Script_typed_ir.instr) : int :=
  match function_parameter with
  | Script_typed_ir.Drop =&gt; 0
  | Script_typed_ir.Dup =&gt; 0
  | Script_typed_ir.Swap =&gt; 0
  | Script_typed_ir.Const _ =&gt; 1
  | Script_typed_ir.Cons_pair =&gt; 1
  | Script_typed_ir.Car =&gt; 0
  | Script_typed_ir.Cdr =&gt; 0
  | Script_typed_ir.Cons_some =&gt; 1
  | Script_typed_ir.Cons_none _ =&gt; 1
  | Script_typed_ir.If_none _ _ =&gt; 0
  | Script_typed_ir.Left =&gt; 0
  | Script_typed_ir.Right =&gt; 0
  | Script_typed_ir.If_left _ _ =&gt; 0
  | Script_typed_ir.Cons_list =&gt; 1
  | Script_typed_ir.Nil =&gt; 1
  | Script_typed_ir.If_cons _ _ =&gt; 0
  | Script_typed_ir.List_map _ =&gt; 1
  | Script_typed_ir.List_size =&gt; 0
  | Script_typed_ir.List_iter _ =&gt; 1
  | Script_typed_ir.Empty_set _ =&gt; 1
  | Script_typed_ir.Set_iter _ =&gt; 0
  | Script_typed_ir.Set_mem =&gt; 0
  | Script_typed_ir.Set_update =&gt; 0
  | Script_typed_ir.Set_size =&gt; 0
  | Script_typed_ir.Empty_map _ _ =&gt; 1
  | Script_typed_ir.Map_map _ =&gt; 1
  | Script_typed_ir.Map_iter _ =&gt; 1
  | Script_typed_ir.Map_mem =&gt; 0
  | Script_typed_ir.Map_get =&gt; 0
  | Script_typed_ir.Map_update =&gt; 0
  | Script_typed_ir.Map_size =&gt; 0
  | Script_typed_ir.Empty_big_map _ _ =&gt; 1
  | Script_typed_ir.Big_map_get =&gt; 0
  | Script_typed_ir.Big_map_update =&gt; 0
  | Script_typed_ir.Big_map_mem =&gt; 0
  | Script_typed_ir.Concat_string =&gt; 0
  | Script_typed_ir.Concat_string_pair =&gt; 0
  | Script_typed_ir.Slice_string =&gt; 0
  | Script_typed_ir.String_size =&gt; 0
  | Script_typed_ir.Concat_bytes =&gt; 0
  | Script_typed_ir.Concat_bytes_pair =&gt; 0
  | Script_typed_ir.Slice_bytes =&gt; 0
  | Script_typed_ir.Bytes_size =&gt; 0
  | Script_typed_ir.Add_seconds_to_timestamp =&gt; 0
  | Script_typed_ir.Add_timestamp_to_seconds =&gt; 0
  | Script_typed_ir.Sub_timestamp_seconds =&gt; 0
  | Script_typed_ir.Diff_timestamps =&gt; 0
  | Script_typed_ir.Add_tez =&gt; 0
  | Script_typed_ir.Sub_tez =&gt; 0
  | Script_typed_ir.Mul_teznat =&gt; 0
  | Script_typed_ir.Mul_nattez =&gt; 0
  | Script_typed_ir.Ediv_teznat =&gt; 0
  | Script_typed_ir.Ediv_tez =&gt; 0
  | Script_typed_ir.Or =&gt; 0
  | Script_typed_ir.And =&gt; 0
  | Script_typed_ir.Xor =&gt; 0
  | Script_typed_ir.Not =&gt; 0
  | Script_typed_ir.Is_nat =&gt; 0
  | Script_typed_ir.Neg_nat =&gt; 0
  | Script_typed_ir.Neg_int =&gt; 0
  | Script_typed_ir.Abs_int =&gt; 0
  | Script_typed_ir.Int_nat =&gt; 0
  | Script_typed_ir.Add_intint =&gt; 0
  | Script_typed_ir.Add_intnat =&gt; 0
  | Script_typed_ir.Add_natint =&gt; 0
  | Script_typed_ir.Add_natnat =&gt; 0
  | Script_typed_ir.Sub_int =&gt; 0
  | Script_typed_ir.Mul_intint =&gt; 0
  | Script_typed_ir.Mul_intnat =&gt; 0
  | Script_typed_ir.Mul_natint =&gt; 0
  | Script_typed_ir.Mul_natnat =&gt; 0
  | Script_typed_ir.Ediv_intint =&gt; 0
  | Script_typed_ir.Ediv_intnat =&gt; 0
  | Script_typed_ir.Ediv_natint =&gt; 0
  | Script_typed_ir.Ediv_natnat =&gt; 0
  | Script_typed_ir.Lsl_nat =&gt; 0
  | Script_typed_ir.Lsr_nat =&gt; 0
  | Script_typed_ir.Or_nat =&gt; 0
  | Script_typed_ir.And_nat =&gt; 0
  | Script_typed_ir.And_int_nat =&gt; 0
  | Script_typed_ir.Xor_nat =&gt; 0
  | Script_typed_ir.Not_nat =&gt; 0
  | Script_typed_ir.Not_int =&gt; 0
  | Script_typed_ir.Seq _ _ =&gt; 0
  | Script_typed_ir.If _ _ =&gt; 0
  | Script_typed_ir.Loop _ =&gt; 0
  | Script_typed_ir.Loop_left _ =&gt; 0
  | Script_typed_ir.Dip _ =&gt; 0
  | Script_typed_ir.Exec =&gt; 0
  | Script_typed_ir.Apply _ =&gt; 0
  | Script_typed_ir.Lambda _ =&gt; 1
  | Script_typed_ir.Failwith _ =&gt; 1
  | Script_typed_ir.Nop =&gt; 0
  | Script_typed_ir.Compare _ =&gt; 1
  | Script_typed_ir.Eq =&gt; 0
  | Script_typed_ir.Neq =&gt; 0
  | Script_typed_ir.Lt =&gt; 0
  | Script_typed_ir.Gt =&gt; 0
  | Script_typed_ir.Le =&gt; 0
  | Script_typed_ir.Ge =&gt; 0
  | Script_typed_ir.Address =&gt; 0
  | Script_typed_ir.Contract _ _ =&gt; 1
  | Script_typed_ir.Transfer_tokens =&gt; 1
  | Script_typed_ir.Create_account =&gt; 0
  | Script_typed_ir.Implicit_account =&gt; 0
  | Script_typed_ir.Create_contract _ _ _ _ =&gt; 1
  | Script_typed_ir.Create_contract_2 _ _ _ _ =&gt; 1
  | Script_typed_ir.Now =&gt; 0
  | Script_typed_ir.Balance =&gt; 0
  | Script_typed_ir.Check_signature =&gt; 0
  | Script_typed_ir.Hash_key =&gt; 0
  | Script_typed_ir.Blake2b =&gt; 0
  | Script_typed_ir.Sha256 =&gt; 0
  | Script_typed_ir.Sha512 =&gt; 0
  | Script_typed_ir.Steps_to_quota =&gt; 0
  | Script_typed_ir.Source =&gt; 0
  | Script_typed_ir.Sender =&gt; 0
  | Script_typed_ir.Self _ _ =&gt; 1
  | Script_typed_ir.Amount =&gt; 0
  | Script_typed_ir.Set_delegate =&gt; 0
  | Script_typed_ir.Pack _ =&gt; 0
  | Script_typed_ir.Unpack _ =&gt; 1
  | Script_typed_ir.Dig _ _ =&gt; 0
  | Script_typed_ir.Dug _ _ =&gt; 0
  | Script_typed_ir.Dipn _ _ _ =&gt; 0
  | Script_typed_ir.Dropn _ _ =&gt; 0
  | Script_typed_ir.ChainId =&gt; 0
  end.

Definition location {A B : Set} (function_parameter : Micheline.node A B) : A :=
  match function_parameter with
  |
    (Micheline.Prim loc _ _ _ | Micheline.Int loc _ | Micheline.String loc _ |
    Micheline.Bytes loc _ | Micheline.Seq loc _) =&gt; loc
  end.

Definition kind {A B : Set} (function_parameter : Micheline.node A B)
  : Script_tc_errors.kind :=
  match function_parameter with
  | Micheline.Int _ _ =&gt; Script_tc_errors.Int_kind
  | Micheline.String _ _ =&gt; Script_tc_errors.String_kind
  | Micheline.Bytes _ _ =&gt; Script_tc_errors.Bytes_kind
  | Micheline.Prim _ _ _ _ =&gt; Script_tc_errors.Prim_kind
  | Micheline.Seq _ _ =&gt; Script_tc_errors.Seq_kind
  end.

Definition namespace (function_parameter : Alpha_context.Script.prim)
  : Script_tc_errors.namespace :=
  match function_parameter with
  |
    (Alpha_context.Script.K_parameter | Alpha_context.Script.K_storage |
    Alpha_context.Script.K_code) =&gt; Script_tc_errors.Keyword_namespace
  |
    (Alpha_context.Script.D_False | Alpha_context.Script.D_Elt |
    Alpha_context.Script.D_Left | Alpha_context.Script.D_None |
    Alpha_context.Script.D_Pair | Alpha_context.Script.D_Right |
    Alpha_context.Script.D_Some | Alpha_context.Script.D_True |
    Alpha_context.Script.D_Unit) =&gt; Script_tc_errors.Constant_namespace
  |
    (Alpha_context.Script.I_PACK | Alpha_context.Script.I_UNPACK |
    Alpha_context.Script.I_BLAKE2B | Alpha_context.Script.I_SHA256 |
    Alpha_context.Script.I_SHA512 | Alpha_context.Script.I_ABS |
    Alpha_context.Script.I_ADD | Alpha_context.Script.I_AMOUNT |
    Alpha_context.Script.I_AND | Alpha_context.Script.I_BALANCE |
    Alpha_context.Script.I_CAR | Alpha_context.Script.I_CDR |
    Alpha_context.Script.I_CHAIN_ID | Alpha_context.Script.I_CHECK_SIGNATURE |
    Alpha_context.Script.I_COMPARE | Alpha_context.Script.I_CONCAT |
    Alpha_context.Script.I_CONS | Alpha_context.Script.I_CREATE_ACCOUNT |
    Alpha_context.Script.I_CREATE_CONTRACT |
    Alpha_context.Script.I_IMPLICIT_ACCOUNT | Alpha_context.Script.I_DIP |
    Alpha_context.Script.I_DROP | Alpha_context.Script.I_DUP |
    Alpha_context.Script.I_EDIV | Alpha_context.Script.I_EMPTY_BIG_MAP |
    Alpha_context.Script.I_EMPTY_MAP | Alpha_context.Script.I_EMPTY_SET |
    Alpha_context.Script.I_EQ | Alpha_context.Script.I_EXEC |
    Alpha_context.Script.I_APPLY | Alpha_context.Script.I_FAILWITH |
    Alpha_context.Script.I_GE | Alpha_context.Script.I_GET |
    Alpha_context.Script.I_GT | Alpha_context.Script.I_HASH_KEY |
    Alpha_context.Script.I_IF | Alpha_context.Script.I_IF_CONS |
    Alpha_context.Script.I_IF_LEFT | Alpha_context.Script.I_IF_NONE |
    Alpha_context.Script.I_INT | Alpha_context.Script.I_LAMBDA |
    Alpha_context.Script.I_LE | Alpha_context.Script.I_LEFT |
    Alpha_context.Script.I_LOOP | Alpha_context.Script.I_LSL |
    Alpha_context.Script.I_LSR | Alpha_context.Script.I_LT |
    Alpha_context.Script.I_MAP | Alpha_context.Script.I_MEM |
    Alpha_context.Script.I_MUL | Alpha_context.Script.I_NEG |
    Alpha_context.Script.I_NEQ | Alpha_context.Script.I_NIL |
    Alpha_context.Script.I_NONE | Alpha_context.Script.I_NOT |
    Alpha_context.Script.I_NOW | Alpha_context.Script.I_OR |
    Alpha_context.Script.I_PAIR | Alpha_context.Script.I_PUSH |
    Alpha_context.Script.I_RIGHT | Alpha_context.Script.I_SIZE |
    Alpha_context.Script.I_SOME | Alpha_context.Script.I_SOURCE |
    Alpha_context.Script.I_SENDER | Alpha_context.Script.I_SELF |
    Alpha_context.Script.I_SLICE | Alpha_context.Script.I_STEPS_TO_QUOTA |
    Alpha_context.Script.I_SUB | Alpha_context.Script.I_SWAP |
    Alpha_context.Script.I_TRANSFER_TOKENS | Alpha_context.Script.I_SET_DELEGATE
    | Alpha_context.Script.I_UNIT | Alpha_context.Script.I_UPDATE |
    Alpha_context.Script.I_XOR | Alpha_context.Script.I_ITER |
    Alpha_context.Script.I_LOOP_LEFT | Alpha_context.Script.I_ADDRESS |
    Alpha_context.Script.I_CONTRACT | Alpha_context.Script.I_ISNAT |
    Alpha_context.Script.I_CAST | Alpha_context.Script.I_RENAME |
    Alpha_context.Script.I_DIG | Alpha_context.Script.I_DUG) =&gt;
    Script_tc_errors.Instr_namespace
  |
    (Alpha_context.Script.T_bool | Alpha_context.Script.T_contract |
    Alpha_context.Script.T_int | Alpha_context.Script.T_key |
    Alpha_context.Script.T_key_hash | Alpha_context.Script.T_lambda |
    Alpha_context.Script.T_list | Alpha_context.Script.T_map |
    Alpha_context.Script.T_big_map | Alpha_context.Script.T_nat |
    Alpha_context.Script.T_option | Alpha_context.Script.T_or |
    Alpha_context.Script.T_pair | Alpha_context.Script.T_set |
    Alpha_context.Script.T_signature | Alpha_context.Script.T_string |
    Alpha_context.Script.T_bytes | Alpha_context.Script.T_mutez |
    Alpha_context.Script.T_timestamp | Alpha_context.Script.T_unit |
    Alpha_context.Script.T_operation | Alpha_context.Script.T_address |
    Alpha_context.Script.T_chain_id) =&gt; Script_tc_errors.Type_namespace
  end.

Definition unexpected
  (expr : Micheline.node Alpha_context.Script.location Alpha_context.Script.prim)
  (exp_kinds : list Script_tc_errors.kind) (exp_ns : Script_tc_errors.namespace)
  (exp_prims : list Alpha_context.Script.prim) : Error_monad.__error :=
  match expr with
  | Micheline.Int loc _ =&gt; extensible_type_value
  | Micheline.String loc _ =&gt; extensible_type_value
  | Micheline.Bytes loc _ =&gt; extensible_type_value
  | Micheline.Seq loc _ =&gt; extensible_type_value
  | Micheline.Prim loc name _ _ =&gt;
    match ((namespace name), exp_ns) with
    |
      ((Script_tc_errors.Type_namespace, Script_tc_errors.Type_namespace) |
      (Script_tc_errors.Instr_namespace, Script_tc_errors.Instr_namespace) |
      (Script_tc_errors.Constant_namespace, Script_tc_errors.Constant_namespace))
      =&gt; extensible_type_value
    | (ns, _) =&gt; extensible_type_value
    end
  end.

Definition check_kind {A : Set}
  (kinds : list Script_tc_errors.kind)
  (expr : Micheline.node Alpha_context.Script.location A)
  : Lwt.t (Error_monad.tzresult unit) :=
  let kind := kind expr in
  if List.mem kind kinds then
    Error_monad.return_unit
  else
    let loc := location expr in
    Error_monad.fail extensible_type_value.

Definition wrap_compare {A B : Set}
  (compare : A -&gt; B -&gt; (|Compare.Int|).(Compare.S.t)) (__a_value : A)
  (__b_value : B) : int :=
  let res := compare __a_value __b_value in
  if (|Compare.Int|).(Compare.S.op_eq) res 0 then
    0
  else
    if (|Compare.Int|).(Compare.S.op_gt) res 0 then
      1
    else
      (-1).

Fixpoint compare_comparable {a : Set}
  (kind : Script_typed_ir.comparable_struct) (x : a) (y : a) {struct kind}
  : int :=
  match (kind, x, y) with
  | (Script_typed_ir.String_key _, _ as x, _ as y) =&gt;
    let '[x, y] := cast [string ** string] [x, y] in
    wrap_compare (|Compare.String|).(Compare.S.compare) x y
  
  | (Script_typed_ir.Bool_key _, _ as x, _ as y) =&gt;
    let '[x, y] := cast [bool ** bool] [x, y] in
    wrap_compare (|Compare.Bool|).(Compare.S.compare) x y
  
  | (Script_typed_ir.Mutez_key _, _ as x, _ as y) =&gt;
    let '[x, y] := cast [Alpha_context.Tez.t ** Alpha_context.Tez.t] [x, y] in
    wrap_compare Alpha_context.Tez.compare x y
  
  | (Script_typed_ir.Key_hash_key _, _ as x, _ as y) =&gt;
    let '[x, y] :=
      cast [Alpha_context.public_key_hash ** Alpha_context.public_key_hash]
        [x, y] in
    wrap_compare (|Signature.Public_key_hash|).(S.SPublic_key_hash.compare) x y
  
  | (Script_typed_ir.Int_key _, _ as x, _ as y) =&gt;
    let '[x, y] :=
      cast [Alpha_context.Script_int.num ** Alpha_context.Script_int.num] [x, y]
      in
    wrap_compare Alpha_context.Script_int.compare x y
  
  | (Script_typed_ir.Nat_key _, _ as x, _ as y) =&gt;
    let '[x, y] :=
      cast [Alpha_context.Script_int.num ** Alpha_context.Script_int.num] [x, y]
      in
    wrap_compare Alpha_context.Script_int.compare x y
  
  | (Script_typed_ir.Timestamp_key _, _ as x, _ as y) =&gt;
    let '[x, y] :=
      cast
        [Alpha_context.Script_timestamp.t ** Alpha_context.Script_timestamp.t]
        [x, y] in
    wrap_compare Alpha_context.Script_timestamp.compare x y
  
  | (Script_typed_ir.Address_key _, _ as x, _ as y) =&gt;
    let '[x, y] :=
      cast [Script_typed_ir.address ** Script_typed_ir.address] [x, y] in
    (wrap_compare
      (fun function_parameter =&gt;
        let '(x, ex) := function_parameter in
        fun function_parameter =&gt;
          let '(y, ey) := function_parameter in
          let lres := Alpha_context.Contract.compare x y in
          if (|Compare.Int|).(Compare.S.op_eq) lres 0 then
            (|Compare.String|).(Compare.S.compare) ex ey
          else
            lres)) x y
  
  | (Script_typed_ir.Bytes_key _, _ as x, _ as y) =&gt;
    let '[x, y] := cast [MBytes.t ** MBytes.t] [x, y] in
    wrap_compare MBytes.compare x y
  
  | (Script_typed_ir.Pair_key (tl, _) (tr, _) _, _ as x, _ as y) =&gt;
    let 'existT _ [__0, __1] [tl, tr, x, y] :=
      cast_exists (Es := [Set ** Set])
        (fun '[__0, __1] =&gt;
          [Script_typed_ir.comparable_struct **
            Script_typed_ir.comparable_struct ** __0 * __1 ** __0 * __1])
        [tl, tr, x, y] in
    (fun function_parameter =&gt;
      let '(lx, rx) := function_parameter in
      fun function_parameter =&gt;
        let '(ly, ry) := function_parameter in
        let lres := compare_comparable tl lx ly in
        if (|Compare.Int|).(Compare.S.op_eq) lres 0 then
          compare_comparable tr rx ry
        else
          lres) x y
  end.

Definition empty_set {a : Set} (ty : Script_typed_ir.comparable_ty)
  : Script_typed_ir.set a :=
  let OPS :=
    __Set.Make
      (let t : Set := a in
      let compare (x : a) (y : a) : int :=
        compare_comparable ty x y in
      existT (A := Set) _ _
        {|
          Compare.COMPARABLE.compare := compare
        |}) in
  (pack
    (let elt : Set := a in
    let elt_ty := ty in
    let OPS := existT (A := unit) (fun _ =&gt; _) tt (|OPS|) in
    let boxed := (|OPS|).(S.SET.empty) in
    let size := 0 in
    existT (A := Set) _ _
      {|
        Script_typed_ir.Boxed_set.elt_ty := elt_ty;
        Script_typed_ir.Boxed_set.OPS := (|OPS|);
        Script_typed_ir.Boxed_set.boxed := boxed;
        Script_typed_ir.Boxed_set.size := size
      |})).

Definition set_update {a : Set}
  (v : a) (__b_value : bool) (Box : Script_typed_ir.set a)
  : Script_typed_ir.set a :=
  let 'existS _ _ Box := Box in
  (pack
    (let elt : Set := a in
    let elt_ty := Box.(Script_typed_ir.Boxed_set.elt_ty) in
    let OPS :=
      existT (A := unit) (fun _ =&gt; _) tt Box.(Script_typed_ir.Boxed_set.OPS) in
    let boxed :=
      if __b_value then
        Box.(Script_typed_ir.Boxed_set.OPS).(S.SET.add) v
          Box.(Script_typed_ir.Boxed_set.boxed)
      else
        Box.(Script_typed_ir.Boxed_set.OPS).(S.SET.remove) v
          Box.(Script_typed_ir.Boxed_set.boxed) in
    let size :=
      let mem :=
        Box.(Script_typed_ir.Boxed_set.OPS).(S.SET.mem) v
          Box.(Script_typed_ir.Boxed_set.boxed) in
      if mem then
        if __b_value then
          Box.(Script_typed_ir.Boxed_set.size)
        else
          Pervasives.op_minus Box.(Script_typed_ir.Boxed_set.size) 1
      else
        if __b_value then
          Pervasives.op_plus Box.(Script_typed_ir.Boxed_set.size) 1
        else
          Box.(Script_typed_ir.Boxed_set.size) in
    existT (A := Set) _ _
      {|
        Script_typed_ir.Boxed_set.elt_ty := elt_ty;
        Script_typed_ir.Boxed_set.OPS := (|OPS|);
        Script_typed_ir.Boxed_set.boxed := boxed;
        Script_typed_ir.Boxed_set.size := size
      |})).

Definition set_mem {elt : Set} (v : elt) (Box : Script_typed_ir.set elt)
  : bool :=
  let 'existS _ _ Box := Box in
  Box.(Script_typed_ir.Boxed_set.OPS).(S.SET.mem) v
    Box.(Script_typed_ir.Boxed_set.boxed).

Definition set_fold {acc elt : Set}
  (f : elt -&gt; acc -&gt; acc) (Box : Script_typed_ir.set elt) : acc -&gt; acc :=
  let 'existS _ _ Box := Box in
  Box.(Script_typed_ir.Boxed_set.OPS).(S.SET.fold) f
    Box.(Script_typed_ir.Boxed_set.boxed).

Definition set_size {elt : Set} (Box : Script_typed_ir.set elt)
  : Alpha_context.Script_int.num :=
  let 'existS _ _ Box := Box in
  Alpha_context.Script_int.abs
    (Alpha_context.Script_int.of_int Box.(Script_typed_ir.Boxed_set.size)).

Definition map_key_ty {a b : Set} (Box : Script_typed_ir.map a b)
  : Script_typed_ir.comparable_ty :=
  let 'existS _ _ Box := Box in
  Box.(Script_typed_ir.Boxed_map.key_ty).

Definition empty_map {a b : Set} (ty : Script_typed_ir.comparable_ty)
  : Script_typed_ir.map a b :=
  let OPS :=
    Map.Make
      (let t : Set := a in
      let compare (x : a) (y : a) : int :=
        compare_comparable ty x y in
      existT (A := Set) _ _
        {|
          Compare.COMPARABLE.compare := compare
        |}) in
  (pack
    (let key : Set := a in
    let value : Set := b in
    let key_ty := ty in
    let OPS := existT (A := unit) (fun _ =&gt; _) tt (|OPS|) in
    let boxed {C : Set} : (|OPS|).(S.MAP.t) C * int :=
      ((|OPS|).(S.MAP.empty), 0) in
    existT (A := Set -&gt; Set) _ _
      {|
        Script_typed_ir.Boxed_map.key_ty := key_ty;
        Script_typed_ir.Boxed_map.OPS := (|OPS|);
        Script_typed_ir.Boxed_map.boxed := boxed
      |})).

Definition map_get {key value : Set}
  (k : key) (Box : Script_typed_ir.map key value) : option value :=
  let 'existS _ _ Box := Box in
  Box.(Script_typed_ir.Boxed_map.OPS).(S.MAP.find_opt) k
    (Pervasives.fst Box.(Script_typed_ir.Boxed_map.boxed)).

Definition map_update {a b : Set}
  (k : a) (v : option b) (Box : Script_typed_ir.map a b)
  : Script_typed_ir.map a b :=
  let 'existS _ _ Box := Box in
  (pack
    (let key : Set := a in
    let value : Set := b in
    let key_ty := Box.(Script_typed_ir.Boxed_map.key_ty) in
    let OPS :=
      existT (A := unit) (fun _ =&gt; _) tt Box.(Script_typed_ir.Boxed_map.OPS) in
    let boxed :=
      let '(map, size) := Box.(Script_typed_ir.Boxed_map.boxed) in
      let contains := Box.(Script_typed_ir.Boxed_map.OPS).(S.MAP.mem) k map in
      match v with
      | Some v =&gt;
        ((Box.(Script_typed_ir.Boxed_map.OPS).(S.MAP.add) k v map),
          (Pervasives.op_plus size
            (if contains then
              0
            else
              1)))
      | None =&gt;
        ((Box.(Script_typed_ir.Boxed_map.OPS).(S.MAP.remove) k map),
          (Pervasives.op_minus size
            (if contains then
              1
            else
              0)))
      end in
    existT (A := Set -&gt; Set) _ _
      {|
        Script_typed_ir.Boxed_map.key_ty := key_ty;
        Script_typed_ir.Boxed_map.OPS := (|OPS|);
        Script_typed_ir.Boxed_map.boxed := boxed
      |})).

Definition map_set {a b : Set} (k : a) (v : b) (Box : Script_typed_ir.map a b)
  : Script_typed_ir.map a b :=
  let 'existS _ _ Box := Box in
  (pack
    (let key : Set := a in
    let value : Set := b in
    let key_ty := Box.(Script_typed_ir.Boxed_map.key_ty) in
    let OPS :=
      existT (A := unit) (fun _ =&gt; _) tt Box.(Script_typed_ir.Boxed_map.OPS) in
    let boxed :=
      let '(map, size) := Box.(Script_typed_ir.Boxed_map.boxed) in
      ((Box.(Script_typed_ir.Boxed_map.OPS).(S.MAP.add) k v map),
        (if Box.(Script_typed_ir.Boxed_map.OPS).(S.MAP.mem) k map then
          size
        else
          Pervasives.op_plus size 1)) in
    existT (A := Set -&gt; Set) _ _
      {|
        Script_typed_ir.Boxed_map.key_ty := key_ty;
        Script_typed_ir.Boxed_map.OPS := (|OPS|);
        Script_typed_ir.Boxed_map.boxed := boxed
      |})).

Definition map_mem {key value : Set}
  (k : key) (Box : Script_typed_ir.map key value) : bool :=
  let 'existS _ _ Box := Box in
  Box.(Script_typed_ir.Boxed_map.OPS).(S.MAP.mem) k
    (Pervasives.fst Box.(Script_typed_ir.Boxed_map.boxed)).

Definition map_fold {acc key value : Set}
  (f : key -&gt; value -&gt; acc -&gt; acc) (Box : Script_typed_ir.map key value)
  : acc -&gt; acc :=
  let 'existS _ _ Box := Box in
  Box.(Script_typed_ir.Boxed_map.OPS).(S.MAP.fold) f
    (Pervasives.fst Box.(Script_typed_ir.Boxed_map.boxed)).

Definition map_size {key value : Set} (Box : Script_typed_ir.map key value)
  : Alpha_context.Script_int.num :=
  let 'existS _ _ Box := Box in
  Alpha_context.Script_int.abs
    (Alpha_context.Script_int.of_int
      (Pervasives.snd Box.(Script_typed_ir.Boxed_map.boxed))).

Fixpoint ty_of_comparable_ty
  (function_parameter : Script_typed_ir.comparable_struct)
  {struct function_parameter} : Script_typed_ir.ty :=
  match function_parameter with
  | Script_typed_ir.Int_key tname =&gt; Script_typed_ir.Int_t tname
  | Script_typed_ir.Nat_key tname =&gt; Script_typed_ir.Nat_t tname
  | Script_typed_ir.String_key tname =&gt; Script_typed_ir.String_t tname
  | Script_typed_ir.Bytes_key tname =&gt; Script_typed_ir.Bytes_t tname
  | Script_typed_ir.Mutez_key tname =&gt; Script_typed_ir.Mutez_t tname
  | Script_typed_ir.Bool_key tname =&gt; Script_typed_ir.Bool_t tname
  | Script_typed_ir.Key_hash_key tname =&gt; Script_typed_ir.Key_hash_t tname
  | Script_typed_ir.Timestamp_key tname =&gt; Script_typed_ir.Timestamp_t tname
  | Script_typed_ir.Address_key tname =&gt; Script_typed_ir.Address_t tname
  | Script_typed_ir.Pair_key (l, al) (__r_value, ar) tname =&gt;
    Script_typed_ir.Pair_t ((ty_of_comparable_ty l), al, None)
      ((ty_of_comparable_ty __r_value), ar, None) tname false
  end.

Fixpoint comparable_ty_of_ty (function_parameter : Script_typed_ir.ty)
  {struct function_parameter} : option Script_typed_ir.comparable_ty :=
  match function_parameter with
  | Script_typed_ir.Int_t tname =&gt; Some (Script_typed_ir.Int_key tname)
  | Script_typed_ir.Nat_t tname =&gt; Some (Script_typed_ir.Nat_key tname)
  | Script_typed_ir.String_t tname =&gt; Some (Script_typed_ir.String_key tname)
  | Script_typed_ir.Bytes_t tname =&gt; Some (Script_typed_ir.Bytes_key tname)
  | Script_typed_ir.Mutez_t tname =&gt; Some (Script_typed_ir.Mutez_key tname)
  | Script_typed_ir.Bool_t tname =&gt; Some (Script_typed_ir.Bool_key tname)
  | Script_typed_ir.Key_hash_t tname =&gt;
    Some (Script_typed_ir.Key_hash_key tname)
  | Script_typed_ir.Timestamp_t tname =&gt;
    Some (Script_typed_ir.Timestamp_key tname)
  | Script_typed_ir.Address_t tname =&gt; Some (Script_typed_ir.Address_key tname)
  | Script_typed_ir.Pair_t (l, al, _) (__r_value, ar, _) pname _ =&gt;
    match comparable_ty_of_ty __r_value with
    | None =&gt; None
    | Some rty =&gt;
      match comparable_ty_of_ty l with
      | None =&gt; None
      | Some (Script_typed_ir.Pair_key _ _ _) =&gt; None
      | Some (Script_typed_ir.Int_key tname) =&gt;
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Int_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Nat_key tname) =&gt;
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Nat_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.String_key tname) =&gt;
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.String_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Bytes_key tname) =&gt;
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Bytes_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Mutez_key tname) =&gt;
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Mutez_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Bool_key tname) =&gt;
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Bool_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Key_hash_key tname) =&gt;
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Key_hash_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Timestamp_key tname) =&gt;
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Timestamp_key tname), al)
            (rty, ar) pname)
      | Some (Script_typed_ir.Address_key tname) =&gt;
        Some
          (Script_typed_ir.Pair_key ((Script_typed_ir.Address_key tname), al)
            (rty, ar) pname)
      end
    end
  | _ =&gt; None
  end.

Definition add_field_annot {A B : Set}
  (__a_value : option Script_typed_ir.field_annot)
  (var : option Script_typed_ir.var_annot)
  (function_parameter : Micheline.node A B) : Micheline.node A B :=
  match function_parameter with
  | Micheline.Prim loc prim args annots =&gt;
    Micheline.Prim loc prim args
      (Pervasives.op_at annots
        (Pervasives.op_at (Script_ir_annot.unparse_field_annot __a_value)
          (Script_ir_annot.unparse_var_annot var)))
  | expr =&gt; expr
  end.

Fixpoint unparse_comparable_ty
  (function_parameter : Script_typed_ir.comparable_struct)
  {struct function_parameter} : Alpha_context.Script.node :=
  match function_parameter with
  | Script_typed_ir.Int_key tname =&gt;
    Micheline.Prim (-1) Alpha_context.Script.T_int nil
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Nat_key tname =&gt;
    Micheline.Prim (-1) Alpha_context.Script.T_nat nil
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.String_key tname =&gt;
    Micheline.Prim (-1) Alpha_context.Script.T_string nil
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Bytes_key tname =&gt;
    Micheline.Prim (-1) Alpha_context.Script.T_bytes nil
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Mutez_key tname =&gt;
    Micheline.Prim (-1) Alpha_context.Script.T_mutez nil
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Bool_key tname =&gt;
    Micheline.Prim (-1) Alpha_context.Script.T_bool nil
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Key_hash_key tname =&gt;
    Micheline.Prim (-1) Alpha_context.Script.T_key_hash nil
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Timestamp_key tname =&gt;
    Micheline.Prim (-1) Alpha_context.Script.T_timestamp nil
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Address_key tname =&gt;
    Micheline.Prim (-1) Alpha_context.Script.T_address nil
      (Script_ir_annot.unparse_type_annot tname)
  | Script_typed_ir.Pair_key (l, al) (__r_value, ar) pname =&gt;
    let tl := add_field_annot al None (unparse_comparable_ty l) in
    let tr := add_field_annot ar None (unparse_comparable_ty __r_value) in
    Micheline.Prim (-1) Alpha_context.Script.T_pair [ tl; tr ]
      (Script_ir_annot.unparse_type_annot pname)
  end.

Fixpoint unparse_ty_no_lwt
  (ctxt : Alpha_context.context) (ty : Script_typed_ir.ty) {struct ctxt}
  : Error_monad.tzresult (Alpha_context.Script.node * Alpha_context.context) :=
  let? ctxt := Alpha_context.Gas.consume ctxt Unparse_costs.cycle in
  let __return {A : Set}
    (ctxt : Alpha_context.context)
    (function_parameter : A * list (Micheline.node int A) * Micheline.annot)
    : Error_monad.tzresult (Micheline.node int A * Alpha_context.context) :=
    let '(name, args, annot) := function_parameter in
    let __result_value := Micheline.Prim (-1) name args annot in
    let? ctxt :=
      Alpha_context.Gas.consume ctxt
        (Unparse_costs.prim_cost (List.length args) annot) in
    Error_monad.ok (__result_value, ctxt) in
  match ty with
  | Script_typed_ir.Unit_t tname =&gt;
    __return ctxt
      (Alpha_context.Script.T_unit, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Int_t tname =&gt;
    __return ctxt
      (Alpha_context.Script.T_int, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Nat_t tname =&gt;
    __return ctxt
      (Alpha_context.Script.T_nat, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.String_t tname =&gt;
    __return ctxt
      (Alpha_context.Script.T_string, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Bytes_t tname =&gt;
    __return ctxt
      (Alpha_context.Script.T_bytes, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Mutez_t tname =&gt;
    __return ctxt
      (Alpha_context.Script.T_mutez, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Bool_t tname =&gt;
    __return ctxt
      (Alpha_context.Script.T_bool, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Key_hash_t tname =&gt;
    __return ctxt
      (Alpha_context.Script.T_key_hash, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Key_t tname =&gt;
    __return ctxt
      (Alpha_context.Script.T_key, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Timestamp_t tname =&gt;
    __return ctxt
      (Alpha_context.Script.T_timestamp, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Address_t tname =&gt;
    __return ctxt
      (Alpha_context.Script.T_address, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Signature_t tname =&gt;
    __return ctxt
      (Alpha_context.Script.T_signature, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Operation_t tname =&gt;
    __return ctxt
      (Alpha_context.Script.T_operation, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Chain_id_t tname =&gt;
    __return ctxt
      (Alpha_context.Script.T_chain_id, nil,
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Contract_t ut tname =&gt;
    let? '(__t_value, ctxt) := unparse_ty_no_lwt ctxt ut in
    __return ctxt
      (Alpha_context.Script.T_contract, [ __t_value ],
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Pair_t (utl, l_field, l_var) (utr, r_field, r_var) tname _
    =&gt;
    let annot := Script_ir_annot.unparse_type_annot tname in
    let? '(utl, ctxt) := unparse_ty_no_lwt ctxt utl in
    let tl := add_field_annot l_field l_var utl in
    let? '(utr, ctxt) := unparse_ty_no_lwt ctxt utr in
    let tr := add_field_annot r_field r_var utr in
    __return ctxt (Alpha_context.Script.T_pair, [ tl; tr ], annot)
  | Script_typed_ir.Union_t (utl, l_field) (utr, r_field) tname _ =&gt;
    let annot := Script_ir_annot.unparse_type_annot tname in
    let? '(utl, ctxt) := unparse_ty_no_lwt ctxt utl in
    let tl := add_field_annot l_field None utl in
    let? '(utr, ctxt) := unparse_ty_no_lwt ctxt utr in
    let tr := add_field_annot r_field None utr in
    __return ctxt (Alpha_context.Script.T_or, [ tl; tr ], annot)
  | Script_typed_ir.Lambda_t uta utr tname =&gt;
    let? '(ta, ctxt) := unparse_ty_no_lwt ctxt uta in
    let? '(tr, ctxt) := unparse_ty_no_lwt ctxt utr in
    __return ctxt
      (Alpha_context.Script.T_lambda, [ ta; tr ],
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Option_t ut tname _ =&gt;
    let annot := Script_ir_annot.unparse_type_annot tname in
    let? '(ut, ctxt) := unparse_ty_no_lwt ctxt ut in
    __return ctxt (Alpha_context.Script.T_option, [ ut ], annot)
  | Script_typed_ir.List_t ut tname _ =&gt;
    let? '(__t_value, ctxt) := unparse_ty_no_lwt ctxt ut in
    __return ctxt
      (Alpha_context.Script.T_list, [ __t_value ],
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Set_t ut tname =&gt;
    let __t_value := unparse_comparable_ty ut in
    __return ctxt
      (Alpha_context.Script.T_set, [ __t_value ],
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Map_t uta utr tname _ =&gt;
    let ta := unparse_comparable_ty uta in
    let? '(tr, ctxt) := unparse_ty_no_lwt ctxt utr in
    __return ctxt
      (Alpha_context.Script.T_map, [ ta; tr ],
        (Script_ir_annot.unparse_type_annot tname))
  | Script_typed_ir.Big_map_t uta utr tname =&gt;
    let ta := unparse_comparable_ty uta in
    let? '(tr, ctxt) := unparse_ty_no_lwt ctxt utr in
    __return ctxt
      (Alpha_context.Script.T_big_map, [ ta; tr ],
        (Script_ir_annot.unparse_type_annot tname))
  end.

Definition unparse_ty (ctxt : Alpha_context.context) (ty : Script_typed_ir.ty)
  : Lwt.t
    (Error_monad.tzresult (Alpha_context.Script.node * Alpha_context.context)) :=
  Lwt.__return (unparse_ty_no_lwt ctxt ty).

Fixpoint strip_var_annots {A B : Set} (function_parameter : Micheline.node A B)
  {struct function_parameter} : Micheline.node A B :=
  match function_parameter with
  | (Micheline.Int _ _ | Micheline.String _ _ | Micheline.Bytes _ _) as atom =&gt;
    atom
  | Micheline.Seq loc args =&gt; Micheline.Seq loc (List.map strip_var_annots args)
  | Micheline.Prim loc name args annots =&gt;
    let not_var_annot (s : string) : bool :=
      (|Compare.Char|).(Compare.S.op_ltgt) (String.get s 0) &quot;@&quot; % char in
    let annots := List.filter not_var_annot annots in
    Micheline.Prim loc name (List.map strip_var_annots args) annots
  end.

Definition serialize_ty_for_error
  (ctxt : Alpha_context.context) (ty : Script_typed_ir.ty)
  : Error_monad.tzresult
    (Micheline.canonical Alpha_context.Script.prim * Alpha_context.context) :=
  Error_monad.op_gtpipequestion
    ((Error_monad.record_trace extensible_type_value)
      (unparse_ty_no_lwt ctxt ty))
    (fun function_parameter =&gt;
      let '(ty, ctxt) := function_parameter in
      ((Micheline.strip_locations (strip_var_annots ty)), ctxt)).

Fixpoint unparse_stack
  (ctxt : Alpha_context.context) (function_parameter : Script_typed_ir.stack_ty)
  {struct ctxt}
  : Lwt.t
    (Error_monad.tzresult
      (list (Alpha_context.Script.expr * Alpha_context.Script.annot) *
        Alpha_context.context)) :=
  match function_parameter with
  | Script_typed_ir.Empty_t =&gt; Error_monad.__return (nil, ctxt)
  | Script_typed_ir.Item_t ty rest annot =&gt;
    let=? '(uty, ctxt) := unparse_ty ctxt ty in
    let=? '(urest, ctxt) := unparse_stack ctxt rest in
    Error_monad.__return
      ((cons
        ((Micheline.strip_locations uty),
          (Script_ir_annot.unparse_var_annot annot)) urest), ctxt)
  end.

Definition serialize_stack_for_error
  (ctxt : Alpha_context.context) (stack_ty : Script_typed_ir.stack_ty)
  : Lwt.t
    (Error_monad.tzresult
      (list (Alpha_context.Script.expr * Alpha_context.Script.annot) *
        Alpha_context.context)) :=
  Error_monad.trace extensible_type_value (unparse_stack ctxt stack_ty).

Definition name_of_ty (function_parameter : Script_typed_ir.ty)
  : option Script_typed_ir.type_annot :=
  match function_parameter with
  | Script_typed_ir.Unit_t tname =&gt; tname
  | Script_typed_ir.Int_t tname =&gt; tname
  | Script_typed_ir.Nat_t tname =&gt; tname
  | Script_typed_ir.String_t tname =&gt; tname
  | Script_typed_ir.Bytes_t tname =&gt; tname
  | Script_typed_ir.Mutez_t tname =&gt; tname
  | Script_typed_ir.Bool_t tname =&gt; tname
  | Script_typed_ir.Key_hash_t tname =&gt; tname
  | Script_typed_ir.Key_t tname =&gt; tname
  | Script_typed_ir.Timestamp_t tname =&gt; tname
  | Script_typed_ir.Address_t tname =&gt; tname
  | Script_typed_ir.Signature_t tname =&gt; tname
  | Script_typed_ir.Operation_t tname =&gt; tname
  | Script_typed_ir.Chain_id_t tname =&gt; tname
  | Script_typed_ir.Contract_t _ tname =&gt; tname
  | Script_typed_ir.Pair_t _ _ tname _ =&gt; tname
  | Script_typed_ir.Union_t _ _ tname _ =&gt; tname
  | Script_typed_ir.Lambda_t _ _ tname =&gt; tname
  | Script_typed_ir.Option_t _ tname _ =&gt; tname
  | Script_typed_ir.List_t _ tname _ =&gt; tname
  | Script_typed_ir.Set_t _ tname =&gt; tname
  | Script_typed_ir.Map_t _ _ tname _ =&gt; tname
  | Script_typed_ir.Big_map_t _ _ tname =&gt; tname
  end.

Inductive eq : Set :=
| Eq : eq.

Definition comparable_ty_eq
  (ctxt : Alpha_context.context) (ta : Script_typed_ir.comparable_ty)
  (tb : Script_typed_ir.comparable_ty) : Error_monad.tzresult eq :=
  match (ta, tb) with
  | (Script_typed_ir.Int_key _, Script_typed_ir.Int_key _) =&gt; Pervasives.Ok Eq
  | (Script_typed_ir.Nat_key _, Script_typed_ir.Nat_key _) =&gt; Pervasives.Ok Eq
  | (Script_typed_ir.String_key _, Script_typed_ir.String_key _) =&gt;
    Pervasives.Ok Eq
  | (Script_typed_ir.Bytes_key _, Script_typed_ir.Bytes_key _) =&gt;
    Pervasives.Ok Eq
  | (Script_typed_ir.Mutez_key _, Script_typed_ir.Mutez_key _) =&gt;
    Pervasives.Ok Eq
  | (Script_typed_ir.Bool_key _, Script_typed_ir.Bool_key _) =&gt; Pervasives.Ok Eq
  | (Script_typed_ir.Key_hash_key _, Script_typed_ir.Key_hash_key _) =&gt;
    Pervasives.Ok Eq
  | (Script_typed_ir.Timestamp_key _, Script_typed_ir.Timestamp_key _) =&gt;
    Pervasives.Ok Eq
  | (Script_typed_ir.Address_key _, Script_typed_ir.Address_key _) =&gt;
    Pervasives.Ok Eq
  | (_, _) =&gt;
    let? '(ta, ctxt) := serialize_ty_for_error ctxt (ty_of_comparable_ty ta) in
    let? '(tb, _ctxt) := serialize_ty_for_error ctxt (ty_of_comparable_ty tb) in
    Error_monad.__error_value extensible_type_value
  end.

Definition record_inconsistent {A : Set}
  (ctxt : Alpha_context.context) (ta : Script_typed_ir.ty)
  (tb : Script_typed_ir.ty)
  : Error_monad.tzresult A -&gt; Error_monad.tzresult A :=
  Error_monad.record_trace_eval
    (fun function_parameter =&gt;
      let '_ := function_parameter in
      let? '(ta, ctxt) := serialize_ty_for_error ctxt ta in
      Error_monad.op_gtpipequestion (serialize_ty_for_error ctxt tb)
        (fun function_parameter =&gt;
          let '(tb, _ctxt) := function_parameter in
          extensible_type_value)).

Definition record_inconsistent_type_annotations {A : Set}
  (ctxt : Alpha_context.context) (loc : Alpha_context.Script.location)
  (ta : Script_typed_ir.ty) (tb : Script_typed_ir.ty)
  : Error_monad.tzresult A -&gt; Error_monad.tzresult A :=
  Error_monad.record_trace_eval
    (fun function_parameter =&gt;
      let '_ := function_parameter in
      let? '(ta, ctxt) := serialize_ty_for_error ctxt ta in
      Error_monad.op_gtpipequestion (serialize_ty_for_error ctxt tb)
        (fun function_parameter =&gt;
          let '(tb, _ctxt) := function_parameter in
          extensible_type_value)).

Fixpoint ty_eq
  (ctxt : Alpha_context.context) (ta : Script_typed_ir.ty)
  (tb : Script_typed_ir.ty) {struct ta}
  : Error_monad.tzresult (eq * Alpha_context.context) :=
  let ok (__eq_value : eq) (ctxt : Alpha_context.context) (nb_args : int)
    : Error_monad.tzresult (eq * Alpha_context.context) :=
    let? ctxt :=
      Alpha_context.Gas.consume ctxt
        (Typecheck_costs.type_ (Pervasives.op_star 2 nb_args)) in
    Pervasives.Ok (__eq_value, ctxt) in
  let? ctxt := Alpha_context.Gas.consume ctxt Typecheck_costs.cycle in
  match (ta, tb) with
  | (Script_typed_ir.Unit_t _, Script_typed_ir.Unit_t _) =&gt; ok Eq ctxt 0
  | (Script_typed_ir.Int_t _, Script_typed_ir.Int_t _) =&gt; ok Eq ctxt 0
  | (Script_typed_ir.Nat_t _, Script_typed_ir.Nat_t _) =&gt; ok Eq ctxt 0
  | (Script_typed_ir.Key_t _, Script_typed_ir.Key_t _) =&gt; ok Eq ctxt 0
  | (Script_typed_ir.Key_hash_t _, Script_typed_ir.Key_hash_t _) =&gt; ok Eq ctxt 0
  | (Script_typed_ir.String_t _, Script_typed_ir.String_t _) =&gt; ok Eq ctxt 0
  | (Script_typed_ir.Bytes_t _, Script_typed_ir.Bytes_t _) =&gt; ok Eq ctxt 0
  | (Script_typed_ir.Signature_t _, Script_typed_ir.Signature_t _) =&gt;
    ok Eq ctxt 0
  | (Script_typed_ir.Mutez_t _, Script_typed_ir.Mutez_t _) =&gt; ok Eq ctxt 0
  | (Script_typed_ir.Timestamp_t _, Script_typed_ir.Timestamp_t _) =&gt;
    ok Eq ctxt 0
  | (Script_typed_ir.Chain_id_t _, Script_typed_ir.Chain_id_t _) =&gt; ok Eq ctxt 0
  | (Script_typed_ir.Address_t _, Script_typed_ir.Address_t _) =&gt; ok Eq ctxt 0
  | (Script_typed_ir.Bool_t _, Script_typed_ir.Bool_t _) =&gt; ok Eq ctxt 0
  | (Script_typed_ir.Operation_t _, Script_typed_ir.Operation_t _) =&gt;
    ok Eq ctxt 0
  | (Script_typed_ir.Map_t tal tar _ _, Script_typed_ir.Map_t tbl tbr _ _) =&gt;
    (record_inconsistent ctxt ta tb)
      (let? 'Eq := comparable_ty_eq ctxt tal tbl in
      let? '(Eq, ctxt) := ty_eq ctxt tar tbr in
      ok Eq ctxt 2)
  | (Script_typed_ir.Big_map_t tal tar _, Script_typed_ir.Big_map_t tbl tbr _)
    =&gt;
    (record_inconsistent ctxt ta tb)
      (let? 'Eq := comparable_ty_eq ctxt tal tbl in
      let? '(Eq, ctxt) := ty_eq ctxt tar tbr in
      ok Eq ctxt 2)
  | (Script_typed_ir.Set_t ea _, Script_typed_ir.Set_t eb _) =&gt;
    (record_inconsistent ctxt ta tb)
      (let? 'Eq := comparable_ty_eq ctxt ea eb in
      ok Eq ctxt 1)
  |
    (Script_typed_ir.Pair_t (tal, _, _) (tar, _, _) _ _,
      Script_typed_ir.Pair_t (tbl, _, _) (tbr, _, _) _ _) =&gt;
    (record_inconsistent ctxt ta tb)
      (let? '(Eq, ctxt) := ty_eq ctxt tal tbl in
      let? '(Eq, ctxt) := ty_eq ctxt tar tbr in
      ok Eq ctxt 2)
  |
    (Script_typed_ir.Union_t (tal, _) (tar, _) _ _,
      Script_typed_ir.Union_t (tbl, _) (tbr, _) _ _) =&gt;
    (record_inconsistent ctxt ta tb)
      (let? '(Eq, ctxt) := ty_eq ctxt tal tbl in
      let? '(Eq, ctxt) := ty_eq ctxt tar tbr in
      ok Eq ctxt 2)
  | (Script_typed_ir.Lambda_t tal tar _, Script_typed_ir.Lambda_t tbl tbr _) =&gt;
    (record_inconsistent ctxt ta tb)
      (let? '(Eq, ctxt) := ty_eq ctxt tal tbl in
      let? '(Eq, ctxt) := ty_eq ctxt tar tbr in
      ok Eq ctxt 2)
  | (Script_typed_ir.Contract_t tal _, Script_typed_ir.Contract_t tbl _) =&gt;
    (record_inconsistent ctxt ta tb)
      (let? '(Eq, ctxt) := ty_eq ctxt tal tbl in
      ok Eq ctxt 1)
  | (Script_typed_ir.Option_t tva _ _, Script_typed_ir.Option_t tvb _ _) =&gt;
    (record_inconsistent ctxt ta tb)
      (let? '(Eq, ctxt) := ty_eq ctxt tva tvb in
      ok Eq ctxt 1)
  | (Script_typed_ir.List_t tva _ _, Script_typed_ir.List_t tvb _ _) =&gt;
    (record_inconsistent ctxt ta tb)
      (let? '(Eq, ctxt) := ty_eq ctxt tva tvb in
      ok Eq ctxt 1)
  | (_, _) =&gt;
    let? '(ta, ctxt) := serialize_ty_for_error ctxt ta in
    let? '(tb, _ctxt) := serialize_ty_for_error ctxt tb in
    Error_monad.__error_value extensible_type_value
  end.

Fixpoint stack_ty_eq
  (ctxt : Alpha_context.context) (lvl : int) (ta : Script_typed_ir.stack_ty)
  (tb : Script_typed_ir.stack_ty) {struct ctxt}
  : Error_monad.tzresult (eq * Alpha_context.context) :=
  match (ta, tb) with
  | (Script_typed_ir.Item_t tva ra _, Script_typed_ir.Item_t tvb rb _) =&gt;
    let? '(Eq, ctxt) :=
      (Error_monad.record_trace extensible_type_value) (ty_eq ctxt tva tvb) in
    let? '(Eq, ctxt) := stack_ty_eq ctxt (Pervasives.op_plus lvl 1) ra rb in
    Pervasives.Ok (Eq, ctxt)
  | (Script_typed_ir.Empty_t, Script_typed_ir.Empty_t) =&gt;
    Pervasives.Ok (Eq, ctxt)
  | (_, _) =&gt; Error_monad.__error_value extensible_type_value
  end.

Definition merge_comparable_types
  (legacy : bool) (ta : Script_typed_ir.comparable_ty)
  (tb : Script_typed_ir.comparable_ty)
  : Error_monad.tzresult Script_typed_ir.comparable_ty :=
  match (ta, tb) with
  | (Script_typed_ir.Int_key annot_a, Script_typed_ir.Int_key annot_b) =&gt;
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot =&gt; Script_typed_ir.Int_key annot)
  | (Script_typed_ir.Nat_key annot_a, Script_typed_ir.Nat_key annot_b) =&gt;
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot =&gt; Script_typed_ir.Nat_key annot)
  | (Script_typed_ir.String_key annot_a, Script_typed_ir.String_key annot_b) =&gt;
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot =&gt; Script_typed_ir.String_key annot)
  | (Script_typed_ir.Bytes_key annot_a, Script_typed_ir.Bytes_key annot_b) =&gt;
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot =&gt; Script_typed_ir.Bytes_key annot)
  | (Script_typed_ir.Mutez_key annot_a, Script_typed_ir.Mutez_key annot_b) =&gt;
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot =&gt; Script_typed_ir.Mutez_key annot)
  | (Script_typed_ir.Bool_key annot_a, Script_typed_ir.Bool_key annot_b) =&gt;
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot =&gt; Script_typed_ir.Bool_key annot)
  | (Script_typed_ir.Key_hash_key annot_a, Script_typed_ir.Key_hash_key annot_b)
    =&gt;
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot =&gt; Script_typed_ir.Key_hash_key annot)
  |
    (Script_typed_ir.Timestamp_key annot_a,
      Script_typed_ir.Timestamp_key annot_b) =&gt;
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot =&gt; Script_typed_ir.Timestamp_key annot)
  | (Script_typed_ir.Address_key annot_a, Script_typed_ir.Address_key annot_b)
    =&gt;
    Error_monad.op_gtpipequestion
      (Script_ir_annot.merge_type_annot legacy annot_a annot_b)
      (fun annot =&gt; Script_typed_ir.Address_key annot)
  | (_, _) =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert (Error_monad.tzresult Script_typed_ir.comparable_ty) false
  end.

Definition merge_types (legacy : bool)
  : Alpha_context.context -&gt; Alpha_context.Script.location -&gt;
  Script_typed_ir.ty -&gt; Script_typed_ir.ty -&gt;
  Error_monad.tzresult (Script_typed_ir.ty * Alpha_context.context) :=
  let fix help
    (ctxt : Alpha_context.context) (ty1 : Script_typed_ir.ty)
    (ty2 : Script_typed_ir.ty) {struct ctxt}
    : Error_monad.tzresult (Script_typed_ir.ty * Alpha_context.context) :=
    match (ty1, ty2) with
    | (Script_typed_ir.Unit_t tn1, Script_typed_ir.Unit_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.Unit_t tname), ctxt))
    | (Script_typed_ir.Int_t tn1, Script_typed_ir.Int_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.Int_t tname), ctxt))
    | (Script_typed_ir.Nat_t tn1, Script_typed_ir.Nat_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.Nat_t tname), ctxt))
    | (Script_typed_ir.Key_t tn1, Script_typed_ir.Key_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.Key_t tname), ctxt))
    | (Script_typed_ir.Key_hash_t tn1, Script_typed_ir.Key_hash_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.Key_hash_t tname), ctxt))
    | (Script_typed_ir.String_t tn1, Script_typed_ir.String_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.String_t tname), ctxt))
    | (Script_typed_ir.Bytes_t tn1, Script_typed_ir.Bytes_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.Bytes_t tname), ctxt))
    | (Script_typed_ir.Signature_t tn1, Script_typed_ir.Signature_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.Signature_t tname), ctxt))
    | (Script_typed_ir.Mutez_t tn1, Script_typed_ir.Mutez_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.Mutez_t tname), ctxt))
    | (Script_typed_ir.Timestamp_t tn1, Script_typed_ir.Timestamp_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.Timestamp_t tname), ctxt))
    | (Script_typed_ir.Address_t tn1, Script_typed_ir.Address_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.Address_t tname), ctxt))
    | (Script_typed_ir.Bool_t tn1, Script_typed_ir.Bool_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.Bool_t tname), ctxt))
    | (Script_typed_ir.Chain_id_t tn1, Script_typed_ir.Chain_id_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.Chain_id_t tname), ctxt))
    | (Script_typed_ir.Operation_t tn1, Script_typed_ir.Operation_t tn2) =&gt;
      Error_monad.op_gtpipequestion
        (Script_ir_annot.merge_type_annot legacy tn1 tn2)
        (fun tname =&gt; ((Script_typed_ir.Operation_t tname), ctxt))
    |
      (Script_typed_ir.Map_t tal tar tn1 has_big_map,
        Script_typed_ir.Map_t tbl tbr tn2 _) =&gt;
      let? tname := Script_ir_annot.merge_type_annot legacy tn1 tn2 in
      let? '(value, ctxt) := help ctxt tar tbr in
      let? '(Eq, ctxt) := ty_eq ctxt tar value in
      Error_monad.op_gtpipequestion (merge_comparable_types legacy tal tbl)
        (fun tk =&gt; ((Script_typed_ir.Map_t tk value tname has_big_map), ctxt))
    |
      (Script_typed_ir.Big_map_t tal tar tn1,
        Script_typed_ir.Big_map_t tbl tbr tn2) =&gt;
      let? tname := Script_ir_annot.merge_type_annot legacy tn1 tn2 in
      let? '(value, ctxt) := help ctxt tar tbr in
      let? '(Eq, ctxt) := ty_eq ctxt tar value in
      Error_monad.op_gtpipequestion (merge_comparable_types legacy tal tbl)
        (fun tk =&gt; ((Script_typed_ir.Big_map_t tk value tname), ctxt))
    | (Script_typed_ir.Set_t ea tn1, Script_typed_ir.Set_t eb tn2) =&gt;
      let? tname := Script_ir_annot.merge_type_annot legacy tn1 tn2 in
      Error_monad.op_gtpipequestion (merge_comparable_types legacy ea eb)
        (fun e =&gt; ((Script_typed_ir.Set_t e tname), ctxt))
    |
      (Script_typed_ir.Pair_t (tal, l_field1, l_var1) (tar, r_field1, r_var1)
        tn1 has_big_map,
        Script_typed_ir.Pair_t (tbl, l_field2, l_var2) (tbr, r_field2, r_var2)
          tn2 _) =&gt;
      let? tname := Script_ir_annot.merge_type_annot legacy tn1 tn2 in
      let? l_field := Script_ir_annot.merge_field_annot legacy l_field1 l_field2
        in
      let? r_field := Script_ir_annot.merge_field_annot legacy r_field1 r_field2
        in
      let l_var := Script_ir_annot.merge_var_annot l_var1 l_var2 in
      let r_var := Script_ir_annot.merge_var_annot r_var1 r_var2 in
      let? '(left_ty, ctxt) := help ctxt tal tbl in
      Error_monad.op_gtpipequestion (help ctxt tar tbr)
        (fun function_parameter =&gt;
          let '(right_ty, ctxt) := function_parameter in
          ((Script_typed_ir.Pair_t (left_ty, l_field, l_var)
            (right_ty, r_field, r_var) tname has_big_map), ctxt))
    |
      (Script_typed_ir.Union_t (tal, tal_annot) (tar, tar_annot) tn1 has_big_map,
        Script_typed_ir.Union_t (tbl, tbl_annot) (tbr, tbr_annot) tn2 _) =&gt;
      let? tname := Script_ir_annot.merge_type_annot legacy tn1 tn2 in
      let? left_annot :=
        Script_ir_annot.merge_field_annot legacy tal_annot tbl_annot in
      let? right_annot :=
        Script_ir_annot.merge_field_annot legacy tar_annot tbr_annot in
      let? '(left_ty, ctxt) := help ctxt tal tbl in
      Error_monad.op_gtpipequestion (help ctxt tar tbr)
        (fun function_parameter =&gt;
          let '(right_ty, ctxt) := function_parameter in
          ((Script_typed_ir.Union_t (left_ty, left_annot)
            (right_ty, right_annot) tname has_big_map), ctxt))
    |
      (Script_typed_ir.Lambda_t tal tar tn1,
        Script_typed_ir.Lambda_t tbl tbr tn2) =&gt;
      let? tname := Script_ir_annot.merge_type_annot legacy tn1 tn2 in
      let? '(left_ty, ctxt) := help ctxt tal tbl in
      Error_monad.op_gtpipequestion (help ctxt tar tbr)
        (fun function_parameter =&gt;
          let '(right_ty, ctxt) := function_parameter in
          ((Script_typed_ir.Lambda_t left_ty right_ty tname), ctxt))
    | (Script_typed_ir.Contract_t tal tn1, Script_typed_ir.Contract_t tbl tn2)
      =&gt;
      let? tname := Script_ir_annot.merge_type_annot legacy tn1 tn2 in
      Error_monad.op_gtpipequestion (help ctxt tal tbl)
        (fun function_parameter =&gt;
          let '(arg_ty, ctxt) := function_parameter in
          ((Script_typed_ir.Contract_t arg_ty tname), ctxt))
    |
      (Script_typed_ir.Option_t tva tn1 has_big_map,
        Script_typed_ir.Option_t tvb tn2 _) =&gt;
      let? tname := Script_ir_annot.merge_type_annot legacy tn1 tn2 in
      Error_monad.op_gtpipequestion (help ctxt tva tvb)
        (fun function_parameter =&gt;
          let '(ty, ctxt) := function_parameter in
          ((Script_typed_ir.Option_t ty tname has_big_map), ctxt))
    |
      (Script_typed_ir.List_t tva tn1 has_big_map,
        Script_typed_ir.List_t tvb tn2 _) =&gt;
      let? tname := Script_ir_annot.merge_type_annot legacy tn1 tn2 in
      Error_monad.op_gtpipequestion (help ctxt tva tvb)
        (fun function_parameter =&gt;
          let '(ty, ctxt) := function_parameter in
          ((Script_typed_ir.List_t ty tname has_big_map), ctxt))
    | (_, _) =&gt;
      (* ‚ùå Assert instruction is not handled. *)
      assert (Error_monad.tzresult (Script_typed_ir.ty * Alpha_context.context))
        false
    end in
  fun ctxt =&gt;
    fun loc =&gt;
      fun ty1 =&gt;
        fun ty2 =&gt;
          record_inconsistent_type_annotations ctxt loc ty1 ty2
            (help ctxt ty1 ty2).

Definition merge_stacks (legacy : bool) (loc : Alpha_context.Script.location)
  : Alpha_context.context -&gt; Script_typed_ir.stack_ty -&gt;
  Script_typed_ir.stack_ty -&gt;
  Error_monad.tzresult (Script_typed_ir.stack_ty * Alpha_context.context) :=
  let fix help
    (ctxt : Alpha_context.context) (stack1 : Script_typed_ir.stack_ty)
    (stack2 : Script_typed_ir.stack_ty) {struct ctxt}
    : Error_monad.tzresult (Script_typed_ir.stack_ty * Alpha_context.context) :=
    match (stack1, stack2) with
    | (Script_typed_ir.Empty_t, Script_typed_ir.Empty_t) =&gt;
      Error_monad.ok (Script_typed_ir.Empty_t, ctxt)
    |
      (Script_typed_ir.Item_t ty1 rest1 annot1,
        Script_typed_ir.Item_t ty2 rest2 annot2) =&gt;
      let annot := Script_ir_annot.merge_var_annot annot1 annot2 in
      let? '(ty, ctxt) := merge_types legacy ctxt loc ty1 ty2 in
      Error_monad.op_gtpipequestion (help ctxt rest1 rest2)
        (fun function_parameter =&gt;
          let '(rest, ctxt) := function_parameter in
          ((Script_typed_ir.Item_t ty rest annot), ctxt))
    | _ =&gt; unreachable_gadt_branch
    end in
  help.

Definition has_big_map (function_parameter : Script_typed_ir.ty) : bool :=
  match function_parameter with
  | Script_typed_ir.Unit_t _ =&gt; false
  | Script_typed_ir.Int_t _ =&gt; false
  | Script_typed_ir.Nat_t _ =&gt; false
  | Script_typed_ir.Signature_t _ =&gt; false
  | Script_typed_ir.String_t _ =&gt; false
  | Script_typed_ir.Bytes_t _ =&gt; false
  | Script_typed_ir.Mutez_t _ =&gt; false
  | Script_typed_ir.Key_hash_t _ =&gt; false
  | Script_typed_ir.Key_t _ =&gt; false
  | Script_typed_ir.Timestamp_t _ =&gt; false
  | Script_typed_ir.Address_t _ =&gt; false
  | Script_typed_ir.Bool_t _ =&gt; false
  | Script_typed_ir.Lambda_t _ _ _ =&gt; false
  | Script_typed_ir.Set_t _ _ =&gt; false
  | Script_typed_ir.Big_map_t _ _ _ =&gt; true
  | Script_typed_ir.Contract_t _ _ =&gt; false
  | Script_typed_ir.Operation_t _ =&gt; false
  | Script_typed_ir.Chain_id_t _ =&gt; false
  | Script_typed_ir.Pair_t _ _ _ has_big_map =&gt; has_big_map
  | Script_typed_ir.Union_t _ _ _ has_big_map =&gt; has_big_map
  | Script_typed_ir.Option_t _ _ has_big_map =&gt; has_big_map
  | Script_typed_ir.List_t _ _ has_big_map =&gt; has_big_map
  | Script_typed_ir.Map_t _ _ _ has_big_map =&gt; has_big_map
  end.

Module ConstructorRecords_judgement.
  Module judgement.
    Module Failed.
      Record record {descr : Set} : Set := Build {
        descr : descr }.
      Arguments record : clear implicits.
      Definition with_descr {t_descr} descr (r : record t_descr) :=
        Build t_descr descr.
    End Failed.
    Definition Failed_skeleton := Failed.record.
  End judgement.
End ConstructorRecords_judgement.
Import ConstructorRecords_judgement.

Reserved Notation &quot;'judgement.Failed&quot;.

Inductive judgement : Set :=
| Typed : Script_typed_ir.descr -&gt; judgement
| Failed : 'judgement.Failed -&gt; judgement

where &quot;'judgement.Failed&quot; :=
  (judgement.Failed_skeleton (Script_typed_ir.stack_ty -&gt; Script_typed_ir.descr)).

Module judgement.
  Include ConstructorRecords_judgement.judgement.
  Definition Failed := 'judgement.Failed.
End judgement.

Module branch.
  Record record : Set := Build {
    branch :
      Script_typed_ir.descr -&gt; Script_typed_ir.descr -&gt; Script_typed_ir.descr }.
  Definition with_branch branch (r : record) :=
    Build branch.
End branch.
Definition branch := branch.record.

Definition merge_branches
  (legacy : bool) (ctxt : Alpha_context.context) (loc : int) (btr : judgement)
  (bfr : judgement) (function_parameter : branch)
  : Lwt.t (Error_monad.tzresult (judgement * Alpha_context.context)) :=
  let '{| branch.branch := branch |} := function_parameter in
  match (btr, bfr) with
  |
    (Typed ({| Script_typed_ir.descr.aft := aftbt |} as dbt),
      Typed ({| Script_typed_ir.descr.aft := aftbf |} as dbf)) =&gt;
    let unmatched_branches (function_parameter : unit)
      : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
      let '_ := function_parameter in
      let=? '(aftbt, ctxt) := serialize_stack_for_error ctxt aftbt in
      Error_monad.op_gtgtpipequestion (serialize_stack_for_error ctxt aftbf)
        (fun function_parameter =&gt;
          let '(aftbf, _ctxt) := function_parameter in
          extensible_type_value) in
    Error_monad.trace_eval unmatched_branches
      (let=? '(Eq, ctxt) := Lwt.__return (stack_ty_eq ctxt 1 aftbt aftbf) in
      let=? '(merged_stack, ctxt) :=
        Lwt.__return (merge_stacks legacy loc ctxt aftbt aftbf) in
      Error_monad.__return
        ((Typed
          (branch (Script_typed_ir.descr.with_aft merged_stack dbt)
            (Script_typed_ir.descr.with_aft merged_stack dbf))), ctxt))
  |
    (Failed {| judgement.Failed.descr := descrt |},
      Failed {| judgement.Failed.descr := descrf |}) =&gt;
    let __descr_value (ret : Script_typed_ir.stack_ty)
      : Script_typed_ir.descr :=
      branch (descrt ret) (descrf ret) in
    Error_monad.__return
      ((Failed {| judgement.Failed.descr := __descr_value |}), ctxt)
  | (Typed dbt, Failed {| judgement.Failed.descr := descrf |}) =&gt;
    Error_monad.__return
      ((Typed (branch dbt (descrf dbt.(Script_typed_ir.descr.aft)))), ctxt)
  | (Failed {| judgement.Failed.descr := descrt |}, Typed dbf) =&gt;
    Error_monad.__return
      ((Typed (branch (descrt dbf.(Script_typed_ir.descr.aft)) dbf)), ctxt)
  end.

Definition parse_comparable_ty
  (ctxt : Alpha_context.context) (ty : Alpha_context.Script.node)
  : Error_monad.tzresult (ex_comparable_ty * Alpha_context.context) :=
  let? ctxt := Alpha_context.Gas.consume ctxt Typecheck_costs.cycle in
  let? ctxt := Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0) in
  match ty with
  | Micheline.Prim loc Alpha_context.Script.T_int [] annot =&gt;
    Error_monad.op_gtpipequestion (Script_ir_annot.parse_type_annot loc annot)
      (fun tname =&gt; ((Ex_comparable_ty (Script_typed_ir.Int_key tname)), ctxt))
  | Micheline.Prim loc Alpha_context.Script.T_nat [] annot =&gt;
    Error_monad.op_gtpipequestion (Script_ir_annot.parse_type_annot loc annot)
      (fun tname =&gt; ((Ex_comparable_ty (Script_typed_ir.Nat_key tname)), ctxt))
  | Micheline.Prim loc Alpha_context.Script.T_string [] annot =&gt;
    Error_monad.op_gtpipequestion (Script_ir_annot.parse_type_annot loc annot)
      (fun tname =&gt;
        ((Ex_comparable_ty (Script_typed_ir.String_key tname)), ctxt))
  | Micheline.Prim loc Alpha_context.Script.T_bytes [] annot =&gt;
    Error_monad.op_gtpipequestion (Script_ir_annot.parse_type_annot loc annot)
      (fun tname =&gt; ((Ex_comparable_ty (Script_typed_ir.Bytes_key tname)), ctxt))
  | Micheline.Prim loc Alpha_context.Script.T_mutez [] annot =&gt;
    Error_monad.op_gtpipequestion (Script_ir_annot.parse_type_annot loc annot)
      (fun tname =&gt; ((Ex_comparable_ty (Script_typed_ir.Mutez_key tname)), ctxt))
  | Micheline.Prim loc Alpha_context.Script.T_bool [] annot =&gt;
    Error_monad.op_gtpipequestion (Script_ir_annot.parse_type_annot loc annot)
      (fun tname =&gt; ((Ex_comparable_ty (Script_typed_ir.Bool_key tname)), ctxt))
  | Micheline.Prim loc Alpha_context.Script.T_key_hash [] annot =&gt;
    Error_monad.op_gtpipequestion (Script_ir_annot.parse_type_annot loc annot)
      (fun tname =&gt;
        ((Ex_comparable_ty (Script_typed_ir.Key_hash_key tname)), ctxt))
  | Micheline.Prim loc Alpha_context.Script.T_timestamp [] annot =&gt;
    Error_monad.op_gtpipequestion (Script_ir_annot.parse_type_annot loc annot)
      (fun tname =&gt;
        ((Ex_comparable_ty (Script_typed_ir.Timestamp_key tname)), ctxt))
  | Micheline.Prim loc Alpha_context.Script.T_address [] annot =&gt;
    Error_monad.op_gtpipequestion (Script_ir_annot.parse_type_annot loc annot)
      (fun tname =&gt;
        ((Ex_comparable_ty (Script_typed_ir.Address_key tname)), ctxt))
  |
    Micheline.Prim loc
      ((Alpha_context.Script.T_int | Alpha_context.Script.T_nat |
      Alpha_context.Script.T_string | Alpha_context.Script.T_mutez |
      Alpha_context.Script.T_bool | Alpha_context.Script.T_key |
      Alpha_context.Script.T_address | Alpha_context.Script.T_timestamp) as prim)
      l _ =&gt; Error_monad.__error_value extensible_type_value
  |
    Micheline.Prim loc
      (Alpha_context.Script.T_pair | Alpha_context.Script.T_or |
      Alpha_context.Script.T_set | Alpha_context.Script.T_map |
      Alpha_context.Script.T_list | Alpha_context.Script.T_option |
      Alpha_context.Script.T_lambda | Alpha_context.Script.T_unit |
      Alpha_context.Script.T_signature | Alpha_context.Script.T_contract) _ _ =&gt;
    Error_monad.__error_value extensible_type_value
  | expr =&gt;
    Error_monad.__error_value
      (unexpected expr nil Script_tc_errors.Type_namespace
        [
          Alpha_context.Script.T_int;
          Alpha_context.Script.T_nat;
          Alpha_context.Script.T_string;
          Alpha_context.Script.T_mutez;
          Alpha_context.Script.T_bool;
          Alpha_context.Script.T_key;
          Alpha_context.Script.T_key_hash;
          Alpha_context.Script.T_timestamp
        ])
  end.

Fixpoint parse_packable_ty (ctxt : Alpha_context.context) (legacy : bool)
  {struct ctxt}
  : Alpha_context.Script.node -&gt;
  Error_monad.tzresult (ex_ty * Alpha_context.context) :=
  parse_ty ctxt legacy false false legacy

with parse_parameter_ty (ctxt : Alpha_context.context) (legacy : bool)
  {struct ctxt}
  : Alpha_context.Script.node -&gt;
  Error_monad.tzresult (ex_ty * Alpha_context.context) :=
  parse_ty ctxt legacy true false true

with parse_any_ty (ctxt : Alpha_context.context) (legacy : bool) {struct ctxt}
  : Alpha_context.Script.node -&gt;
  Error_monad.tzresult (ex_ty * Alpha_context.context) :=
  parse_ty ctxt legacy true true true

with parse_ty
  (ctxt : Alpha_context.context) (legacy : bool) (allow_big_map : bool)
  (allow_operation : bool) (allow_contract : bool)
  (node : Alpha_context.Script.node) {struct ctxt}
  : Error_monad.tzresult (ex_ty * Alpha_context.context) :=
  let? ctxt := Alpha_context.Gas.consume ctxt Typecheck_costs.cycle in
  match
    (node,
      match node with
      | Micheline.Prim loc Alpha_context.Script.T_big_map args annot =&gt;
        allow_big_map
      | _ =&gt; false
      end) with
  | (Micheline.Prim loc Alpha_context.Script.T_unit [] annot, _) =&gt;
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
      (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Unit_t ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_int [] annot, _) =&gt;
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
      (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Int_t ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_nat [] annot, _) =&gt;
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
      (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Nat_t ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_string [] annot, _) =&gt;
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
      (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.String_t ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_bytes [] annot, _) =&gt;
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
      (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Bytes_t ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_mutez [] annot, _) =&gt;
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
      (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Mutez_t ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_bool [] annot, _) =&gt;
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
      (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Bool_t ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_key [] annot, _) =&gt;
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
      (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Key_t ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_key_hash [] annot, _) =&gt;
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
      (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Key_hash_t ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_timestamp [] annot, _) =&gt;
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
      (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Timestamp_t ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_address [] annot, _) =&gt;
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
      (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Address_t ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_signature [] annot, _) =&gt;
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
      (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Signature_t ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_operation [] annot, _) =&gt;
    if allow_operation then
      let? ty_name := Script_ir_annot.parse_type_annot loc annot in
      Error_monad.op_gtpipequestion
        (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
        (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Operation_t ty_name)), ctxt))
    else
      Error_monad.__error_value extensible_type_value
  | (Micheline.Prim loc Alpha_context.Script.T_chain_id [] annot, _) =&gt;
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 0))
      (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Chain_id_t ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_contract (cons utl []) annot, _)
    =&gt;
    if allow_contract then
      let? '(Ex_ty tl, ctxt) := parse_parameter_ty ctxt legacy utl in
      let? ty_name := Script_ir_annot.parse_type_annot loc annot in
      Error_monad.op_gtpipequestion
        (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 1))
        (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Contract_t tl ty_name)), ctxt))
    else
      Error_monad.__error_value extensible_type_value
  |
    (Micheline.Prim loc Alpha_context.Script.T_pair (cons utl (cons utr []))
      annot, _) =&gt;
    let? '(utl, left_field) := Script_ir_annot.extract_field_annot utl in
    let? '(utr, right_field) := Script_ir_annot.extract_field_annot utr in
    let? '(Ex_ty tl, ctxt) :=
      parse_ty ctxt legacy allow_big_map allow_operation allow_contract utl in
    let? '(Ex_ty tr, ctxt) :=
      parse_ty ctxt legacy allow_big_map allow_operation allow_contract utr in
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 2))
      (fun ctxt =&gt;
        ((Ex_ty
          (Script_typed_ir.Pair_t (tl, left_field, None) (tr, right_field, None)
            ty_name (Pervasives.op_pipepipe (has_big_map tl) (has_big_map tr)))),
          ctxt))
  |
    (Micheline.Prim loc Alpha_context.Script.T_or (cons utl (cons utr [])) annot,
      _) =&gt;
    let? '(utl, left_constr) := Script_ir_annot.extract_field_annot utl in
    let? '(utr, right_constr) := Script_ir_annot.extract_field_annot utr in
    let? '(Ex_ty tl, ctxt) :=
      parse_ty ctxt legacy allow_big_map allow_operation allow_contract utl in
    let? '(Ex_ty tr, ctxt) :=
      parse_ty ctxt legacy allow_big_map allow_operation allow_contract utr in
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 2))
      (fun ctxt =&gt;
        ((Ex_ty
          (Script_typed_ir.Union_t (tl, left_constr) (tr, right_constr) ty_name
            (Pervasives.op_pipepipe (has_big_map tl) (has_big_map tr)))), ctxt))
  |
    (Micheline.Prim loc Alpha_context.Script.T_lambda (cons uta (cons utr []))
      annot, _) =&gt;
    let? '(Ex_ty ta, ctxt) := parse_any_ty ctxt legacy uta in
    let? '(Ex_ty tr, ctxt) := parse_any_ty ctxt legacy utr in
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 2))
      (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Lambda_t ta tr ty_name)), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_option (cons ut []) annot, _) =&gt;
    let? '(ut, ty_name) :=
      if legacy then
        let? '(ut, _some_constr) := Script_ir_annot.extract_field_annot ut in
        let? '(ty_name, _none_constr, _) :=
          Script_ir_annot.parse_composed_type_annot loc annot in
        Error_monad.ok (ut, ty_name)
      else
        let? ty_name := Script_ir_annot.parse_type_annot loc annot in
        Error_monad.ok (ut, ty_name) in
    let? '(Ex_ty __t_value, ctxt) :=
      parse_ty ctxt legacy allow_big_map allow_operation allow_contract ut in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 2))
      (fun ctxt =&gt;
        ((Ex_ty
          (Script_typed_ir.Option_t __t_value ty_name (has_big_map __t_value))),
          ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_list (cons ut []) annot, _) =&gt;
    let? '(Ex_ty __t_value, ctxt) :=
      parse_ty ctxt legacy allow_big_map allow_operation allow_contract ut in
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 1))
      (fun ctxt =&gt;
        ((Ex_ty
          (Script_typed_ir.List_t __t_value ty_name (has_big_map __t_value))),
          ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_set (cons ut []) annot, _) =&gt;
    let? '(Ex_comparable_ty __t_value, ctxt) := parse_comparable_ty ctxt ut in
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 1))
      (fun ctxt =&gt; ((Ex_ty (Script_typed_ir.Set_t __t_value ty_name)), ctxt))
  |
    (Micheline.Prim loc Alpha_context.Script.T_map (cons uta (cons utr []))
      annot, _) =&gt;
    let? '(Ex_comparable_ty ta, ctxt) := parse_comparable_ty ctxt uta in
    let? '(Ex_ty tr, ctxt) :=
      parse_ty ctxt legacy allow_big_map allow_operation allow_contract utr in
    let? ty_name := Script_ir_annot.parse_type_annot loc annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 2))
      (fun ctxt =&gt;
        ((Ex_ty (Script_typed_ir.Map_t ta tr ty_name (has_big_map tr))), ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_big_map args annot, true) =&gt;
    let? '(big_map_ty, ctxt) := parse_big_map_ty ctxt legacy loc args annot in
    Error_monad.op_gtpipequestion
      (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 2))
      (fun ctxt =&gt; (big_map_ty, ctxt))
  | (Micheline.Prim loc Alpha_context.Script.T_big_map _ _, _) =&gt;
    Error_monad.__error_value extensible_type_value
  |
    (Micheline.Prim loc
      ((Alpha_context.Script.T_unit | Alpha_context.Script.T_signature |
      Alpha_context.Script.T_int | Alpha_context.Script.T_nat |
      Alpha_context.Script.T_string | Alpha_context.Script.T_bytes |
      Alpha_context.Script.T_mutez | Alpha_context.Script.T_bool |
      Alpha_context.Script.T_key | Alpha_context.Script.T_key_hash |
      Alpha_context.Script.T_timestamp | Alpha_context.Script.T_address) as prim)
      l _, _) =&gt; Error_monad.__error_value extensible_type_value
  |
    (Micheline.Prim loc
      ((Alpha_context.Script.T_set | Alpha_context.Script.T_list |
      Alpha_context.Script.T_option | Alpha_context.Script.T_contract) as prim)
      l _, _) =&gt; Error_monad.__error_value extensible_type_value
  |
    (Micheline.Prim loc
      ((Alpha_context.Script.T_pair | Alpha_context.Script.T_or |
      Alpha_context.Script.T_map | Alpha_context.Script.T_lambda) as prim) l _,
      _) =&gt; Error_monad.__error_value extensible_type_value
  | (expr, _) =&gt;
    Error_monad.__error_value
      (unexpected expr nil Script_tc_errors.Type_namespace
        [
          Alpha_context.Script.T_pair;
          Alpha_context.Script.T_or;
          Alpha_context.Script.T_set;
          Alpha_context.Script.T_map;
          Alpha_context.Script.T_list;
          Alpha_context.Script.T_option;
          Alpha_context.Script.T_lambda;
          Alpha_context.Script.T_unit;
          Alpha_context.Script.T_signature;
          Alpha_context.Script.T_contract;
          Alpha_context.Script.T_int;
          Alpha_context.Script.T_nat;
          Alpha_context.Script.T_operation;
          Alpha_context.Script.T_string;
          Alpha_context.Script.T_bytes;
          Alpha_context.Script.T_mutez;
          Alpha_context.Script.T_bool;
          Alpha_context.Script.T_key;
          Alpha_context.Script.T_key_hash;
          Alpha_context.Script.T_timestamp;
          Alpha_context.Script.T_chain_id
        ])
  end

with parse_big_map_ty
  (ctxt : Alpha_context.context) (legacy : bool)
  (big_map_loc : Alpha_context.Script.location)
  (args :
    list
      (Micheline.node Alpha_context.Script.location Alpha_context.Script.prim))
  (map_annot : Micheline.annot) {struct ctxt}
  : Error_monad.tzresult (ex_ty * Alpha_context.context) :=
  let? ctxt := Alpha_context.Gas.consume ctxt Typecheck_costs.cycle in
  match args with
  | cons key_ty (cons value_ty []) =&gt;
    let? '(Ex_comparable_ty key_ty, ctxt) := parse_comparable_ty ctxt key_ty in
    let? '(Ex_ty value_ty, ctxt) := parse_packable_ty ctxt legacy value_ty in
    Error_monad.op_gtpipequestion
      (Script_ir_annot.parse_type_annot big_map_loc map_annot)
      (fun map_name =&gt;
        let big_map_ty := Script_typed_ir.Big_map_t key_ty value_ty map_name in
        ((Ex_ty big_map_ty), ctxt))
  | args =&gt; Error_monad.__error_value extensible_type_value
  end.

Definition parse_storage_ty
  (ctxt : Alpha_context.context) (legacy : bool)
  (node : Alpha_context.Script.node)
  : Error_monad.tzresult (ex_ty * Alpha_context.context) :=
  match
    (node,
      match node with
      |
        Micheline.Prim loc Alpha_context.Script.T_pair
          (cons
            (Micheline.Prim big_map_loc Alpha_context.Script.T_big_map args
              map_annot) (cons remaining_storage [])) storage_annot =&gt; legacy
      | _ =&gt; false
      end) with
  |
    (Micheline.Prim loc Alpha_context.Script.T_pair
      (cons
        (Micheline.Prim big_map_loc Alpha_context.Script.T_big_map args
          map_annot) (cons remaining_storage [])) storage_annot, true) =&gt;
    match
      (storage_annot,
        match storage_annot with
        | cons single [] =&gt;
          Pervasives.op_andand
            ((|Compare.Int|).(Compare.S.op_gt) (String.length single) 0)
            ((|Compare.Char|).(Compare.S.op_eq) (String.get single 0) &quot;%&quot; % char)
        | _ =&gt; false
        end) with
    | ([], _) =&gt; parse_ty ctxt legacy true false legacy node
    | (cons single [], true) =&gt; parse_ty ctxt legacy true false legacy node
    | (_, _) =&gt;
      let? ctxt := Alpha_context.Gas.consume ctxt Typecheck_costs.cycle in
      let? '(Ex_ty big_map_ty, ctxt) :=
        parse_big_map_ty ctxt legacy big_map_loc args map_annot in
      let? '(Ex_ty remaining_storage, ctxt) :=
        parse_ty ctxt legacy true false legacy remaining_storage in
      let? '(ty_name, map_field, storage_field) :=
        Script_ir_annot.parse_composed_type_annot loc storage_annot in
      Error_monad.op_gtpipequestion
        (Alpha_context.Gas.consume ctxt (Typecheck_costs.type_ 5))
        (fun ctxt =&gt;
          ((Ex_ty
            (Script_typed_ir.Pair_t (big_map_ty, map_field, None)
              (remaining_storage, storage_field, None) ty_name true)), ctxt))
    end
  | (_, _) =&gt; parse_ty ctxt legacy true false legacy node
  end.

Definition check_packable
  (legacy : bool) (loc : Alpha_context.Script.location)
  (root : Script_typed_ir.ty) : Error_monad.tzresult unit :=
  let fix check (function_parameter : Script_typed_ir.ty)
    {struct function_parameter} : Error_monad.tzresult unit :=
    match
      (function_parameter,
        match function_parameter with
        | Script_typed_ir.Contract_t _ _ =&gt; legacy
        | _ =&gt; false
        end) with
    | (Script_typed_ir.Big_map_t _ _ _, _) =&gt;
      Error_monad.__error_value extensible_type_value
    | (Script_typed_ir.Operation_t _, _) =&gt;
      Error_monad.__error_value extensible_type_value
    | (Script_typed_ir.Unit_t _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Int_t _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Nat_t _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Signature_t _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.String_t _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Bytes_t _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Mutez_t _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Key_hash_t _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Key_t _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Timestamp_t _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Address_t _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Bool_t _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Chain_id_t _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Pair_t (l_ty, _, _) (r_ty, _, _) _ _, _) =&gt;
      let? '_ := check l_ty in
      check r_ty
    | (Script_typed_ir.Union_t (l_ty, _) (r_ty, _) _ _, _) =&gt;
      let? '_ := check l_ty in
      check r_ty
    | (Script_typed_ir.Option_t v_ty _ _, _) =&gt; check v_ty
    | (Script_typed_ir.List_t elt_ty _ _, _) =&gt; check elt_ty
    | (Script_typed_ir.Set_t _ _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Map_t _ elt_ty _ _, _) =&gt; check elt_ty
    | (Script_typed_ir.Lambda_t _l_ty _r_ty _, _) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Contract_t _ _, true) =&gt; Error_monad.ok tt
    | (Script_typed_ir.Contract_t _ _, _) =&gt;
      Error_monad.__error_value extensible_type_value
    end in
  check root.

Inductive ex_script : Set :=
| Ex_script : forall {c : Set}, Script_typed_ir.script c -&gt; ex_script.

Inductive dig_proof_argument : Set :=
| Dig_proof_argument :
  Script_typed_ir.stack_prefix_preservation_witness *
    (Script_typed_ir.ty * option Script_typed_ir.var_annot) *
    Script_typed_ir.stack_ty -&gt; dig_proof_argument.

Inductive dug_proof_argument : Set :=
| Dug_proof_argument :
  Script_typed_ir.stack_prefix_preservation_witness * unit *
    Script_typed_ir.stack_ty -&gt; dug_proof_argument.

Inductive dipn_proof_argument : Set :=
| Dipn_proof_argument :
  Script_typed_ir.stack_prefix_preservation_witness *
    (Alpha_context.context * Script_typed_ir.descr) * Script_typed_ir.stack_ty
  -&gt; dipn_proof_argument.

Inductive dropn_proof_argument : Set :=
| Dropn_proof_argument :
  Script_typed_ir.stack_prefix_preservation_witness * Script_typed_ir.stack_ty *
    Script_typed_ir.stack_ty -&gt; dropn_proof_argument.

Definition parse_var_annot
  (loc : int) (default : option (option Script_typed_ir.var_annot))
  (annot : list string)
  : Lwt.t (Error_monad.tzresult (option Script_typed_ir.var_annot)) :=
  Lwt.__return (Script_ir_annot.parse_var_annot loc default annot).

Definition parse_entrypoint_annot
  (loc : int) (default : option (option Script_typed_ir.var_annot))
  (annot : list string)
  : Lwt.t
    (Error_monad.tzresult
      (option Script_typed_ir.var_annot * option Script_typed_ir.field_annot)) :=
  Lwt.__return (Script_ir_annot.parse_entrypoint_annot loc default annot).

Definition parse_constr_annot
  (loc : int) (if_special_first : option (option Script_typed_ir.field_annot))
  (if_special_second : option (option Script_typed_ir.field_annot))
  (annot : list string)
  : Lwt.t
    (Error_monad.tzresult
      (option Script_typed_ir.var_annot * option Script_typed_ir.type_annot *
        option Script_typed_ir.field_annot * option Script_typed_ir.field_annot)) :=
  Lwt.__return
    (Script_ir_annot.parse_constr_annot loc if_special_first if_special_second
      annot).

Definition parse_two_var_annot (loc : int) (annot : list string)
  : Lwt.t
    (Error_monad.tzresult
      (option Script_typed_ir.var_annot * option Script_typed_ir.var_annot)) :=
  Lwt.__return (Script_ir_annot.parse_two_var_annot loc annot).

Definition parse_destr_annot
  (loc : int) (annot : list string)
  (default_accessor : option Script_typed_ir.field_annot)
  (field_name : option Script_typed_ir.field_annot)
  (pair_annot : option Script_typed_ir.var_annot)
  (value_annot : option Script_typed_ir.var_annot)
  : Lwt.t
    (Error_monad.tzresult
      (option Script_typed_ir.var_annot * option Script_typed_ir.field_annot)) :=
  Lwt.__return
    (Script_ir_annot.parse_destr_annot loc annot default_accessor field_name
      pair_annot value_annot).

Definition parse_var_type_annot (loc : int) (annot : list string)
  : Lwt.t
    (Error_monad.tzresult
      (option Script_typed_ir.var_annot * option Script_typed_ir.type_annot)) :=
  Lwt.__return (Script_ir_annot.parse_var_type_annot loc annot).

Definition find_entrypoint
  (full : Script_typed_ir.ty)
  (root_name : option (|Compare.String|).(Compare.S.t))
  (entrypoint : (|Compare.String|).(Compare.S.t))
  : Error_monad.tzresult
    ((Alpha_context.Script.node -&gt; Alpha_context.Script.node) * ex_ty) :=
  let fix find_entrypoint (__t_value : Script_typed_ir.ty) (entrypoint : string)
    {struct __t_value}
    : (Alpha_context.Script.node -&gt; Alpha_context.Script.node) * ex_ty :=
    match __t_value with
    | Script_typed_ir.Union_t (tl, al) (tr, ar) _ _ =&gt;
      if
        match al with
        | None =&gt; false
        | Some (Script_typed_ir.Field_annot l) =&gt;
          (|Compare.String|).(Compare.S.op_eq) l entrypoint
        end then
        ((fun e =&gt; Micheline.Prim 0 Alpha_context.Script.D_Left [ e ] nil),
          (Ex_ty tl))
      else
        if
          match ar with
          | None =&gt; false
          | Some (Script_typed_ir.Field_annot __r_value) =&gt;
            (|Compare.String|).(Compare.S.op_eq) __r_value entrypoint
          end then
          ((fun e =&gt; Micheline.Prim 0 Alpha_context.Script.D_Right [ e ] nil),
            (Ex_ty tr))
        else
          (* ‚ùå Try-with are not handled *)
          try
            (let '(f, __t_value) := find_entrypoint tl entrypoint in
            ((fun e =&gt; Micheline.Prim 0 Alpha_context.Script.D_Left [ f e ] nil),
              __t_value))
    | _ =&gt; Pervasives.raise extensible_type_value
    end in
  let entrypoint :=
    if (|Compare.String|).(Compare.S.op_eq) entrypoint &quot;&quot; then
      &quot;default&quot;
    else
      entrypoint in
  if (|Compare.Int|).(Compare.S.op_gt) (String.length entrypoint) 31 then
    Error_monad.__error_value extensible_type_value
  else
    match
      (root_name,
        match root_name with
        | Some root_name =&gt;
          (|Compare.String|).(Compare.S.op_eq) entrypoint root_name
        | _ =&gt; false
        end) with
    | (Some root_name, true) =&gt; Error_monad.ok ((fun e =&gt; e), (Ex_ty full))
    | (_, _) =&gt;
      (* ‚ùå Try-with are not handled *)
      try (Error_monad.ok (find_entrypoint full entrypoint))
    end.

Definition find_entrypoint_for_type
  (full : Script_typed_ir.ty) (expected : Script_typed_ir.ty)
  (root_name : option (|Compare.String|).(Compare.S.t))
  (entrypoint : (|Compare.String|).(Compare.S.t)) (ctxt : Alpha_context.context)
  : Error_monad.tzresult (Alpha_context.context * string * Script_typed_ir.ty) :=
  match (entrypoint, root_name) with
  | (&quot;default&quot;, Some &quot;root&quot;) =&gt;
    match find_entrypoint full root_name entrypoint with
    | Pervasives.Error __error_value =&gt; Pervasives.Error __error_value
    | Pervasives.Ok (_, Ex_ty ty) =&gt;
      match ty_eq ctxt expected ty with
      | Pervasives.Ok (Eq, ctxt) =&gt; Error_monad.ok (ctxt, &quot;default&quot;, ty)
      | Pervasives.Error _ =&gt;
        let? '(Eq, ctxt) := ty_eq ctxt expected full in
        Error_monad.ok (ctxt, &quot;root&quot;, full)
      end
    end
  | _ =&gt;
    let? '(_, Ex_ty ty) := find_entrypoint full root_name entrypoint in
    let? '(Eq, ctxt) := ty_eq ctxt expected ty in
    Error_monad.ok (ctxt, entrypoint, ty)
  end.

Definition Entrypoints :=
  __Set.Make
    (existT (A := Set) _ _
      {|
        Compare.COMPARABLE.compare := String.compare
      |}).

(* ‚ùå The definition of exceptions is not handled. *)
(* exception Duplicate *)

(* ‚ùå The definition of exceptions is not handled. *)
(* exception Too_long *)

Definition well_formed_entrypoints
  (full : Script_typed_ir.ty) (root_name : option (|Entrypoints|).(S.SET.elt))
  : Error_monad.tzresult unit :=
  let merge {A : Set}
    (path : list A) (annot : option Script_typed_ir.field_annot)
    (ty : Script_typed_ir.ty) (reachable : bool)
    (function_parameter : option (list A) * (|Entrypoints|).(S.SET.t))
    : option (list A) * (|Entrypoints|).(S.SET.t) :=
    let '(first_unreachable, all) as acc := function_parameter in
    match annot with
    | (None | Some (Script_typed_ir.Field_annot &quot;&quot;)) =&gt;
      if reachable then
        acc
      else
        match ty with
        | Script_typed_ir.Union_t _ _ _ _ =&gt; acc
        | _ =&gt;
          match first_unreachable with
          | None =&gt; ((Some (List.rev path)), all)
          | Some _ =&gt; acc
          end
        end
    | Some (Script_typed_ir.Field_annot name) =&gt;
      if (|Compare.Int|).(Compare.S.op_gt) (String.length name) 31 then
        Pervasives.raise extensible_type_value
      else
        if (|Entrypoints|).(S.SET.mem) name all then
          Pervasives.raise extensible_type_value
        else
          (first_unreachable, ((|Entrypoints|).(S.SET.add) name all))
    end in
  let fix check
    (__t_value : Script_typed_ir.ty) (path : list Alpha_context.Script.prim)
    (reachable : bool)
    (acc : option (list Alpha_context.Script.prim) * (|Entrypoints|).(S.SET.t))
    {struct __t_value}
    : option (list Alpha_context.Script.prim) * (|Entrypoints|).(S.SET.t) :=
    match __t_value with
    | Script_typed_ir.Union_t (tl, al) (tr, ar) _ _ =&gt;
      let acc :=
        merge (cons Alpha_context.Script.D_Left path) al tl reachable acc in
      let acc :=
        merge (cons Alpha_context.Script.D_Right path) ar tr reachable acc in
      let acc :=
        check tl (cons Alpha_context.Script.D_Left path)
          match al with
          | Some _ =&gt; true
          | None =&gt; reachable
          end acc in
      check tr (cons Alpha_context.Script.D_Right path)
        match ar with
        | Some _ =&gt; true
        | None =&gt; reachable
        end acc
    | _ =&gt; acc
    end in
  (* ‚ùå Try-with are not handled *)
  try
    (let '(init, reachable) :=
      match root_name with
      | (None | Some &quot;&quot;) =&gt; ((|Entrypoints|).(S.SET.empty), false)
      | Some name =&gt; (((|Entrypoints|).(S.SET.singleton) name), true)
      end in
    let '(first_unreachable, all) := check full nil reachable (None, init) in
    if Pervasives.not ((|Entrypoints|).(S.SET.mem) &quot;default&quot; all) then
      Error_monad.ok tt
    else
      match first_unreachable with
      | None =&gt; Error_monad.ok tt
      | Some path =&gt; Error_monad.__error_value extensible_type_value
      end).

Definition parse_int32
  (n : Micheline.node Alpha_context.Script.location Alpha_context.Script.prim)
  : Error_monad.tzresult int :=
  let error' (function_parameter : unit) : Error_monad.__error :=
    let '_ := function_parameter in
    extensible_type_value in
  match n with
  | Micheline.Int _ n' =&gt;
    (* ‚ùå Try-with are not handled *)
    try
      (let n'' := Z.to_int n' in
      if
        Pervasives.op_andand ((|Compare.Int|).(Compare.S.op_lteq) 0 n'')
          ((|Compare.Int|).(Compare.S.op_lteq) n'' (Int32.to_int Int32.max_int))
        then
        Error_monad.ok n''
      else
        Error_monad.__error_value (error' tt))
  | _ =&gt; Error_monad.__error_value (error' tt)
  end.

Definition parse_toplevel (legacy : bool) (toplevel : Alpha_context.Script.expr)
  : Error_monad.tzresult
    (Alpha_context.Script.node * Alpha_context.Script.node *
      Alpha_context.Script.node * option string) :=
  (Error_monad.record_trace extensible_type_value)
    match Micheline.root toplevel with
    | Micheline.Int loc _ =&gt; Error_monad.__error_value extensible_type_value
    | Micheline.String loc _ =&gt; Error_monad.__error_value extensible_type_value
    | Micheline.Bytes loc _ =&gt; Error_monad.__error_value extensible_type_value
    | Micheline.Prim loc _ _ _ =&gt;
      Error_monad.__error_value extensible_type_value
    | Micheline.Seq _ fields =&gt;
      let fix find_fields
        (__p_value :
          option
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim * Alpha_context.Script.location *
              Micheline.annot))
        (s :
          option
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim * Alpha_context.Script.location *
              Micheline.annot))
        (c :
          option
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim * Alpha_context.Script.location *
              Micheline.annot))
        (fields :
          list
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim)) {struct __p_value}
        : Error_monad.tzresult
          (option
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim * Alpha_context.Script.location *
              Micheline.annot) *
            option
              (Micheline.node Alpha_context.Script.location
                Alpha_context.Script.prim * Alpha_context.Script.location *
                Micheline.annot) *
            option
              (Micheline.node Alpha_context.Script.location
                Alpha_context.Script.prim * Alpha_context.Script.location *
                Micheline.annot)) :=
        match fields with
        | [] =&gt; Error_monad.ok (__p_value, s, c)
        | cons (Micheline.Int loc _) _ =&gt;
          Error_monad.__error_value extensible_type_value
        | cons (Micheline.String loc _) _ =&gt;
          Error_monad.__error_value extensible_type_value
        | cons (Micheline.Bytes loc _) _ =&gt;
          Error_monad.__error_value extensible_type_value
        | cons (Micheline.Seq loc _) _ =&gt;
          Error_monad.__error_value extensible_type_value
        |
          cons
            (Micheline.Prim loc Alpha_context.Script.K_parameter (cons arg [])
              annot) rest =&gt;
          match __p_value with
          | None =&gt; find_fields (Some (arg, loc, annot)) s c rest
          | Some _ =&gt; Error_monad.__error_value extensible_type_value
          end
        |
          cons
            (Micheline.Prim loc Alpha_context.Script.K_storage (cons arg [])
              annot) rest =&gt;
          match s with
          | None =&gt; find_fields __p_value (Some (arg, loc, annot)) c rest
          | Some _ =&gt; Error_monad.__error_value extensible_type_value
          end
        |
          cons
            (Micheline.Prim loc Alpha_context.Script.K_code (cons arg []) annot)
            rest =&gt;
          match c with
          | None =&gt; find_fields __p_value s (Some (arg, loc, annot)) rest
          | Some _ =&gt; Error_monad.__error_value extensible_type_value
          end
        |
          cons
            (Micheline.Prim loc
              ((Alpha_context.Script.K_parameter |
              Alpha_context.Script.K_storage | Alpha_context.Script.K_code) as
                name) args _) _ =&gt;
          Error_monad.__error_value extensible_type_value
        | cons (Micheline.Prim loc name _ _) _ =&gt;
          let allowed :=
            [
              Alpha_context.Script.K_parameter;
              Alpha_context.Script.K_storage;
              Alpha_context.Script.K_code
            ] in
          Error_monad.__error_value extensible_type_value
        end in
      let? function_parameter := find_fields None None None fields in
      match function_parameter with
      | (None, _, _) =&gt; Error_monad.__error_value extensible_type_value
      | (Some _, None, _) =&gt; Error_monad.__error_value extensible_type_value
      | (Some _, Some _, None) =&gt;
        Error_monad.__error_value extensible_type_value
      |
        (Some (__p_value, ploc, pannot), Some (s, sloc, sannot),
          Some (c, cloc, carrot)) =&gt;
        let maybe_root_name :=
          let? '(__p_value, root_name) :=
            Script_ir_annot.extract_field_annot __p_value in
          match root_name with
          | Some (Script_typed_ir.Field_annot root_name) =&gt;
            Error_monad.ok (__p_value, pannot, (Some root_name))
          | None =&gt;
            match
              (pannot,
                match pannot with
                | cons single [] =&gt;
                  Pervasives.op_andand
                    ((|Compare.Int|).(Compare.S.op_gt) (String.length single) 0)
                    ((|Compare.Char|).(Compare.S.op_eq) (String.get single 0)
                      &quot;%&quot; % char)
                | _ =&gt; false
                end) with
            | (cons single [], true) =&gt;
              Error_monad.ok
                (__p_value, nil,
                  (Some
                    (String.sub single 1
                      (Pervasives.op_minus (String.length single) 1))))
            | (_, _) =&gt; Error_monad.ok (__p_value, pannot, None)
            end
          end in
        if legacy then
          let '(__p_value, root_name) :=
            match maybe_root_name with
            | Pervasives.Ok (__p_value, _, root_name) =&gt; (__p_value, root_name)
            | Pervasives.Error _ =&gt; (__p_value, None)
            end in
          Error_monad.ok (__p_value, s, c, root_name)
        else
          let? '(__p_value, pannot, root_name) := maybe_root_name in
          let? '_ := Script_ir_annot.error_unexpected_annot ploc pannot in
          let? '_ := Script_ir_annot.error_unexpected_annot cloc carrot in
          let? '_ := Script_ir_annot.error_unexpected_annot sloc sannot in
          Error_monad.ok (__p_value, s, c, root_name)
      end
    end.

Definition parse_contract
  (legacy : bool) (ctxt : Alpha_context.context)
  (loc : Alpha_context.Script.location) (arg : Script_typed_ir.ty)
  (contract : Alpha_context.Contract.t) (entrypoint : string)
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context * Script_typed_ir.typed_contract)) :=
  let=? ctxt :=
    Lwt.__return
      (Alpha_context.Gas.consume ctxt Typecheck_costs.contract_exists) in
  let=? function_parameter := Alpha_context.Contract.__exists ctxt contract in
  match function_parameter with
  | false =&gt; Error_monad.fail extensible_type_value
  | true =&gt;
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.get_script)
      in
    let=? '(ctxt, code) :=
      (Error_monad.trace extensible_type_value)
        (Alpha_context.Contract.get_script_code ctxt contract) in
    match code with
    | None =&gt;
      Lwt.__return
        (let? '(Eq, ctxt) := ty_eq ctxt arg (Script_typed_ir.Unit_t None) in
        match entrypoint with
        | &quot;default&quot; =&gt;
          let contract := (arg, (contract, entrypoint)) in
          Error_monad.ok (ctxt, contract)
        | entrypoint =&gt; Error_monad.__error_value extensible_type_value
        end)
    | Some code =&gt;
      let=? '(code, ctxt) :=
        Alpha_context.Script.force_decode_in_context ctxt code in
      Lwt.__return
        (let? '(arg_type, _, _, root_name) := parse_toplevel true code in
        let? '(Ex_ty targ, ctxt) := parse_parameter_ty ctxt true arg_type in
        let __return
          (ctxt : Alpha_context.context) (targ : Script_typed_ir.ty)
          (entrypoint : string)
          : Error_monad.tzresult
            (Alpha_context.context * Script_typed_ir.typed_contract) :=
          let? '(arg, ctxt) := merge_types legacy ctxt loc targ arg in
          let contract := (arg, (contract, entrypoint)) in
          Error_monad.ok (ctxt, contract) in
        let? '(ctxt, entrypoint, targ) :=
          find_entrypoint_for_type targ arg root_name entrypoint ctxt in
        let? '(targ, ctxt) := merge_types legacy ctxt loc targ arg in
        __return ctxt targ entrypoint)
    end
  end.

Fixpoint parse_data {a : Set}
  (__type_logger_value : option type_logger) (ctxt : Alpha_context.context)
  (legacy : bool) (ty : Script_typed_ir.ty)
  (script_data : Alpha_context.Script.node) {struct ty}
  : Lwt.t (Error_monad.tzresult (a * Alpha_context.context)) :=
  let=? ctxt :=
    Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle) in
  let __error_value (function_parameter : unit)
    : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
    let '_ := function_parameter in
    Error_monad.op_gtgtpipequestion
      (Lwt.__return (serialize_ty_for_error ctxt ty))
      (fun function_parameter =&gt;
        let '(ty, _ctxt) := function_parameter in
        extensible_type_value) in
  let traced {B : Set} (body : Lwt.t (Error_monad.tzresult B))
    : Lwt.t (Error_monad.tzresult B) :=
    Error_monad.trace_eval __error_value body in
  let parse_items {B C D E : Set}
    (__type_logger_value : option type_logger)
    (loc : Alpha_context.Script.location) (ctxt : Alpha_context.context)
    (expr : Micheline.node B Alpha_context.Script.prim)
    (key_type : Script_typed_ir.comparable_ty) (value_type : Script_typed_ir.ty)
    (items :
      list
        (Micheline.node Alpha_context.Script.location Alpha_context.Script.prim))
    (item_wrapper : C -&gt; D)
    : Lwt.t
      (Error_monad.tzresult (Script_typed_ir.map E D * Alpha_context.context)) :=
    let length := List.length items in
    Error_monad.op_gtgtpipequestion
      (traced
        (Error_monad.fold_left_s
          (fun function_parameter =&gt;
            let '(last_value, map, ctxt) := function_parameter in
            fun item =&gt;
              let=? ctxt :=
                Lwt.__return
                  (Alpha_context.Gas.consume ctxt
                    (Typecheck_costs.map_element length)) in
              match item with
              |
                Micheline.Prim _ Alpha_context.Script.D_Elt (cons k (cons v []))
                  _ =&gt;
                let=? '(k, ctxt) :=
                  parse_comparable_data __type_logger_value ctxt key_type k in
                let=? '(v, ctxt) :=
                  parse_data __type_logger_value ctxt legacy value_type v in
                let=? '_ :=
                  match last_value with
                  | Some value =&gt;
                    if
                      (|Compare.Int|).(Compare.S.op_lteq) 0
                        (compare_comparable key_type value k) then
                      if
                        (|Compare.Int|).(Compare.S.op_eq) 0
                          (compare_comparable key_type value k) then
                        Error_monad.fail extensible_type_value
                      else
                        Error_monad.fail extensible_type_value
                    else
                      Error_monad.return_unit
                  | None =&gt; Error_monad.return_unit
                  end in
                Error_monad.__return
                  ((Some k), (map_update k (Some (item_wrapper v)) map), ctxt)
              | Micheline.Prim loc Alpha_context.Script.D_Elt l _ =&gt;
                Error_monad.fail extensible_type_value
              | Micheline.Prim loc name _ _ =&gt;
                Error_monad.fail extensible_type_value
              |
                (Micheline.Int _ _ | Micheline.String _ _ | Micheline.Bytes _ _
                | Micheline.Seq _ _) =&gt;
                Error_monad.op_gtgteqquestion (__error_value tt)
                  Error_monad.fail
              end) (None, (empty_map key_type), ctxt) items))
      (fun function_parameter =&gt;
        let '(_, items, ctxt) := function_parameter in
        (items, ctxt)) in
  match (ty, script_data) with
  |
    (Script_typed_ir.Unit_t _,
      Micheline.Prim loc Alpha_context.Script.D_Unit [] annot) =&gt;
    let '[loc, annot] :=
      cast [Alpha_context.Script.location ** Micheline.annot] [loc, annot] in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? '_ :=
      if legacy then
        Error_monad.__return tt
      else
        Script_ir_annot.fail_unexpected_annot loc annot in
    Error_monad.op_gtgtpipequestion
      (Lwt.__return
        (Alpha_context.Gas.consume ctxt Typecheck_costs.__unit_value))
      (fun ctxt =&gt; (tt, ctxt)))
  
  |
    (Script_typed_ir.Unit_t _,
      Micheline.Prim loc Alpha_context.Script.D_Unit l _) =&gt;
    let '[loc, l] :=
      cast
        [Alpha_context.Script.location **
          list
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim)] [loc, l] in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((traced (B := unit)) (Error_monad.fail extensible_type_value))
  
  | (Script_typed_ir.Unit_t _, expr) =&gt;
    let expr := cast Alpha_context.Script.node expr in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((traced (B := unit))
      (Error_monad.fail
        (unexpected expr nil Script_tc_errors.Constant_namespace
          [ Alpha_context.Script.D_Unit ])))
  
  |
    (Script_typed_ir.Bool_t _,
      Micheline.Prim loc Alpha_context.Script.D_True [] annot) =&gt;
    let '[loc, annot] :=
      cast [Alpha_context.Script.location ** Micheline.annot] [loc, annot] in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? '_ :=
      if legacy then
        Error_monad.__return tt
      else
        Script_ir_annot.fail_unexpected_annot loc annot in
    Error_monad.op_gtgtpipequestion
      (Lwt.__return
        (Alpha_context.Gas.consume ctxt Typecheck_costs.__bool_value))
      (fun ctxt =&gt; (true, ctxt)))
  
  |
    (Script_typed_ir.Bool_t _,
      Micheline.Prim loc Alpha_context.Script.D_False [] annot) =&gt;
    let '[loc, annot] :=
      cast [Alpha_context.Script.location ** Micheline.annot] [loc, annot] in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? '_ :=
      if legacy then
        Error_monad.__return tt
      else
        Script_ir_annot.fail_unexpected_annot loc annot in
    Error_monad.op_gtgtpipequestion
      (Lwt.__return
        (Alpha_context.Gas.consume ctxt Typecheck_costs.__bool_value))
      (fun ctxt =&gt; (false, ctxt)))
  
  |
    (Script_typed_ir.Bool_t _,
      Micheline.Prim loc
        ((Alpha_context.Script.D_True | Alpha_context.Script.D_False) as c) l _)
    =&gt;
    let '[loc, c, l] :=
      cast
        [Alpha_context.Script.location ** Alpha_context.Script.prim **
          list
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim)] [loc, c, l] in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((traced (B := unit)) (Error_monad.fail extensible_type_value))
  
  | (Script_typed_ir.Bool_t _, expr) =&gt;
    let expr := cast Alpha_context.Script.node expr in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((traced (B := unit))
      (Error_monad.fail
        (unexpected expr nil Script_tc_errors.Constant_namespace
          [ Alpha_context.Script.D_True; Alpha_context.Script.D_False ])))
  
  | (Script_typed_ir.String_t _, Micheline.String _ v) =&gt;
    let v := cast string v in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt
          (Typecheck_costs.__string_value (String.length v))) in
    let fix check_printable_ascii (i : (|Compare.Int|).(Compare.S.t)) {struct i}
      : bool :=
      if (|Compare.Int|).(Compare.S.op_lt) i 0 then
        true
      else
        match String.get v i with
        |
          (&quot;010&quot; % char | &quot; &quot; % char | &quot;!&quot; % char | &quot;&quot;&quot;&quot; % char | &quot;#&quot; % char |
          &quot;$&quot; % char | &quot;%&quot; % char | &quot;&amp;&quot; % char | &quot;'&quot; % char | &quot;(&quot; % char |
          &quot;)&quot; % char | &quot;*&quot; % char | &quot;+&quot; % char | &quot;,&quot; % char | &quot;-&quot; % char |
          &quot;.&quot; % char | &quot;/&quot; % char | &quot;0&quot; % char | &quot;1&quot; % char | &quot;2&quot; % char |
          &quot;3&quot; % char | &quot;4&quot; % char | &quot;5&quot; % char | &quot;6&quot; % char | &quot;7&quot; % char |
          &quot;8&quot; % char | &quot;9&quot; % char | &quot;:&quot; % char | &quot;;&quot; % char | &quot;&lt;&quot; % char |
          &quot;=&quot; % char | &quot;&gt;&quot; % char | &quot;?&quot; % char | &quot;@&quot; % char | &quot;A&quot; % char |
          &quot;B&quot; % char | &quot;C&quot; % char | &quot;D&quot; % char | &quot;E&quot; % char | &quot;F&quot; % char |
          &quot;G&quot; % char | &quot;H&quot; % char | &quot;I&quot; % char | &quot;J&quot; % char | &quot;K&quot; % char |
          &quot;L&quot; % char | &quot;M&quot; % char | &quot;N&quot; % char | &quot;O&quot; % char | &quot;P&quot; % char |
          &quot;Q&quot; % char | &quot;R&quot; % char | &quot;S&quot; % char | &quot;T&quot; % char | &quot;U&quot; % char |
          &quot;V&quot; % char | &quot;W&quot; % char | &quot;X&quot; % char | &quot;Y&quot; % char | &quot;Z&quot; % char |
          &quot;[&quot; % char | &quot;\&quot; % char | &quot;]&quot; % char | &quot;^&quot; % char | &quot;_&quot; % char |
          &quot;`&quot; % char | &quot;a&quot; % char | &quot;b&quot; % char | &quot;c&quot; % char | &quot;d&quot; % char |
          &quot;e&quot; % char | &quot;f&quot; % char | &quot;g&quot; % char | &quot;h&quot; % char | &quot;i&quot; % char |
          &quot;j&quot; % char | &quot;k&quot; % char | &quot;l&quot; % char | &quot;m&quot; % char | &quot;n&quot; % char |
          &quot;o&quot; % char | &quot;p&quot; % char | &quot;q&quot; % char | &quot;r&quot; % char | &quot;s&quot; % char |
          &quot;t&quot; % char | &quot;u&quot; % char | &quot;v&quot; % char | &quot;w&quot; % char | &quot;x&quot; % char |
          &quot;y&quot; % char | &quot;z&quot; % char | &quot;{&quot; % char | &quot;|&quot; % char | &quot;}&quot; % char |
          &quot;~&quot; % char) =&gt; check_printable_ascii (Pervasives.op_minus i 1)
        | _ =&gt; false
        end in
    if check_printable_ascii (Pervasives.op_minus (String.length v) 1) then
      Error_monad.__return (v, ctxt)
    else
      Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail)
  
  | (Script_typed_ir.String_t _, expr) =&gt;
    let expr := cast Alpha_context.Script.node expr in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((traced (B := unit)) (Error_monad.fail extensible_type_value))
  
  | (Script_typed_ir.Bytes_t _, Micheline.Bytes _ v) =&gt;
    let v := cast MBytes.t v in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt
          (Typecheck_costs.__string_value (MBytes.length v))) in
    Error_monad.__return (v, ctxt))
  
  | (Script_typed_ir.Bytes_t _, expr) =&gt;
    let expr := cast Alpha_context.Script.node expr in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((traced (B := unit)) (Error_monad.fail extensible_type_value))
  
  | (Script_typed_ir.Int_t _, Micheline.Int _ v) =&gt;
    let v := cast Z.t v in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt (Typecheck_costs.z v)) in
    Error_monad.__return ((Alpha_context.Script_int.of_zint v), ctxt))
  
  | (Script_typed_ir.Nat_t _, Micheline.Int _ v) =&gt;
    let v := cast Z.t v in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt (Typecheck_costs.z v)) in
    let v := Alpha_context.Script_int.of_zint v in
    if
      (|Compare.Int|).(Compare.S.op_gteq)
        (Alpha_context.Script_int.compare v Alpha_context.Script_int.zero) 0
      then
      Error_monad.__return ((Alpha_context.Script_int.abs v), ctxt)
    else
      Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail)
  
  | (Script_typed_ir.Int_t _, expr) =&gt;
    let expr := cast Alpha_context.Script.node expr in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((traced (B := unit)) (Error_monad.fail extensible_type_value))
  
  | (Script_typed_ir.Nat_t _, expr) =&gt;
    let expr := cast Alpha_context.Script.node expr in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((traced (B := unit)) (Error_monad.fail extensible_type_value))
  
  | (Script_typed_ir.Mutez_t _, Micheline.Int _ v) =&gt;
    let v := cast Z.t v in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? ctxt :=
      Lwt.__return
        (let? ctxt := Alpha_context.Gas.consume ctxt Typecheck_costs.tez in
        Alpha_context.Gas.consume ctxt
          Michelson_v1_gas.Cost_of.Legacy.z_to_int64) in
    (* ‚ùå Try-with are not handled *)
    try
      match Alpha_context.Tez.of_mutez (Z.to_int64 v) with
      | None =&gt; Pervasives.raise extensible_type_value
      | Some tez =&gt; Error_monad.__return (tez, ctxt)
      end)
  
  | (Script_typed_ir.Mutez_t _, expr) =&gt;
    let expr := cast Alpha_context.Script.node expr in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((traced (B := unit)) (Error_monad.fail extensible_type_value))
  
  | (Script_typed_ir.Timestamp_t _, Micheline.Int _ v) =&gt;
    let v := cast Z.t v in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt (Typecheck_costs.z v)) in
    Error_monad.__return ((Alpha_context.Script_timestamp.of_zint v), ctxt))
  
  | (Script_typed_ir.Timestamp_t _, Micheline.String _ s) =&gt;
    let s := cast string s in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt Typecheck_costs.string_timestamp) in
    match Alpha_context.Script_timestamp.of_string s with
    | Some v =&gt; Error_monad.__return (v, ctxt)
    | None =&gt; Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
    end)
  
  | (Script_typed_ir.Timestamp_t _, expr) =&gt;
    let expr := cast Alpha_context.Script.node expr in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((traced (B := unit)) (Error_monad.fail extensible_type_value))
  
  | (Script_typed_ir.Key_t _, Micheline.Bytes _ __bytes_value) =&gt;
    let __bytes_value := cast MBytes.t __bytes_value in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.__key_value)
      in
    match
      Data_encoding.Binary.of_bytes
        (|Signature.Public_key|).(S.SPublic_key.encoding) __bytes_value with
    | Some k =&gt; Error_monad.__return (k, ctxt)
    | None =&gt; Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
    end)
  
  | (Script_typed_ir.Key_t _, Micheline.String _ s) =&gt;
    let s := cast string s in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.__key_value)
      in
    match (|Signature.Public_key|).(S.SPublic_key.of_b58check_opt) s with
    | Some k =&gt; Error_monad.__return (k, ctxt)
    | None =&gt; Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
    end)
  
  | (Script_typed_ir.Key_t _, expr) =&gt;
    let expr := cast Alpha_context.Script.node expr in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((traced (B := unit)) (Error_monad.fail extensible_type_value))
  
  | (Script_typed_ir.Key_hash_t _, Micheline.Bytes _ __bytes_value) =&gt;
    let __bytes_value := cast MBytes.t __bytes_value in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.key_hash) in
    match
      Data_encoding.Binary.of_bytes
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding)
        __bytes_value with
    | Some k =&gt; Error_monad.__return (k, ctxt)
    | None =&gt; Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
    end)
  
  | (Script_typed_ir.Key_hash_t _, Micheline.String _ s) =&gt;
    let s := cast string s in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.key_hash) in
    match (|Signature.Public_key_hash|).(S.SPublic_key_hash.of_b58check_opt) s
      with
    | Some k =&gt; Error_monad.__return (k, ctxt)
    | None =&gt; Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
    end)
  
  | (Script_typed_ir.Key_hash_t _, expr) =&gt;
    let expr := cast Alpha_context.Script.node expr in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((traced (B := unit)) (Error_monad.fail extensible_type_value))
  
  | (Script_typed_ir.Signature_t _, Micheline.Bytes _ __bytes_value) =&gt;
    let __bytes_value := cast MBytes.t __bytes_value in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.signature) in
    match Data_encoding.Binary.of_bytes Signature.encoding __bytes_value with
    | Some k =&gt; Error_monad.__return (k, ctxt)
    | None =&gt; Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
    end)
  
  | (Script_typed_ir.Signature_t _, Micheline.String _ s) =&gt;
    let s := cast string s in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.signature) in
    match Signature.of_b58check_opt s with
    | Some s =&gt; Error_monad.__return (s, ctxt)
    | None =&gt; Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
    end)
  
  | (Script_typed_ir.Signature_t _, expr) =&gt;
    let expr := cast Alpha_context.Script.node expr in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((traced (B := unit)) (Error_monad.fail extensible_type_value))
  
  | (Script_typed_ir.Operation_t _, _) =&gt;
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (* ‚ùå Assert instruction is not handled. *)
    (assert (Lwt.t (Error_monad.tzresult (a * Alpha_context.context))) false)
  
  | (Script_typed_ir.Chain_id_t _, Micheline.Bytes _ __bytes_value) =&gt;
    let __bytes_value := cast MBytes.t __bytes_value in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.chain_id) in
    match
      Data_encoding.Binary.of_bytes (|Chain_id|).(S.HASH.encoding) __bytes_value
      with
    | Some k =&gt; Error_monad.__return (k, ctxt)
    | None =&gt; Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
    end)
  
  | (Script_typed_ir.Chain_id_t _, Micheline.String _ s) =&gt;
    let s := cast string s in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.chain_id) in
    match (|Chain_id|).(S.HASH.of_b58check_opt) s with
    | Some s =&gt; Error_monad.__return (s, ctxt)
    | None =&gt; Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
    end)
  
  | (Script_typed_ir.Chain_id_t _, expr) =&gt;
    let expr := cast Alpha_context.Script.node expr in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((traced (B := unit)) (Error_monad.fail extensible_type_value))
  
  | (Script_typed_ir.Address_t _, Micheline.Bytes loc __bytes_value) =&gt;
    let '[loc, __bytes_value] :=
      cast [Alpha_context.Script.location ** MBytes.t] [loc, __bytes_value] in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.contract) in
    match
      Data_encoding.Binary.of_bytes
        (Data_encoding.tup2 Alpha_context.Contract.encoding
          Data_encoding.__Variable.__string_value) __bytes_value with
    | Some (c, entrypoint) =&gt;
      if (|Compare.Int|).(Compare.S.op_gt) (String.length entrypoint) 31 then
        Error_monad.fail extensible_type_value
      else
        let=? entrypoint :=
          match entrypoint with
          | &quot;&quot; =&gt; Error_monad.__return &quot;default&quot;
          | &quot;default&quot; =&gt; Error_monad.fail extensible_type_value
          | name =&gt; Error_monad.__return name
          end in
        Error_monad.__return ((c, entrypoint), ctxt)
    | None =&gt; Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
    end)
  
  | (Script_typed_ir.Address_t _, Micheline.String loc s) =&gt;
    let '[loc, s] := cast [Alpha_context.Script.location ** string] [loc, s] in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.contract) in
    let=? '(addr, entrypoint) :=
      match String.index_opt s &quot;%&quot; % char with
      | None =&gt; Error_monad.__return (s, &quot;default&quot;)
      | Some pos =&gt;
        let len :=
          Pervasives.op_minus (Pervasives.op_minus (String.length s) pos) 1 in
        let name := String.sub s (Pervasives.op_plus pos 1) len in
        if (|Compare.Int|).(Compare.S.op_gt) len 31 then
          Error_monad.fail extensible_type_value
        else
          match ((String.sub s 0 pos), name) with
          | (_, &quot;default&quot;) =&gt; traced (Error_monad.fail extensible_type_value)
          | addr_and_name =&gt; Error_monad.__return addr_and_name
          end
      end in
    let=? c := Lwt.__return (Alpha_context.Contract.of_b58check addr) in
    Error_monad.__return ((c, entrypoint), ctxt))
  
  | (Script_typed_ir.Address_t _, expr) =&gt;
    let expr := cast Alpha_context.Script.node expr in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((traced (B := unit)) (Error_monad.fail extensible_type_value))
  
  | (Script_typed_ir.Contract_t ty _, Micheline.Bytes loc __bytes_value) =&gt;
    let '[ty, loc, __bytes_value] :=
      cast [Script_typed_ir.ty ** Alpha_context.Script.location ** MBytes.t]
        [ty, loc, __bytes_value] in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.contract) in
    match
      Data_encoding.Binary.of_bytes
        (Data_encoding.tup2 Alpha_context.Contract.encoding
          Data_encoding.__Variable.__string_value) __bytes_value with
    | Some (c, entrypoint) =&gt;
      if (|Compare.Int|).(Compare.S.op_gt) (String.length entrypoint) 31 then
        Error_monad.fail extensible_type_value
      else
        let=? entrypoint :=
          match entrypoint with
          | &quot;&quot; =&gt; Error_monad.__return &quot;default&quot;
          | &quot;default&quot; =&gt; traced (Error_monad.fail extensible_type_value)
          | name =&gt; Error_monad.__return name
          end in
        let=? '(ctxt, _) :=
          traced (parse_contract legacy ctxt loc ty c entrypoint) in
        Error_monad.__return ((ty, (c, entrypoint)), ctxt)
    | None =&gt; Error_monad.op_gtgteqquestion (__error_value tt) Error_monad.fail
    end)
  
  | (Script_typed_ir.Contract_t ty _, Micheline.String loc s) =&gt;
    let '[ty, loc, s] :=
      cast [Script_typed_ir.ty ** Alpha_context.Script.location ** string]
        [ty, loc, s] in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.contract) in
    let=? '(addr, entrypoint) :=
      match String.index_opt s &quot;%&quot; % char with
      | None =&gt; Error_monad.__return (s, &quot;default&quot;)
      | Some pos =&gt;
        let len :=
          Pervasives.op_minus (Pervasives.op_minus (String.length s) pos) 1 in
        let name := String.sub s (Pervasives.op_plus pos 1) len in
        if (|Compare.Int|).(Compare.S.op_gt) len 31 then
          Error_monad.fail extensible_type_value
        else
          match ((String.sub s 0 pos), name) with
          | (_, &quot;default&quot;) =&gt; traced (Error_monad.fail extensible_type_value)
          | addr_and_name =&gt; Error_monad.__return addr_and_name
          end
      end in
    let=? c := traced (Lwt.__return (Alpha_context.Contract.of_b58check addr))
      in
    let=? '(ctxt, _) := parse_contract legacy ctxt loc ty c entrypoint in
    Error_monad.__return ((ty, (c, entrypoint)), ctxt))
  
  | (Script_typed_ir.Contract_t _ _, expr) =&gt;
    let expr := cast Alpha_context.Script.node expr in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((traced (B := unit)) (Error_monad.fail extensible_type_value))
  
  |
    (Script_typed_ir.Pair_t (ta, _, _) (tb, _, _) _ _,
      Micheline.Prim loc Alpha_context.Script.D_Pair (cons va (cons vb []))
        annot) =&gt;
    let '[ta, tb, loc, va, vb, annot] :=
      cast
        [Script_typed_ir.ty ** Script_typed_ir.ty **
          Alpha_context.Script.location **
          Micheline.node Alpha_context.Script.location Alpha_context.Script.prim
          **
          Micheline.node Alpha_context.Script.location Alpha_context.Script.prim
          ** Micheline.annot] [ta, tb, loc, va, vb, annot] in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? '_ :=
      if legacy then
        Error_monad.__return tt
      else
        Script_ir_annot.fail_unexpected_annot loc annot in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.pair) in
    let=? '(va, ctxt) :=
      traced ((parse_data (a := unit)) __type_logger_value ctxt legacy ta va) in
    let=? '(vb, ctxt) :=
      (parse_data (a := unit)) __type_logger_value ctxt legacy tb vb in
    Error_monad.__return ((va, vb), ctxt))
  
  |
    (Script_typed_ir.Pair_t _ _ _ _,
      Micheline.Prim loc Alpha_context.Script.D_Pair l _) =&gt;
    let '[loc, l] :=
      cast
        [Alpha_context.Script.location **
          list
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim)] [loc, l] in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((Error_monad.fail (a := unit)) extensible_type_value)
  
  | (Script_typed_ir.Pair_t _ _ _ _, expr) =&gt;
    let expr := cast Alpha_context.Script.node expr in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((traced (B := unit))
      (Error_monad.fail
        (unexpected expr nil Script_tc_errors.Constant_namespace
          [ Alpha_context.Script.D_Pair ])))
  
  |
    (Script_typed_ir.Union_t (tl, _) _ _ _,
      Micheline.Prim loc Alpha_context.Script.D_Left (cons v []) annot) =&gt;
    let '[tl, loc, v, annot] :=
      cast
        [Script_typed_ir.ty ** Alpha_context.Script.location **
          Micheline.node Alpha_context.Script.location Alpha_context.Script.prim
          ** Micheline.annot] [tl, loc, v, annot] in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? '_ :=
      if legacy then
        Error_monad.__return tt
      else
        Script_ir_annot.fail_unexpected_annot loc annot in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.union) in
    let=? '(v, ctxt) :=
      traced ((parse_data (a := unit)) __type_logger_value ctxt legacy tl v) in
    Error_monad.__return ((Script_typed_ir.L (b := unit) v), ctxt))
  
  |
    (Script_typed_ir.Union_t _ _ _ _,
      Micheline.Prim loc Alpha_context.Script.D_Left l _) =&gt;
    let '[loc, l] :=
      cast
        [Alpha_context.Script.location **
          list
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim)] [loc, l] in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((Error_monad.fail (a := unit)) extensible_type_value)
  
  |
    (Script_typed_ir.Union_t _ (tr, _) _ _,
      Micheline.Prim loc Alpha_context.Script.D_Right (cons v []) annot) =&gt;
    let '[tr, loc, v, annot] :=
      cast
        [Script_typed_ir.ty ** Alpha_context.Script.location **
          Micheline.node Alpha_context.Script.location Alpha_context.Script.prim
          ** Micheline.annot] [tr, loc, v, annot] in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? '_ := Script_ir_annot.fail_unexpected_annot loc annot in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.union) in
    let=? '(v, ctxt) :=
      traced ((parse_data (a := unit)) __type_logger_value ctxt legacy tr v) in
    Error_monad.__return ((Script_typed_ir.R (a := unit) v), ctxt))
  
  |
    (Script_typed_ir.Union_t _ _ _ _,
      Micheline.Prim loc Alpha_context.Script.D_Right l _) =&gt;
    let '[loc, l] :=
      cast
        [Alpha_context.Script.location **
          list
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim)] [loc, l] in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((Error_monad.fail (a := unit)) extensible_type_value)
  
  | (Script_typed_ir.Union_t _ _ _ _, expr) =&gt;
    let expr := cast Alpha_context.Script.node expr in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((traced (B := unit))
      (Error_monad.fail
        (unexpected expr nil Script_tc_errors.Constant_namespace
          [ Alpha_context.Script.D_Left; Alpha_context.Script.D_Right ])))
  
  |
    (Script_typed_ir.Lambda_t ta tr _ty_name,
      (Micheline.Seq _loc _) as script_instr) =&gt;
    let '[ta, tr, _ty_name, _loc, script_instr] :=
      cast
        [Script_typed_ir.ty ** Script_typed_ir.ty **
          option Script_typed_ir.type_annot ** Alpha_context.Script.location **
          Micheline.node Alpha_context.Script.location Alpha_context.Script.prim]
        [ta, tr, _ty_name, _loc, script_instr] in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.lambda) in
    traced
      (parse_returning __type_logger_value Lambda ctxt legacy
        (ta, (Some (Script_typed_ir.Var_annot &quot;@arg&quot;))) tr script_instr))
  
  | (Script_typed_ir.Lambda_t _ _ _, expr) =&gt;
    let expr := cast Alpha_context.Script.node expr in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((traced (B := unit)) (Error_monad.fail extensible_type_value))
  
  |
    (Script_typed_ir.Option_t __t_value _ _,
      Micheline.Prim loc Alpha_context.Script.D_Some (cons v []) annot) =&gt;
    let '[__t_value, loc, v, annot] :=
      cast
        [Script_typed_ir.ty ** Alpha_context.Script.location **
          Micheline.node Alpha_context.Script.location Alpha_context.Script.prim
          ** Micheline.annot] [__t_value, loc, v, annot] in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? '_ :=
      if legacy then
        Error_monad.__return tt
      else
        Script_ir_annot.fail_unexpected_annot loc annot in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.some) in
    let=? '(v, ctxt) :=
      traced
        ((parse_data (a := unit)) __type_logger_value ctxt legacy __t_value v)
      in
    Error_monad.__return ((Some v), ctxt))
  
  |
    (Script_typed_ir.Option_t _ _ _,
      Micheline.Prim loc Alpha_context.Script.D_Some l _) =&gt;
    let '[loc, l] :=
      cast
        [Alpha_context.Script.location **
          list
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim)] [loc, l] in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((Error_monad.fail (a := unit)) extensible_type_value)
  
  |
    (Script_typed_ir.Option_t _ _ _,
      Micheline.Prim loc Alpha_context.Script.D_None [] annot) =&gt;
    let '[loc, annot] :=
      cast [Alpha_context.Script.location ** Micheline.annot] [loc, annot] in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? '_ :=
      if legacy then
        Error_monad.__return tt
      else
        Script_ir_annot.fail_unexpected_annot loc annot in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.none) in
    Error_monad.__return ((None (A := unit)), ctxt))
  
  |
    (Script_typed_ir.Option_t _ _ _,
      Micheline.Prim loc Alpha_context.Script.D_None l _) =&gt;
    let '[loc, l] :=
      cast
        [Alpha_context.Script.location **
          list
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim)] [loc, l] in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((Error_monad.fail (a := unit)) extensible_type_value)
  
  | (Script_typed_ir.Option_t _ _ _, expr) =&gt;
    let expr := cast Alpha_context.Script.node expr in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((traced (B := unit))
      (Error_monad.fail
        (unexpected expr nil Script_tc_errors.Constant_namespace
          [ Alpha_context.Script.D_Some; Alpha_context.Script.D_None ])))
  
  | (Script_typed_ir.List_t __t_value _ty_name _, Micheline.Seq _loc items) =&gt;
    let '[__t_value, _ty_name, _loc, items] :=
      cast
        [Script_typed_ir.ty ** option Script_typed_ir.type_annot **
          Alpha_context.Script.location **
          list
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim)] [__t_value, _ty_name, _loc, items] in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (traced
      (Error_monad.fold_right_s
        (fun v =&gt;
          fun function_parameter =&gt;
            let '(rest, ctxt) := function_parameter in
            let=? ctxt :=
              Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.list_element) in
            let=? '(v, ctxt) :=
              (parse_data (a := unit)) __type_logger_value ctxt legacy __t_value
                v in
            Error_monad.__return ((cons v rest), ctxt)) items (nil, ctxt)))
  
  | (Script_typed_ir.List_t _ _ _, expr) =&gt;
    let expr := cast Alpha_context.Script.node expr in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((traced (B := unit)) (Error_monad.fail extensible_type_value))
  
  | (Script_typed_ir.Set_t __t_value _ty_name, (Micheline.Seq loc vs) as expr)
    =&gt;
    let '[__t_value, _ty_name, loc, vs, expr] :=
      cast
        [Script_typed_ir.comparable_ty ** option Script_typed_ir.type_annot **
          Alpha_context.Script.location **
          list
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim) **
          Micheline.node Alpha_context.Script.location Alpha_context.Script.prim]
        [__t_value, _ty_name, loc, vs, expr] in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let length := List.length vs in
    Error_monad.op_gtgtpipequestion
      (traced
        (Error_monad.fold_left_s
          (fun function_parameter =&gt;
            let '(last_value, set, ctxt) := function_parameter in
            fun v =&gt;
              let=? ctxt :=
                Lwt.__return
                  (Alpha_context.Gas.consume ctxt
                    (Typecheck_costs.set_element length)) in
              let=? '(v, ctxt) :=
                (parse_comparable_data (a := unit)) __type_logger_value ctxt
                  __t_value v in
              let=? '_ :=
                match last_value with
                | Some value =&gt;
                  if
                    (|Compare.Int|).(Compare.S.op_lteq) 0
                      (compare_comparable __t_value value v) then
                    if
                      (|Compare.Int|).(Compare.S.op_eq) 0
                        (compare_comparable __t_value value v) then
                      Error_monad.fail extensible_type_value
                    else
                      Error_monad.fail extensible_type_value
                  else
                    Error_monad.return_unit
                | None =&gt; Error_monad.return_unit
                end in
              let=? ctxt :=
                Lwt.__return
                  (Alpha_context.Gas.consume ctxt
                    (Michelson_v1_gas.Cost_of.Legacy.set_update v false set)) in
              Error_monad.__return ((Some v), (set_update v true set), ctxt))
          (None, (empty_set __t_value), ctxt) vs))
      (fun function_parameter =&gt;
        let '(_, set, ctxt) := function_parameter in
        (set, ctxt)))
  
  | (Script_typed_ir.Set_t _ _, expr) =&gt;
    let expr := cast Alpha_context.Script.node expr in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((traced (B := unit)) (Error_monad.fail extensible_type_value))
  
  | (Script_typed_ir.Map_t tk tv _ty_name _, (Micheline.Seq loc vs) as expr) =&gt;
    let '[tk, tv, _ty_name, loc, vs, expr] :=
      cast
        [Script_typed_ir.comparable_ty ** Script_typed_ir.ty **
          option Script_typed_ir.type_annot ** Alpha_context.Script.location **
          list
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim) **
          Micheline.node Alpha_context.Script.location Alpha_context.Script.prim]
        [tk, tv, _ty_name, loc, vs, expr] in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((parse_items (D := option unit) (E := unit)) __type_logger_value loc ctxt
      expr tk tv vs (fun x =&gt; x))
  
  | (Script_typed_ir.Map_t _ _ _ _, expr) =&gt;
    let expr := cast Alpha_context.Script.node expr in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((traced (B := unit)) (Error_monad.fail extensible_type_value))
  
  | (Script_typed_ir.Big_map_t tk tv _ty_name, (Micheline.Seq loc vs) as expr)
    =&gt;
    let '[tk, tv, _ty_name, loc, vs, expr] :=
      cast
        [Script_typed_ir.comparable_ty ** Script_typed_ir.ty **
          option Script_typed_ir.type_annot ** Alpha_context.Script.location **
          list
            (Micheline.node Alpha_context.Script.location
              Alpha_context.Script.prim) **
          Micheline.node Alpha_context.Script.location Alpha_context.Script.prim]
        [tk, tv, _ty_name, loc, vs, expr] in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (Error_monad.op_gtgtpipequestion
      ((parse_items (D := option unit) (E := unit)) __type_logger_value loc ctxt
        expr tk tv vs (fun x =&gt; Some x))
      (fun function_parameter =&gt;
        let '(diff, ctxt) := function_parameter in
        ({| Script_typed_ir.big_map.id := None (A := unit);
          Script_typed_ir.big_map.diff := diff;
          Script_typed_ir.big_map.key_type := ty_of_comparable_ty tk;
          Script_typed_ir.big_map.value_type := tv |}, ctxt)))
  
  | (Script_typed_ir.Big_map_t tk tv _ty_name, Micheline.Int loc id) =&gt;
    let '[tk, tv, _ty_name, loc, id] :=
      cast
        [Script_typed_ir.comparable_ty ** Script_typed_ir.ty **
          option Script_typed_ir.type_annot ** Alpha_context.Script.location **
          Z.t] [tk, tv, _ty_name, loc, id] in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    (let=? function_parameter := Alpha_context.Big_map.__exists ctxt id in
    match function_parameter with
    | (_, None) =&gt; traced (Error_monad.fail extensible_type_value)
    | (ctxt, Some (btk, btv)) =&gt;
      Lwt.__return
        (let? '(Ex_comparable_ty btk, ctxt) :=
          parse_comparable_ty ctxt (Micheline.root btk) in
        let? '(Ex_ty btv, ctxt) :=
          parse_packable_ty ctxt legacy (Micheline.root btv) in
        let? 'Eq := comparable_ty_eq ctxt tk btk in
        let? '(Eq, ctxt) := ty_eq ctxt tv btv in
        Error_monad.ok
          ({| Script_typed_ir.big_map.id := Some id;
            Script_typed_ir.big_map.diff :=
              (empty_map (a := unit) (b := unit)) tk;
            Script_typed_ir.big_map.key_type := ty_of_comparable_ty tk;
            Script_typed_ir.big_map.value_type := tv |}, ctxt))
    end)
  
  | (Script_typed_ir.Big_map_t _tk _tv _, expr) =&gt;
    let '[_tk, _tv, expr] :=
      cast
        [Script_typed_ir.comparable_ty ** Script_typed_ir.ty **
          Alpha_context.Script.node] [_tk, _tv, expr] in
    cast (Lwt.t (Error_monad.tzresult (a * Alpha_context.context)))
    ((traced (B := unit)) (Error_monad.fail extensible_type_value))
  end

with parse_comparable_data {a : Set}
  (__type_logger_value : option type_logger) (ctxt : Alpha_context.context)
  (ty : Script_typed_ir.comparable_ty) (script_data : Alpha_context.Script.node)
  {struct __type_logger_value}
  : Lwt.t (Error_monad.tzresult (a * Alpha_context.context)) :=
  parse_data __type_logger_value ctxt false (ty_of_comparable_ty ty) script_data

with parse_returning
  (__type_logger_value : option type_logger) (__tc_context_value : tc_context)
  (ctxt : Alpha_context.context) (legacy : bool)
  (function_parameter : Script_typed_ir.ty * option Script_typed_ir.var_annot)
  {struct __type_logger_value}
  : Script_typed_ir.ty -&gt; Alpha_context.Script.node -&gt;
  Lwt.t (Error_monad.tzresult (Script_typed_ir.lambda * Alpha_context.context)) :=
  let '(arg, arg_annot) := function_parameter in
  fun ret =&gt;
    fun script_instr =&gt;
      let=? function_parameter :=
        parse_instr __type_logger_value __tc_context_value ctxt legacy
          script_instr
          (Script_typed_ir.Item_t arg Script_typed_ir.Empty_t arg_annot) in
      match function_parameter with
      |
        (Typed
          ({|
            Script_typed_ir.descr.loc := loc;
              Script_typed_ir.descr.aft :=
                (Script_typed_ir.Item_t ty Script_typed_ir.Empty_t _)
                  as stack_ty
              |} as __descr_value), ctxt) =&gt;
        Error_monad.trace_eval
          (fun function_parameter =&gt;
            let '_ := function_parameter in
            let=? '(ret, ctxt) := Lwt.__return (serialize_ty_for_error ctxt ret)
              in
            Error_monad.op_gtgtpipequestion
              (serialize_stack_for_error ctxt stack_ty)
              (fun function_parameter =&gt;
                let '(stack_ty, _ctxt) := function_parameter in
                extensible_type_value))
          (let=? '(Eq, ctxt) := Lwt.__return (ty_eq ctxt ty ret) in
          let=? '(_ret, ctxt) :=
            Lwt.__return (merge_types legacy ctxt loc ty ret) in
          Error_monad.__return
            ({| Script_typed_ir.lambda.lam := (__descr_value, script_instr) |},
              ctxt))
      |
        (Typed {|
          Script_typed_ir.descr.loc := loc;
            Script_typed_ir.descr.aft := stack_ty
            |}, ctxt) =&gt;
        let=? '(ret, ctxt) := Lwt.__return (serialize_ty_for_error ctxt ret) in
        let=? '(stack_ty, _ctxt) := serialize_stack_for_error ctxt stack_ty in
        Error_monad.fail extensible_type_value
      | (Failed {| judgement.Failed.descr := __descr_value |}, ctxt) =&gt;
        Error_monad.__return
          ({|
            Script_typed_ir.lambda.lam :=
              ((__descr_value
                (Script_typed_ir.Item_t ret Script_typed_ir.Empty_t None)),
                script_instr) |}, ctxt)
      end

with parse_instr
  (__type_logger_value : option type_logger) (__tc_context_value : tc_context)
  (ctxt : Alpha_context.context) (legacy : bool)
  (script_instr : Alpha_context.Script.node)
  (stack_ty : Script_typed_ir.stack_ty) {struct __type_logger_value}
  : Lwt.t (Error_monad.tzresult (judgement * Alpha_context.context)) :=
  let _check_item {A : Set}
    (check : Error_monad.tzresult A) (loc : Alpha_context.Script.location)
    (name : Alpha_context.Script.prim) (n : int) (m : int)
    : Lwt.t (Error_monad.tzresult A) :=
    (Error_monad.trace_eval
      (fun function_parameter =&gt;
        let '_ := function_parameter in
        Error_monad.op_gtgtpipequestion
          (serialize_stack_for_error ctxt stack_ty)
          (fun function_parameter =&gt;
            let '(stack_ty, _ctxt) := function_parameter in
            extensible_type_value)))
      ((Error_monad.trace extensible_type_value) (Lwt.__return check)) in
  let check_item_ty
    (ctxt : Alpha_context.context) (exp : Script_typed_ir.ty)
    (got : Script_typed_ir.ty) (loc : Alpha_context.Script.location)
    (name : Alpha_context.Script.prim) (n : int) (m : int)
    : Lwt.t
      (Error_monad.tzresult (eq * Script_typed_ir.ty * Alpha_context.context)) :=
    (Error_monad.trace_eval
      (fun function_parameter =&gt;
        let '_ := function_parameter in
        Error_monad.op_gtgtpipequestion
          (serialize_stack_for_error ctxt stack_ty)
          (fun function_parameter =&gt;
            let '(stack_ty, _ctxt) := function_parameter in
            extensible_type_value)))
      ((Error_monad.trace extensible_type_value)
        (Lwt.__return
          (let? '(Eq, ctxt) := ty_eq ctxt exp got in
          let? '(ty, ctxt) := merge_types legacy ctxt loc exp got in
          Error_monad.ok (Eq, ty, ctxt)))) in
  let check_item_comparable_ty
    (exp : Script_typed_ir.comparable_ty) (got : Script_typed_ir.comparable_ty)
    (loc : Alpha_context.Script.location) (name : Alpha_context.Script.prim)
    (n : int) (m : int)
    : Lwt.t (Error_monad.tzresult (eq * Script_typed_ir.comparable_ty)) :=
    (Error_monad.trace_eval
      (fun function_parameter =&gt;
        let '_ := function_parameter in
        Error_monad.op_gtgtpipequestion
          (serialize_stack_for_error ctxt stack_ty)
          (fun function_parameter =&gt;
            let '(stack_ty, _ctxt) := function_parameter in
            extensible_type_value)))
      ((Error_monad.trace extensible_type_value)
        (Lwt.__return
          (let? 'Eq := comparable_ty_eq ctxt exp got in
          let? ty := merge_comparable_types legacy exp got in
          Error_monad.ok (Eq, ty)))) in
  let log_stack
    (ctxt : Alpha_context.context) (loc : int)
    (stack_ty : Script_typed_ir.stack_ty) (aft : Script_typed_ir.stack_ty)
    : Lwt.t (Error_monad.tzresult unit) :=
    match (__type_logger_value, script_instr) with
    |
      ((None, _) |
      (Some _,
        (Micheline.Seq (-1) _ | Micheline.Int _ _ | Micheline.String _ _ |
        Micheline.Bytes _ _))) =&gt; Error_monad.return_unit
    | (Some log, (Micheline.Prim _ _ _ _ | Micheline.Seq _ _)) =&gt;
      let ctxt := Alpha_context.Gas.set_unlimited ctxt in
      let=? '(stack_ty, _) := unparse_stack ctxt stack_ty in
      let=? '(aft, _) := unparse_stack ctxt aft in
      (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
      (* ‚ùå instruction_sequence &quot;;&quot; *)
      Error_monad.return_unit
    end in
  let outer_return {A : Set} : A -&gt; Lwt.t (Error_monad.tzresult A) :=
    Error_monad.__return in
  let __return (ctxt : Alpha_context.context) (__judgement_value : judgement)
    : Lwt.t (Error_monad.tzresult (judgement * Alpha_context.context)) :=
    match __judgement_value with
    |
      Typed {|
        Script_typed_ir.descr.loc := loc;
          Script_typed_ir.descr.aft := aft;
          Script_typed_ir.descr.instr := instr
          |} =&gt;
      let maximum_type_size :=
        Alpha_context.Constants.michelson_maximum_type_size ctxt in
      let type_size :=
        type_size_of_stack_head aft (number_of_generated_growing_types instr) in
      if (|Compare.Int|).(Compare.S.op_gt) type_size maximum_type_size then
        Error_monad.fail extensible_type_value
      else
        Error_monad.__return (__judgement_value, ctxt)
    | Failed _ =&gt; Error_monad.__return (__judgement_value, ctxt)
    end in
  let typed
    (ctxt : Alpha_context.context) (loc : int) (instr : Script_typed_ir.instr)
    (aft : Script_typed_ir.stack_ty)
    : Lwt.t (Error_monad.tzresult (judgement * Alpha_context.context)) :=
    let=? '_ := log_stack ctxt loc stack_ty aft in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt (Typecheck_costs.instr instr)) in
    __return ctxt
      (Typed
        {| Script_typed_ir.descr.loc := loc;
          Script_typed_ir.descr.bef := stack_ty;
          Script_typed_ir.descr.aft := aft; Script_typed_ir.descr.instr := instr
          |}) in
  let=? ctxt :=
    Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle) in
  match
    ((script_instr, stack_ty),
      match (script_instr, stack_ty) with
      |
        (Micheline.Prim loc Alpha_context.Script.I_DIP (cons n (cons code []))
          result_annot, __stack_value) =&gt;
        match parse_int32 n with
        | Pervasives.Ok _ =&gt; true
        | Pervasives.Error _ =&gt; false
        end
      | _ =&gt; false
      end) with
  |
    ((Micheline.Prim loc Alpha_context.Script.I_DROP [] annot,
      Script_typed_ir.Item_t _ rest _), _) =&gt;
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc annot in
    typed ctxt loc Script_typed_ir.Drop rest
  |
    ((Micheline.Prim loc Alpha_context.Script.I_DROP (cons n []) result_annot,
      whole_stack), _) =&gt;
    let=? whole_n := Lwt.__return (parse_int32 n) in
    let fix make_proof_argument (n : int) (stk : Script_typed_ir.stack_ty)
      {struct n} : Lwt.t (Error_monad.tzresult dropn_proof_argument) :=
      match (((|Compare.Int|).(Compare.S.op_eq) n 0), stk) with
      | (true, rest) =&gt;
        outer_return (Dropn_proof_argument (Script_typed_ir.Rest, rest, rest))
      | (false, Script_typed_ir.Item_t v rest annot) =&gt;
        let=? 'Dropn_proof_argument (n', stack_after_drops, aft') :=
          make_proof_argument (Pervasives.op_minus n 1) rest in
        outer_return
          (Dropn_proof_argument
            ((Script_typed_ir.Prefix n'), stack_after_drops,
              (Script_typed_ir.Item_t v aft' annot)))
      | (_, _) =&gt;
        let=? '(whole_stack, _ctxt) :=
          serialize_stack_for_error ctxt whole_stack in
        Error_monad.fail extensible_type_value
      end in
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc result_annot in
    let=? 'Dropn_proof_argument (n', stack_after_drops, _aft) :=
      make_proof_argument whole_n whole_stack in
    typed ctxt loc (Script_typed_ir.Dropn whole_n n') stack_after_drops
  |
    ((Micheline.Prim loc Alpha_context.Script.I_DROP ((cons _ (cons _ _)) as l)
      _, _), _) =&gt; Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_DUP [] annot,
      Script_typed_ir.Item_t v rest stack_annot), _) =&gt;
    let=? annot := parse_var_annot loc (Some stack_annot) annot in
    typed ctxt loc Script_typed_ir.Dup
      (Script_typed_ir.Item_t v (Script_typed_ir.Item_t v rest stack_annot)
        annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_DIG (cons n []) result_annot,
      __stack_value), _) =&gt;
    let fix make_proof_argument (n : int) (stk : Script_typed_ir.stack_ty)
      {struct n} : Lwt.t (Error_monad.tzresult dig_proof_argument) :=
      match (((|Compare.Int|).(Compare.S.op_eq) n 0), stk) with
      | (true, Script_typed_ir.Item_t v rest annot) =&gt;
        outer_return
          (Dig_proof_argument (Script_typed_ir.Rest, (v, annot), rest))
      | (false, Script_typed_ir.Item_t v rest annot) =&gt;
        let=? 'Dig_proof_argument (n', (x, xv), aft') :=
          make_proof_argument (Pervasives.op_minus n 1) rest in
        outer_return
          (Dig_proof_argument
            ((Script_typed_ir.Prefix n'), (x, xv),
              (Script_typed_ir.Item_t v aft' annot)))
      | (_, _) =&gt;
        let=? '(whole_stack, _ctxt) :=
          serialize_stack_for_error ctxt __stack_value in
        Error_monad.fail extensible_type_value
      end in
    let=? n := Lwt.__return (parse_int32 n) in
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc result_annot in
    let=? 'Dig_proof_argument (n', (x, stack_annot), aft) :=
      make_proof_argument n __stack_value in
    typed ctxt loc (Script_typed_ir.Dig n n')
      (Script_typed_ir.Item_t x aft stack_annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_DIG
      (([] | cons _ (cons _ _)) as l) _, _), _) =&gt;
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_DUG (cons n []) result_annot,
      Script_typed_ir.Item_t x whole_stack stack_annot), _) =&gt;
    let=? whole_n := Lwt.__return (parse_int32 n) in
    let fix make_proof_argument
      (n : int) (x : Script_typed_ir.ty)
      (stack_annot : option Script_typed_ir.var_annot)
      (stk : Script_typed_ir.stack_ty) {struct n}
      : Lwt.t (Error_monad.tzresult dug_proof_argument) :=
      match (((|Compare.Int|).(Compare.S.op_eq) n 0), stk) with
      | (true, rest) =&gt;
        outer_return
          (Dug_proof_argument
            (Script_typed_ir.Rest, tt,
              (Script_typed_ir.Item_t x rest stack_annot)))
      | (false, Script_typed_ir.Item_t v rest annot) =&gt;
        let=? 'Dug_proof_argument (n', _, aft') :=
          make_proof_argument (Pervasives.op_minus n 1) x stack_annot rest in
        outer_return
          (Dug_proof_argument
            ((Script_typed_ir.Prefix n'), tt,
              (Script_typed_ir.Item_t v aft' annot)))
      | (_, _) =&gt;
        let=? '(whole_stack, _ctxt) :=
          serialize_stack_for_error ctxt whole_stack in
        Error_monad.fail extensible_type_value
      end in
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc result_annot in
    let=? 'Dug_proof_argument (n', _, aft) :=
      make_proof_argument whole_n x stack_annot whole_stack in
    typed ctxt loc (Script_typed_ir.Dug whole_n n') aft
  |
    ((Micheline.Prim loc Alpha_context.Script.I_DUG (cons _ []) result_annot,
      Script_typed_ir.Empty_t as __stack_value), _) =&gt;
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc result_annot in
    let=? '(__stack_value, _ctxt) :=
      serialize_stack_for_error ctxt __stack_value in
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_DUG
      (([] | cons _ (cons _ _)) as l) _, _), _) =&gt;
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SWAP [] annot,
      Script_typed_ir.Item_t v (Script_typed_ir.Item_t w rest stack_annot)
        cur_top_annot), _) =&gt;
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc annot in
    typed ctxt loc Script_typed_ir.Swap
      (Script_typed_ir.Item_t w (Script_typed_ir.Item_t v rest cur_top_annot)
        stack_annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_PUSH
      (cons __t_value (cons d [])) annot, __stack_value), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    let=? '(Ex_ty __t_value, ctxt) :=
      Lwt.__return (parse_packable_ty ctxt legacy __t_value) in
    let=? '(v, ctxt) :=
      (parse_data (a := unit)) __type_logger_value ctxt legacy __t_value d in
    typed ctxt loc (Script_typed_ir.Const v)
      (Script_typed_ir.Item_t __t_value __stack_value annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_UNIT [] annot, __stack_value), _)
    =&gt;
    let=? '(annot, ty_name) := parse_var_type_annot loc annot in
    typed ctxt loc (Script_typed_ir.Const tt)
      (Script_typed_ir.Item_t (Script_typed_ir.Unit_t ty_name) __stack_value
        annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SOME [] annot,
      Script_typed_ir.Item_t __t_value rest _), _) =&gt;
    let=? '(annot, ty_name) := parse_var_type_annot loc annot in
    typed ctxt loc Script_typed_ir.Cons_some
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t __t_value ty_name (has_big_map __t_value))
        rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_NONE (cons __t_value []) annot,
      __stack_value), _) =&gt;
    let=? '(Ex_ty __t_value, ctxt) :=
      Lwt.__return (parse_any_ty ctxt legacy __t_value) in
    let=? '(annot, ty_name) := parse_var_type_annot loc annot in
    typed ctxt loc (Script_typed_ir.Cons_none __t_value)
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t __t_value ty_name (has_big_map __t_value))
        __stack_value annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_IF_NONE (cons bt (cons bf []))
      annot,
      (Script_typed_ir.Item_t (Script_typed_ir.Option_t __t_value _ _) rest
        option_annot) as bef), _) =&gt;
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] bt in
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] bf in
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc annot in
    let annot :=
      Script_ir_annot.gen_access_annot option_annot None
        Script_ir_annot.default_some_annot in
    let=? '(btr, ctxt) :=
      parse_instr __type_logger_value __tc_context_value ctxt legacy bt rest in
    let=? '(bfr, ctxt) :=
      parse_instr __type_logger_value __tc_context_value ctxt legacy bf
        (Script_typed_ir.Item_t __t_value rest annot) in
    let branch (ibt : Script_typed_ir.descr) (ibf : Script_typed_ir.descr)
      : Script_typed_ir.descr :=
      {| Script_typed_ir.descr.loc := loc; Script_typed_ir.descr.bef := bef;
        Script_typed_ir.descr.aft := ibt.(Script_typed_ir.descr.aft);
        Script_typed_ir.descr.instr := Script_typed_ir.If_none ibt ibf |} in
    let=? '(__judgement_value, ctxt) :=
      merge_branches legacy ctxt loc btr bfr {| branch.branch := branch |} in
    __return ctxt __judgement_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_PAIR [] annot,
      Script_typed_ir.Item_t __a_value
        (Script_typed_ir.Item_t __b_value rest snd_annot) fst_annot), _) =&gt;
    let=? '(annot, ty_name, l_field, r_field) :=
      parse_constr_annot loc
        (Some (Script_ir_annot.var_to_field_annot fst_annot))
        (Some (Script_ir_annot.var_to_field_annot snd_annot)) annot in
    typed ctxt loc Script_typed_ir.Cons_pair
      (Script_typed_ir.Item_t
        (Script_typed_ir.Pair_t (__a_value, l_field, fst_annot)
          (__b_value, r_field, snd_annot) ty_name
          (Pervasives.op_pipepipe (has_big_map __a_value)
            (has_big_map __b_value))) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CAR [] annot,
      Script_typed_ir.Item_t
        (Script_typed_ir.Pair_t (__a_value, expected_field_annot, a_annot) _ _ _)
        rest pair_annot), _) =&gt;
    let=? '(annot, field_annot) :=
      parse_destr_annot loc annot Script_ir_annot.default_car_annot
        expected_field_annot pair_annot a_annot in
    let=? '_ :=
      Lwt.__return
        (Script_ir_annot.check_correct_field field_annot expected_field_annot)
      in
    typed ctxt loc Script_typed_ir.Car
      (Script_typed_ir.Item_t __a_value rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CDR [] annot,
      Script_typed_ir.Item_t
        (Script_typed_ir.Pair_t _ (__b_value, expected_field_annot, b_annot) _ _)
        rest pair_annot), _) =&gt;
    let=? '(annot, field_annot) :=
      parse_destr_annot loc annot Script_ir_annot.default_cdr_annot
        expected_field_annot pair_annot b_annot in
    let=? '_ :=
      Lwt.__return
        (Script_ir_annot.check_correct_field field_annot expected_field_annot)
      in
    typed ctxt loc Script_typed_ir.Cdr
      (Script_typed_ir.Item_t __b_value rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_LEFT (cons tr []) annot,
      Script_typed_ir.Item_t tl rest stack_annot), _) =&gt;
    let=? '(Ex_ty tr, ctxt) := Lwt.__return (parse_any_ty ctxt legacy tr) in
    let=? '(annot, tname, l_field, r_field) :=
      parse_constr_annot loc
        (Some (Script_ir_annot.var_to_field_annot stack_annot)) None annot in
    typed ctxt loc Script_typed_ir.Left
      (Script_typed_ir.Item_t
        (Script_typed_ir.Union_t (tl, l_field) (tr, r_field) tname
          (Pervasives.op_pipepipe (has_big_map tl) (has_big_map tr))) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_RIGHT (cons tl []) annot,
      Script_typed_ir.Item_t tr rest stack_annot), _) =&gt;
    let=? '(Ex_ty tl, ctxt) := Lwt.__return (parse_any_ty ctxt legacy tl) in
    let=? '(annot, tname, l_field, r_field) :=
      parse_constr_annot loc None
        (Some (Script_ir_annot.var_to_field_annot stack_annot)) annot in
    typed ctxt loc Script_typed_ir.Right
      (Script_typed_ir.Item_t
        (Script_typed_ir.Union_t (tl, l_field) (tr, r_field) tname
          (Pervasives.op_pipepipe (has_big_map tl) (has_big_map tr))) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_IF_LEFT (cons bt (cons bf []))
      annot,
      (Script_typed_ir.Item_t
        (Script_typed_ir.Union_t (tl, l_field) (tr, r_field) _ _) rest
        union_annot) as bef), _) =&gt;
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] bt in
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] bf in
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc annot in
    let left_annot :=
      Script_ir_annot.gen_access_annot union_annot
        (Some Script_ir_annot.default_left_annot) l_field in
    let right_annot :=
      Script_ir_annot.gen_access_annot union_annot
        (Some Script_ir_annot.default_right_annot) r_field in
    let=? '(btr, ctxt) :=
      parse_instr __type_logger_value __tc_context_value ctxt legacy bt
        (Script_typed_ir.Item_t tl rest left_annot) in
    let=? '(bfr, ctxt) :=
      parse_instr __type_logger_value __tc_context_value ctxt legacy bf
        (Script_typed_ir.Item_t tr rest right_annot) in
    let branch (ibt : Script_typed_ir.descr) (ibf : Script_typed_ir.descr)
      : Script_typed_ir.descr :=
      {| Script_typed_ir.descr.loc := loc; Script_typed_ir.descr.bef := bef;
        Script_typed_ir.descr.aft := ibt.(Script_typed_ir.descr.aft);
        Script_typed_ir.descr.instr := Script_typed_ir.If_left ibt ibf |} in
    let=? '(__judgement_value, ctxt) :=
      merge_branches legacy ctxt loc btr bfr {| branch.branch := branch |} in
    __return ctxt __judgement_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_NIL (cons __t_value []) annot,
      __stack_value), _) =&gt;
    let=? '(Ex_ty __t_value, ctxt) :=
      Lwt.__return (parse_any_ty ctxt legacy __t_value) in
    let=? '(annot, ty_name) := parse_var_type_annot loc annot in
    typed ctxt loc Script_typed_ir.Nil
      (Script_typed_ir.Item_t
        (Script_typed_ir.List_t __t_value ty_name (has_big_map __t_value))
        __stack_value annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CONS [] annot,
      Script_typed_ir.Item_t tv
        (Script_typed_ir.Item_t
          (Script_typed_ir.List_t __t_value ty_name has_big_map) rest _) _), _)
    =&gt;
    let=? '(Eq, __t_value, ctxt) :=
      check_item_ty ctxt tv __t_value loc Alpha_context.Script.I_CONS 1 2 in
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Cons_list
      (Script_typed_ir.Item_t
        (Script_typed_ir.List_t __t_value ty_name has_big_map) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_IF_CONS (cons bt (cons bf []))
      annot,
      (Script_typed_ir.Item_t
        (Script_typed_ir.List_t __t_value ty_name has_big_map) rest list_annot)
        as bef), _) =&gt;
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] bt in
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] bf in
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc annot in
    let hd_annot :=
      Script_ir_annot.gen_access_annot list_annot None
        Script_ir_annot.default_hd_annot in
    let tl_annot :=
      Script_ir_annot.gen_access_annot list_annot None
        Script_ir_annot.default_tl_annot in
    let=? '(btr, ctxt) :=
      parse_instr __type_logger_value __tc_context_value ctxt legacy bt
        (Script_typed_ir.Item_t __t_value
          (Script_typed_ir.Item_t
            (Script_typed_ir.List_t __t_value ty_name has_big_map) rest tl_annot)
          hd_annot) in
    let=? '(bfr, ctxt) :=
      parse_instr __type_logger_value __tc_context_value ctxt legacy bf rest in
    let branch (ibt : Script_typed_ir.descr) (ibf : Script_typed_ir.descr)
      : Script_typed_ir.descr :=
      {| Script_typed_ir.descr.loc := loc; Script_typed_ir.descr.bef := bef;
        Script_typed_ir.descr.aft := ibt.(Script_typed_ir.descr.aft);
        Script_typed_ir.descr.instr := Script_typed_ir.If_cons ibt ibf |} in
    let=? '(__judgement_value, ctxt) :=
      merge_branches legacy ctxt loc btr bfr {| branch.branch := branch |} in
    __return ctxt __judgement_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SIZE [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.List_t _ _ _) rest _), _) =&gt;
    let=? '(annot, tname) := parse_var_type_annot loc annot in
    typed ctxt loc Script_typed_ir.List_size
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_MAP (cons body []) annot,
      Script_typed_ir.Item_t (Script_typed_ir.List_t __elt_value _ _)
        starting_rest list_annot), _) =&gt;
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] body in
    let=? '(ret_annot, list_ty_name) := parse_var_type_annot loc annot in
    let elt_annot :=
      Script_ir_annot.gen_access_annot list_annot None
        Script_ir_annot.default_elt_annot in
    let=? '(__judgement_value, ctxt) :=
      parse_instr __type_logger_value __tc_context_value ctxt legacy body
        (Script_typed_ir.Item_t __elt_value starting_rest elt_annot) in
    match __judgement_value with
    |
      Typed
        ({| Script_typed_ir.descr.aft := Script_typed_ir.Item_t ret rest _ |} as
          ibody) =&gt;
      let invalid_map_body (function_parameter : unit)
        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
        let '_ := function_parameter in
        Error_monad.op_gtgtpipequestion
          (serialize_stack_for_error ctxt ibody.(Script_typed_ir.descr.aft))
          (fun function_parameter =&gt;
            let '(aft, _ctxt) := function_parameter in
            extensible_type_value) in
      Error_monad.trace_eval invalid_map_body
        (let=? '(Eq, ctxt) :=
          Lwt.__return (stack_ty_eq ctxt 1 rest starting_rest) in
        let=? '(rest, ctxt) :=
          Lwt.__return (merge_stacks legacy loc ctxt rest starting_rest) in
        typed ctxt loc (Script_typed_ir.List_map ibody)
          (Script_typed_ir.Item_t
            (Script_typed_ir.List_t ret list_ty_name (has_big_map ret)) rest
            ret_annot))
    | Typed {| Script_typed_ir.descr.aft := aft |} =&gt;
      let=? '(aft, _ctxt) := serialize_stack_for_error ctxt aft in
      Error_monad.fail extensible_type_value
    | Failed _ =&gt; Error_monad.fail extensible_type_value
    end
  |
    ((Micheline.Prim loc Alpha_context.Script.I_ITER (cons body []) annot,
      Script_typed_ir.Item_t (Script_typed_ir.List_t __elt_value _ _) rest
        list_annot), _) =&gt;
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] body in
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc annot in
    let elt_annot :=
      Script_ir_annot.gen_access_annot list_annot None
        Script_ir_annot.default_elt_annot in
    let=? '(__judgement_value, ctxt) :=
      parse_instr __type_logger_value __tc_context_value ctxt legacy body
        (Script_typed_ir.Item_t __elt_value rest elt_annot) in
    match __judgement_value with
    | Typed ({| Script_typed_ir.descr.aft := aft |} as ibody) =&gt;
      let invalid_iter_body (function_parameter : unit)
        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
        let '_ := function_parameter in
        let=? '(aft, ctxt) :=
          serialize_stack_for_error ctxt ibody.(Script_typed_ir.descr.aft) in
        Error_monad.op_gtgtpipequestion (serialize_stack_for_error ctxt rest)
          (fun function_parameter =&gt;
            let '(rest, _ctxt) := function_parameter in
            extensible_type_value) in
      Error_monad.trace_eval invalid_iter_body
        (let=? '(Eq, ctxt) := Lwt.__return (stack_ty_eq ctxt 1 aft rest) in
        let=? '(rest, ctxt) :=
          Lwt.__return (merge_stacks legacy loc ctxt aft rest) in
        typed ctxt loc (Script_typed_ir.List_iter ibody) rest)
    | Failed {| judgement.Failed.descr := __descr_value |} =&gt;
      typed ctxt loc (Script_typed_ir.List_iter (__descr_value rest)) rest
    end
  |
    ((Micheline.Prim loc Alpha_context.Script.I_EMPTY_SET (cons __t_value [])
      annot, rest), _) =&gt;
    let=? '(Ex_comparable_ty __t_value, ctxt) :=
      Lwt.__return (parse_comparable_ty ctxt __t_value) in
    let=? '(annot, tname) := parse_var_type_annot loc annot in
    typed ctxt loc (Script_typed_ir.Empty_set __t_value)
      (Script_typed_ir.Item_t (Script_typed_ir.Set_t __t_value tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_ITER (cons body []) annot,
      Script_typed_ir.Item_t (Script_typed_ir.Set_t comp_elt _) rest set_annot),
      _) =&gt;
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] body in
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc annot in
    let elt_annot :=
      Script_ir_annot.gen_access_annot set_annot None
        Script_ir_annot.default_elt_annot in
    let __elt_value := ty_of_comparable_ty comp_elt in
    let=? '(__judgement_value, ctxt) :=
      parse_instr __type_logger_value __tc_context_value ctxt legacy body
        (Script_typed_ir.Item_t __elt_value rest elt_annot) in
    match __judgement_value with
    | Typed ({| Script_typed_ir.descr.aft := aft |} as ibody) =&gt;
      let invalid_iter_body (function_parameter : unit)
        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
        let '_ := function_parameter in
        let=? '(aft, ctxt) :=
          serialize_stack_for_error ctxt ibody.(Script_typed_ir.descr.aft) in
        Error_monad.op_gtgtpipequestion (serialize_stack_for_error ctxt rest)
          (fun function_parameter =&gt;
            let '(rest, _ctxt) := function_parameter in
            extensible_type_value) in
      Error_monad.trace_eval invalid_iter_body
        (let=? '(Eq, ctxt) := Lwt.__return (stack_ty_eq ctxt 1 aft rest) in
        let=? '(rest, ctxt) :=
          Lwt.__return (merge_stacks legacy loc ctxt aft rest) in
        typed ctxt loc (Script_typed_ir.Set_iter ibody) rest)
    | Failed {| judgement.Failed.descr := __descr_value |} =&gt;
      typed ctxt loc (Script_typed_ir.Set_iter (__descr_value rest)) rest
    end
  |
    ((Micheline.Prim loc Alpha_context.Script.I_MEM [] annot,
      Script_typed_ir.Item_t v
        (Script_typed_ir.Item_t (Script_typed_ir.Set_t __elt_value _) rest _) _),
      _) =&gt;
    let __elt_value := ty_of_comparable_ty __elt_value in
    let=? '(annot, tname) := parse_var_type_annot loc annot in
    let=? '(Eq, _, ctxt) :=
      check_item_ty ctxt __elt_value v loc Alpha_context.Script.I_MEM 1 2 in
    typed ctxt loc Script_typed_ir.Set_mem
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_UPDATE [] annot,
      Script_typed_ir.Item_t v
        (Script_typed_ir.Item_t (Script_typed_ir.Bool_t _)
          (Script_typed_ir.Item_t (Script_typed_ir.Set_t __elt_value tname) rest
            set_annot) _) _), _) =&gt;
    match comparable_ty_of_ty v with
    | None =&gt;
      let=? '(v, _ctxt) := unparse_ty ctxt v in
      Error_monad.fail extensible_type_value
    | Some v =&gt;
      let=? annot := parse_var_annot loc (Some set_annot) annot in
      let=? '(Eq, __elt_value) :=
        check_item_comparable_ty __elt_value v loc Alpha_context.Script.I_UPDATE
          1 3 in
      typed ctxt loc Script_typed_ir.Set_update
        (Script_typed_ir.Item_t (Script_typed_ir.Set_t __elt_value tname) rest
          annot)
    end
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SIZE [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Set_t _ _) rest _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Set_size
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_EMPTY_MAP (cons tk (cons tv []))
      annot, __stack_value), _) =&gt;
    let=? '(Ex_comparable_ty tk, ctxt) :=
      Lwt.__return (parse_comparable_ty ctxt tk) in
    let=? '(Ex_ty tv, ctxt) := Lwt.__return (parse_any_ty ctxt legacy tv) in
    let=? '(annot, ty_name) := parse_var_type_annot loc annot in
    typed ctxt loc (Script_typed_ir.Empty_map tk tv)
      (Script_typed_ir.Item_t
        (Script_typed_ir.Map_t tk tv ty_name (has_big_map tv)) __stack_value
        annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_MAP (cons body []) annot,
      Script_typed_ir.Item_t (Script_typed_ir.Map_t ck __elt_value _ _)
        starting_rest _map_annot), _) =&gt;
    let k := ty_of_comparable_ty ck in
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] body in
    let=? '(ret_annot, ty_name) := parse_var_type_annot loc annot in
    let k_name :=
      Script_ir_annot.field_to_var_annot Script_ir_annot.default_key_annot in
    let e_name :=
      Script_ir_annot.field_to_var_annot Script_ir_annot.default_elt_annot in
    let=? '(__judgement_value, ctxt) :=
      parse_instr __type_logger_value __tc_context_value ctxt legacy body
        (Script_typed_ir.Item_t
          (Script_typed_ir.Pair_t (k, None, k_name) (__elt_value, None, e_name)
            None (has_big_map __elt_value)) starting_rest None) in
    match __judgement_value with
    |
      Typed
        ({| Script_typed_ir.descr.aft := Script_typed_ir.Item_t ret rest _ |} as
          ibody) =&gt;
      let invalid_map_body (function_parameter : unit)
        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
        let '_ := function_parameter in
        Error_monad.op_gtgtpipequestion
          (serialize_stack_for_error ctxt ibody.(Script_typed_ir.descr.aft))
          (fun function_parameter =&gt;
            let '(aft, _ctxt) := function_parameter in
            extensible_type_value) in
      Error_monad.trace_eval invalid_map_body
        (let=? '(Eq, ctxt) :=
          Lwt.__return (stack_ty_eq ctxt 1 rest starting_rest) in
        let=? '(rest, ctxt) :=
          Lwt.__return (merge_stacks legacy loc ctxt rest starting_rest) in
        typed ctxt loc (Script_typed_ir.Map_map ibody)
          (Script_typed_ir.Item_t
            (Script_typed_ir.Map_t ck ret ty_name (has_big_map ret)) rest
            ret_annot))
    | Typed {| Script_typed_ir.descr.aft := aft |} =&gt;
      let=? '(aft, _ctxt) := serialize_stack_for_error ctxt aft in
      Error_monad.fail extensible_type_value
    | Failed _ =&gt; Error_monad.fail extensible_type_value
    end
  |
    ((Micheline.Prim loc Alpha_context.Script.I_ITER (cons body []) annot,
      Script_typed_ir.Item_t (Script_typed_ir.Map_t comp_elt element_ty _ _)
        rest _map_annot), _) =&gt;
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] body in
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc annot in
    let k_name :=
      Script_ir_annot.field_to_var_annot Script_ir_annot.default_key_annot in
    let e_name :=
      Script_ir_annot.field_to_var_annot Script_ir_annot.default_elt_annot in
    let __key_value := ty_of_comparable_ty comp_elt in
    let=? '(__judgement_value, ctxt) :=
      parse_instr __type_logger_value __tc_context_value ctxt legacy body
        (Script_typed_ir.Item_t
          (Script_typed_ir.Pair_t (__key_value, None, k_name)
            (element_ty, None, e_name) None (has_big_map element_ty)) rest None)
      in
    match __judgement_value with
    | Typed ({| Script_typed_ir.descr.aft := aft |} as ibody) =&gt;
      let invalid_iter_body (function_parameter : unit)
        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
        let '_ := function_parameter in
        let=? '(aft, ctxt) :=
          serialize_stack_for_error ctxt ibody.(Script_typed_ir.descr.aft) in
        Error_monad.op_gtgtpipequestion (serialize_stack_for_error ctxt rest)
          (fun function_parameter =&gt;
            let '(rest, _ctxt) := function_parameter in
            extensible_type_value) in
      Error_monad.trace_eval invalid_iter_body
        (let=? '(Eq, ctxt) := Lwt.__return (stack_ty_eq ctxt 1 aft rest) in
        let=? '(rest, ctxt) :=
          Lwt.__return (merge_stacks legacy loc ctxt aft rest) in
        typed ctxt loc (Script_typed_ir.Map_iter ibody) rest)
    | Failed {| judgement.Failed.descr := __descr_value |} =&gt;
      typed ctxt loc (Script_typed_ir.Map_iter (__descr_value rest)) rest
    end
  |
    ((Micheline.Prim loc Alpha_context.Script.I_MEM [] annot,
      Script_typed_ir.Item_t vk
        (Script_typed_ir.Item_t (Script_typed_ir.Map_t ck _ _ _) rest _) _), _)
    =&gt;
    let k := ty_of_comparable_ty ck in
    let=? '(Eq, _, ctxt) :=
      check_item_ty ctxt vk k loc Alpha_context.Script.I_MEM 1 2 in
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Map_mem
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_GET [] annot,
      Script_typed_ir.Item_t vk
        (Script_typed_ir.Item_t
          (Script_typed_ir.Map_t ck __elt_value _ has_big_map) rest _) _), _) =&gt;
    let k := ty_of_comparable_ty ck in
    let=? '(Eq, _, ctxt) :=
      check_item_ty ctxt vk k loc Alpha_context.Script.I_GET 1 2 in
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Map_get
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t __elt_value None has_big_map) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_UPDATE [] annot,
      Script_typed_ir.Item_t vk
        (Script_typed_ir.Item_t (Script_typed_ir.Option_t vv _ _)
          (Script_typed_ir.Item_t
            (Script_typed_ir.Map_t ck v map_name has_big_map) rest map_annot) _)
        _), _) =&gt;
    let k := ty_of_comparable_ty ck in
    let=? '(Eq, _, ctxt) :=
      check_item_ty ctxt vk k loc Alpha_context.Script.I_UPDATE 1 3 in
    let=? '(Eq, v, ctxt) :=
      check_item_ty ctxt vv v loc Alpha_context.Script.I_UPDATE 2 3 in
    let=? annot := parse_var_annot loc (Some map_annot) annot in
    typed ctxt loc Script_typed_ir.Map_update
      (Script_typed_ir.Item_t (Script_typed_ir.Map_t ck v map_name has_big_map)
        rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SIZE [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Map_t _ _ _ _) rest _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Map_size
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_EMPTY_BIG_MAP
      (cons tk (cons tv [])) annot, __stack_value), _) =&gt;
    let=? '(Ex_comparable_ty tk, ctxt) :=
      Lwt.__return (parse_comparable_ty ctxt tk) in
    let=? '(Ex_ty tv, ctxt) := Lwt.__return (parse_packable_ty ctxt legacy tv)
      in
    let=? '(annot, ty_name) := parse_var_type_annot loc annot in
    typed ctxt loc (Script_typed_ir.Empty_big_map tk tv)
      (Script_typed_ir.Item_t (Script_typed_ir.Big_map_t tk tv ty_name)
        __stack_value annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_MEM [] annot,
      Script_typed_ir.Item_t set_key
        (Script_typed_ir.Item_t (Script_typed_ir.Big_map_t map_key _ _) rest _)
        _), _) =&gt;
    let k := ty_of_comparable_ty map_key in
    let=? '(Eq, _, ctxt) :=
      check_item_ty ctxt set_key k loc Alpha_context.Script.I_MEM 1 2 in
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Big_map_mem
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_GET [] annot,
      Script_typed_ir.Item_t vk
        (Script_typed_ir.Item_t (Script_typed_ir.Big_map_t ck __elt_value _)
          rest _) _), _) =&gt;
    let k := ty_of_comparable_ty ck in
    let=? '(Eq, _, ctxt) :=
      check_item_ty ctxt vk k loc Alpha_context.Script.I_GET 1 2 in
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Big_map_get
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t __elt_value None (has_big_map __elt_value))
        rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_UPDATE [] annot,
      Script_typed_ir.Item_t set_key
        (Script_typed_ir.Item_t (Script_typed_ir.Option_t set_value _ _)
          (Script_typed_ir.Item_t
            (Script_typed_ir.Big_map_t map_key map_value map_name) rest
            map_annot) _) _), _) =&gt;
    let k := ty_of_comparable_ty map_key in
    let=? '(Eq, _, ctxt) :=
      check_item_ty ctxt set_key k loc Alpha_context.Script.I_UPDATE 1 3 in
    let=? '(Eq, map_value, ctxt) :=
      check_item_ty ctxt set_value map_value loc Alpha_context.Script.I_UPDATE 2
        3 in
    let=? annot := parse_var_annot loc (Some map_annot) annot in
    typed ctxt loc Script_typed_ir.Big_map_update
      (Script_typed_ir.Item_t
        (Script_typed_ir.Big_map_t map_key map_value map_name) rest annot)
  | ((Micheline.Seq loc [], __stack_value), _) =&gt;
    typed ctxt loc Script_typed_ir.Nop __stack_value
  | ((Micheline.Seq loc (cons single []), __stack_value), _) =&gt;
    let=? '(__judgement_value, ctxt) :=
      parse_instr __type_logger_value __tc_context_value ctxt legacy single
        __stack_value in
    match __judgement_value with
    | Typed ({| Script_typed_ir.descr.aft := aft |} as instr) =&gt;
      let nop :=
        {| Script_typed_ir.descr.loc := loc; Script_typed_ir.descr.bef := aft;
          Script_typed_ir.descr.aft := aft;
          Script_typed_ir.descr.instr := Script_typed_ir.Nop |} in
      typed ctxt loc (Script_typed_ir.Seq instr nop) aft
    | Failed {| judgement.Failed.descr := __descr_value |} =&gt;
      let __descr_value (aft : Script_typed_ir.stack_ty)
        : Script_typed_ir.descr :=
        let nop :=
          {| Script_typed_ir.descr.loc := loc; Script_typed_ir.descr.bef := aft;
            Script_typed_ir.descr.aft := aft;
            Script_typed_ir.descr.instr := Script_typed_ir.Nop |} in
        let __descr_value := __descr_value aft in
        Script_typed_ir.descr.with_instr (Script_typed_ir.Seq __descr_value nop)
          __descr_value in
      __return ctxt (Failed {| judgement.Failed.descr := __descr_value |})
    end
  | ((Micheline.Seq loc (cons hd tl), __stack_value), _) =&gt;
    let=? '(__judgement_value, ctxt) :=
      parse_instr __type_logger_value __tc_context_value ctxt legacy hd
        __stack_value in
    match __judgement_value with
    | Failed _ =&gt; Error_monad.fail extensible_type_value
    | Typed ({| Script_typed_ir.descr.aft := middle |} as ihd) =&gt;
      let=? '(__judgement_value, ctxt) :=
        parse_instr __type_logger_value __tc_context_value ctxt legacy
          (Micheline.Seq (-1) tl) middle in
      match __judgement_value with
      | Failed {| judgement.Failed.descr := __descr_value |} =&gt;
        let __descr_value (ret : Script_typed_ir.stack_ty)
          : Script_typed_ir.descr :=
          {| Script_typed_ir.descr.loc := loc;
            Script_typed_ir.descr.bef := __stack_value;
            Script_typed_ir.descr.aft := ret;
            Script_typed_ir.descr.instr :=
              Script_typed_ir.Seq ihd (__descr_value ret) |} in
        __return ctxt (Failed {| judgement.Failed.descr := __descr_value |})
      | Typed itl =&gt;
        typed ctxt loc (Script_typed_ir.Seq ihd itl)
          itl.(Script_typed_ir.descr.aft)
      end
    end
  |
    ((Micheline.Prim loc Alpha_context.Script.I_IF (cons bt (cons bf [])) annot,
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t _) rest _) as bef), _) =&gt;
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] bt in
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] bf in
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc annot in
    let=? '(btr, ctxt) :=
      parse_instr __type_logger_value __tc_context_value ctxt legacy bt rest in
    let=? '(bfr, ctxt) :=
      parse_instr __type_logger_value __tc_context_value ctxt legacy bf rest in
    let branch (ibt : Script_typed_ir.descr) (ibf : Script_typed_ir.descr)
      : Script_typed_ir.descr :=
      {| Script_typed_ir.descr.loc := loc; Script_typed_ir.descr.bef := bef;
        Script_typed_ir.descr.aft := ibt.(Script_typed_ir.descr.aft);
        Script_typed_ir.descr.instr := Script_typed_ir.If ibt ibf |} in
    let=? '(__judgement_value, ctxt) :=
      merge_branches legacy ctxt loc btr bfr {| branch.branch := branch |} in
    __return ctxt __judgement_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_LOOP (cons body []) annot,
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t _) rest _stack_annot) as
        __stack_value), _) =&gt;
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] body in
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc annot in
    let=? '(__judgement_value, ctxt) :=
      parse_instr __type_logger_value __tc_context_value ctxt legacy body rest
      in
    match __judgement_value with
    | Typed ibody =&gt;
      let unmatched_branches (function_parameter : unit)
        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
        let '_ := function_parameter in
        let=? '(aft, ctxt) :=
          serialize_stack_for_error ctxt ibody.(Script_typed_ir.descr.aft) in
        Error_monad.op_gtgtpipequestion
          (serialize_stack_for_error ctxt __stack_value)
          (fun function_parameter =&gt;
            let '(__stack_value, _ctxt) := function_parameter in
            extensible_type_value) in
      Error_monad.trace_eval unmatched_branches
        (let=? '(Eq, ctxt) :=
          Lwt.__return
            (stack_ty_eq ctxt 1 ibody.(Script_typed_ir.descr.aft) __stack_value)
          in
        let=? '(_stack, ctxt) :=
          Lwt.__return
            (merge_stacks legacy loc ctxt ibody.(Script_typed_ir.descr.aft)
              __stack_value) in
        typed ctxt loc (Script_typed_ir.Loop ibody) rest)
    | Failed {| judgement.Failed.descr := __descr_value |} =&gt;
      let ibody := __descr_value __stack_value in
      typed ctxt loc (Script_typed_ir.Loop ibody) rest
    end
  |
    ((Micheline.Prim loc Alpha_context.Script.I_LOOP_LEFT (cons body []) annot,
      (Script_typed_ir.Item_t
        (Script_typed_ir.Union_t (tl, l_field) (tr, _) _ _) rest union_annot) as
        __stack_value), _) =&gt;
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] body in
    let=? annot := parse_var_annot loc None annot in
    let l_annot :=
      Script_ir_annot.gen_access_annot union_annot
        (Some Script_ir_annot.default_left_annot) l_field in
    let=? '(__judgement_value, ctxt) :=
      parse_instr __type_logger_value __tc_context_value ctxt legacy body
        (Script_typed_ir.Item_t tl rest l_annot) in
    match __judgement_value with
    | Typed ibody =&gt;
      let unmatched_branches (function_parameter : unit)
        : Lwt.t (Error_monad.tzresult Error_monad.__error) :=
        let '_ := function_parameter in
        let=? '(aft, ctxt) :=
          serialize_stack_for_error ctxt ibody.(Script_typed_ir.descr.aft) in
        Error_monad.op_gtgtpipequestion
          (serialize_stack_for_error ctxt __stack_value)
          (fun function_parameter =&gt;
            let '(__stack_value, _ctxt) := function_parameter in
            extensible_type_value) in
      Error_monad.trace_eval unmatched_branches
        (let=? '(Eq, ctxt) :=
          Lwt.__return
            (stack_ty_eq ctxt 1 ibody.(Script_typed_ir.descr.aft) __stack_value)
          in
        let=? '(_stack, ctxt) :=
          Lwt.__return
            (merge_stacks legacy loc ctxt ibody.(Script_typed_ir.descr.aft)
              __stack_value) in
        typed ctxt loc (Script_typed_ir.Loop_left ibody)
          (Script_typed_ir.Item_t tr rest annot))
    | Failed {| judgement.Failed.descr := __descr_value |} =&gt;
      let ibody := __descr_value __stack_value in
      typed ctxt loc (Script_typed_ir.Loop_left ibody)
        (Script_typed_ir.Item_t tr rest annot)
    end
  |
    ((Micheline.Prim loc Alpha_context.Script.I_LAMBDA
      (cons arg (cons ret (cons code []))) annot, __stack_value), _) =&gt;
    let=? '(Ex_ty arg, ctxt) := Lwt.__return (parse_any_ty ctxt legacy arg) in
    let=? '(Ex_ty ret, ctxt) := Lwt.__return (parse_any_ty ctxt legacy ret) in
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] code in
    let=? annot := parse_var_annot loc None annot in
    let=? '(lambda, ctxt) :=
      parse_returning __type_logger_value Lambda ctxt legacy
        (arg, Script_ir_annot.default_arg_annot) ret code in
    typed ctxt loc (Script_typed_ir.Lambda lambda)
      (Script_typed_ir.Item_t (Script_typed_ir.Lambda_t arg ret None)
        __stack_value annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_EXEC [] annot,
      Script_typed_ir.Item_t arg
        (Script_typed_ir.Item_t (Script_typed_ir.Lambda_t param ret _) rest _) _),
      _) =&gt;
    let=? '(Eq, _, ctxt) :=
      check_item_ty ctxt arg param loc Alpha_context.Script.I_EXEC 1 2 in
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Exec (Script_typed_ir.Item_t ret rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_APPLY [] annot,
      Script_typed_ir.Item_t capture
        (Script_typed_ir.Item_t
          (Script_typed_ir.Lambda_t
            (Script_typed_ir.Pair_t (capture_ty, _, _) (arg_ty, _, _) lam_annot
              _) ret _) rest _) _), _) =&gt;
    let=? '_ := Lwt.__return (check_packable false loc capture_ty) in
    let=? '(Eq, capture_ty, ctxt) :=
      check_item_ty ctxt capture capture_ty loc Alpha_context.Script.I_APPLY 1 2
      in
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc (Script_typed_ir.Apply capture_ty)
      (Script_typed_ir.Item_t (Script_typed_ir.Lambda_t arg_ty ret lam_annot)
        rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_DIP (cons code []) annot,
      Script_typed_ir.Item_t v rest stack_annot), _) =&gt;
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc annot in
    let=? '_ := check_kind [ Script_tc_errors.Seq_kind ] code in
    let=? '(__judgement_value, ctxt) :=
      parse_instr __type_logger_value (add_dip v stack_annot __tc_context_value)
        ctxt legacy code rest in
    match __judgement_value with
    | Typed __descr_value =&gt;
      typed ctxt loc (Script_typed_ir.Dip __descr_value)
        (Script_typed_ir.Item_t v __descr_value.(Script_typed_ir.descr.aft)
          stack_annot)
    | Failed _ =&gt; Error_monad.fail extensible_type_value
    end
  |
    ((Micheline.Prim loc Alpha_context.Script.I_DIP (cons n (cons code []))
      result_annot, __stack_value), true) =&gt;
    let fix make_proof_argument
      (n : int) (inner_tc_context : tc_context) (stk : Script_typed_ir.stack_ty)
      {struct n} : Lwt.t (Error_monad.tzresult dipn_proof_argument) :=
      match (((|Compare.Int|).(Compare.S.op_eq) n 0), stk) with
      | (true, rest) =&gt;
        let=? '(__judgement_value, ctxt) :=
          parse_instr __type_logger_value inner_tc_context ctxt legacy code rest
          in
        match __judgement_value with
        | Typed __descr_value =&gt;
          outer_return
            (Dipn_proof_argument
              (Script_typed_ir.Rest, (ctxt, __descr_value),
                __descr_value.(Script_typed_ir.descr.aft)))
        | Failed _ =&gt; Error_monad.fail extensible_type_value
        end
      | (false, Script_typed_ir.Item_t v rest annot) =&gt;
        let=? 'Dipn_proof_argument (n', __descr_value, aft') :=
          make_proof_argument (Pervasives.op_minus n 1)
            (add_dip v annot __tc_context_value) rest in
        outer_return
          (Dipn_proof_argument
            ((Script_typed_ir.Prefix n'), __descr_value,
              (Script_typed_ir.Item_t v aft' annot)))
      | (_, _) =&gt;
        let=? '(whole_stack, _ctxt) :=
          serialize_stack_for_error ctxt __stack_value in
        Error_monad.fail extensible_type_value
      end in
    let=? n := Lwt.__return (parse_int32 n) in
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc result_annot in
    let=? 'Dipn_proof_argument (n', (new_ctxt, __descr_value), aft) :=
      make_proof_argument n __tc_context_value __stack_value in
    typed new_ctxt loc (Script_typed_ir.Dipn n n' __descr_value) aft
  |
    ((Micheline.Prim loc Alpha_context.Script.I_DIP
      (([] | cons _ (cons _ (cons _ _))) as l) _, _), _) =&gt;
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_FAILWITH [] annot,
      Script_typed_ir.Item_t v _rest _), _) =&gt;
    let=? '_ := Script_ir_annot.fail_unexpected_annot loc annot in
    let __descr_value (aft : Script_typed_ir.stack_ty)
      : Script_typed_ir.descr :=
      {| Script_typed_ir.descr.loc := loc;
        Script_typed_ir.descr.bef := stack_ty; Script_typed_ir.descr.aft := aft;
        Script_typed_ir.descr.instr := Script_typed_ir.Failwith v |} in
    let=? '_ := log_stack ctxt loc stack_ty Script_typed_ir.Empty_t in
    __return ctxt (Failed {| judgement.Failed.descr := __descr_value |})
  |
    ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tname)
        (Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Add_timestamp_to_seconds
      (Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t _)
        (Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tname) rest _) _),
      _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Add_seconds_to_timestamp
      (Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tname)
        (Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Sub_timestamp_seconds
      (Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t tn2) rest _) _), _)
    =&gt;
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Diff_timestamps
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CONCAT [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.String_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.String_t tn2) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Concat_string_pair
      (Script_typed_ir.Item_t (Script_typed_ir.String_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CONCAT [] annot,
      Script_typed_ir.Item_t
        (Script_typed_ir.List_t (Script_typed_ir.String_t tname) _ _) rest
        list_annot), _) =&gt;
    let=? annot := parse_var_annot loc (Some list_annot) annot in
    typed ctxt loc Script_typed_ir.Concat_string
      (Script_typed_ir.Item_t (Script_typed_ir.String_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SLICE [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
          (Script_typed_ir.Item_t (Script_typed_ir.String_t tname) rest
            string_annot) _) _), _) =&gt;
    let=? annot :=
      parse_var_annot loc
        (Some
          (Script_ir_annot.gen_access_annot string_annot None
            Script_ir_annot.default_slice_annot)) annot in
    typed ctxt loc Script_typed_ir.Slice_string
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t (Script_typed_ir.String_t tname) None false)
        rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SIZE [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.String_t _) rest _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.String_size
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CONCAT [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Bytes_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t tn2) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Concat_bytes_pair
      (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CONCAT [] annot,
      Script_typed_ir.Item_t
        (Script_typed_ir.List_t (Script_typed_ir.Bytes_t tname) _ _) rest
        list_annot), _) =&gt;
    let=? annot := parse_var_annot loc (Some list_annot) annot in
    typed ctxt loc Script_typed_ir.Concat_bytes
      (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SLICE [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
          (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t tname) rest
            bytes_annot) _) _), _) =&gt;
    let=? annot :=
      parse_var_annot loc
        (Some
          (Script_ir_annot.gen_access_annot bytes_annot None
            Script_ir_annot.default_slice_annot)) annot in
    typed ctxt loc Script_typed_ir.Slice_bytes
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t (Script_typed_ir.Bytes_t tname) None false)
        rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SIZE [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Bytes_t _) rest _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Bytes_size
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tn2) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Add_tez
      (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tn2) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Sub_tez
      (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_MUL [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Mul_teznat
      (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_MUL [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
        (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname) rest _) _), _)
    =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Mul_nattez
      (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_OR [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Bool_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tn2) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Or
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_AND [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Bool_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tn2) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.And
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_XOR [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Bool_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tn2) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Xor
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_NOT [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Bool_t tname) rest _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Not
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_ABS [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Abs_int
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_ISNAT [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest int_annot), _) =&gt;
    let=? annot := parse_var_annot loc (Some int_annot) annot in
    typed ctxt loc Script_typed_ir.Is_nat
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t (Script_typed_ir.Nat_t None) None false) rest
        annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_INT [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Int_nat
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_NEG [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Neg_int
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_NEG [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Neg_nat
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Int_t tn2) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Add_intint
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t tname)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Add_intnat
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
        (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Add_natint
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_ADD [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Add_natnat
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Int_t tn2) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Sub_int
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t tname)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Sub_int
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
        (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Sub_int
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SUB [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    let=? _tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Sub_int
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_MUL [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Int_t tn2) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Mul_intint
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_MUL [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t tname)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Mul_intnat
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_MUL [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t _)
        (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Mul_natint
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_MUL [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Mul_natnat
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_EDIV [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tname)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Ediv_teznat
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t
          (Script_typed_ir.Pair_t ((Script_typed_ir.Mutez_t tname), None, None)
            ((Script_typed_ir.Mutez_t tname), None, None) None false) None false)
        rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_EDIV [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t tn2) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Ediv_tez
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t
          (Script_typed_ir.Pair_t ((Script_typed_ir.Nat_t None), None, None)
            ((Script_typed_ir.Mutez_t tname), None, None) None false) None false)
        rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_EDIV [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Int_t tn2) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Ediv_intint
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t
          (Script_typed_ir.Pair_t ((Script_typed_ir.Int_t tname), None, None)
            ((Script_typed_ir.Nat_t None), None, None) None false) None false)
        rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_EDIV [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t tname)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Ediv_intnat
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t
          (Script_typed_ir.Pair_t ((Script_typed_ir.Int_t tname), None, None)
            ((Script_typed_ir.Nat_t None), None, None) None false) None false)
        rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_EDIV [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname)
        (Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Ediv_natint
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t
          (Script_typed_ir.Pair_t ((Script_typed_ir.Int_t None), None, None)
            ((Script_typed_ir.Nat_t tname), None, None) None false) None false)
        rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_EDIV [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Ediv_natnat
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t
          (Script_typed_ir.Pair_t ((Script_typed_ir.Nat_t tname), None, None)
            ((Script_typed_ir.Nat_t tname), None, None) None false) None false)
        rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_LSL [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Lsl_nat
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_LSR [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Lsr_nat
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_OR [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Or_nat
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_AND [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.And_nat
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_AND [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t _)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.And_int_nat
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_XOR [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn1)
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tn2) rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    let=? tname :=
      Lwt.__return (Script_ir_annot.merge_type_annot legacy tn1 tn2) in
    typed ctxt loc Script_typed_ir.Xor_nat
      (Script_typed_ir.Item_t (Script_typed_ir.Nat_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_NOT [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Not_int
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t tname) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_NOT [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Nat_t _) rest _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Not_nat
      (Script_typed_ir.Item_t (Script_typed_ir.Int_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_COMPARE [] annot,
      Script_typed_ir.Item_t t1 (Script_typed_ir.Item_t t2 rest _) _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    let=? '(Eq, __t_value, ctxt) :=
      check_item_ty ctxt t1 t2 loc Alpha_context.Script.I_COMPARE 1 2 in
    match comparable_ty_of_ty __t_value with
    | None =&gt;
      let=? '(__t_value, _ctxt) :=
        Lwt.__return (serialize_ty_for_error ctxt __t_value) in
      Error_monad.fail extensible_type_value
    | Some __key_value =&gt;
      typed ctxt loc (Script_typed_ir.Compare __key_value)
        (Script_typed_ir.Item_t (Script_typed_ir.Int_t None) rest annot)
    end
  |
    ((Micheline.Prim loc Alpha_context.Script.I_EQ [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Eq
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_NEQ [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Neq
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_LT [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Lt
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_GT [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Gt
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_LE [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Le
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_GE [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Int_t _) rest _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Ge
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CAST (cons cast_t []) annot,
      Script_typed_ir.Item_t __t_value __stack_value item_annot), _) =&gt;
    let=? annot := parse_var_annot loc (Some item_annot) annot in
    let=? '(Ex_ty cast_t, ctxt) :=
      Lwt.__return (parse_any_ty ctxt legacy cast_t) in
    let=? '(Eq, ctxt) := Lwt.__return (ty_eq ctxt cast_t __t_value) in
    let=? '(_, ctxt) :=
      Lwt.__return (merge_types legacy ctxt loc cast_t __t_value) in
    typed ctxt loc Script_typed_ir.Nop
      (Script_typed_ir.Item_t cast_t __stack_value annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_RENAME [] annot,
      Script_typed_ir.Item_t __t_value __stack_value _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Nop
      (Script_typed_ir.Item_t __t_value __stack_value annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_PACK [] annot,
      Script_typed_ir.Item_t __t_value rest unpacked_annot), _) =&gt;
    let=? '_ := Lwt.__return (check_packable true loc __t_value) in
    let=? annot :=
      parse_var_annot loc
        (Some
          (Script_ir_annot.gen_access_annot unpacked_annot None
            Script_ir_annot.default_pack_annot)) annot in
    typed ctxt loc (Script_typed_ir.Pack __t_value)
      (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_UNPACK (cons ty []) annot,
      Script_typed_ir.Item_t (Script_typed_ir.Bytes_t _) rest packed_annot), _)
    =&gt;
    let=? '(Ex_ty __t_value, ctxt) :=
      Lwt.__return (parse_packable_ty ctxt legacy ty) in
    let=? '(annot, ty_name) := parse_var_type_annot loc annot in
    let annot :=
      Script_ir_annot.default_annot
        (Script_ir_annot.gen_access_annot packed_annot None
          Script_ir_annot.default_unpack_annot) annot in
    typed ctxt loc (Script_typed_ir.Unpack __t_value)
      (Script_typed_ir.Item_t (Script_typed_ir.Option_t __t_value ty_name false)
        rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_ADDRESS [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Contract_t _ _) rest
        contract_annot), _) =&gt;
    let=? annot :=
      parse_var_annot loc
        (Some
          (Script_ir_annot.gen_access_annot contract_annot None
            Script_ir_annot.default_addr_annot)) annot in
    typed ctxt loc Script_typed_ir.Address
      (Script_typed_ir.Item_t (Script_typed_ir.Address_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CONTRACT (cons ty []) annot,
      Script_typed_ir.Item_t (Script_typed_ir.Address_t _) rest addr_annot), _)
    =&gt;
    let=? '(Ex_ty __t_value, ctxt) :=
      Lwt.__return (parse_parameter_ty ctxt legacy ty) in
    let=? '(annot, entrypoint) :=
      parse_entrypoint_annot loc
        (Some
          (Script_ir_annot.gen_access_annot addr_annot None
            Script_ir_annot.default_contract_annot)) annot in
    let=? entrypoint :=
      Lwt.__return
        match entrypoint with
        | None =&gt; Pervasives.Ok &quot;default&quot;
        | Some (Script_typed_ir.Field_annot &quot;default&quot;) =&gt;
          Error_monad.__error_value extensible_type_value
        | Some (Script_typed_ir.Field_annot entrypoint) =&gt;
          if (|Compare.Int|).(Compare.S.op_gt) (String.length entrypoint) 31
            then
            Error_monad.__error_value extensible_type_value
          else
            Pervasives.Ok entrypoint
        end in
    typed ctxt loc (Script_typed_ir.Contract __t_value entrypoint)
      (Script_typed_ir.Item_t
        (Script_typed_ir.Option_t (Script_typed_ir.Contract_t __t_value None)
          None false) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_TRANSFER_TOKENS [] annot,
      Script_typed_ir.Item_t __p_value
        (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t _)
          (Script_typed_ir.Item_t (Script_typed_ir.Contract_t cp _) rest _) _) _),
      _) =&gt;
    let=? '(Eq, _, ctxt) :=
      check_item_ty ctxt __p_value cp loc Alpha_context.Script.I_TRANSFER_TOKENS
        1 4 in
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Transfer_tokens
      (Script_typed_ir.Item_t (Script_typed_ir.Operation_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SET_DELEGATE [] annot,
      Script_typed_ir.Item_t
        (Script_typed_ir.Option_t (Script_typed_ir.Key_hash_t _) _ _) rest _), _)
    =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Set_delegate
      (Script_typed_ir.Item_t (Script_typed_ir.Operation_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CREATE_ACCOUNT [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Key_hash_t _)
        (Script_typed_ir.Item_t
          (Script_typed_ir.Option_t (Script_typed_ir.Key_hash_t _) _ _)
          (Script_typed_ir.Item_t (Script_typed_ir.Bool_t _)
            (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t _) rest _) _) _) _),
      _) =&gt;
    if legacy then
      let=? '(op_annot, addr_annot) := parse_two_var_annot loc annot in
      typed ctxt loc Script_typed_ir.Create_account
        (Script_typed_ir.Item_t (Script_typed_ir.Operation_t None)
          (Script_typed_ir.Item_t (Script_typed_ir.Address_t None) rest
            addr_annot) op_annot)
    else
      Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_IMPLICIT_ACCOUNT [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Key_hash_t _) rest _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Implicit_account
      (Script_typed_ir.Item_t
        (Script_typed_ir.Contract_t (Script_typed_ir.Unit_t None) None) rest
        annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CREATE_CONTRACT
      (cons ((Micheline.Seq _ _) as code) []) annot,
      Script_typed_ir.Item_t (Script_typed_ir.Key_hash_t _)
        (Script_typed_ir.Item_t
          (Script_typed_ir.Option_t (Script_typed_ir.Key_hash_t _) _ _)
          (Script_typed_ir.Item_t (Script_typed_ir.Bool_t _)
            (Script_typed_ir.Item_t (Script_typed_ir.Bool_t _)
              (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t _)
                (Script_typed_ir.Item_t ginit rest _) _) _) _) _) _), _) =&gt;
    if legacy then
      let=? '(op_annot, addr_annot) := parse_two_var_annot loc annot in
      let cannonical_code := Pervasives.fst (Micheline.extract_locations code)
        in
      let=? '(arg_type, storage_type, code_field, root_name) :=
        Lwt.__return (parse_toplevel legacy cannonical_code) in
      let=? '(Ex_ty arg_type, ctxt) :=
        Error_monad.trace extensible_type_value
          (Lwt.__return (parse_parameter_ty ctxt legacy arg_type)) in
      let=? '_ :=
        if legacy then
          Error_monad.__return tt
        else
          Lwt.__return (well_formed_entrypoints arg_type root_name) in
      let=? '(Ex_ty storage_type, ctxt) :=
        Error_monad.trace extensible_type_value
          (Lwt.__return (parse_storage_ty ctxt legacy storage_type)) in
      let arg_annot :=
        Script_ir_annot.default_annot Script_ir_annot.default_param_annot
          (Script_ir_annot.type_to_var_annot (name_of_ty arg_type)) in
      let storage_annot :=
        Script_ir_annot.default_annot Script_ir_annot.default_storage_annot
          (Script_ir_annot.type_to_var_annot (name_of_ty storage_type)) in
      let arg_type_full :=
        Script_typed_ir.Pair_t (arg_type, None, arg_annot)
          (storage_type, None, storage_annot) None
          (Pervasives.op_pipepipe (has_big_map arg_type)
            (has_big_map storage_type)) in
      let ret_type_full :=
        Script_typed_ir.Pair_t
          ((Script_typed_ir.List_t (Script_typed_ir.Operation_t None) None false),
            None, None) (storage_type, None, None) None
          (has_big_map storage_type) in
      let=? function_parameter :=
        Error_monad.trace extensible_type_value
          (parse_returning __type_logger_value
            (Toplevel
              {| tc_context.Toplevel.storage_type := storage_type;
                tc_context.Toplevel.param_type := arg_type;
                tc_context.Toplevel.root_name := root_name;
                tc_context.Toplevel.legacy_create_contract_literal := true |})
            ctxt legacy (arg_type_full, None) ret_type_full code_field) in
      match function_parameter with
      |
        ({|
          Script_typed_ir.lambda.lam :=
            ({|
              Script_typed_ir.descr.bef :=
                Script_typed_ir.Item_t arg
                  Script_typed_ir.Empty_t _;
                Script_typed_ir.descr.aft :=
                  Script_typed_ir.Item_t ret
                    Script_typed_ir.Empty_t
                    _
                |}, _)
            |} as lambda, ctxt) =&gt;
        let=? '(Eq, ctxt) := Lwt.__return (ty_eq ctxt arg arg_type_full) in
        let=? '(_, ctxt) :=
          Lwt.__return (merge_types legacy ctxt loc arg arg_type_full) in
        let=? '(Eq, ctxt) := Lwt.__return (ty_eq ctxt ret ret_type_full) in
        let=? '(_, ctxt) :=
          Lwt.__return (merge_types legacy ctxt loc ret ret_type_full) in
        let=? '(Eq, ctxt) := Lwt.__return (ty_eq ctxt storage_type ginit) in
        let=? '(_, ctxt) :=
          Lwt.__return (merge_types legacy ctxt loc storage_type ginit) in
        typed ctxt loc
          (Script_typed_ir.Create_contract storage_type arg_type lambda
            root_name)
          (Script_typed_ir.Item_t (Script_typed_ir.Operation_t None)
            (Script_typed_ir.Item_t (Script_typed_ir.Address_t None) rest
              addr_annot) op_annot)
      | _ =&gt; unreachable_gadt_branch
      end
    else
      Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CREATE_CONTRACT
      (cons ((Micheline.Seq _ _) as code) []) annot,
      Script_typed_ir.Item_t
        (Script_typed_ir.Option_t (Script_typed_ir.Key_hash_t _) _ _)
        (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t _)
          (Script_typed_ir.Item_t ginit rest _) _) _), _) =&gt;
    let=? '(op_annot, addr_annot) := parse_two_var_annot loc annot in
    let cannonical_code := Pervasives.fst (Micheline.extract_locations code) in
    let=? '(arg_type, storage_type, code_field, root_name) :=
      Lwt.__return (parse_toplevel legacy cannonical_code) in
    let=? '(Ex_ty arg_type, ctxt) :=
      Error_monad.trace extensible_type_value
        (Lwt.__return (parse_parameter_ty ctxt legacy arg_type)) in
    let=? '_ :=
      if legacy then
        Error_monad.__return tt
      else
        Lwt.__return (well_formed_entrypoints arg_type root_name) in
    let=? '(Ex_ty storage_type, ctxt) :=
      Error_monad.trace extensible_type_value
        (Lwt.__return (parse_storage_ty ctxt legacy storage_type)) in
    let arg_annot :=
      Script_ir_annot.default_annot Script_ir_annot.default_param_annot
        (Script_ir_annot.type_to_var_annot (name_of_ty arg_type)) in
    let storage_annot :=
      Script_ir_annot.default_annot Script_ir_annot.default_storage_annot
        (Script_ir_annot.type_to_var_annot (name_of_ty storage_type)) in
    let arg_type_full :=
      Script_typed_ir.Pair_t (arg_type, None, arg_annot)
        (storage_type, None, storage_annot) None
        (Pervasives.op_pipepipe (has_big_map arg_type)
          (has_big_map storage_type)) in
    let ret_type_full :=
      Script_typed_ir.Pair_t
        ((Script_typed_ir.List_t (Script_typed_ir.Operation_t None) None false),
          None, None) (storage_type, None, None) None (has_big_map storage_type)
      in
    let=? function_parameter :=
      Error_monad.trace extensible_type_value
        (parse_returning __type_logger_value
          (Toplevel
            {| tc_context.Toplevel.storage_type := storage_type;
              tc_context.Toplevel.param_type := arg_type;
              tc_context.Toplevel.root_name := root_name;
              tc_context.Toplevel.legacy_create_contract_literal := false |})
          ctxt legacy (arg_type_full, None) ret_type_full code_field) in
    match function_parameter with
    |
      ({|
        Script_typed_ir.lambda.lam :=
          ({|
            Script_typed_ir.descr.bef :=
              Script_typed_ir.Item_t arg Script_typed_ir.Empty_t _;
              Script_typed_ir.descr.aft :=
                Script_typed_ir.Item_t ret
                  Script_typed_ir.Empty_t
                  _
              |}, _)
          |} as lambda, ctxt) =&gt;
      let=? '(Eq, ctxt) := Lwt.__return (ty_eq ctxt arg arg_type_full) in
      let=? '(_, ctxt) :=
        Lwt.__return (merge_types legacy ctxt loc arg arg_type_full) in
      let=? '(Eq, ctxt) := Lwt.__return (ty_eq ctxt ret ret_type_full) in
      let=? '(_, ctxt) :=
        Lwt.__return (merge_types legacy ctxt loc ret ret_type_full) in
      let=? '(Eq, ctxt) := Lwt.__return (ty_eq ctxt storage_type ginit) in
      let=? '(_, ctxt) :=
        Lwt.__return (merge_types legacy ctxt loc storage_type ginit) in
      typed ctxt loc
        (Script_typed_ir.Create_contract_2 storage_type arg_type lambda
          root_name)
        (Script_typed_ir.Item_t (Script_typed_ir.Operation_t None)
          (Script_typed_ir.Item_t (Script_typed_ir.Address_t None) rest
            addr_annot) op_annot)
    | _ =&gt; unreachable_gadt_branch
    end
  | ((Micheline.Prim loc Alpha_context.Script.I_NOW [] annot, __stack_value), _)
    =&gt;
    let=? annot :=
      parse_var_annot loc (Some Script_ir_annot.default_now_annot) annot in
    typed ctxt loc Script_typed_ir.Now
      (Script_typed_ir.Item_t (Script_typed_ir.Timestamp_t None) __stack_value
        annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_AMOUNT [] annot, __stack_value),
      _) =&gt;
    let=? annot :=
      parse_var_annot loc (Some Script_ir_annot.default_amount_annot) annot in
    typed ctxt loc Script_typed_ir.Amount
      (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t None) __stack_value annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CHAIN_ID [] annot, __stack_value),
      _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.ChainId
      (Script_typed_ir.Item_t (Script_typed_ir.Chain_id_t None) __stack_value
        annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_BALANCE [] annot, __stack_value),
      _) =&gt;
    let=? annot :=
      parse_var_annot loc (Some Script_ir_annot.default_balance_annot) annot in
    typed ctxt loc Script_typed_ir.Balance
      (Script_typed_ir.Item_t (Script_typed_ir.Mutez_t None) __stack_value annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_HASH_KEY [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Key_t _) rest _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Hash_key
      (Script_typed_ir.Item_t (Script_typed_ir.Key_hash_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CHECK_SIGNATURE [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Key_t _)
        (Script_typed_ir.Item_t (Script_typed_ir.Signature_t _)
          (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t _) rest _) _) _), _)
    =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Check_signature
      (Script_typed_ir.Item_t (Script_typed_ir.Bool_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_BLAKE2B [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Bytes_t _) rest _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Blake2b
      (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SHA256 [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Bytes_t _) rest _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Sha256
      (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SHA512 [] annot,
      Script_typed_ir.Item_t (Script_typed_ir.Bytes_t _) rest _), _) =&gt;
    let=? annot := parse_var_annot loc None annot in
    typed ctxt loc Script_typed_ir.Sha512
      (Script_typed_ir.Item_t (Script_typed_ir.Bytes_t None) rest annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_STEPS_TO_QUOTA [] annot,
      __stack_value), _) =&gt;
    if legacy then
      let=? annot :=
        parse_var_annot loc (Some Script_ir_annot.default_steps_annot) annot in
      typed ctxt loc Script_typed_ir.Steps_to_quota
        (Script_typed_ir.Item_t (Script_typed_ir.Nat_t None) __stack_value annot)
    else
      Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SOURCE [] annot, __stack_value),
      _) =&gt;
    let=? annot :=
      parse_var_annot loc (Some Script_ir_annot.default_source_annot) annot in
    typed ctxt loc Script_typed_ir.Source
      (Script_typed_ir.Item_t (Script_typed_ir.Address_t None) __stack_value
        annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SENDER [] annot, __stack_value),
      _) =&gt;
    let=? annot :=
      parse_var_annot loc (Some Script_ir_annot.default_sender_annot) annot in
    typed ctxt loc Script_typed_ir.Sender
      (Script_typed_ir.Item_t (Script_typed_ir.Address_t None) __stack_value
        annot)
  |
    ((Micheline.Prim loc Alpha_context.Script.I_SELF [] annot, __stack_value), _)
    =&gt;
    let=? '(annot, entrypoint) :=
      parse_entrypoint_annot loc (Some Script_ir_annot.default_self_annot) annot
      in
    let entrypoint :=
      Option.unopt_map
        (fun function_parameter =&gt;
          let 'Script_typed_ir.Field_annot annot := function_parameter in
          annot) &quot;default&quot; entrypoint in
    let fix get_toplevel_type (function_parameter : tc_context)
      {struct function_parameter}
      : Lwt.t (Error_monad.tzresult (judgement * Alpha_context.context)) :=
      match function_parameter with
      | Lambda =&gt; Error_monad.fail extensible_type_value
      | Dip _ prev =&gt; get_toplevel_type prev
      |
        Toplevel {|
          tc_context.Toplevel.param_type := param_type;
            tc_context.Toplevel.root_name := root_name;
            tc_context.Toplevel.legacy_create_contract_literal := false
            |} =&gt;
        let=? '(_, Ex_ty param_type) :=
          Lwt.__return (find_entrypoint param_type root_name entrypoint) in
        typed ctxt loc (Script_typed_ir.Self param_type entrypoint)
          (Script_typed_ir.Item_t (Script_typed_ir.Contract_t param_type None)
            __stack_value annot)
      |
        Toplevel {|
          tc_context.Toplevel.param_type := param_type;
            tc_context.Toplevel.root_name := _;
            tc_context.Toplevel.legacy_create_contract_literal := true
            |} =&gt;
        typed ctxt loc (Script_typed_ir.Self param_type &quot;default&quot;)
          (Script_typed_ir.Item_t (Script_typed_ir.Contract_t param_type None)
            __stack_value annot)
      end in
    get_toplevel_type __tc_context_value
  |
    ((Micheline.Prim loc
      ((Alpha_context.Script.I_DUP | Alpha_context.Script.I_SWAP |
      Alpha_context.Script.I_SOME | Alpha_context.Script.I_UNIT |
      Alpha_context.Script.I_PAIR | Alpha_context.Script.I_CAR |
      Alpha_context.Script.I_CDR | Alpha_context.Script.I_CONS |
      Alpha_context.Script.I_CONCAT | Alpha_context.Script.I_SLICE |
      Alpha_context.Script.I_MEM | Alpha_context.Script.I_UPDATE |
      Alpha_context.Script.I_MAP | Alpha_context.Script.I_GET |
      Alpha_context.Script.I_EXEC | Alpha_context.Script.I_FAILWITH |
      Alpha_context.Script.I_SIZE | Alpha_context.Script.I_ADD |
      Alpha_context.Script.I_SUB | Alpha_context.Script.I_MUL |
      Alpha_context.Script.I_EDIV | Alpha_context.Script.I_OR |
      Alpha_context.Script.I_AND | Alpha_context.Script.I_XOR |
      Alpha_context.Script.I_NOT | Alpha_context.Script.I_ABS |
      Alpha_context.Script.I_NEG | Alpha_context.Script.I_LSL |
      Alpha_context.Script.I_LSR | Alpha_context.Script.I_COMPARE |
      Alpha_context.Script.I_EQ | Alpha_context.Script.I_NEQ |
      Alpha_context.Script.I_LT | Alpha_context.Script.I_GT |
      Alpha_context.Script.I_LE | Alpha_context.Script.I_GE |
      Alpha_context.Script.I_TRANSFER_TOKENS |
      Alpha_context.Script.I_CREATE_ACCOUNT |
      Alpha_context.Script.I_SET_DELEGATE | Alpha_context.Script.I_NOW |
      Alpha_context.Script.I_IMPLICIT_ACCOUNT | Alpha_context.Script.I_AMOUNT |
      Alpha_context.Script.I_BALANCE | Alpha_context.Script.I_CHECK_SIGNATURE |
      Alpha_context.Script.I_HASH_KEY | Alpha_context.Script.I_SOURCE |
      Alpha_context.Script.I_SENDER | Alpha_context.Script.I_BLAKE2B |
      Alpha_context.Script.I_SHA256 | Alpha_context.Script.I_SHA512 |
      Alpha_context.Script.I_STEPS_TO_QUOTA | Alpha_context.Script.I_ADDRESS) as
        name) ((cons _ _) as l) _, _), _) =&gt;
    Error_monad.fail extensible_type_value
  |
    (((Micheline.Prim loc
      ((Alpha_context.Script.I_NONE | Alpha_context.Script.I_LEFT |
      Alpha_context.Script.I_RIGHT | Alpha_context.Script.I_NIL |
      Alpha_context.Script.I_ITER | Alpha_context.Script.I_EMPTY_SET |
      Alpha_context.Script.I_LOOP | Alpha_context.Script.I_LOOP_LEFT |
      Alpha_context.Script.I_CONTRACT) as name) (([] | cons _ (cons _ _)) as l)
      _, _) |
    (Micheline.Prim loc (Alpha_context.Script.I_MAP as name) ([] as l) _, _) |
    (Micheline.Prim loc (Alpha_context.Script.I_DIP as name)
      ((cons _ (cons _ _)) as l) _, _)), _) =&gt;
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc
      ((Alpha_context.Script.I_PUSH | Alpha_context.Script.I_IF_NONE |
      Alpha_context.Script.I_IF_LEFT | Alpha_context.Script.I_IF_CONS |
      Alpha_context.Script.I_EMPTY_MAP | Alpha_context.Script.I_IF) as name)
      (([] | cons _ [] | cons _ (cons _ (cons _ _))) as l) _, _), _) =&gt;
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_LAMBDA
      (([] | cons _ [] | cons _ (cons _ (cons _ (cons _ _)))) as l) _, _), _) =&gt;
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc
      ((Alpha_context.Script.I_ADD | Alpha_context.Script.I_SUB |
      Alpha_context.Script.I_MUL | Alpha_context.Script.I_EDIV |
      Alpha_context.Script.I_AND | Alpha_context.Script.I_OR |
      Alpha_context.Script.I_XOR | Alpha_context.Script.I_LSL |
      Alpha_context.Script.I_LSR) as name) [] _,
      Script_typed_ir.Item_t ta (Script_typed_ir.Item_t tb _ _) _), _) =&gt;
    let=? '(ta, ctxt) := Lwt.__return (serialize_ty_for_error ctxt ta) in
    let=? '(tb, _ctxt) := Lwt.__return (serialize_ty_for_error ctxt tb) in
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc
      ((Alpha_context.Script.I_NEG | Alpha_context.Script.I_ABS |
      Alpha_context.Script.I_NOT | Alpha_context.Script.I_CONCAT |
      Alpha_context.Script.I_SIZE | Alpha_context.Script.I_EQ |
      Alpha_context.Script.I_NEQ | Alpha_context.Script.I_LT |
      Alpha_context.Script.I_GT | Alpha_context.Script.I_LE |
      Alpha_context.Script.I_GE) as name) [] _,
      Script_typed_ir.Item_t __t_value _ _), _) =&gt;
    let=? '(__t_value, _ctxt) :=
      Lwt.__return (serialize_ty_for_error ctxt __t_value) in
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc
      ((Alpha_context.Script.I_UPDATE | Alpha_context.Script.I_SLICE) as name)
      [] _, __stack_value), _) =&gt;
    let=? '(__stack_value, _ctxt) :=
      serialize_stack_for_error ctxt __stack_value in
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CREATE_CONTRACT _ _,
      __stack_value), _) =&gt;
    let=? '(__stack_value, _ctxt) :=
      serialize_stack_for_error ctxt __stack_value in
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_CREATE_ACCOUNT [] _,
      __stack_value), _) =&gt;
    let=? '(__stack_value, _ctxt) :=
      serialize_stack_for_error ctxt __stack_value in
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc Alpha_context.Script.I_TRANSFER_TOKENS [] _,
      __stack_value), _) =&gt;
    let=? '(__stack_value, _ctxt) :=
      serialize_stack_for_error ctxt __stack_value in
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc
      ((Alpha_context.Script.I_DROP | Alpha_context.Script.I_DUP |
      Alpha_context.Script.I_CAR | Alpha_context.Script.I_CDR |
      Alpha_context.Script.I_SOME | Alpha_context.Script.I_BLAKE2B |
      Alpha_context.Script.I_SHA256 | Alpha_context.Script.I_SHA512 |
      Alpha_context.Script.I_DIP | Alpha_context.Script.I_IF_NONE |
      Alpha_context.Script.I_LEFT | Alpha_context.Script.I_RIGHT |
      Alpha_context.Script.I_IF_LEFT | Alpha_context.Script.I_IF |
      Alpha_context.Script.I_LOOP | Alpha_context.Script.I_IF_CONS |
      Alpha_context.Script.I_IMPLICIT_ACCOUNT | Alpha_context.Script.I_NEG |
      Alpha_context.Script.I_ABS | Alpha_context.Script.I_INT |
      Alpha_context.Script.I_NOT | Alpha_context.Script.I_HASH_KEY |
      Alpha_context.Script.I_EQ | Alpha_context.Script.I_NEQ |
      Alpha_context.Script.I_LT | Alpha_context.Script.I_GT |
      Alpha_context.Script.I_LE | Alpha_context.Script.I_GE) as name) _ _,
      __stack_value), _) =&gt;
    let=? '(__stack_value, _ctxt) :=
      serialize_stack_for_error ctxt __stack_value in
    Error_monad.fail extensible_type_value
  |
    ((Micheline.Prim loc
      ((Alpha_context.Script.I_SWAP | Alpha_context.Script.I_PAIR |
      Alpha_context.Script.I_CONS | Alpha_context.Script.I_GET |
      Alpha_context.Script.I_MEM | Alpha_context.Script.I_EXEC |
      Alpha_context.Script.I_CHECK_SIGNATURE | Alpha_context.Script.I_ADD |
      Alpha_context.Script.I_SUB | Alpha_context.Script.I_MUL |
      Alpha_context.Script.I_EDIV | Alpha_context.Script.I_AND |
      Alpha_context.Script.I_OR | Alpha_context.Script.I_XOR |
      Alpha_context.Script.I_LSL | Alpha_context.Script.I_LSR) as name) _ _,
      __stack_value), _) =&gt;
    let=? '(__stack_value, _ctxt) :=
      serialize_stack_for_error ctxt __stack_value in
    Error_monad.fail extensible_type_value
  | ((expr, _), _) =&gt;
    Error_monad.fail
      (unexpected expr [ Script_tc_errors.Seq_kind ]
        Script_tc_errors.Instr_namespace
        [
          Alpha_context.Script.I_DROP;
          Alpha_context.Script.I_DUP;
          Alpha_context.Script.I_DIG;
          Alpha_context.Script.I_DUG;
          Alpha_context.Script.I_SWAP;
          Alpha_context.Script.I_SOME;
          Alpha_context.Script.I_UNIT;
          Alpha_context.Script.I_PAIR;
          Alpha_context.Script.I_CAR;
          Alpha_context.Script.I_CDR;
          Alpha_context.Script.I_CONS;
          Alpha_context.Script.I_MEM;
          Alpha_context.Script.I_UPDATE;
          Alpha_context.Script.I_MAP;
          Alpha_context.Script.I_ITER;
          Alpha_context.Script.I_GET;
          Alpha_context.Script.I_EXEC;
          Alpha_context.Script.I_FAILWITH;
          Alpha_context.Script.I_SIZE;
          Alpha_context.Script.I_CONCAT;
          Alpha_context.Script.I_ADD;
          Alpha_context.Script.I_SUB;
          Alpha_context.Script.I_MUL;
          Alpha_context.Script.I_EDIV;
          Alpha_context.Script.I_OR;
          Alpha_context.Script.I_AND;
          Alpha_context.Script.I_XOR;
          Alpha_context.Script.I_NOT;
          Alpha_context.Script.I_ABS;
          Alpha_context.Script.I_INT;
          Alpha_context.Script.I_NEG;
          Alpha_context.Script.I_LSL;
          Alpha_context.Script.I_LSR;
          Alpha_context.Script.I_COMPARE;
          Alpha_context.Script.I_EQ;
          Alpha_context.Script.I_NEQ;
          Alpha_context.Script.I_LT;
          Alpha_context.Script.I_GT;
          Alpha_context.Script.I_LE;
          Alpha_context.Script.I_GE;
          Alpha_context.Script.I_TRANSFER_TOKENS;
          Alpha_context.Script.I_CREATE_ACCOUNT;
          Alpha_context.Script.I_CREATE_CONTRACT;
          Alpha_context.Script.I_NOW;
          Alpha_context.Script.I_AMOUNT;
          Alpha_context.Script.I_BALANCE;
          Alpha_context.Script.I_IMPLICIT_ACCOUNT;
          Alpha_context.Script.I_CHECK_SIGNATURE;
          Alpha_context.Script.I_BLAKE2B;
          Alpha_context.Script.I_SHA256;
          Alpha_context.Script.I_SHA512;
          Alpha_context.Script.I_HASH_KEY;
          Alpha_context.Script.I_STEPS_TO_QUOTA;
          Alpha_context.Script.I_PUSH;
          Alpha_context.Script.I_NONE;
          Alpha_context.Script.I_LEFT;
          Alpha_context.Script.I_RIGHT;
          Alpha_context.Script.I_NIL;
          Alpha_context.Script.I_EMPTY_SET;
          Alpha_context.Script.I_DIP;
          Alpha_context.Script.I_LOOP;
          Alpha_context.Script.I_IF_NONE;
          Alpha_context.Script.I_IF_LEFT;
          Alpha_context.Script.I_IF_CONS;
          Alpha_context.Script.I_EMPTY_MAP;
          Alpha_context.Script.I_IF;
          Alpha_context.Script.I_SOURCE;
          Alpha_context.Script.I_SENDER;
          Alpha_context.Script.I_SELF;
          Alpha_context.Script.I_LAMBDA
        ])
  end.

Definition parse_contract_for_script
  (legacy : bool) (ctxt : Alpha_context.context)
  (loc : Alpha_context.Script.location) (arg : Script_typed_ir.ty)
  (contract : Alpha_context.Contract.t) (entrypoint : string)
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context * option Script_typed_ir.typed_contract)) :=
  let=? ctxt :=
    Lwt.__return
      (Alpha_context.Gas.consume ctxt Typecheck_costs.contract_exists) in
  let=? function_parameter := Alpha_context.Contract.__exists ctxt contract in
  match function_parameter with
  | false =&gt; Error_monad.__return (ctxt, None)
  | true =&gt;
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.get_script)
      in
    let=? '(ctxt, code) :=
      (Error_monad.trace extensible_type_value)
        (Alpha_context.Contract.get_script_code ctxt contract) in
    match code with
    | None =&gt;
      match entrypoint with
      | &quot;default&quot; =&gt;
        Lwt.__return
          match ty_eq ctxt arg (Script_typed_ir.Unit_t None) with
          | Pervasives.Ok (Eq, ctxt) =&gt;
            let contract := (arg, (contract, entrypoint)) in
            Error_monad.ok (ctxt, (Some contract))
          | Pervasives.Error _ =&gt;
            let? ctxt := Alpha_context.Gas.consume ctxt Typecheck_costs.cycle in
            Error_monad.ok (ctxt, None)
          end
      | _ =&gt; Error_monad.__return (ctxt, None)
      end
    | Some code =&gt;
      let=? '(code, ctxt) :=
        Alpha_context.Script.force_decode_in_context ctxt code in
      Lwt.__return
        match parse_toplevel true code with
        | Pervasives.Error _ =&gt; Error_monad.__error_value extensible_type_value
        | Pervasives.Ok (arg_type, _, _, root_name) =&gt;
          match parse_parameter_ty ctxt true arg_type with
          | Pervasives.Error _ =&gt;
            Error_monad.__error_value extensible_type_value
          | Pervasives.Ok (Ex_ty targ, ctxt) =&gt;
            let __result_value :=
              let? '(ctxt, entrypoint, targ) :=
                find_entrypoint_for_type targ arg root_name entrypoint ctxt in
              let? '(targ, ctxt) := merge_types legacy ctxt loc targ arg in
              let? '(arg, ctxt) := merge_types legacy ctxt loc targ arg in
              let contract := (arg, (contract, entrypoint)) in
              Error_monad.ok (ctxt, (Some contract)) in
            match __result_value with
            | Pervasives.Ok res =&gt; Error_monad.ok res
            | Pervasives.Error _ =&gt;
              let? '(Eq, ctxt) := ty_eq ctxt targ targ in
              let? '(_, ctxt) := merge_types legacy ctxt loc targ targ in
              Error_monad.ok (ctxt, None)
            end
          end
        end
    end
  end.

Definition parse_script
  (__type_logger_value : option type_logger) (ctxt : Alpha_context.context)
  (legacy : bool) (function_parameter : Alpha_context.Script.t)
  : Lwt.t (Error_monad.tzresult (ex_script * Alpha_context.context)) :=
  let '{|
    Alpha_context.Script.t.code := code;
      Alpha_context.Script.t.storage := storage
      |} := function_parameter in
  let=? '(code, ctxt) := Alpha_context.Script.force_decode_in_context ctxt code
    in
  let=? '(storage, ctxt) :=
    Alpha_context.Script.force_decode_in_context ctxt storage in
  let=? '(arg_type, storage_type, code_field, root_name) :=
    Lwt.__return (parse_toplevel legacy code) in
  let=? '(Ex_ty arg_type, ctxt) :=
    Error_monad.trace extensible_type_value
      (Lwt.__return (parse_parameter_ty ctxt legacy arg_type)) in
  let=? '_ :=
    if legacy then
      Error_monad.__return tt
    else
      Lwt.__return (well_formed_entrypoints arg_type root_name) in
  let=? '(Ex_ty storage_type, ctxt) :=
    Error_monad.trace extensible_type_value
      (Lwt.__return (parse_storage_ty ctxt legacy storage_type)) in
  let arg_annot :=
    Script_ir_annot.default_annot Script_ir_annot.default_param_annot
      (Script_ir_annot.type_to_var_annot (name_of_ty arg_type)) in
  let storage_annot :=
    Script_ir_annot.default_annot Script_ir_annot.default_storage_annot
      (Script_ir_annot.type_to_var_annot (name_of_ty storage_type)) in
  let arg_type_full :=
    Script_typed_ir.Pair_t (arg_type, None, arg_annot)
      (storage_type, None, storage_annot) None
      (Pervasives.op_pipepipe (has_big_map arg_type) (has_big_map storage_type))
    in
  let ret_type_full :=
    Script_typed_ir.Pair_t
      ((Script_typed_ir.List_t (Script_typed_ir.Operation_t None) None false),
        None, None) (storage_type, None, None) None (has_big_map storage_type)
    in
  let=? '(storage, ctxt) :=
    Error_monad.trace_eval
      (fun function_parameter =&gt;
        let '_ := function_parameter in
        Error_monad.op_gtgtpipequestion
          (Lwt.__return (serialize_ty_for_error ctxt storage_type))
          (fun function_parameter =&gt;
            let '(storage_type, _ctxt) := function_parameter in
            extensible_type_value))
      (parse_data __type_logger_value ctxt legacy storage_type
        (Micheline.root storage)) in
  let=? '(code, ctxt) :=
    Error_monad.trace extensible_type_value
      (parse_returning __type_logger_value
        (Toplevel
          {| tc_context.Toplevel.storage_type := storage_type;
            tc_context.Toplevel.param_type := arg_type;
            tc_context.Toplevel.root_name := root_name;
            tc_context.Toplevel.legacy_create_contract_literal := false |}) ctxt
        legacy (arg_type_full, None) ret_type_full code_field) in
  Error_monad.__return
    ((Ex_script (c := unit)
      {| Script_typed_ir.script.code := code;
        Script_typed_ir.script.arg_type := arg_type;
        Script_typed_ir.script.storage := storage;
        Script_typed_ir.script.storage_type := storage_type;
        Script_typed_ir.script.root_name := root_name |}), ctxt).

Definition typecheck_code
  (ctxt : Alpha_context.context) (code : Alpha_context.Script.expr)
  : Lwt.t
    (Error_monad.tzresult (Script_tc_errors.type_map * Alpha_context.context)) :=
  let legacy := false in
  let=? '(arg_type, storage_type, code_field, root_name) :=
    Lwt.__return (parse_toplevel legacy code) in
  let type_map := Pervasives.__ref_value nil in
  let=? '(Ex_ty arg_type, ctxt) :=
    Error_monad.trace extensible_type_value
      (Lwt.__return (parse_parameter_ty ctxt legacy arg_type)) in
  let=? '_ :=
    if legacy then
      Error_monad.__return tt
    else
      Lwt.__return (well_formed_entrypoints arg_type root_name) in
  let=? '(Ex_ty storage_type, ctxt) :=
    Error_monad.trace extensible_type_value
      (Lwt.__return (parse_storage_ty ctxt legacy storage_type)) in
  let arg_annot :=
    Script_ir_annot.default_annot Script_ir_annot.default_param_annot
      (Script_ir_annot.type_to_var_annot (name_of_ty arg_type)) in
  let storage_annot :=
    Script_ir_annot.default_annot Script_ir_annot.default_storage_annot
      (Script_ir_annot.type_to_var_annot (name_of_ty storage_type)) in
  let arg_type_full :=
    Script_typed_ir.Pair_t (arg_type, None, arg_annot)
      (storage_type, None, storage_annot) None
      (Pervasives.op_pipepipe (has_big_map arg_type) (has_big_map storage_type))
    in
  let ret_type_full :=
    Script_typed_ir.Pair_t
      ((Script_typed_ir.List_t (Script_typed_ir.Operation_t None) None false),
        None, None) (storage_type, None, None) None (has_big_map storage_type)
    in
  let __result_value :=
    parse_returning
      (Some
        (fun loc =&gt;
          fun bef =&gt;
            fun aft =&gt;
              Pervasives.op_coloneq type_map
                (cons (loc, (bef, aft)) (Pervasives.op_exclamation type_map))))
      (Toplevel
        {| tc_context.Toplevel.storage_type := storage_type;
          tc_context.Toplevel.param_type := arg_type;
          tc_context.Toplevel.root_name := root_name;
          tc_context.Toplevel.legacy_create_contract_literal := false |}) ctxt
      legacy (arg_type_full, None) ret_type_full code_field in
  let=? '({| Script_typed_ir.lambda.lam := _ |}, ctxt) :=
    Error_monad.trace extensible_type_value __result_value in
  Error_monad.__return ((Pervasives.op_exclamation type_map), ctxt).

Definition typecheck_data
  (__type_logger_value : option type_logger) (ctxt : Alpha_context.context)
  (function_parameter : Alpha_context.Script.expr * Alpha_context.Script.expr)
  : Lwt.t (Error_monad.tzresult Alpha_context.context) :=
  let '(data, exp_ty) := function_parameter in
  let legacy := false in
  let=? '(Ex_ty exp_ty, ctxt) :=
    Error_monad.trace extensible_type_value
      (Lwt.__return (parse_packable_ty ctxt legacy (Micheline.root exp_ty))) in
  let=? '(_, ctxt) :=
    Error_monad.trace_eval
      (fun function_parameter =&gt;
        let '_ := function_parameter in
        Error_monad.op_gtgtpipequestion
          (Lwt.__return (serialize_ty_for_error ctxt exp_ty))
          (fun function_parameter =&gt;
            let '(exp_ty, _ctxt) := function_parameter in
            extensible_type_value))
      ((parse_data (a := unit)) __type_logger_value ctxt legacy exp_ty
        (Micheline.root data)) in
  Error_monad.__return ctxt.

Definition Entrypoints_map :=
  Map.Make
    (existT (A := Set) _ _
      {|
        Compare.COMPARABLE.compare := String.compare
      |}).

Definition list_entrypoints
  (full : Script_typed_ir.ty) (ctxt : Alpha_context.context)
  (root_name : option (|Entrypoints_map|).(S.MAP.key))
  : Error_monad.tzresult
    (list (list Alpha_context.Script.prim) *
      (|Entrypoints_map|).(S.MAP.t)
        (list Alpha_context.Script.prim * Alpha_context.Script.node)) :=
  let merge {A : Set}
    (path : list A) (annot : option Script_typed_ir.field_annot)
    (ty : Script_typed_ir.ty) (reachable : bool)
    (function_parameter :
      list (list A) *
        (|Entrypoints_map|).(S.MAP.t) (list A * Alpha_context.Script.node))
    : Error_monad.tzresult
      (list (list A) *
        (|Entrypoints_map|).(S.MAP.t) (list A * Alpha_context.Script.node)) :=
    let '(unreachables, all) as acc := function_parameter in
    match annot with
    | (None | Some (Script_typed_ir.Field_annot &quot;&quot;)) =&gt;
      Error_monad.ok
        (if reachable then
          acc
        else
          match ty with
          | Script_typed_ir.Union_t _ _ _ _ =&gt; acc
          | _ =&gt; ((cons (List.rev path) unreachables), all)
          end)
    | Some (Script_typed_ir.Field_annot name) =&gt;
      if (|Compare.Int|).(Compare.S.op_gt) (String.length name) 31 then
        Error_monad.ok ((cons (List.rev path) unreachables), all)
      else
        if (|Entrypoints_map|).(S.MAP.mem) name all then
          Error_monad.ok ((cons (List.rev path) unreachables), all)
        else
          let? '(unparsed_ty, _) := unparse_ty_no_lwt ctxt ty in
          Error_monad.ok
            (unreachables,
              ((|Entrypoints_map|).(S.MAP.add) name
                ((List.rev path), unparsed_ty) all))
    end in
  let fix fold_tree
    (__t_value : Script_typed_ir.ty) (path : list Alpha_context.Script.prim)
    (reachable : bool)
    (acc :
      list (list Alpha_context.Script.prim) *
        (|Entrypoints_map|).(S.MAP.t)
          (list Alpha_context.Script.prim * Alpha_context.Script.node))
    {struct __t_value}
    : Error_monad.tzresult
      (list (list Alpha_context.Script.prim) *
        (|Entrypoints_map|).(S.MAP.t)
          (list Alpha_context.Script.prim * Alpha_context.Script.node)) :=
    match __t_value with
    | Script_typed_ir.Union_t (tl, al) (tr, ar) _ _ =&gt;
      let? acc :=
        merge (cons Alpha_context.Script.D_Left path) al tl reachable acc in
      let? acc :=
        merge (cons Alpha_context.Script.D_Right path) ar tr reachable acc in
      let? acc :=
        fold_tree tl (cons Alpha_context.Script.D_Left path)
          match al with
          | Some _ =&gt; true
          | None =&gt; reachable
          end acc in
      fold_tree tr (cons Alpha_context.Script.D_Right path)
        match ar with
        | Some _ =&gt; true
        | None =&gt; reachable
        end acc
    | _ =&gt; Error_monad.ok acc
    end in
  let? '(unparsed_full, _) := unparse_ty_no_lwt ctxt full in
  let '(init, reachable) :=
    match root_name with
    | (None | Some &quot;&quot;) =&gt; ((|Entrypoints_map|).(S.MAP.empty), false)
    | Some name =&gt;
      (((|Entrypoints_map|).(S.MAP.singleton) name (nil, unparsed_full)), true)
    end in
  fold_tree full nil reachable (nil, init).

Fixpoint unparse_data {a : Set}
  (ctxt : Alpha_context.context) (mode : unparsing_mode)
  (ty : Script_typed_ir.ty) (__a_value : a) {struct ty}
  : Lwt.t
    (Error_monad.tzresult (Alpha_context.Script.node * Alpha_context.context)) :=
  let=? ctxt :=
    Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.cycle) in
  match (ty, __a_value) with
  | (Script_typed_ir.Unit_t _, _) =&gt;
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.__unit_value)
      in
    Error_monad.__return
      ((Micheline.Prim (-1) Alpha_context.Script.D_Unit nil nil), ctxt)
  
  | (Script_typed_ir.Int_t _, _ as v) =&gt;
    let v := cast Alpha_context.Script_int.num v in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt (Unparse_costs.__int_value v)) in
    Error_monad.__return
      ((Micheline.Int (-1) (Alpha_context.Script_int.to_zint v)), ctxt)
  
  | (Script_typed_ir.Nat_t _, _ as v) =&gt;
    let v := cast Alpha_context.Script_int.num v in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt (Unparse_costs.__int_value v)) in
    Error_monad.__return
      ((Micheline.Int (-1) (Alpha_context.Script_int.to_zint v)), ctxt)
  
  | (Script_typed_ir.String_t _, _ as s) =&gt;
    let s := cast string s in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt (Unparse_costs.__string_value s)) in
    Error_monad.__return ((Micheline.String (-1) s), ctxt)
  
  | (Script_typed_ir.Bytes_t _, _ as s) =&gt;
    let s := cast MBytes.t s in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt (Unparse_costs.__bytes_value s)) in
    Error_monad.__return ((Micheline.Bytes (-1) s), ctxt)
  
  | (Script_typed_ir.Bool_t _, _ as __b_value) =&gt;
    let __b_value := cast bool __b_value in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.__bool_value)
      in
    if __b_value then
      Error_monad.__return
        ((Micheline.Prim (-1) Alpha_context.Script.D_True nil nil), ctxt)
    else
      Error_monad.__return
        ((Micheline.Prim (-1) Alpha_context.Script.D_False nil nil), ctxt)
  
  | (Script_typed_ir.Timestamp_t _, _ as __t_value) =&gt;
    let __t_value := cast Alpha_context.Script_timestamp.t __t_value in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt (Unparse_costs.timestamp __t_value)) in
    match mode with
    | Optimized =&gt;
      Error_monad.__return
        ((Micheline.Int (-1) (Alpha_context.Script_timestamp.to_zint __t_value)),
          ctxt)
    | Readable =&gt;
      match Alpha_context.Script_timestamp.to_notation __t_value with
      | None =&gt;
        Error_monad.__return
          ((Micheline.Int (-1)
            (Alpha_context.Script_timestamp.to_zint __t_value)), ctxt)
      | Some s =&gt; Error_monad.__return ((Micheline.String (-1) s), ctxt)
      end
    end
  
  | (Script_typed_ir.Address_t _, _ as __a_value) =&gt;
    let __a_value := cast Script_typed_ir.address __a_value in
    let '(c, entrypoint) := __a_value in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.contract) in
    match mode with
    | Optimized =&gt;
      let entrypoint :=
        match entrypoint with
        | &quot;default&quot; =&gt; &quot;&quot;
        | name =&gt; name
        end in
      let __bytes_value :=
        Data_encoding.Binary.to_bytes_exn
          (Data_encoding.tup2 Alpha_context.Contract.encoding
            Data_encoding.__Variable.__string_value) (c, entrypoint) in
      Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt)
    | Readable =&gt;
      let notation :=
        match entrypoint with
        | &quot;default&quot; =&gt; Alpha_context.Contract.to_b58check c
        | entrypoint =&gt;
          Pervasives.op_caret (Alpha_context.Contract.to_b58check c)
            (Pervasives.op_caret &quot;%&quot; entrypoint)
        end in
      Error_monad.__return ((Micheline.String (-1) notation), ctxt)
    end
  
  | (Script_typed_ir.Contract_t _ _, _ as __a_value) =&gt;
    let __a_value := cast Script_typed_ir.typed_contract __a_value in
    let '(_, (c, entrypoint)) := __a_value in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.contract) in
    match mode with
    | Optimized =&gt;
      let entrypoint :=
        match entrypoint with
        | &quot;default&quot; =&gt; &quot;&quot;
        | name =&gt; name
        end in
      let __bytes_value :=
        Data_encoding.Binary.to_bytes_exn
          (Data_encoding.tup2 Alpha_context.Contract.encoding
            Data_encoding.__Variable.__string_value) (c, entrypoint) in
      Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt)
    | Readable =&gt;
      let notation :=
        match entrypoint with
        | &quot;default&quot; =&gt; Alpha_context.Contract.to_b58check c
        | entrypoint =&gt;
          Pervasives.op_caret (Alpha_context.Contract.to_b58check c)
            (Pervasives.op_caret &quot;%&quot; entrypoint)
        end in
      Error_monad.__return ((Micheline.String (-1) notation), ctxt)
    end
  
  | (Script_typed_ir.Signature_t _, _ as s) =&gt;
    let s := cast Alpha_context.signature s in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.signature) in
    match mode with
    | Optimized =&gt;
      let __bytes_value :=
        Data_encoding.Binary.to_bytes_exn Signature.encoding s in
      Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt)
    | Readable =&gt;
      Error_monad.__return
        ((Micheline.String (-1) (Signature.to_b58check s)), ctxt)
    end
  
  | (Script_typed_ir.Mutez_t _, _ as v) =&gt;
    let v := cast Alpha_context.Tez.t v in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.tez) in
    Error_monad.__return
      ((Micheline.Int (-1) (Z.of_int64 (Alpha_context.Tez.to_mutez v))), ctxt)
  
  | (Script_typed_ir.Key_t _, _ as k) =&gt;
    let k := cast Alpha_context.public_key k in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.__key_value) in
    match mode with
    | Optimized =&gt;
      let __bytes_value :=
        Data_encoding.Binary.to_bytes_exn
          (|Signature.Public_key|).(S.SPublic_key.encoding) k in
      Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt)
    | Readable =&gt;
      Error_monad.__return
        ((Micheline.String (-1)
          ((|Signature.Public_key|).(S.SPublic_key.to_b58check) k)), ctxt)
    end
  
  | (Script_typed_ir.Key_hash_t _, _ as k) =&gt;
    let k := cast Alpha_context.public_key_hash k in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.key_hash) in
    match mode with
    | Optimized =&gt;
      let __bytes_value :=
        Data_encoding.Binary.to_bytes_exn
          (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding) k in
      Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt)
    | Readable =&gt;
      Error_monad.__return
        ((Micheline.String (-1)
          ((|Signature.Public_key_hash|).(S.SPublic_key_hash.to_b58check) k)),
          ctxt)
    end
  
  | (Script_typed_ir.Operation_t _, _ as __a_value) =&gt;
    let __a_value := cast Script_typed_ir.operation __a_value in
    let '(op, _big_map_diff) := __a_value in
    let __bytes_value :=
      Data_encoding.Binary.to_bytes_exn
        Alpha_context.Operation.internal_operation_encoding op in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt (Unparse_costs.operation __bytes_value))
      in
    Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt)
  
  | (Script_typed_ir.Chain_id_t _, _ as chain_id) =&gt;
    let chain_id := cast (|Chain_id|).(S.HASH.t) chain_id in
    let __bytes_value :=
      Data_encoding.Binary.to_bytes_exn (|Chain_id|).(S.HASH.encoding) chain_id
      in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt (Unparse_costs.chain_id __bytes_value))
      in
    Error_monad.__return ((Micheline.Bytes (-1) __bytes_value), ctxt)
  
  | (Script_typed_ir.Pair_t (tl, _, _) (tr, _, _) _ _, _ as __a_value) =&gt;
    let 'existT _ [__1, __2] [tl, tr, __a_value] :=
      cast_exists (Es := [Set ** Set])
        (fun '[__1, __2] =&gt;
          [Script_typed_ir.ty ** Script_typed_ir.ty ** __1 * __2])
        [tl, tr, __a_value] in
    let '(l, __r_value) := __a_value in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.pair) in
    let=? '(l, ctxt) := unparse_data ctxt mode tl l in
    let=? '(__r_value, ctxt) := unparse_data ctxt mode tr __r_value in
    Error_monad.__return
      ((Micheline.Prim (-1) Alpha_context.Script.D_Pair [ l; __r_value ] nil),
        ctxt)
  
  | (Script_typed_ir.Union_t (tl, _) (tr, _) _ _, _ as __a_value) =&gt;
    let 'existT _ [__3, __4] [tl, tr, __a_value] :=
      cast_exists (Es := [Set ** Set])
        (fun '[__3, __4] =&gt;
          [Script_typed_ir.ty ** Script_typed_ir.ty **
            Script_typed_ir.union __3 __4]) [tl, tr, __a_value] in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.union) in
    match __a_value with
    | Script_typed_ir.L l =&gt;
      let=? '(l, ctxt) := unparse_data ctxt mode tl l in
      Error_monad.__return
        ((Micheline.Prim (-1) Alpha_context.Script.D_Left [ l ] nil), ctxt)
    | Script_typed_ir.R __r_value =&gt;
      let=? '(__r_value, ctxt) := unparse_data ctxt mode tr __r_value in
      Error_monad.__return
        ((Micheline.Prim (-1) Alpha_context.Script.D_Right [ __r_value ] nil),
          ctxt)
    end
  
  | (Script_typed_ir.Option_t __t_value _ _, _ as __a_value) =&gt;
    let 'existT _ __5 [__t_value, __a_value] :=
      cast_exists (Es := Set) (fun __5 =&gt; [Script_typed_ir.ty ** option __5])
        [__t_value, __a_value] in
    match __a_value with
    | Some v =&gt;
      let=? ctxt :=
        Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.some) in
      let=? '(v, ctxt) := unparse_data ctxt mode __t_value v in
      Error_monad.__return
        ((Micheline.Prim (-1) Alpha_context.Script.D_Some [ v ] nil), ctxt)
    | None =&gt;
      let=? ctxt :=
        Lwt.__return (Alpha_context.Gas.consume ctxt Unparse_costs.none) in
      Error_monad.__return
        ((Micheline.Prim (-1) Alpha_context.Script.D_None nil nil), ctxt)
    end
  
  | (Script_typed_ir.List_t __t_value _ _, _ as items) =&gt;
    let 'existT _ __6 [__t_value, items] :=
      cast_exists (Es := Set) (fun __6 =&gt; [Script_typed_ir.ty ** list __6])
        [__t_value, items] in
    let=? '(items, ctxt) :=
      Error_monad.fold_left_s
        (fun function_parameter =&gt;
          let '(l, ctxt) := function_parameter in
          fun element =&gt;
            let=? ctxt :=
              Lwt.__return
                (Alpha_context.Gas.consume ctxt Unparse_costs.list_element) in
            let=? '(unparsed, ctxt) := unparse_data ctxt mode __t_value element
              in
            Error_monad.__return ((cons unparsed l), ctxt)) (nil, ctxt) items in
    Error_monad.__return ((Micheline.Seq (-1) (List.rev items)), ctxt)
  
  | (Script_typed_ir.Set_t __t_value _, _ as set) =&gt;
    let 'existT _ __7 [__t_value, set] :=
      cast_exists (Es := Set)
        (fun __7 =&gt; [Script_typed_ir.comparable_ty ** Script_typed_ir.set __7])
        [__t_value, set] in
    let __t_value := ty_of_comparable_ty __t_value in
    let=? '(items, ctxt) :=
      Error_monad.fold_left_s
        (fun function_parameter =&gt;
          let '(l, ctxt) := function_parameter in
          fun item =&gt;
            let=? ctxt :=
              Lwt.__return
                (Alpha_context.Gas.consume ctxt Unparse_costs.set_element) in
            let=? '(item, ctxt) := unparse_data ctxt mode __t_value item in
            Error_monad.__return ((cons item l), ctxt)) (nil, ctxt)
        (set_fold (fun e =&gt; fun acc =&gt; cons e acc) set nil) in
    Error_monad.__return ((Micheline.Seq (-1) items), ctxt)
  
  | (Script_typed_ir.Map_t kt vt _ _, _ as map) =&gt;
    let 'existT _ [__8, __9] [kt, vt, map] :=
      cast_exists (Es := [Set ** Set])
        (fun '[__8, __9] =&gt;
          [Script_typed_ir.comparable_ty ** Script_typed_ir.ty **
            Script_typed_ir.map __8 __9]) [kt, vt, map] in
    let kt := ty_of_comparable_ty kt in
    let=? '(items, ctxt) :=
      Error_monad.fold_left_s
        (fun function_parameter =&gt;
          let '(l, ctxt) := function_parameter in
          fun function_parameter =&gt;
            let '(k, v) := function_parameter in
            let=? ctxt :=
              Lwt.__return
                (Alpha_context.Gas.consume ctxt Unparse_costs.map_element) in
            let=? '(__key_value, ctxt) := unparse_data ctxt mode kt k in
            let=? '(value, ctxt) := unparse_data ctxt mode vt v in
            Error_monad.__return
              ((cons
                (Micheline.Prim (-1) Alpha_context.Script.D_Elt
                  [ __key_value; value ] nil) l), ctxt)) (nil, ctxt)
        (map_fold (fun k =&gt; fun v =&gt; fun acc =&gt; cons (k, v) acc) map nil) in
    Error_monad.__return ((Micheline.Seq (-1) items), ctxt)
  
  | (Script_typed_ir.Big_map_t kt vt _, _ as __a_value) =&gt;
    let 'existT _ [__10, __11] [kt, vt, __a_value] :=
      cast_exists (Es := [Set ** Set])
        (fun '[__10, __11] =&gt;
          [Script_typed_ir.comparable_ty ** Script_typed_ir.ty **
            Script_typed_ir.big_map __10 __11]) [kt, vt, __a_value] in
    let '{|
      Script_typed_ir.big_map.id := id;
        Script_typed_ir.big_map.diff := Diff
        |} := __a_value in
    let 'existS _ _ Diff := Diff in
    match id with
    | None =&gt;
      let kt := ty_of_comparable_ty kt in
      let=? '(items, ctxt) :=
        Error_monad.fold_left_s
          (fun function_parameter =&gt;
            let '(l, ctxt) := function_parameter in
            fun function_parameter =&gt;
              let '(k, v) := function_parameter in
              let=? ctxt :=
                Lwt.__return
                  (Alpha_context.Gas.consume ctxt Unparse_costs.map_element) in
              let=? '(__key_value, ctxt) := unparse_data ctxt mode kt k in
              let=? '(value, ctxt) := unparse_data ctxt mode vt v in
              Error_monad.__return
                ((cons
                  (Micheline.Prim (-1) Alpha_context.Script.D_Elt
                    [ __key_value; value ] nil) l), ctxt)) (nil, ctxt)
          (Diff.(Script_typed_ir.Boxed_map.OPS).(S.MAP.fold)
            (fun k =&gt;
              fun v =&gt;
                fun acc =&gt;
                  match v with
                  | None =&gt; acc
                  | Some v =&gt; cons (k, v) acc
                  end) (Pervasives.fst Diff.(Script_typed_ir.Boxed_map.boxed))
            nil) in
      Error_monad.__return ((Micheline.Seq (-1) items), ctxt)
    | Some id =&gt;
      if
        (|Compare.Int|).(Compare.S.op_eq)
          (Diff.(Script_typed_ir.Boxed_map.OPS).(S.MAP.cardinal)
            (Pervasives.fst Diff.(Script_typed_ir.Boxed_map.boxed))) 0 then
        Error_monad.__return ((Micheline.Int (-1) id), ctxt)
      else
        (* ‚ùå Assert instruction is not handled. *)
        assert
          (Lwt.t
            (Error_monad.tzresult
              (Micheline.node int Alpha_context.Script.prim *
                Alpha_context.context))) false
    end
  
  | (Script_typed_ir.Lambda_t _ _ _, _ as __a_value) =&gt;
    let __a_value := cast Script_typed_ir.lambda __a_value in
    let '{| Script_typed_ir.lambda.lam := (_, original_code) |} := __a_value in
    unparse_code ctxt mode original_code
  end

with unparse_code (ctxt : Alpha_context.context) (mode : unparsing_mode)
  {struct ctxt}
  : Alpha_context.Script.node -&gt;
  Lwt.t
    (Error_monad.tzresult
      (Micheline.node int Alpha_context.Script.prim * Alpha_context.context)) :=
  let legacy := true in
  fun function_parameter =&gt;
    match function_parameter with
    |
      Micheline.Prim loc Alpha_context.Script.I_PUSH (cons ty (cons data []))
        annot =&gt;
      let=? '(Ex_ty __t_value, ctxt) :=
        Lwt.__return (parse_packable_ty ctxt legacy ty) in
      let=? '(data, ctxt) :=
        (parse_data (a := unit)) None ctxt legacy __t_value data in
      let=? '(data, ctxt) := unparse_data ctxt mode __t_value data in
      let=? ctxt :=
        Lwt.__return
          (Alpha_context.Gas.consume ctxt (Unparse_costs.prim_cost 2 annot)) in
      Error_monad.__return
        ((Micheline.Prim loc Alpha_context.Script.I_PUSH [ ty; data ] annot),
          ctxt)
    | Micheline.Seq loc items =&gt;
      let=? '(items, ctxt) :=
        Error_monad.fold_left_s
          (fun function_parameter =&gt;
            let '(l, ctxt) := function_parameter in
            fun item =&gt;
              let=? '(item, ctxt) := unparse_code ctxt mode item in
              Error_monad.__return ((cons item l), ctxt)) (nil, ctxt) items in
      let=? ctxt :=
        Lwt.__return
          (Alpha_context.Gas.consume ctxt
            (Unparse_costs.seq_cost (List.length items))) in
      Error_monad.__return ((Micheline.Seq loc (List.rev items)), ctxt)
    | Micheline.Prim loc prim items annot =&gt;
      let=? '(items, ctxt) :=
        Error_monad.fold_left_s
          (fun function_parameter =&gt;
            let '(l, ctxt) := function_parameter in
            fun item =&gt;
              let=? '(item, ctxt) := unparse_code ctxt mode item in
              Error_monad.__return ((cons item l), ctxt)) (nil, ctxt) items in
      let=? ctxt :=
        Lwt.__return
          (Alpha_context.Gas.consume ctxt (Unparse_costs.prim_cost 3 annot)) in
      Error_monad.__return
        ((Micheline.Prim loc prim (List.rev items) annot), ctxt)
    | (Micheline.Int _ _ | Micheline.String _ _ | Micheline.Bytes _ _) as atom
      =&gt; Error_monad.__return (atom, ctxt)
    end.

Definition unparse_script {A : Set}
  (ctxt : Alpha_context.context) (mode : unparsing_mode)
  (function_parameter : Script_typed_ir.script A)
  : Lwt.t
    (Error_monad.tzresult (Alpha_context.Script.t * Alpha_context.context)) :=
  let '{|
    Script_typed_ir.script.code := code;
      Script_typed_ir.script.arg_type := arg_type;
      Script_typed_ir.script.storage := storage;
      Script_typed_ir.script.storage_type := storage_type;
      Script_typed_ir.script.root_name := root_name
      |} := function_parameter in
  let '{| Script_typed_ir.lambda.lam := (_, original_code) |} := code in
  let=? '(code, ctxt) := unparse_code ctxt mode original_code in
  let=? '(storage, ctxt) := unparse_data ctxt mode storage_type storage in
  let=? '(arg_type, ctxt) := unparse_ty ctxt arg_type in
  let=? '(storage_type, ctxt) := unparse_ty ctxt storage_type in
  let arg_type :=
    add_field_annot
      (Option.map (fun n =&gt; Script_typed_ir.Field_annot n) root_name) None
      arg_type in
  let code :=
    Micheline.Seq (-1)
      [
        Micheline.Prim (-1) Alpha_context.Script.K_parameter [ arg_type ] nil;
        Micheline.Prim (-1) Alpha_context.Script.K_storage [ storage_type ] nil;
        Micheline.Prim (-1) Alpha_context.Script.K_code [ code ] nil
      ] in
  let=? ctxt :=
    Lwt.__return
      (let? ctxt := Alpha_context.Gas.consume ctxt (Unparse_costs.seq_cost 3) in
      let? ctxt :=
        Alpha_context.Gas.consume ctxt (Unparse_costs.prim_cost 1 nil) in
      let? ctxt :=
        Alpha_context.Gas.consume ctxt (Unparse_costs.prim_cost 1 nil) in
      Alpha_context.Gas.consume ctxt (Unparse_costs.prim_cost 1 nil)) in
  Error_monad.__return
    ({|
      Alpha_context.Script.t.code :=
        Alpha_context.Script.__lazy_expr_value (Micheline.strip_locations code);
      Alpha_context.Script.t.storage :=
        Alpha_context.Script.__lazy_expr_value
          (Micheline.strip_locations storage) |}, ctxt).

Definition pack_data {A : Set}
  (ctxt : Alpha_context.context) (typ : Script_typed_ir.ty) (data : A)
  : Lwt.t (Error_monad.tzresult (MBytes.t * Alpha_context.context)) :=
  let=? '(unparsed, ctxt) := unparse_data ctxt Optimized typ data in
  let __bytes_value :=
    Data_encoding.Binary.to_bytes_exn Alpha_context.Script.expr_encoding
      (Micheline.strip_locations unparsed) in
  let=? ctxt :=
    Lwt.__return
      (Alpha_context.Gas.consume ctxt
        (Alpha_context.Script.serialized_cost __bytes_value)) in
  let __bytes_value :=
    MBytes.concat &quot;&quot; [ MBytes.of_string &quot;\005&quot;; __bytes_value ] in
  let=? ctxt :=
    Lwt.__return
      (Alpha_context.Gas.consume ctxt
        (Alpha_context.Script.serialized_cost __bytes_value)) in
  Error_monad.__return (__bytes_value, ctxt).

Definition hash_data {A : Set}
  (ctxt : Alpha_context.context) (typ : Script_typed_ir.ty) (data : A)
  : Lwt.t (Error_monad.tzresult (Script_expr_hash.t * Alpha_context.context)) :=
  let=? '(__bytes_value, ctxt) := pack_data ctxt typ data in
  let=? ctxt :=
    Lwt.__return
      (Alpha_context.Gas.consume ctxt
        (Michelson_v1_gas.Cost_of.Legacy.__hash_value __bytes_value
          Script_expr_hash.size)) in
  Error_monad.__return
    ((Script_expr_hash.hash_bytes None [ __bytes_value ]), ctxt).

Definition empty_big_map {A B : Set}
  (tk : Script_typed_ir.comparable_ty) (tv : Script_typed_ir.ty)
  : Script_typed_ir.big_map A B :=
  {| Script_typed_ir.big_map.id := None;
    Script_typed_ir.big_map.diff := empty_map tk;
    Script_typed_ir.big_map.key_type := ty_of_comparable_ty tk;
    Script_typed_ir.big_map.value_type := tv |}.

Definition big_map_mem {A B : Set}
  (ctxt : Alpha_context.context) (__key_value : A)
  (function_parameter : Script_typed_ir.big_map A B)
  : Lwt.t (Error_monad.tzresult (bool * Alpha_context.context)) :=
  let '{|
    Script_typed_ir.big_map.id := id;
      Script_typed_ir.big_map.diff := diff;
      Script_typed_ir.big_map.key_type := key_type
      |} := function_parameter in
  match ((map_get __key_value diff), id) with
  | (None, None) =&gt; Error_monad.__return (false, ctxt)
  | (None, Some id) =&gt;
    let=? '(__hash_value, ctxt) := hash_data ctxt key_type __key_value in
    let=? '(ctxt, res) := Alpha_context.Big_map.mem ctxt id __hash_value in
    Error_monad.__return (res, ctxt)
  | (Some None, _) =&gt; Error_monad.__return (false, ctxt)
  | (Some (Some _), _) =&gt; Error_monad.__return (true, ctxt)
  end.

Definition big_map_get {A B : Set}
  (ctxt : Alpha_context.context) (__key_value : A)
  (function_parameter : Script_typed_ir.big_map A B)
  : Lwt.t (Error_monad.tzresult (option B * Alpha_context.context)) :=
  let '{|
    Script_typed_ir.big_map.id := id;
      Script_typed_ir.big_map.diff := diff;
      Script_typed_ir.big_map.key_type := key_type;
      Script_typed_ir.big_map.value_type := value_type
      |} := function_parameter in
  match ((map_get __key_value diff), id) with
  | (Some x, _) =&gt; Error_monad.__return (x, ctxt)
  | (None, None) =&gt; Error_monad.__return (None, ctxt)
  | (None, Some id) =&gt;
    let=? '(__hash_value, ctxt) := hash_data ctxt key_type __key_value in
    let=? function_parameter :=
      Alpha_context.Big_map.get_opt ctxt id __hash_value in
    match function_parameter with
    | (ctxt, None) =&gt; Error_monad.__return (None, ctxt)
    | (ctxt, Some value) =&gt;
      let=? '(x, ctxt) :=
        parse_data None ctxt true value_type (Micheline.root value) in
      Error_monad.__return ((Some x), ctxt)
    end
  end.

Definition big_map_update {A B : Set}
  (__key_value : A) (value : option B)
  (function_parameter : Script_typed_ir.big_map A B)
  : Script_typed_ir.big_map A B :=
  let '{| Script_typed_ir.big_map.diff := diff |} as map := function_parameter
    in
  Script_typed_ir.big_map.with_diff (map_set __key_value value diff) map.

Definition Ids :=
  __Set.Make
    (existT (A := Set) _ _
      {|
        Compare.COMPARABLE.compare := (|Compare.Z|).(Compare.S.compare)
      |}).

Definition big_map_ids : Set := (|Ids|).(S.SET.t).

Definition no_big_map_id : (|Ids|).(S.SET.t) := (|Ids|).(S.SET.empty).

Definition diff_of_big_map {A B : Set}
  (ctxt : Alpha_context.context)
  (fresh :
    Alpha_context.context -&gt;
    Lwt.t
      (Error_monad.tzresult (Alpha_context.context * Alpha_context.Big_map.id)))
  (mode : unparsing_mode) (ids : (|Ids|).(S.SET.t))
  (function_parameter : Script_typed_ir.big_map A B)
  : Lwt.t
    (Error_monad.tzresult
      (list Alpha_context.Contract.big_map_diff_item * Alpha_context.Big_map.id
        * Alpha_context.context)) :=
  let '{|
    Script_typed_ir.big_map.id := id;
      Script_typed_ir.big_map.diff := diff;
      Script_typed_ir.big_map.key_type := key_type;
      Script_typed_ir.big_map.value_type := value_type
      |} := function_parameter in
  let=? ctxt :=
    Lwt.__return
      (Alpha_context.Gas.consume ctxt
        (Michelson_v1_gas.Cost_of.Legacy.map_to_list diff)) in
  let=? '(ctxt, init, big_map) :=
    match id with
    | Some id =&gt;
      if (|Ids|).(S.SET.mem) id ids then
        let=? '(ctxt, duplicate) := fresh ctxt in
        Error_monad.__return
          (ctxt, [ Alpha_context.Contract.Copy id duplicate ], duplicate)
      else
        Error_monad.__return (ctxt, nil, id)
    | None =&gt;
      let=? '(ctxt, id) := fresh ctxt in
      let=? '(kt, ctxt) := unparse_ty ctxt key_type in
      let=? '(kv, ctxt) := unparse_ty ctxt value_type in
      Error_monad.__return
        (ctxt,
          [
            Alpha_context.Contract.Alloc
              {|
                Alpha_context.Contract.big_map_diff_item.Alloc.big_map :=
                  id;
                Alpha_context.Contract.big_map_diff_item.Alloc.key_type :=
                  Micheline.strip_locations kt;
                Alpha_context.Contract.big_map_diff_item.Alloc.value_type :=
                  Micheline.strip_locations kv |}
          ], id)
    end in
  let pairs :=
    map_fold
      (fun __key_value =&gt; fun value =&gt; fun acc =&gt; cons (__key_value, value) acc)
      diff nil in
  let=? '(diff, ctxt) :=
    Error_monad.fold_left_s
      (fun function_parameter =&gt;
        let '(acc, ctxt) := function_parameter in
        fun function_parameter =&gt;
          let '(__key_value, value) := function_parameter in
          let=? ctxt :=
            Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle)
            in
          let=? '(diff_key_hash, ctxt) := hash_data ctxt key_type __key_value in
          let=? '(key_node, ctxt) := unparse_data ctxt mode key_type __key_value
            in
          let diff_key := Micheline.strip_locations key_node in
          let=? '(diff_value, ctxt) :=
            match value with
            | None =&gt; Error_monad.__return (None, ctxt)
            | Some x =&gt;
              let=? '(node, ctxt) := unparse_data ctxt mode value_type x in
              Error_monad.__return
                ((Some (Micheline.strip_locations node)), ctxt)
            end in
          let diff_item :=
            Alpha_context.Contract.Update
              {|
                Alpha_context.Contract.big_map_diff_item.Update.big_map :=
                  big_map;
                Alpha_context.Contract.big_map_diff_item.Update.diff_key :=
                  diff_key;
                Alpha_context.Contract.big_map_diff_item.Update.diff_key_hash :=
                  diff_key_hash;
                Alpha_context.Contract.big_map_diff_item.Update.diff_value :=
                  diff_value |} in
          Error_monad.__return ((cons diff_item acc), ctxt)) (nil, ctxt) pairs
    in
  Error_monad.__return ((Pervasives.op_at init diff), big_map, ctxt).

Fixpoint extract_big_map_updates {a : Set}
  (ctxt : Alpha_context.context)
  (fresh :
    Alpha_context.context -&gt;
    Lwt.t
      (Error_monad.tzresult (Alpha_context.context * Alpha_context.Big_map.id)))
  (mode : unparsing_mode) (ids : (|Ids|).(S.SET.t))
  (acc : list Alpha_context.Contract.big_map_diff) (ty : Script_typed_ir.ty)
  (x : a) {struct ctxt}
  : Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context * a * (|Ids|).(S.SET.t) *
        list Alpha_context.Contract.big_map_diff)) :=
  match (ty, x) with
  | (Script_typed_ir.Big_map_t _ _ _, _ as map) =&gt;
    let 'existT _ [__0, __1] map :=
      cast_exists (Es := [Set ** Set])
        (fun '[__0, __1] =&gt; Script_typed_ir.big_map __0 __1) map in
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    (let=? '(diff, id, ctxt) := diff_of_big_map ctxt fresh mode ids map in
    let Map := map.(Script_typed_ir.big_map.diff) in
    let 'existS _ _ Map := Map in
    let map :=
      Script_typed_ir.big_map.with_diff
        (empty_map Map.(Script_typed_ir.Boxed_map.key_ty))
        (Script_typed_ir.big_map.with_id (Some id) map) in
    Error_monad.__return
      (ctxt, map, ((|Ids|).(S.SET.add) id ids), (cons diff acc)))
  
  | (Script_typed_ir.Pair_t (tyl, _, _) (tyr, _, _) _ true, _ as x) =&gt;
    let 'existT _ [__2, __3] [tyl, tyr, x] :=
      cast_exists (Es := [Set ** Set])
        (fun '[__2, __3] =&gt;
          [Script_typed_ir.ty ** Script_typed_ir.ty ** __2 * __3]) [tyl, tyr, x]
      in
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    (let '(xl, xr) := x in
    let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle) in
    let=? '(ctxt, xl, ids, acc) :=
      extract_big_map_updates ctxt fresh mode ids acc tyl xl in
    let=? '(ctxt, xr, ids, acc) :=
      extract_big_map_updates ctxt fresh mode ids acc tyr xr in
    Error_monad.__return (ctxt, (xl, xr), ids, acc))
  
  | (Script_typed_ir.Union_t (ty_l, _) (ty_r, _) _ true, _ as x) =&gt;
    let 'existT _ [__4, __5] [ty_l, ty_r, x] :=
      cast_exists (Es := [Set ** Set])
        (fun '[__4, __5] =&gt;
          [Script_typed_ir.ty ** Script_typed_ir.ty **
            Script_typed_ir.union __4 __5]) [ty_l, ty_r, x] in
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    (let=? ctxt :=
      Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle) in
    match x with
    | Script_typed_ir.L x =&gt;
      let=? '(ctxt, x, ids, acc) :=
        extract_big_map_updates ctxt fresh mode ids acc ty_l x in
      Error_monad.__return (ctxt, (Script_typed_ir.L x), ids, acc)
    | Script_typed_ir.R x =&gt;
      let=? '(ctxt, x, ids, acc) :=
        extract_big_map_updates ctxt fresh mode ids acc ty_r x in
      Error_monad.__return (ctxt, (Script_typed_ir.R x), ids, acc)
    end)
  
  | (Script_typed_ir.Option_t ty _ true, _ as x) =&gt;
    let 'existT _ __6 [ty, x] :=
      cast_exists (Es := Set) (fun __6 =&gt; [Script_typed_ir.ty ** option __6])
        [ty, x] in
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    match x with
    | Some x =&gt;
      let=? ctxt :=
        Lwt.__return (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle) in
      let=? '(ctxt, x, ids, acc) :=
        extract_big_map_updates ctxt fresh mode ids acc ty x in
      Error_monad.__return (ctxt, (Some x), ids, acc)
    | None =&gt; Error_monad.__return (ctxt, None, ids, acc)
    end
  
  | (Script_typed_ir.List_t ty _ true, _ as l) =&gt;
    let 'existT _ __7 [ty, l] :=
      cast_exists (Es := Set) (fun __7 =&gt; [Script_typed_ir.ty ** list __7])
        [ty, l] in
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    (let=? '(ctxt, l, ids, acc) :=
      Error_monad.fold_left_s
        (fun function_parameter =&gt;
          let '(ctxt, l, ids, acc) := function_parameter in
          fun x =&gt;
            let=? ctxt :=
              Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle) in
            let=? '(ctxt, x, ids, acc) :=
              extract_big_map_updates ctxt fresh mode ids acc ty x in
            Error_monad.__return (ctxt, (cons x l), ids, acc))
        (ctxt, nil, ids, acc) l in
    Error_monad.__return (ctxt, (List.rev l), ids, acc))
  
  | (Script_typed_ir.Map_t _ ty _ true, _ as m) =&gt;
    let 'existT _ [__8, __9] [ty, m] :=
      cast_exists (Es := [Set ** Set])
        (fun '[__8, __9] =&gt; [Script_typed_ir.ty ** Script_typed_ir.map __8 __9])
        [ty, m] in
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    (let M := m in
    let 'existS _ _ M := M in
    let=? ctxt :=
      Lwt.__return
        (Alpha_context.Gas.consume ctxt
          (Michelson_v1_gas.Cost_of.Legacy.map_to_list m)) in
    let=? '(ctxt, m, ids, acc) :=
      Error_monad.fold_left_s
        (fun function_parameter =&gt;
          let '(ctxt, m, ids, acc) := function_parameter in
          fun function_parameter =&gt;
            let '(k, x) := function_parameter in
            let=? ctxt :=
              Lwt.__return
                (Alpha_context.Gas.consume ctxt Typecheck_costs.cycle) in
            let=? '(ctxt, x, ids, acc) :=
              extract_big_map_updates ctxt fresh mode ids acc ty x in
            Error_monad.__return
              (ctxt, (M.(Script_typed_ir.Boxed_map.OPS).(S.MAP.add) k x m), ids,
                acc))
        (ctxt, M.(Script_typed_ir.Boxed_map.OPS).(S.MAP.empty), ids, acc)
        (M.(Script_typed_ir.Boxed_map.OPS).(S.MAP.bindings)
          (Pervasives.fst M.(Script_typed_ir.Boxed_map.boxed))) in
    let M :=
      ((let OPS :=
        existT (A := unit) (fun _ =&gt; _) tt M.(Script_typed_ir.Boxed_map.OPS) in
      let key : Set := M.(Script_typed_ir.Boxed_map.key) in
      let value : Set := M.(Script_typed_ir.Boxed_map.value) in
      let key_ty := M.(Script_typed_ir.Boxed_map.key_ty) in
      let boxed := (m, (Pervasives.snd M.(Script_typed_ir.Boxed_map.boxed))) in
      existT (A := Set -&gt; Set) _ _
        {|
          Script_typed_ir.Boxed_map.key_ty := key_ty;
          Script_typed_ir.Boxed_map.OPS := (|OPS|);
          Script_typed_ir.Boxed_map.boxed := boxed
        |})
        :
          {OPS_t : Set -&gt; Set &amp;
            Boxed_map.signature (key := M.(Script_typed_ir.Boxed_map.key))
              (value := M.(Script_typed_ir.Boxed_map.value)) (OPS_t := OPS_t)})
      in
    (Error_monad.__return
      (a := context * Script_typed_ir.map __8 __9 * big_map_ids * list Contract.big_map_diff))
      (ctxt, (pack (existT (A := Set -&gt; Set) _ _ (|M|))), ids, acc))
  
  | (Script_typed_ir.List_t _ _ false, v) =&gt;
    let v := cast a v in
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    (Error_monad.__return (ctxt, v, ids, acc))
  
  | (Script_typed_ir.Map_t _ _ _ false, v) =&gt;
    let v := cast a v in
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    (Error_monad.__return (ctxt, v, ids, acc))
  
  | (Script_typed_ir.Pair_t _ _ _ false, v) =&gt;
    let v := cast a v in
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    (Error_monad.__return (ctxt, v, ids, acc))
  
  | (Script_typed_ir.Union_t _ _ _ false, v) =&gt;
    let v := cast a v in
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    (Error_monad.__return (ctxt, v, ids, acc))
  
  | (Script_typed_ir.Option_t _ _ false, v) =&gt;
    let v := cast a v in
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    (Error_monad.__return (ctxt, v, ids, acc))
  
  | (Script_typed_ir.Chain_id_t _, v) =&gt;
    let v := cast a v in
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    (Error_monad.__return (ctxt, v, ids, acc))
  
  | (Script_typed_ir.Set_t _ _, v) =&gt;
    let v := cast a v in
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    (Error_monad.__return (ctxt, v, ids, acc))
  
  | (Script_typed_ir.Unit_t _, v) =&gt;
    let v := cast a v in
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    (Error_monad.__return (ctxt, v, ids, acc))
  
  | (Script_typed_ir.Int_t _, v) =&gt;
    let v := cast a v in
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    (Error_monad.__return (ctxt, v, ids, acc))
  
  | (Script_typed_ir.Nat_t _, v) =&gt;
    let v := cast a v in
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    (Error_monad.__return (ctxt, v, ids, acc))
  
  | (Script_typed_ir.Signature_t _, v) =&gt;
    let v := cast a v in
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    (Error_monad.__return (ctxt, v, ids, acc))
  
  | (Script_typed_ir.String_t _, v) =&gt;
    let v := cast a v in
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    (Error_monad.__return (ctxt, v, ids, acc))
  
  | (Script_typed_ir.Bytes_t _, v) =&gt;
    let v := cast a v in
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    (Error_monad.__return (ctxt, v, ids, acc))
  
  | (Script_typed_ir.Mutez_t _, v) =&gt;
    let v := cast a v in
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    (Error_monad.__return (ctxt, v, ids, acc))
  
  | (Script_typed_ir.Key_hash_t _, v) =&gt;
    let v := cast a v in
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    (Error_monad.__return (ctxt, v, ids, acc))
  
  | (Script_typed_ir.Key_t _, v) =&gt;
    let v := cast a v in
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    (Error_monad.__return (ctxt, v, ids, acc))
  
  | (Script_typed_ir.Timestamp_t _, v) =&gt;
    let v := cast a v in
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    (Error_monad.__return (ctxt, v, ids, acc))
  
  | (Script_typed_ir.Address_t _, v) =&gt;
    let v := cast a v in
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    (Error_monad.__return (ctxt, v, ids, acc))
  
  | (Script_typed_ir.Bool_t _, v) =&gt;
    let v := cast a v in
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    (Error_monad.__return (ctxt, v, ids, acc))
  
  | (Script_typed_ir.Lambda_t _ _ _, v) =&gt;
    let v := cast a v in
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    (Error_monad.__return (ctxt, v, ids, acc))
  
  | (Script_typed_ir.Contract_t _ _, v) =&gt;
    let v := cast a v in
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    (Error_monad.__return (ctxt, v, ids, acc))
  
  | (Script_typed_ir.Operation_t _, _) =&gt;
    cast
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff)))
    (* ‚ùå Assert instruction is not handled. *)
    (assert
      (Lwt.t
        (Error_monad.tzresult
          (Alpha_context.context * a * (|Ids|).(S.SET.t) *
            list Alpha_context.Contract.big_map_diff))) false)
  end.

Definition collect_big_maps {A : Set}
  (ctxt : Alpha_context.context) (ty : Script_typed_ir.ty) (x : A)
  : Lwt.t (Error_monad.tzresult ((|Ids|).(S.SET.t) * Alpha_context.context)) :=
  let fix collect {a : Set}
    (ctxt : Alpha_context.context) (ty : Script_typed_ir.ty) (x : a)
    (acc : (|Ids|).(S.SET.t)) {struct ctxt}
    : Error_monad.tzresult ((|Ids|).(S.SET.t) * Alpha_context.context) :=
    match (ty, x) with
    | (Script_typed_ir.Big_map_t _ _ _, _ as x) =&gt;
      let 'existT _ [__0, __1] x :=
        cast_exists (Es := [Set ** Set])
          (fun '[__0, __1] =&gt; Script_typed_ir.big_map __0 __1) x in
      match x with
      | {| Script_typed_ir.big_map.id := Some id |} =&gt;
        let? ctxt := Alpha_context.Gas.consume ctxt Typecheck_costs.cycle in
        Error_monad.ok (((|Ids|).(S.SET.add) id acc), ctxt)
      | {| Script_typed_ir.big_map.id := None |} =&gt; Error_monad.ok (acc, ctxt)
      end
    
    | (Script_typed_ir.Pair_t (tyl, _, _) (tyr, _, _) _ true, _ as x) =&gt;
      let 'existT _ [__2, __3] [tyl, tyr, x] :=
        cast_exists (Es := [Set ** Set])
          (fun '[__2, __3] =&gt;
            [Script_typed_ir.ty ** Script_typed_ir.ty ** __2 * __3])
          [tyl, tyr, x] in
      let '(xl, xr) := x in
      let? '(acc, ctxt) := collect ctxt tyl xl acc in
      collect ctxt tyr xr acc
    
    | (Script_typed_ir.Union_t (ty_l, _) (ty_r, _) _ true, _ as x) =&gt;
      let 'existT _ [__4, __5] [ty_l, ty_r, x] :=
        cast_exists (Es := [Set ** Set])
          (fun '[__4, __5] =&gt;
            [Script_typed_ir.ty ** Script_typed_ir.ty **
              Script_typed_ir.union __4 __5]) [ty_l, ty_r, x] in
      match x with
      | Script_typed_ir.L x =&gt; collect ctxt ty_l x acc
      | Script_typed_ir.R x =&gt; collect ctxt ty_r x acc
      end
    
    | (Script_typed_ir.Option_t ty _ true, _ as x) =&gt;
      let 'existT _ __6 [ty, x] :=
        cast_exists (Es := Set) (fun __6 =&gt; [Script_typed_ir.ty ** option __6])
          [ty, x] in
      match x with
      | Some x =&gt; collect ctxt ty x acc
      | None =&gt; Error_monad.ok (acc, ctxt)
      end
    
    | (Script_typed_ir.List_t ty _ true, _ as l) =&gt;
      let 'existT _ __7 [ty, l] :=
        cast_exists (Es := Set) (fun __7 =&gt; [Script_typed_ir.ty ** list __7])
          [ty, l] in
      List.fold_left
        (fun acc =&gt;
          fun x =&gt;
            let? '(acc, ctxt) := acc in
            collect ctxt ty x acc) (Error_monad.ok (acc, ctxt)) l
    
    | (Script_typed_ir.Map_t _ ty _ true, _ as m) =&gt;
      let 'existT _ [__8, __9] [ty, m] :=
        cast_exists (Es := [Set ** Set])
          (fun '[__8, __9] =&gt;
            [Script_typed_ir.ty ** Script_typed_ir.map __8 __9]) [ty, m] in
      map_fold
        (fun function_parameter =&gt;
          let '_ := function_parameter in
          fun v =&gt;
            fun acc =&gt;
              let? '(acc, ctxt) := acc in
              collect ctxt ty v acc) m (Error_monad.ok (acc, ctxt))
    
    | (Script_typed_ir.List_t _ _ false, _) =&gt; Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Map_t _ _ _ false, _) =&gt; Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Option_t _ _ false, _) =&gt; Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Union_t _ _ _ false, _) =&gt; Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Pair_t _ _ _ false, _) =&gt; Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Chain_id_t _, _) =&gt; Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Set_t _ _, _) =&gt; Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Unit_t _, _) =&gt; Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Int_t _, _) =&gt; Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Nat_t _, _) =&gt; Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Signature_t _, _) =&gt; Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.String_t _, _) =&gt; Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Bytes_t _, _) =&gt; Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Mutez_t _, _) =&gt; Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Key_hash_t _, _) =&gt; Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Key_t _, _) =&gt; Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Timestamp_t _, _) =&gt; Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Address_t _, _) =&gt; Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Bool_t _, _) =&gt; Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Lambda_t _ _ _, _) =&gt; Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Contract_t _ _, _) =&gt; Error_monad.ok (acc, ctxt)
    
    | (Script_typed_ir.Operation_t _, _) =&gt;
      (* ‚ùå Assert instruction is not handled. *)
      assert (Error_monad.tzresult ((|Ids|).(S.SET.t) * Alpha_context.context))
        false
    end in
  Lwt.__return (collect ctxt ty x no_big_map_id).

Definition extract_big_map_diff {A : Set}
  (ctxt : Alpha_context.context) (mode : unparsing_mode) (temporary : bool)
  (to_duplicate : (|Ids|).(S.SET.t)) (to_update : (|Ids|).(S.SET.t))
  (ty : Script_typed_ir.ty) (v : A)
  : Lwt.t
    (Error_monad.tzresult
      (A * option (list Alpha_context.Contract.big_map_diff_item) *
        Alpha_context.context)) :=
  let to_duplicate := (|Ids|).(S.SET.diff) to_duplicate to_update in
  let fresh :=
    if temporary then
      fun c =&gt; Error_monad.__return (Alpha_context.Big_map.fresh_temporary c)
    else
      Alpha_context.Big_map.fresh in
  let=? '(ctxt, v, alive, diffs) :=
    extract_big_map_updates ctxt fresh mode to_duplicate nil ty v in
  let diffs :=
    if temporary then
      diffs
    else
      let dead := (|Ids|).(S.SET.diff) to_update alive in
      cons
        ((|Ids|).(S.SET.fold)
          (fun id =&gt; fun acc =&gt; cons (Alpha_context.Contract.Clear id) acc) dead
          nil) diffs in
  match diffs with
  | [] =&gt; Error_monad.__return (v, None, ctxt)
  | diffs =&gt; Error_monad.__return (v, (Some (List.flatten diffs)), ctxt)
  end.

Definition list_of_big_map_ids (ids : (|Ids|).(S.SET.t))
  : list (|Ids|).(S.SET.elt) := (|Ids|).(S.SET.elements) ids.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_ir_translator.mli">
  <div style="margin: 20px;">
    <h3>Script_ir_translator_mli</h3>
    <ul>
      <li>OCaml size: 273 lines</li>
      <li>Coq size: 309 lines (+13% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#script_ir_translator.mli"><code>script_ir_translator.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context
open Script_tc_errors

type ('ta, 'tb) eq = Eq : ('same, 'same) eq

type ex_comparable_ty =
  | Ex_comparable_ty : 'a Script_typed_ir.comparable_ty -&gt; ex_comparable_ty

type ex_ty = Ex_ty : 'a Script_typed_ir.ty -&gt; ex_ty

type ex_stack_ty = Ex_stack_ty : 'a Script_typed_ir.stack_ty -&gt; ex_stack_ty

type ex_script = Ex_script : ('a, 'b) Script_typed_ir.script -&gt; ex_script

type tc_context =
  | Lambda : tc_context
  | Dip : 'a Script_typed_ir.stack_ty * tc_context -&gt; tc_context
  | Toplevel : {
      storage_type : 'sto Script_typed_ir.ty;
      param_type : 'param Script_typed_ir.ty;
      root_name : string option;
      legacy_create_contract_literal : bool;
    }
      -&gt; tc_context

type 'bef judgement =
  | Typed : ('bef, 'aft) Script_typed_ir.descr -&gt; 'bef judgement
  | Failed : {
      descr :
        'aft. 'aft Script_typed_ir.stack_ty -&gt;
        ('bef, 'aft) Script_typed_ir.descr;
    }
      -&gt; 'bef judgement
[@@coq_force_gadt]

type unparsing_mode = Optimized | Readable

type type_logger =
  int -&gt;
  (Script.expr * Script.annot) list -&gt;
  (Script.expr * Script.annot) list -&gt;
  unit

(* ---- Sets and Maps -------------------------------------------------------*)

val empty_set : 'a Script_typed_ir.comparable_ty -&gt; 'a Script_typed_ir.set

val set_fold :
  ('elt -&gt; 'acc -&gt; 'acc) -&gt; 'elt Script_typed_ir.set -&gt; 'acc -&gt; 'acc

val set_update : 'a -&gt; bool -&gt; 'a Script_typed_ir.set -&gt; 'a Script_typed_ir.set

val set_mem : 'elt -&gt; 'elt Script_typed_ir.set -&gt; bool

val set_size : 'elt Script_typed_ir.set -&gt; Script_int.num

val empty_map :
  'a Script_typed_ir.comparable_ty -&gt; ('a, 'b) Script_typed_ir.map

val map_fold :
  ('key -&gt; 'value -&gt; 'acc -&gt; 'acc) -&gt;
  ('key, 'value) Script_typed_ir.map -&gt;
  'acc -&gt;
  'acc

val map_update :
  'a -&gt;
  'b option -&gt;
  ('a, 'b) Script_typed_ir.map -&gt;
  ('a, 'b) Script_typed_ir.map

val map_mem : 'key -&gt; ('key, 'value) Script_typed_ir.map -&gt; bool

val map_get : 'key -&gt; ('key, 'value) Script_typed_ir.map -&gt; 'value option

val map_key_ty :
  ('a, 'b) Script_typed_ir.map -&gt; 'a Script_typed_ir.comparable_ty

val map_size : ('a, 'b) Script_typed_ir.map -&gt; Script_int.num

val empty_big_map :
  'a Script_typed_ir.comparable_ty -&gt;
  'b Script_typed_ir.ty -&gt;
  ('a, 'b) Script_typed_ir.big_map

val big_map_mem :
  context -&gt;
  'key -&gt;
  ('key, 'value) Script_typed_ir.big_map -&gt;
  (bool * context) tzresult Lwt.t

val big_map_get :
  context -&gt;
  'key -&gt;
  ('key, 'value) Script_typed_ir.big_map -&gt;
  ('value option * context) tzresult Lwt.t

val big_map_update :
  'key -&gt;
  'value option -&gt;
  ('key, 'value) Script_typed_ir.big_map -&gt;
  ('key, 'value) Script_typed_ir.big_map

val ty_eq :
  context -&gt;
  'ta Script_typed_ir.ty -&gt;
  'tb Script_typed_ir.ty -&gt;
  (('ta Script_typed_ir.ty, 'tb Script_typed_ir.ty) eq * context) tzresult

val compare_comparable : 'a Script_typed_ir.comparable_ty -&gt; 'a -&gt; 'a -&gt; int

val parse_data :
  ?type_logger:type_logger -&gt;
  context -&gt;
  legacy:bool -&gt;
  'a Script_typed_ir.ty -&gt;
  Script.node -&gt;
  ('a * context) tzresult Lwt.t

val unparse_data :
  context -&gt;
  unparsing_mode -&gt;
  'a Script_typed_ir.ty -&gt;
  'a -&gt;
  (Script.node * context) tzresult Lwt.t

val parse_instr :
  ?type_logger:type_logger -&gt;
  tc_context -&gt;
  context -&gt;
  legacy:bool -&gt;
  Script.node -&gt;
  'bef Script_typed_ir.stack_ty -&gt;
  ('bef judgement * context) tzresult Lwt.t

val parse_ty :
  context -&gt;
  legacy:bool -&gt;
  allow_big_map:bool -&gt;
  allow_operation:bool -&gt;
  allow_contract:bool -&gt;
  Script.node -&gt;
  (ex_ty * context) tzresult

val parse_packable_ty :
  context -&gt; legacy:bool -&gt; Script.node -&gt; (ex_ty * context) tzresult

val unparse_ty :
  context -&gt; 'a Script_typed_ir.ty -&gt; (Script.node * context) tzresult Lwt.t

val parse_toplevel :
  legacy:bool -&gt;
  Script.expr -&gt;
  (Script.node * Script.node * Script.node * string option) tzresult

val add_field_annot :
  Script_typed_ir.field_annot option -&gt;
  Script_typed_ir.var_annot option -&gt;
  Script.node -&gt;
  Script.node

val typecheck_code :
  context -&gt; Script.expr -&gt; (type_map * context) tzresult Lwt.t

val typecheck_data :
  ?type_logger:type_logger -&gt;
  context -&gt;
  Script.expr * Script.expr -&gt;
  context tzresult Lwt.t

val parse_script :
  ?type_logger:type_logger -&gt;
  context -&gt;
  legacy:bool -&gt;
  Script.t -&gt;
  (ex_script * context) tzresult Lwt.t

(* Gas accounting may not be perfect in this function, as it is only called by RPCs. *)
val unparse_script :
  context -&gt;
  unparsing_mode -&gt;
  ('a, 'b) Script_typed_ir.script -&gt;
  (Script.t * context) tzresult Lwt.t

val parse_contract :
  legacy:bool -&gt;
  context -&gt;
  Script.location -&gt;
  'a Script_typed_ir.ty -&gt;
  Contract.t -&gt;
  entrypoint:string -&gt;
  (context * 'a Script_typed_ir.typed_contract) tzresult Lwt.t

val parse_contract_for_script :
  legacy:bool -&gt;
  context -&gt;
  Script.location -&gt;
  'a Script_typed_ir.ty -&gt;
  Contract.t -&gt;
  entrypoint:string -&gt;
  (context * 'a Script_typed_ir.typed_contract option) tzresult Lwt.t

val find_entrypoint :
  't Script_typed_ir.ty -&gt;
  root_name:string option -&gt;
  string -&gt;
  ((Script.node -&gt; Script.node) * ex_ty) tzresult

module Entrypoints_map : S.MAP with type key = string

val list_entrypoints :
  't Script_typed_ir.ty -&gt;
  context -&gt;
  root_name:string option -&gt;
  ( Michelson_v1_primitives.prim list list
  * (Michelson_v1_primitives.prim list * Script.node) Entrypoints_map.t )
  tzresult

val pack_data :
  context -&gt; 'a Script_typed_ir.ty -&gt; 'a -&gt; (MBytes.t * context) tzresult Lwt.t

val hash_data :
  context -&gt;
  'a Script_typed_ir.ty -&gt;
  'a -&gt;
  (Script_expr_hash.t * context) tzresult Lwt.t

type big_map_ids

val no_big_map_id : big_map_ids

val collect_big_maps :
  context -&gt;
  'a Script_typed_ir.ty -&gt;
  'a -&gt;
  (big_map_ids * context) tzresult Lwt.t

val list_of_big_map_ids : big_map_ids -&gt; Z.t list

val extract_big_map_diff :
  context -&gt;
  unparsing_mode -&gt;
  temporary:bool -&gt;
  to_duplicate:big_map_ids -&gt;
  to_update:big_map_ids -&gt;
  'a Script_typed_ir.ty -&gt;
  'a -&gt;
  ('a * Contract.big_map_diff option * context) tzresult Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_ir_translator.mli"><code>Script_ir_translator_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Michelson_v1_primitives.
Require Tezos.Script_expr_hash.
Require Tezos.Script_tc_errors.
Require Tezos.Script_typed_ir.

Import Alpha_context.

Import Script_tc_errors.

Inductive eq : Set :=
| Eq : eq.

Inductive ex_comparable_ty : Set :=
| Ex_comparable_ty : Script_typed_ir.comparable_ty -&gt; ex_comparable_ty.

Inductive ex_ty : Set :=
| Ex_ty : Script_typed_ir.ty -&gt; ex_ty.

Inductive ex_stack_ty : Set :=
| Ex_stack_ty : Script_typed_ir.stack_ty -&gt; ex_stack_ty.

Inductive ex_script : Set :=
| Ex_script : forall {b : Set}, Script_typed_ir.script b -&gt; ex_script.

Module ConstructorRecords_tc_context.
  Module tc_context.
    Module Toplevel.
      Record record {storage_type param_type root_name
        legacy_create_contract_literal : Set} : Set := Build {
        storage_type : storage_type;
        param_type : param_type;
        root_name : root_name;
        legacy_create_contract_literal : legacy_create_contract_literal }.
      Arguments record : clear implicits.
      Definition with_storage_type
        {t_storage_type t_param_type t_root_name
          t_legacy_create_contract_literal} storage_type
        (r :
          record t_storage_type t_param_type t_root_name
            t_legacy_create_contract_literal) :=
        Build t_storage_type t_param_type t_root_name
          t_legacy_create_contract_literal storage_type r.(param_type)
          r.(root_name) r.(legacy_create_contract_literal).
      Definition with_param_type
        {t_storage_type t_param_type t_root_name
          t_legacy_create_contract_literal} param_type
        (r :
          record t_storage_type t_param_type t_root_name
            t_legacy_create_contract_literal) :=
        Build t_storage_type t_param_type t_root_name
          t_legacy_create_contract_literal r.(storage_type) param_type
          r.(root_name) r.(legacy_create_contract_literal).
      Definition with_root_name
        {t_storage_type t_param_type t_root_name
          t_legacy_create_contract_literal} root_name
        (r :
          record t_storage_type t_param_type t_root_name
            t_legacy_create_contract_literal) :=
        Build t_storage_type t_param_type t_root_name
          t_legacy_create_contract_literal r.(storage_type) r.(param_type)
          root_name r.(legacy_create_contract_literal).
      Definition with_legacy_create_contract_literal
        {t_storage_type t_param_type t_root_name
          t_legacy_create_contract_literal} legacy_create_contract_literal
        (r :
          record t_storage_type t_param_type t_root_name
            t_legacy_create_contract_literal) :=
        Build t_storage_type t_param_type t_root_name
          t_legacy_create_contract_literal r.(storage_type) r.(param_type)
          r.(root_name) legacy_create_contract_literal.
    End Toplevel.
    Definition Toplevel_skeleton := Toplevel.record.
  End tc_context.
End ConstructorRecords_tc_context.
Import ConstructorRecords_tc_context.

Reserved Notation &quot;'tc_context.Toplevel&quot;.

Inductive tc_context : Set :=
| Lambda : tc_context
| Dip : Script_typed_ir.stack_ty -&gt; tc_context -&gt; tc_context
| Toplevel : 'tc_context.Toplevel -&gt; tc_context

where &quot;'tc_context.Toplevel&quot; :=
  (tc_context.Toplevel_skeleton Script_typed_ir.ty Script_typed_ir.ty
    (option string) bool).

Module tc_context.
  Include ConstructorRecords_tc_context.tc_context.
  Definition Toplevel := 'tc_context.Toplevel.
End tc_context.

Module ConstructorRecords_judgement.
  Module judgement.
    Module Failed.
      Record record {descr : Set} : Set := Build {
        descr : descr }.
      Arguments record : clear implicits.
      Definition with_descr {t_descr} descr (r : record t_descr) :=
        Build t_descr descr.
    End Failed.
    Definition Failed_skeleton := Failed.record.
  End judgement.
End ConstructorRecords_judgement.
Import ConstructorRecords_judgement.

Reserved Notation &quot;'judgement.Failed&quot;.

Inductive judgement : Set :=
| Typed : Script_typed_ir.descr -&gt; judgement
| Failed : 'judgement.Failed -&gt; judgement

where &quot;'judgement.Failed&quot; :=
  (judgement.Failed_skeleton (Script_typed_ir.stack_ty -&gt; Script_typed_ir.descr)).

Module judgement.
  Include ConstructorRecords_judgement.judgement.
  Definition Failed := 'judgement.Failed.
End judgement.

Inductive unparsing_mode : Set :=
| Optimized : unparsing_mode
| Readable : unparsing_mode.

Definition type_logger : Set :=
  int -&gt; list (Alpha_context.Script.expr * Alpha_context.Script.annot) -&gt;
  list (Alpha_context.Script.expr * Alpha_context.Script.annot) -&gt; unit.

Parameter empty_set : forall {a : Set},
  Script_typed_ir.comparable_ty -&gt; Script_typed_ir.set a.

Parameter set_fold : forall {acc elt : Set},
  (elt -&gt; acc -&gt; acc) -&gt; Script_typed_ir.set elt -&gt; acc -&gt; acc.

Parameter set_update : forall {a : Set},
  a -&gt; bool -&gt; Script_typed_ir.set a -&gt; Script_typed_ir.set a.

Parameter set_mem : forall {elt : Set}, elt -&gt; Script_typed_ir.set elt -&gt; bool.

Parameter set_size : forall {elt : Set},
  Script_typed_ir.set elt -&gt; Alpha_context.Script_int.num.

Parameter empty_map : forall {a b : Set},
  Script_typed_ir.comparable_ty -&gt; Script_typed_ir.map a b.

Parameter map_fold : forall {acc key value : Set},
  (key -&gt; value -&gt; acc -&gt; acc) -&gt; Script_typed_ir.map key value -&gt; acc -&gt; acc.

Parameter map_update : forall {a b : Set},
  a -&gt; option b -&gt; Script_typed_ir.map a b -&gt; Script_typed_ir.map a b.

Parameter map_mem : forall {key value : Set},
  key -&gt; Script_typed_ir.map key value -&gt; bool.

Parameter map_get : forall {key value : Set},
  key -&gt; Script_typed_ir.map key value -&gt; option value.

Parameter map_key_ty : forall {a b : Set},
  Script_typed_ir.map a b -&gt; Script_typed_ir.comparable_ty.

Parameter map_size : forall {a b : Set},
  Script_typed_ir.map a b -&gt; Alpha_context.Script_int.num.

Parameter empty_big_map : forall {a b : Set},
  Script_typed_ir.comparable_ty -&gt; Script_typed_ir.ty -&gt;
  Script_typed_ir.big_map a b.

Parameter big_map_mem : forall {key value : Set},
  Alpha_context.context -&gt; key -&gt; Script_typed_ir.big_map key value -&gt;
  Lwt.t (Error_monad.tzresult (bool * Alpha_context.context)).

Parameter big_map_get : forall {key value : Set},
  Alpha_context.context -&gt; key -&gt; Script_typed_ir.big_map key value -&gt;
  Lwt.t (Error_monad.tzresult (option value * Alpha_context.context)).

Parameter big_map_update : forall {key value : Set},
  key -&gt; option value -&gt; Script_typed_ir.big_map key value -&gt;
  Script_typed_ir.big_map key value.

Parameter ty_eq :
  Alpha_context.context -&gt; Script_typed_ir.ty -&gt; Script_typed_ir.ty -&gt;
  Error_monad.tzresult (eq * Alpha_context.context).

Parameter compare_comparable : forall {a : Set},
  Script_typed_ir.comparable_ty -&gt; a -&gt; a -&gt; int.

Parameter parse_data : forall {a : Set},
  option type_logger -&gt; Alpha_context.context -&gt; bool -&gt; Script_typed_ir.ty -&gt;
  Alpha_context.Script.node -&gt;
  Lwt.t (Error_monad.tzresult (a * Alpha_context.context)).

Parameter unparse_data : forall {a : Set},
  Alpha_context.context -&gt; unparsing_mode -&gt; Script_typed_ir.ty -&gt; a -&gt;
  Lwt.t
    (Error_monad.tzresult (Alpha_context.Script.node * Alpha_context.context)).

Parameter parse_instr :
  option type_logger -&gt; tc_context -&gt; Alpha_context.context -&gt; bool -&gt;
  Alpha_context.Script.node -&gt; Script_typed_ir.stack_ty -&gt;
  Lwt.t (Error_monad.tzresult (judgement * Alpha_context.context)).

Parameter parse_ty :
  Alpha_context.context -&gt; bool -&gt; bool -&gt; bool -&gt; bool -&gt;
  Alpha_context.Script.node -&gt;
  Error_monad.tzresult (ex_ty * Alpha_context.context).

Parameter parse_packable_ty :
  Alpha_context.context -&gt; bool -&gt; Alpha_context.Script.node -&gt;
  Error_monad.tzresult (ex_ty * Alpha_context.context).

Parameter unparse_ty :
  Alpha_context.context -&gt; Script_typed_ir.ty -&gt;
  Lwt.t
    (Error_monad.tzresult (Alpha_context.Script.node * Alpha_context.context)).

Parameter parse_toplevel :
  bool -&gt; Alpha_context.Script.expr -&gt;
  Error_monad.tzresult
    (Alpha_context.Script.node * Alpha_context.Script.node *
      Alpha_context.Script.node * option string).

Parameter add_field_annot :
  option Script_typed_ir.field_annot -&gt; option Script_typed_ir.var_annot -&gt;
  Alpha_context.Script.node -&gt; Alpha_context.Script.node.

Parameter typecheck_code :
  Alpha_context.context -&gt; Alpha_context.Script.expr -&gt;
  Lwt.t
    (Error_monad.tzresult (Script_tc_errors.type_map * Alpha_context.context)).

Parameter typecheck_data :
  option type_logger -&gt; Alpha_context.context -&gt;
  Alpha_context.Script.expr * Alpha_context.Script.expr -&gt;
  Lwt.t (Error_monad.tzresult Alpha_context.context).

Parameter parse_script :
  option type_logger -&gt; Alpha_context.context -&gt; bool -&gt;
  Alpha_context.Script.t -&gt;
  Lwt.t (Error_monad.tzresult (ex_script * Alpha_context.context)).

Parameter unparse_script : forall {b : Set},
  Alpha_context.context -&gt; unparsing_mode -&gt; Script_typed_ir.script b -&gt;
  Lwt.t (Error_monad.tzresult (Alpha_context.Script.t * Alpha_context.context)).

Parameter parse_contract :
  bool -&gt; Alpha_context.context -&gt; Alpha_context.Script.location -&gt;
  Script_typed_ir.ty -&gt; Alpha_context.Contract.t -&gt; string -&gt;
  Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context * Script_typed_ir.typed_contract)).

Parameter parse_contract_for_script :
  bool -&gt; Alpha_context.context -&gt; Alpha_context.Script.location -&gt;
  Script_typed_ir.ty -&gt; Alpha_context.Contract.t -&gt; string -&gt;
  Lwt.t
    (Error_monad.tzresult
      (Alpha_context.context * option Script_typed_ir.typed_contract)).

Parameter find_entrypoint :
  Script_typed_ir.ty -&gt; option string -&gt; string -&gt;
  Error_monad.tzresult
    ((Alpha_context.Script.node -&gt; Alpha_context.Script.node) * ex_ty).

Parameter Entrypoints_map :
  {t : Set -&gt; Set &amp; S.MAP.signature (key := string) (t := t)}.

Parameter list_entrypoints :
  Script_typed_ir.ty -&gt; Alpha_context.context -&gt; option string -&gt;
  Error_monad.tzresult
    (list (list Michelson_v1_primitives.prim) *
      (|Entrypoints_map|).(S.MAP.t)
        (list Michelson_v1_primitives.prim * Alpha_context.Script.node)).

Parameter pack_data : forall {a : Set},
  Alpha_context.context -&gt; Script_typed_ir.ty -&gt; a -&gt;
  Lwt.t (Error_monad.tzresult (MBytes.t * Alpha_context.context)).

Parameter hash_data : forall {a : Set},
  Alpha_context.context -&gt; Script_typed_ir.ty -&gt; a -&gt;
  Lwt.t (Error_monad.tzresult (Script_expr_hash.t * Alpha_context.context)).

Parameter big_map_ids : Set.

Parameter no_big_map_id : big_map_ids.

Parameter collect_big_maps : forall {a : Set},
  Alpha_context.context -&gt; Script_typed_ir.ty -&gt; a -&gt;
  Lwt.t (Error_monad.tzresult (big_map_ids * Alpha_context.context)).

Parameter list_of_big_map_ids : big_map_ids -&gt; list Z.t.

Parameter extract_big_map_diff : forall {a : Set},
  Alpha_context.context -&gt; unparsing_mode -&gt; bool -&gt; big_map_ids -&gt;
  big_map_ids -&gt; Script_typed_ir.ty -&gt; a -&gt;
  Lwt.t
    (Error_monad.tzresult
      (a * option Alpha_context.Contract.big_map_diff * Alpha_context.context)).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_repr.ml">
  <div style="margin: 20px;">
    <h3>Script_repr</h3>
    <ul>
      <li>OCaml size: 233 lines</li>
      <li>Coq size: 296 lines (+27% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#script_repr.ml"><code>script_repr.ml</code></a>&nbsp;<span class="label label-warning">4 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type location = Micheline.canonical_location

let location_encoding = Micheline.canonical_location_encoding

type annot = Micheline.annot

type expr = Michelson_v1_primitives.prim Micheline.canonical

type lazy_expr = expr Data_encoding.lazy_t

type node = (location, Michelson_v1_primitives.prim) Micheline.node

let expr_encoding =
  Micheline.canonical_encoding_v1
    ~variant:&quot;michelson_v1&quot;
    Michelson_v1_primitives.prim_encoding

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Lazy_script_decode</abbr> (* `Permanent *)

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  register_error_kind
    `Permanent
    ~id:&quot;invalid_binary_format&quot;
    ~title:&quot;Invalid binary format&quot;
    ~description:
      &quot;Could not deserialize some piece of data from its binary representation&quot;
    Data_encoding.empty
    (function Lazy_script_decode -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Lazy_script_decode)</abbr>

let lazy_expr_encoding = Data_encoding.lazy_encoding expr_encoding

let lazy_expr expr = Data_encoding.make_lazy expr_encoding expr

type t = {code : lazy_expr; storage : lazy_expr}

let encoding =
  let open Data_encoding in
  def &quot;scripted.contracts&quot;
  @@ conv
       (fun {code; storage} -&gt; (code, storage))
       (fun (code, storage) -&gt; {code; storage})
       (obj2 (req &quot;code&quot; lazy_expr_encoding) (req &quot;storage&quot; lazy_expr_encoding))

let int_node_size_of_numbits n = (1, 1 + ((n + 63) / 64))

let int_node_size n = int_node_size_of_numbits (Z.numbits n)

let string_node_size_of_length s = (1, 1 + ((s + 7) / 8))

let string_node_size s = string_node_size_of_length (String.length s)

let bytes_node_size_of_length s =
  (* approx cost of indirection to the C heap *)
  (2, 1 + ((s + 7) / 8) + 12)

let bytes_node_size s = bytes_node_size_of_length (MBytes.length s)

let prim_node_size_nonrec_of_lengths n_args annots =
  let annots_length =
    List.fold_left (fun acc s -&gt; acc + String.length s) 0 annots
  in
  if Compare.Int.(annots_length = 0) then (1 + n_args, 2 + (2 * n_args))
  else (2 + n_args, 4 + (2 * n_args) + ((annots_length + 7) / 8))

let prim_node_size_nonrec args annots =
  let n_args = List.length args in
  prim_node_size_nonrec_of_lengths n_args annots

let seq_node_size_nonrec_of_length n_args = (1 + n_args, 2 + (2 * n_args))

let seq_node_size_nonrec args =
  let n_args = List.length args in
  seq_node_size_nonrec_of_length n_args

let rec node_size node =
  let open Micheline in
  match node with
  | Int (_, n) -&gt;
      int_node_size n
  | String (_, s) -&gt;
      string_node_size s
  | Bytes (_, s) -&gt;
      bytes_node_size s
  | Prim (_, _, args, annot) -&gt;
      List.fold_left
        (fun (blocks, words) node -&gt;
          let (nblocks, nwords) = node_size node in
          (blocks + nblocks, words + nwords))
        (prim_node_size_nonrec args annot)
        args
  | Seq (_, args) -&gt;
      List.fold_left
        (fun (blocks, words) node -&gt;
          let (nblocks, nwords) = node_size node in
          (blocks + nblocks, words + nwords))
        (seq_node_size_nonrec args)
        args

let expr_size expr = node_size (Micheline.root expr)

let traversal_cost node =
  let (blocks, _words) = node_size node in
  Gas_limit_repr.step_cost blocks

let cost_of_size (blocks, words) =
  let open Gas_limit_repr in
  (Compare.Int.max 0 (blocks - 1) *@ alloc_cost 0)
  +@ alloc_cost words +@ step_cost blocks

let node_cost node = cost_of_size (node_size node)

let int_node_cost n = cost_of_size (int_node_size n)

let int_node_cost_of_numbits n = cost_of_size (int_node_size_of_numbits n)

let string_node_cost s = cost_of_size (string_node_size s)

let string_node_cost_of_length s = cost_of_size (string_node_size_of_length s)

let bytes_node_cost s = cost_of_size (bytes_node_size s)

let bytes_node_cost_of_length s = cost_of_size (bytes_node_size_of_length s)

let prim_node_cost_nonrec args annot =
  cost_of_size (prim_node_size_nonrec args annot)

let prim_node_cost_nonrec_of_length n_args annot =
  cost_of_size (prim_node_size_nonrec_of_lengths n_args annot)

let seq_node_cost_nonrec args = cost_of_size (seq_node_size_nonrec args)

let seq_node_cost_nonrec_of_length n_args =
  cost_of_size (seq_node_size_nonrec_of_length n_args)

let deserialized_cost expr = cost_of_size (expr_size expr)

let serialized_cost bytes =
  let open Gas_limit_repr in
  alloc_mbytes_cost (MBytes.length bytes)

let force_decode lexpr =
  let account_deserialization_cost =
    Data_encoding.apply_lazy
      ~fun_value:(fun _ -&gt; false)
      ~fun_bytes:(fun _ -&gt; true)
      ~fun_combine:(fun _ _ -&gt; false)
      lexpr
  in
  match Data_encoding.force_decode lexpr with
  | Some v -&gt;
      if account_deserialization_cost then ok (v, deserialized_cost v)
      else ok (v, Gas_limit_repr.free)
  | None -&gt;
      error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Lazy_script_decode</abbr>

let force_bytes expr =
  let open Gas_limit_repr in
  let account_serialization_cost =
    Data_encoding.apply_lazy
      ~fun_value:(fun v -&gt; Some v)
      ~fun_bytes:(fun _ -&gt; None)
      ~fun_combine:(fun _ _ -&gt; None)
      expr
  in
  match Data_encoding.force_bytes expr with
  | bytes -&gt; (
    match account_serialization_cost with
    | Some v -&gt;
        ok (bytes, traversal_cost (Micheline.root v) +@ serialized_cost bytes)
    | None -&gt;
        ok (bytes, Gas_limit_repr.free) )
  | exception <abbr class="mark-warning" title="We do not support pattern-matching on exceptions">_</abbr> -&gt;
      error Lazy_script_decode

let minimal_deserialize_cost lexpr =
  Data_encoding.apply_lazy
    ~fun_value:(fun _ -&gt; Gas_limit_repr.free)
    ~fun_bytes:(fun b -&gt; serialized_cost b)
    ~fun_combine:(fun c_free _ -&gt; c_free)
    lexpr

let unit =
  Micheline.strip_locations (Prim (0, Michelson_v1_primitives.D_Unit, [], []))

let unit_parameter = lazy_expr unit

let is_unit_parameter =
  let unit_bytes = Data_encoding.force_bytes unit_parameter in
  Data_encoding.apply_lazy
    ~fun_value:(fun v -&gt;
      match Micheline.root v with
      | Prim (_, Michelson_v1_primitives.D_Unit, [], []) -&gt;
          true
      | _ -&gt;
          false)
    ~fun_bytes:(fun b -&gt; MBytes.( = ) b unit_bytes)
    ~fun_combine:(fun res _ -&gt; res)

let rec strip_annotations node =
  let open Micheline in
  match node with
  | (Int (_, _) | String (_, _) | Bytes (_, _)) as leaf -&gt;
      leaf
  | Prim (loc, name, args, _) -&gt;
      Prim (loc, name, List.map strip_annotations args, [])
  | Seq (loc, args) -&gt;
      Seq (loc, List.map strip_annotations args)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_repr.ml"><code>Script_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Gas_limit_repr.
Require Tezos.Michelson_v1_primitives.

Definition location : Set := Micheline.canonical_location.

Definition location_encoding
  : Data_encoding.encoding Micheline.canonical_location :=
  Micheline.canonical_location_encoding.

Definition annot : Set := Micheline.annot.

Definition expr : Set := Micheline.canonical Michelson_v1_primitives.prim.

Definition lazy_expr : Set := Data_encoding.lazy_t expr.

Definition node : Set := Micheline.node location Michelson_v1_primitives.prim.

Definition expr_encoding
  : Data_encoding.encoding (Micheline.canonical Michelson_v1_primitives.prim) :=
  Micheline.canonical_encoding_v1 &quot;michelson_v1&quot;
    Michelson_v1_primitives.prim_encoding.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition lazy_expr_encoding
  : Data_encoding.encoding
    (Data_encoding.lazy_t (Micheline.canonical Michelson_v1_primitives.prim)) :=
  Data_encoding.lazy_encoding expr_encoding.

Definition __lazy_expr_value
  (expr : Micheline.canonical Michelson_v1_primitives.prim)
  : Data_encoding.lazy_t (Micheline.canonical Michelson_v1_primitives.prim) :=
  Data_encoding.make_lazy expr_encoding expr.

Module t.
  Record record : Set := Build {
    code : lazy_expr;
    storage : lazy_expr }.
  Definition with_code code (r : record) :=
    Build code r.(storage).
  Definition with_storage storage (r : record) :=
    Build r.(code) storage.
End t.
Definition t := t.record.

Definition encoding : Data_encoding.encoding t :=
  (let arg := Data_encoding.def &quot;scripted.contracts&quot; in
  fun eta =&gt; arg None None eta)
    (Data_encoding.conv
      (fun function_parameter =&gt;
        let '{| t.code := code; t.storage := storage |} := function_parameter in
        (code, storage))
      (fun function_parameter =&gt;
        let '(code, storage) := function_parameter in
        {| t.code := code; t.storage := storage |}) None
      (Data_encoding.obj2
        (Data_encoding.req None None &quot;code&quot; lazy_expr_encoding)
        (Data_encoding.req None None &quot;storage&quot; lazy_expr_encoding))).

Definition int_node_size_of_numbits (n : int) : int * int :=
  (1, (Pervasives.op_plus 1 (Pervasives.op_div (Pervasives.op_plus n 63) 64))).

Definition int_node_size (n : Z.t) : int * int :=
  int_node_size_of_numbits (Z.numbits n).

Definition string_node_size_of_length (s : int) : int * int :=
  (1, (Pervasives.op_plus 1 (Pervasives.op_div (Pervasives.op_plus s 7) 8))).

Definition string_node_size (s : string) : int * int :=
  string_node_size_of_length (String.length s).

Definition bytes_node_size_of_length (s : int) : int * int :=
  (2,
    (Pervasives.op_plus
      (Pervasives.op_plus 1 (Pervasives.op_div (Pervasives.op_plus s 7) 8)) 12)).

Definition bytes_node_size (s : MBytes.t) : int * int :=
  bytes_node_size_of_length (MBytes.length s).

Definition prim_node_size_nonrec_of_lengths
  (n_args : int) (annots : list string) : int * int :=
  let annots_length :=
    List.fold_left
      (fun acc =&gt; fun s =&gt; Pervasives.op_plus acc (String.length s)) 0 annots in
  if (|Compare.Int|).(Compare.S.op_eq) annots_length 0 then
    ((Pervasives.op_plus 1 n_args),
      (Pervasives.op_plus 2 (Pervasives.op_star 2 n_args)))
  else
    ((Pervasives.op_plus 2 n_args),
      (Pervasives.op_plus (Pervasives.op_plus 4 (Pervasives.op_star 2 n_args))
        (Pervasives.op_div (Pervasives.op_plus annots_length 7) 8))).

Definition prim_node_size_nonrec {A : Set}
  (args : list A) (annots : list string) : int * int :=
  let n_args := List.length args in
  prim_node_size_nonrec_of_lengths n_args annots.

Definition seq_node_size_nonrec_of_length (n_args : int) : int * int :=
  ((Pervasives.op_plus 1 n_args),
    (Pervasives.op_plus 2 (Pervasives.op_star 2 n_args))).

Definition seq_node_size_nonrec {A : Set} (args : list A) : int * int :=
  let n_args := List.length args in
  seq_node_size_nonrec_of_length n_args.

Fixpoint node_size {A B : Set} (node : Micheline.node A B) {struct node}
  : int * int :=
  match node with
  | Micheline.Int _ n =&gt; int_node_size n
  | Micheline.String _ s =&gt; string_node_size s
  | Micheline.Bytes _ s =&gt; bytes_node_size s
  | Micheline.Prim _ _ args annot =&gt;
    List.fold_left
      (fun function_parameter =&gt;
        let '(blocks, words) := function_parameter in
        fun node =&gt;
          let '(nblocks, nwords) := node_size node in
          ((Pervasives.op_plus blocks nblocks),
            (Pervasives.op_plus words nwords)))
      (prim_node_size_nonrec args annot) args
  | Micheline.Seq _ args =&gt;
    List.fold_left
      (fun function_parameter =&gt;
        let '(blocks, words) := function_parameter in
        fun node =&gt;
          let '(nblocks, nwords) := node_size node in
          ((Pervasives.op_plus blocks nblocks),
            (Pervasives.op_plus words nwords))) (seq_node_size_nonrec args) args
  end.

Definition expr_size {A : Set} (expr : Micheline.canonical A) : int * int :=
  node_size (Micheline.root expr).

Definition traversal_cost {A B : Set} (node : Micheline.node A B)
  : Gas_limit_repr.cost :=
  let '(blocks, _words) := node_size node in
  Gas_limit_repr.step_cost blocks.

Definition cost_of_size (function_parameter : int * int)
  : Gas_limit_repr.cost :=
  let '(blocks, words) := function_parameter in
  Gas_limit_repr.op_plusat
    (Gas_limit_repr.op_plusat
      (Gas_limit_repr.op_starat
        ((|Compare.Int|).(Compare.S.max) 0 (Pervasives.op_minus blocks 1))
        (Gas_limit_repr.alloc_cost 0)) (Gas_limit_repr.alloc_cost words))
    (Gas_limit_repr.step_cost blocks).

Definition node_cost {A B : Set} (node : Micheline.node A B)
  : Gas_limit_repr.cost := cost_of_size (node_size node).

Definition int_node_cost (n : Z.t) : Gas_limit_repr.cost :=
  cost_of_size (int_node_size n).

Definition int_node_cost_of_numbits (n : int) : Gas_limit_repr.cost :=
  cost_of_size (int_node_size_of_numbits n).

Definition string_node_cost (s : string) : Gas_limit_repr.cost :=
  cost_of_size (string_node_size s).

Definition string_node_cost_of_length (s : int) : Gas_limit_repr.cost :=
  cost_of_size (string_node_size_of_length s).

Definition bytes_node_cost (s : MBytes.t) : Gas_limit_repr.cost :=
  cost_of_size (bytes_node_size s).

Definition bytes_node_cost_of_length (s : int) : Gas_limit_repr.cost :=
  cost_of_size (bytes_node_size_of_length s).

Definition prim_node_cost_nonrec {A : Set} (args : list A) (annot : list string)
  : Gas_limit_repr.cost := cost_of_size (prim_node_size_nonrec args annot).

Definition prim_node_cost_nonrec_of_length (n_args : int) (annot : list string)
  : Gas_limit_repr.cost :=
  cost_of_size (prim_node_size_nonrec_of_lengths n_args annot).

Definition seq_node_cost_nonrec {A : Set} (args : list A)
  : Gas_limit_repr.cost := cost_of_size (seq_node_size_nonrec args).

Definition seq_node_cost_nonrec_of_length (n_args : int)
  : Gas_limit_repr.cost := cost_of_size (seq_node_size_nonrec_of_length n_args).

Definition deserialized_cost {A : Set} (expr : Micheline.canonical A)
  : Gas_limit_repr.cost := cost_of_size (expr_size expr).

Definition serialized_cost (__bytes_value : MBytes.t) : Gas_limit_repr.cost :=
  Gas_limit_repr.alloc_mbytes_cost (MBytes.length __bytes_value).

Definition force_decode {A : Set}
  (lexpr : Data_encoding.lazy_t (Micheline.canonical A))
  : Error_monad.tzresult (Micheline.canonical A * Gas_limit_repr.cost) :=
  let account_deserialization_cost :=
    Data_encoding.apply_lazy
      (fun function_parameter =&gt;
        let '_ := function_parameter in
        false)
      (fun function_parameter =&gt;
        let '_ := function_parameter in
        true)
      (fun function_parameter =&gt;
        let '_ := function_parameter in
        fun function_parameter =&gt;
          let '_ := function_parameter in
          false) lexpr in
  match Data_encoding.force_decode lexpr with
  | Some v =&gt;
    if account_deserialization_cost then
      Error_monad.ok (v, (deserialized_cost v))
    else
      Error_monad.ok (v, Gas_limit_repr.free)
  | None =&gt; Error_monad.__error_value extensible_type_value
  end.

Definition force_bytes {A : Set}
  (expr : Data_encoding.lazy_t (Micheline.canonical A))
  : Error_monad.tzresult (MBytes.t * Gas_limit_repr.cost) :=
  let account_serialization_cost :=
    Data_encoding.apply_lazy (fun v =&gt; Some v)
      (fun function_parameter =&gt;
        let '_ := function_parameter in
        None)
      (fun function_parameter =&gt;
        let '_ := function_parameter in
        fun function_parameter =&gt;
          let '_ := function_parameter in
          None) expr in
  let '__bytes_value := Data_encoding.force_bytes expr in
  match account_serialization_cost with
  | Some v =&gt;
    Error_monad.ok
      (__bytes_value,
        (Gas_limit_repr.op_plusat (traversal_cost (Micheline.root v))
          (serialized_cost __bytes_value)))
  | None =&gt; Error_monad.ok (__bytes_value, Gas_limit_repr.free)
  end.

Definition minimal_deserialize_cost {A : Set} (lexpr : Data_encoding.lazy_t A)
  : Gas_limit_repr.cost :=
  Data_encoding.apply_lazy
    (fun function_parameter =&gt;
      let '_ := function_parameter in
      Gas_limit_repr.free) (fun __b_value =&gt; serialized_cost __b_value)
    (fun c_free =&gt;
      fun function_parameter =&gt;
        let '_ := function_parameter in
        c_free) lexpr.

Definition __unit_value : Micheline.canonical Michelson_v1_primitives.prim :=
  Micheline.strip_locations
    (Micheline.Prim 0 Michelson_v1_primitives.D_Unit nil nil).

Definition unit_parameter
  : Data_encoding.lazy_t (Micheline.canonical Michelson_v1_primitives.prim) :=
  __lazy_expr_value __unit_value.

Definition is_unit_parameter
  : Data_encoding.lazy_t (Micheline.canonical Michelson_v1_primitives.prim) -&gt;
  bool :=
  let unit_bytes := Data_encoding.force_bytes unit_parameter in
  Data_encoding.apply_lazy
    (fun v =&gt;
      match Micheline.root v with
      | Micheline.Prim _ Michelson_v1_primitives.D_Unit [] [] =&gt; true
      | _ =&gt; false
      end) (fun __b_value =&gt; MBytes.op_eq __b_value unit_bytes)
    (fun res =&gt;
      fun function_parameter =&gt;
        let '_ := function_parameter in
        res).

Fixpoint strip_annotations {A B : Set} (node : Micheline.node A B) {struct node}
  : Micheline.node A B :=
  match node with
  | (Micheline.Int _ _ | Micheline.String _ _ | Micheline.Bytes _ _) as leaf =&gt;
    leaf
  | Micheline.Prim loc name args _ =&gt;
    Micheline.Prim loc name (List.map strip_annotations args) nil
  | Micheline.Seq loc args =&gt;
    Micheline.Seq loc (List.map strip_annotations args)
  end.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_repr.mli">
  <div style="margin: 20px;">
    <h3>Script_repr_mli</h3>
    <ul>
      <li>OCaml size: 88 lines</li>
      <li>Coq size: 88 lines (+0% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#script_repr.mli"><code>script_repr.mli</code></a>&nbsp;<span class="label label-warning">1 warning</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type location = Micheline.canonical_location

type annot = Micheline.annot

type expr = Michelson_v1_primitives.prim Micheline.canonical

<abbr class="mark-warning" title="Extensible types are not handled.">type error += Lazy_script_decode</abbr> (* `Permanent *)

type lazy_expr = expr Data_encoding.lazy_t

type node = (location, Michelson_v1_primitives.prim) Micheline.node

val location_encoding : location Data_encoding.t

val expr_encoding : expr Data_encoding.t

val lazy_expr_encoding : lazy_expr Data_encoding.t

val lazy_expr : expr -&gt; lazy_expr

type t = {code : lazy_expr; storage : lazy_expr}

val encoding : t Data_encoding.encoding

val deserialized_cost : expr -&gt; Gas_limit_repr.cost

val serialized_cost : MBytes.t -&gt; Gas_limit_repr.cost

val traversal_cost : node -&gt; Gas_limit_repr.cost

val node_cost : node -&gt; Gas_limit_repr.cost

val int_node_cost : Z.t -&gt; Gas_limit_repr.cost

val int_node_cost_of_numbits : int -&gt; Gas_limit_repr.cost

val string_node_cost : string -&gt; Gas_limit_repr.cost

val string_node_cost_of_length : int -&gt; Gas_limit_repr.cost

val bytes_node_cost : MBytes.t -&gt; Gas_limit_repr.cost

val bytes_node_cost_of_length : int -&gt; Gas_limit_repr.cost

val prim_node_cost_nonrec : expr list -&gt; annot -&gt; Gas_limit_repr.cost

val prim_node_cost_nonrec_of_length : int -&gt; annot -&gt; Gas_limit_repr.cost

val seq_node_cost_nonrec : expr list -&gt; Gas_limit_repr.cost

val seq_node_cost_nonrec_of_length : int -&gt; Gas_limit_repr.cost

val force_decode : lazy_expr -&gt; (expr * Gas_limit_repr.cost) tzresult

val force_bytes : lazy_expr -&gt; (MBytes.t * Gas_limit_repr.cost) tzresult

val minimal_deserialize_cost : lazy_expr -&gt; Gas_limit_repr.cost

val unit_parameter : lazy_expr

val is_unit_parameter : lazy_expr -&gt; bool

val strip_annotations : node -&gt; node
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_repr.mli"><code>Script_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Gas_limit_repr.
Require Tezos.Michelson_v1_primitives.

Definition location : Set := Micheline.canonical_location.

Definition annot : Set := Micheline.annot.

Definition expr : Set := Micheline.canonical Michelson_v1_primitives.prim.

(* extensible_type_definition `error` *)

Definition lazy_expr : Set := Data_encoding.lazy_t expr.

Definition node : Set := Micheline.node location Michelson_v1_primitives.prim.

Parameter location_encoding : Data_encoding.t location.

Parameter expr_encoding : Data_encoding.t expr.

Parameter lazy_expr_encoding : Data_encoding.t lazy_expr.

Parameter __lazy_expr_value : expr -&gt; lazy_expr.

Module t.
  Record record : Set := Build {
    code : lazy_expr;
    storage : lazy_expr }.
  Definition with_code code (r : record) :=
    Build code r.(storage).
  Definition with_storage storage (r : record) :=
    Build r.(code) storage.
End t.
Definition t := t.record.

Parameter encoding : Data_encoding.encoding t.

Parameter deserialized_cost : expr -&gt; Gas_limit_repr.cost.

Parameter serialized_cost : MBytes.t -&gt; Gas_limit_repr.cost.

Parameter traversal_cost : node -&gt; Gas_limit_repr.cost.

Parameter node_cost : node -&gt; Gas_limit_repr.cost.

Parameter int_node_cost : Z.t -&gt; Gas_limit_repr.cost.

Parameter int_node_cost_of_numbits : int -&gt; Gas_limit_repr.cost.

Parameter string_node_cost : string -&gt; Gas_limit_repr.cost.

Parameter string_node_cost_of_length : int -&gt; Gas_limit_repr.cost.

Parameter bytes_node_cost : MBytes.t -&gt; Gas_limit_repr.cost.

Parameter bytes_node_cost_of_length : int -&gt; Gas_limit_repr.cost.

Parameter prim_node_cost_nonrec : list expr -&gt; annot -&gt; Gas_limit_repr.cost.

Parameter prim_node_cost_nonrec_of_length : int -&gt; annot -&gt; Gas_limit_repr.cost.

Parameter seq_node_cost_nonrec : list expr -&gt; Gas_limit_repr.cost.

Parameter seq_node_cost_nonrec_of_length : int -&gt; Gas_limit_repr.cost.

Parameter force_decode :
  lazy_expr -&gt; Error_monad.tzresult (expr * Gas_limit_repr.cost).

Parameter force_bytes :
  lazy_expr -&gt; Error_monad.tzresult (MBytes.t * Gas_limit_repr.cost).

Parameter minimal_deserialize_cost : lazy_expr -&gt; Gas_limit_repr.cost.

Parameter unit_parameter : lazy_expr.

Parameter is_unit_parameter : lazy_expr -&gt; bool.

Parameter strip_annotations : node -&gt; node.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_tc_errors.ml">
  <div style="margin: 20px;">
    <h3>Script_tc_errors</h3>
    <ul>
      <li>OCaml size: 162 lines</li>
      <li>Coq size: 173 lines (+6% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#script_tc_errors.ml"><code>script_tc_errors.ml</code></a>&nbsp;<span class="label label-warning">46 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context
open Script

(* ---- Error definitions ---------------------------------------------------*)

(* Auxiliary types for error documentation *)
type namespace =
  | Type_namespace
  | Constant_namespace
  | Instr_namespace
  | Keyword_namespace

type kind = Int_kind | String_kind | Bytes_kind | Prim_kind | Seq_kind

type unparsed_stack_ty = (Script.expr * Script.annot) list

type type_map = (int * (unparsed_stack_ty * unparsed_stack_ty)) list

(* Structure errors *)
<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Invalid_arity of Script.location * prim * int * int</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | Invalid_namespace of Script.location * prim * namespace * namespace</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Invalid_primitive of Script.location * prim list * prim</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Invalid_kind of Script.location * kind list * kind</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Missing_field of prim</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Duplicate_field of Script.location * prim</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Unexpected_big_map of Script.location</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Unexpected_operation of Script.location</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Unexpected_contract of Script.location</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += No_such_entrypoint of string</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Duplicate_entrypoint of string</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Unreachable_entrypoint of prim list</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Entrypoint_name_too_long of string</abbr>

(* Instruction typing errors *)
<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Fail_not_in_tail_position of Script.location</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | Undefined_binop :
      Script.location * prim * Script.expr * Script.expr
      -&gt; error</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Undefined_unop : Script.location * prim * Script.expr -&gt; error</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | Bad_return : Script.location * unparsed_stack_ty * Script.expr -&gt; error</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | Bad_stack : Script.location * prim * int * unparsed_stack_ty -&gt; error</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | Unmatched_branches :
      Script.location * unparsed_stack_ty * unparsed_stack_ty
      -&gt; error</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Self_in_lambda of Script.location</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Bad_stack_length</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Bad_stack_item of int</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Inconsistent_annotations of string * string</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | Inconsistent_type_annotations :
      Script.location * Script.expr * Script.expr
      -&gt; error</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Inconsistent_field_annotations of string * string</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Unexpected_annotation of Script.location</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Ungrouped_annotations of Script.location</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Invalid_map_body : Script.location * unparsed_stack_ty -&gt; error</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Invalid_map_block_fail of Script.location</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | Invalid_iter_body :
      Script.location * unparsed_stack_ty * unparsed_stack_ty
      -&gt; error</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Type_too_large : Script.location * int * int -&gt; error</abbr>

(* Value typing errors *)
<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | Invalid_constant : Script.location * Script.expr * Script.expr -&gt; error</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | Invalid_syntactic_constant :
      Script.location * Script.expr * string
      -&gt; error</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Invalid_contract of Script.location * Contract.t</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Invalid_big_map of Script.location * Big_map.id</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | Comparable_type_expected : Script.location * Script.expr -&gt; error</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Inconsistent_types : Script.expr * Script.expr -&gt; error</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Unordered_map_keys of Script.location * Script.expr</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Unordered_set_values of Script.location * Script.expr</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Duplicate_map_keys of Script.location * Script.expr</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Duplicate_set_values of Script.location * Script.expr</abbr>

(* Toplevel errors *)
<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | Ill_typed_data : string option * Script.expr * Script.expr -&gt; error</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | Ill_formed_type of string option * Script.expr * Script.location</abbr>

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Ill_typed_contract : Script.expr * type_map -&gt; error</abbr>

(* Gas related errors *)
<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Cannot_serialize_error</abbr>

(* Deprecation errors *)
<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Deprecated_instruction of prim</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_tc_errors.ml"><code>Script_tc_errors.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.

Import Alpha_context.

Import Alpha_context.Script.

Inductive namespace : Set :=
| Type_namespace : namespace
| Constant_namespace : namespace
| Instr_namespace : namespace
| Keyword_namespace : namespace.

Inductive kind : Set :=
| Int_kind : kind
| String_kind : kind
| Bytes_kind : kind
| Prim_kind : kind
| Seq_kind : kind.

Definition unparsed_stack_ty : Set :=
  list (Alpha_context.Script.expr * Alpha_context.Script.annot).

Definition type_map : Set :=
  list (int * (unparsed_stack_ty * unparsed_stack_ty)).

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_tc_errors_registration.ml">
  <div style="margin: 20px;">
    <h3>Script_tc_errors_registration</h3>
    <ul>
      <li>OCaml size: 652 lines</li>
      <li>Coq size: 54 lines (-92% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#script_tc_errors_registration.ml"><code>script_tc_errors_registration.ml</code></a>&nbsp;<span class="label label-warning">1 warning</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context
open Script
open Script_tc_errors

(* Helpers for encoding *)
let type_map_enc =
  let open Data_encoding in
  let stack_enc = list (tup2 Script.expr_encoding (list string)) in
  list
    (conv
       (fun (loc, (bef, aft)) -&gt; (loc, bef, aft))
       (fun (loc, bef, aft) -&gt; (loc, (bef, aft)))
       (obj3
          (req &quot;location&quot; Script.location_encoding)
          (req &quot;stack_before&quot; stack_enc)
          (req &quot;stack_after&quot; stack_enc)))

let stack_ty_enc =
  let open Data_encoding in
  list (obj2 (req &quot;type&quot; Script.expr_encoding) (dft &quot;annots&quot; (list string) []))

(* main registration *)
<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  let open Data_encoding in
  let located enc =
    merge_objs (obj1 (req &quot;location&quot; Script.location_encoding)) enc
  in
  let arity_enc = int8 in
  let namespace_enc =
    def
      &quot;primitiveNamespace&quot;
      ~title:&quot;Primitive namespace&quot;
      ~description:
        &quot;One of the three possible namespaces of primitive (data constructor, \
         type name or instruction).&quot;
    @@ string_enum
         [ (&quot;type&quot;, Type_namespace);
           (&quot;constant&quot;, Constant_namespace);
           (&quot;instruction&quot;, Instr_namespace) ]
  in
  let kind_enc =
    def
      &quot;expressionKind&quot;
      ~title:&quot;Expression kind&quot;
      ~description:
        &quot;One of the four possible kinds of expression (integer, string, \
         primitive application or sequence).&quot;
    @@ string_enum
         [ (&quot;integer&quot;, Int_kind);
           (&quot;string&quot;, String_kind);
           (&quot;bytes&quot;, Bytes_kind);
           (&quot;primitiveApplication&quot;, Prim_kind);
           (&quot;sequence&quot;, Seq_kind) ]
  in
  (* -- Structure errors ---------------------- *)
  (* Invalid arity *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.invalid_arity&quot;
    ~title:&quot;Invalid arity&quot;
    ~description:
      &quot;In a script or data expression, a primitive was applied to an \
       unsupported number of arguments.&quot;
    (located
       (obj3
          (req &quot;primitive_name&quot; Script.prim_encoding)
          (req &quot;expected_arity&quot; arity_enc)
          (req &quot;wrong_arity&quot; arity_enc)))
    (function
      | Invalid_arity (loc, name, exp, got) -&gt;
          Some (loc, (name, exp, got))
      | _ -&gt;
          None)
    (fun (loc, (name, exp, got)) -&gt; Invalid_arity (loc, name, exp, got)) ;
  (* Missing field *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.missing_script_field&quot;
    ~title:&quot;Script is missing a field (parse error)&quot;
    ~description:&quot;When parsing script, a field was expected, but not provided&quot;
    (obj1 (req &quot;prim&quot; prim_encoding))
    (function Missing_field prim -&gt; Some prim | _ -&gt; None)
    (fun prim -&gt; Missing_field prim) ;
  (* Invalid primitive *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.invalid_primitive&quot;
    ~title:&quot;Invalid primitive&quot;
    ~description:&quot;In a script or data expression, a primitive was unknown.&quot;
    (located
       (obj2
          (dft &quot;expected_primitive_names&quot; (list prim_encoding) [])
          (req &quot;wrong_primitive_name&quot; prim_encoding)))
    (function
      | Invalid_primitive (loc, exp, got) -&gt; Some (loc, (exp, got)) | _ -&gt; None)
    (fun (loc, (exp, got)) -&gt; Invalid_primitive (loc, exp, got)) ;
  (* Invalid kind *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.invalid_expression_kind&quot;
    ~title:&quot;Invalid expression kind&quot;
    ~description:
      &quot;In a script or data expression, an expression was of the wrong kind \
       (for instance a string where only a primitive applications can appear).&quot;
    (located
       (obj2 (req &quot;expected_kinds&quot; (list kind_enc)) (req &quot;wrong_kind&quot; kind_enc)))
    (function
      | Invalid_kind (loc, exp, got) -&gt; Some (loc, (exp, got)) | _ -&gt; None)
    (fun (loc, (exp, got)) -&gt; Invalid_kind (loc, exp, got)) ;
  (* Invalid namespace *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.invalid_primitive_namespace&quot;
    ~title:&quot;Invalid primitive namespace&quot;
    ~description:
      &quot;In a script or data expression, a primitive was of the wrong namespace.&quot;
    (located
       (obj3
          (req &quot;primitive_name&quot; prim_encoding)
          (req &quot;expected_namespace&quot; namespace_enc)
          (req &quot;wrong_namespace&quot; namespace_enc)))
    (function
      | Invalid_namespace (loc, name, exp, got) -&gt;
          Some (loc, (name, exp, got))
      | _ -&gt;
          None)
    (fun (loc, (name, exp, got)) -&gt; Invalid_namespace (loc, name, exp, got)) ;
  (* Duplicate field *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.duplicate_script_field&quot;
    ~title:&quot;Script has a duplicated field (parse error)&quot;
    ~description:&quot;When parsing script, a field was found more than once&quot;
    (obj2 (req &quot;loc&quot; location_encoding) (req &quot;prim&quot; prim_encoding))
    (function Duplicate_field (loc, prim) -&gt; Some (loc, prim) | _ -&gt; None)
    (fun (loc, prim) -&gt; Duplicate_field (loc, prim)) ;
  (* Unexpected big_map *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.unexpected_bigmap&quot;
    ~title:&quot;Big map in unauthorized position (type error)&quot;
    ~description:
      &quot;When parsing script, a big_map type was found in a position where it \
       could end up stored inside a big_map, which is forbidden for now.&quot;
    (obj1 (req &quot;loc&quot; location_encoding))
    (function Unexpected_big_map loc -&gt; Some loc | _ -&gt; None)
    (fun loc -&gt; Unexpected_big_map loc) ;
  (* Unexpected operation *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.unexpected_operation&quot;
    ~title:&quot;Operation in unauthorized position (type error)&quot;
    ~description:
      &quot;When parsing script, an operation type was found in the storage or \
       parameter field.&quot;
    (obj1 (req &quot;loc&quot; location_encoding))
    (function Unexpected_operation loc -&gt; Some loc | _ -&gt; None)
    (fun loc -&gt; Unexpected_operation loc) ;
  (* No such entrypoint *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.no_such_entrypoint&quot;
    ~title:&quot;No such entrypoint (type error)&quot;
    ~description:&quot;An entrypoint was not found when calling a contract.&quot;
    (obj1 (req &quot;entrypoint&quot; string))
    (function No_such_entrypoint entrypoint -&gt; Some entrypoint | _ -&gt; None)
    (fun entrypoint -&gt; No_such_entrypoint entrypoint) ;
  (* Unreachable entrypoint *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.unreachable_entrypoint&quot;
    ~title:&quot;Unreachable entrypoint (type error)&quot;
    ~description:&quot;An entrypoint in the contract is not reachable.&quot;
    (obj1 (req &quot;path&quot; (list prim_encoding)))
    (function Unreachable_entrypoint path -&gt; Some path | _ -&gt; None)
    (fun path -&gt; Unreachable_entrypoint path) ;
  (* Duplicate entrypoint *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.duplicate_entrypoint&quot;
    ~title:&quot;Duplicate entrypoint (type error)&quot;
    ~description:&quot;Two entrypoints have the same name.&quot;
    (obj1 (req &quot;path&quot; string))
    (function Duplicate_entrypoint entrypoint -&gt; Some entrypoint | _ -&gt; None)
    (fun entrypoint -&gt; Duplicate_entrypoint entrypoint) ;
  (* Entrypoint name too long *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.entrypoint_name_too_long&quot;
    ~title:&quot;Entrypoint name too long (type error)&quot;
    ~description:
      &quot;An entrypoint name exceeds the maximum length of 31 characters.&quot;
    (obj1 (req &quot;name&quot; string))
    (function
      | Entrypoint_name_too_long entrypoint -&gt; Some entrypoint | _ -&gt; None)
    (fun entrypoint -&gt; Entrypoint_name_too_long entrypoint) ;
  (* Unexpected contract *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.unexpected_contract&quot;
    ~title:&quot;Contract in unauthorized position (type error)&quot;
    ~description:
      &quot;When parsing script, a contract type was found in the storage or \
       parameter field.&quot;
    (obj1 (req &quot;loc&quot; location_encoding))
    (function Unexpected_contract loc -&gt; Some loc | _ -&gt; None)
    (fun loc -&gt; Unexpected_contract loc) ;
  (* -- Value typing errors ---------------------- *)
  (* Unordered map keys *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.unordered_map_literal&quot;
    ~title:&quot;Invalid map key order&quot;
    ~description:&quot;Map keys must be in strictly increasing order&quot;
    (obj2
       (req &quot;location&quot; Script.location_encoding)
       (req &quot;item&quot; Script.expr_encoding))
    (function Unordered_map_keys (loc, expr) -&gt; Some (loc, expr) | _ -&gt; None)
    (fun (loc, expr) -&gt; Unordered_map_keys (loc, expr)) ;
  (* Duplicate map keys *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.duplicate_map_keys&quot;
    ~title:&quot;Duplicate map keys&quot;
    ~description:&quot;Map literals cannot contain duplicated keys&quot;
    (obj2
       (req &quot;location&quot; Script.location_encoding)
       (req &quot;item&quot; Script.expr_encoding))
    (function Duplicate_map_keys (loc, expr) -&gt; Some (loc, expr) | _ -&gt; None)
    (fun (loc, expr) -&gt; Duplicate_map_keys (loc, expr)) ;
  (* Unordered set values *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.unordered_set_literal&quot;
    ~title:&quot;Invalid set value order&quot;
    ~description:&quot;Set values must be in strictly increasing order&quot;
    (obj2
       (req &quot;location&quot; Script.location_encoding)
       (req &quot;value&quot; Script.expr_encoding))
    (function
      | Unordered_set_values (loc, expr) -&gt; Some (loc, expr) | _ -&gt; None)
    (fun (loc, expr) -&gt; Unordered_set_values (loc, expr)) ;
  (* Duplicate set values *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.duplicate_set_values_in_literal&quot;
    ~title:&quot;Sets literals cannot contain duplicate elements&quot;
    ~description:
      &quot;Set literals cannot contain duplicate elements, but a duplicae was \
       found while parsing.&quot;
    (obj2
       (req &quot;location&quot; Script.location_encoding)
       (req &quot;value&quot; Script.expr_encoding))
    (function
      | Duplicate_set_values (loc, expr) -&gt; Some (loc, expr) | _ -&gt; None)
    (fun (loc, expr) -&gt; Duplicate_set_values (loc, expr)) ;
  (* -- Instruction typing errors ------------- *)
  (* Fail not in tail position *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.fail_not_in_tail_position&quot;
    ~title:&quot;FAIL not in tail position&quot;
    ~description:&quot;There is non trivial garbage code after a FAIL instruction.&quot;
    (located empty)
    (function Fail_not_in_tail_position loc -&gt; Some (loc, ()) | _ -&gt; None)
    (fun (loc, ()) -&gt; Fail_not_in_tail_position loc) ;
  (* Undefined binary operation *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.undefined_binop&quot;
    ~title:&quot;Undefined binop&quot;
    ~description:
      &quot;A binary operation is called on operands of types over which it is not \
       defined.&quot;
    (located
       (obj3
          (req &quot;operator_name&quot; prim_encoding)
          (req &quot;wrong_left_operand_type&quot; Script.expr_encoding)
          (req &quot;wrong_right_operand_type&quot; Script.expr_encoding)))
    (function
      | Undefined_binop (loc, n, tyl, tyr) -&gt;
          Some (loc, (n, tyl, tyr))
      | _ -&gt;
          None)
    (fun (loc, (n, tyl, tyr)) -&gt; Undefined_binop (loc, n, tyl, tyr)) ;
  (* Undefined unary operation *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.undefined_unop&quot;
    ~title:&quot;Undefined unop&quot;
    ~description:
      &quot;A unary operation is called on an operand of type over which it is not \
       defined.&quot;
    (located
       (obj2
          (req &quot;operator_name&quot; prim_encoding)
          (req &quot;wrong_operand_type&quot; Script.expr_encoding)))
    (function Undefined_unop (loc, n, ty) -&gt; Some (loc, (n, ty)) | _ -&gt; None)
    (fun (loc, (n, ty)) -&gt; Undefined_unop (loc, n, ty)) ;
  (* Bad return *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.bad_return&quot;
    ~title:&quot;Bad return&quot;
    ~description:&quot;Unexpected stack at the end of a lambda or script.&quot;
    (located
       (obj2
          (req &quot;expected_return_type&quot; Script.expr_encoding)
          (req &quot;wrong_stack_type&quot; stack_ty_enc)))
    (function Bad_return (loc, sty, ty) -&gt; Some (loc, (ty, sty)) | _ -&gt; None)
    (fun (loc, (ty, sty)) -&gt; Bad_return (loc, sty, ty)) ;
  (* Bad stack *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.bad_stack&quot;
    ~title:&quot;Bad stack&quot;
    ~description:&quot;The stack has an unexpected length or contents.&quot;
    (located
       (obj3
          (req &quot;primitive_name&quot; prim_encoding)
          (req &quot;relevant_stack_portion&quot; int16)
          (req &quot;wrong_stack_type&quot; stack_ty_enc)))
    (function
      | Bad_stack (loc, name, s, sty) -&gt; Some (loc, (name, s, sty)) | _ -&gt; None)
    (fun (loc, (name, s, sty)) -&gt; Bad_stack (loc, name, s, sty)) ;
  (* Inconsistent annotations *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.inconsistent_annotations&quot;
    ~title:&quot;Annotations inconsistent between branches&quot;
    ~description:&quot;The annotations on two types could not be merged&quot;
    (obj2 (req &quot;annot1&quot; string) (req &quot;annot2&quot; string))
    (function
      | Inconsistent_annotations (annot1, annot2) -&gt;
          Some (annot1, annot2)
      | _ -&gt;
          None)
    (fun (annot1, annot2) -&gt; Inconsistent_annotations (annot1, annot2)) ;
  (* Inconsistent field annotations *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.inconsistent_field_annotations&quot;
    ~title:&quot;Annotations for field accesses is inconsistent&quot;
    ~description:
      &quot;The specified field does not match the field annotation in the type&quot;
    (obj2 (req &quot;annot1&quot; string) (req &quot;annot2&quot; string))
    (function
      | Inconsistent_field_annotations (annot1, annot2) -&gt;
          Some (annot1, annot2)
      | _ -&gt;
          None)
    (fun (annot1, annot2) -&gt; Inconsistent_field_annotations (annot1, annot2)) ;
  (* Inconsistent type annotations *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.inconsistent_type_annotations&quot;
    ~title:&quot;Types contain inconsistent annotations&quot;
    ~description:&quot;The two types contain annotations that do not match&quot;
    (located
       (obj2
          (req &quot;type1&quot; Script.expr_encoding)
          (req &quot;type2&quot; Script.expr_encoding)))
    (function
      | Inconsistent_type_annotations (loc, ty1, ty2) -&gt;
          Some (loc, (ty1, ty2))
      | _ -&gt;
          None)
    (fun (loc, (ty1, ty2)) -&gt; Inconsistent_type_annotations (loc, ty1, ty2)) ;
  (* Unexpected annotation *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.unexpected_annotation&quot;
    ~title:&quot;An annotation was encountered where no annotation is expected&quot;
    ~description:&quot;A node in the syntax tree was impropperly annotated&quot;
    (located empty)
    (function Unexpected_annotation loc -&gt; Some (loc, ()) | _ -&gt; None)
    (fun (loc, ()) -&gt; Unexpected_annotation loc) ;
  (* Ungrouped annotations *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.ungrouped_annotations&quot;
    ~title:&quot;Annotations of the same kind were found spread apart&quot;
    ~description:&quot;Annotations of the same kind must be grouped&quot;
    (located empty)
    (function Ungrouped_annotations loc -&gt; Some (loc, ()) | _ -&gt; None)
    (fun (loc, ()) -&gt; Ungrouped_annotations loc) ;
  (* Unmatched branches *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.unmatched_branches&quot;
    ~title:&quot;Unmatched branches&quot;
    ~description:
      &quot;At the join point at the end of two code branches the stacks have \
       inconsistent lengths or contents.&quot;
    (located
       (obj2
          (req &quot;first_stack_type&quot; stack_ty_enc)
          (req &quot;other_stack_type&quot; stack_ty_enc)))
    (function
      | Unmatched_branches (loc, stya, styb) -&gt;
          Some (loc, (stya, styb))
      | _ -&gt;
          None)
    (fun (loc, (stya, styb)) -&gt; Unmatched_branches (loc, stya, styb)) ;
  (* Bad stack item *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.bad_stack_item&quot;
    ~title:&quot;Bad stack item&quot;
    ~description:
      &quot;The type of a stack item is unexpected (this error is always \
       accompanied by a more precise one).&quot;
    (obj1 (req &quot;item_level&quot; int16))
    (function Bad_stack_item n -&gt; Some n | _ -&gt; None)
    (fun n -&gt; Bad_stack_item n) ;
  (* SELF in lambda *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.self_in_lambda&quot;
    ~title:&quot;SELF instruction in lambda&quot;
    ~description:&quot;A SELF instruction was encountered in a lambda expression.&quot;
    (located empty)
    (function Self_in_lambda loc -&gt; Some (loc, ()) | _ -&gt; None)
    (fun (loc, ()) -&gt; Self_in_lambda loc) ;
  (* Bad stack length *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.inconsistent_stack_lengths&quot;
    ~title:&quot;Inconsistent stack lengths&quot;
    ~description:
      &quot;A stack was of an unexpected length (this error is always in the \
       context of a located error).&quot;
    empty
    (function Bad_stack_length -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Bad_stack_length) ;
  (* -- Value typing errors ------------------- *)
  (* Invalid constant *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.invalid_constant&quot;
    ~title:&quot;Invalid constant&quot;
    ~description:&quot;A data expression was invalid for its expected type.&quot;
    (located
       (obj2
          (req &quot;expected_type&quot; Script.expr_encoding)
          (req &quot;wrong_expression&quot; Script.expr_encoding)))
    (function
      | Invalid_constant (loc, expr, ty) -&gt; Some (loc, (ty, expr)) | _ -&gt; None)
    (fun (loc, (ty, expr)) -&gt; Invalid_constant (loc, expr, ty)) ;
  (* Invalid syntactic constant *)
  register_error_kind
    `Permanent
    ~id:&quot;invalidSyntacticConstantError&quot;
    ~title:&quot;Invalid constant (parse error)&quot;
    ~description:&quot;A compile-time constant was invalid for its expected form.&quot;
    (located
       (obj2
          (req &quot;expectedForm&quot; Script.expr_encoding)
          (req &quot;wrongExpression&quot; Script.expr_encoding)))
    (function
      | Invalid_constant (loc, expr, ty) -&gt; Some (loc, (ty, expr)) | _ -&gt; None)
    (fun (loc, (ty, expr)) -&gt; Invalid_constant (loc, expr, ty)) ;
  (* Invalid contract *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.invalid_contract&quot;
    ~title:&quot;Invalid contract&quot;
    ~description:
      &quot;A script or data expression references a contract that does not exist \
       or assumes a wrong type for an existing contract.&quot;
    (located (obj1 (req &quot;contract&quot; Contract.encoding)))
    (function Invalid_contract (loc, c) -&gt; Some (loc, c) | _ -&gt; None)
    (fun (loc, c) -&gt; Invalid_contract (loc, c)) ;
  (* Invalid big_map *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.invalid_big_map&quot;
    ~title:&quot;Invalid big_map&quot;
    ~description:
      &quot;A script or data expression references a big_map that does not exist \
       or assumes a wrong type for an existing big_map.&quot;
    (located (obj1 (req &quot;big_map&quot; z)))
    (function Invalid_big_map (loc, c) -&gt; Some (loc, c) | _ -&gt; None)
    (fun (loc, c) -&gt; Invalid_big_map (loc, c)) ;
  (* Comparable type expected *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.comparable_type_expected&quot;
    ~title:&quot;Comparable type expected&quot;
    ~description:
      &quot;A non comparable type was used in a place where only comparable types \
       are accepted.&quot;
    (located (obj1 (req &quot;wrong_type&quot; Script.expr_encoding)))
    (function
      | Comparable_type_expected (loc, ty) -&gt; Some (loc, ty) | _ -&gt; None)
    (fun (loc, ty) -&gt; Comparable_type_expected (loc, ty)) ;
  (* Inconsistent types *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.inconsistent_types&quot;
    ~title:&quot;Inconsistent types&quot;
    ~description:
      &quot;This is the basic type clash error, that appears in several places \
       where the equality of two types have to be proven, it is always \
       accompanied with another error that provides more context.&quot;
    (obj2
       (req &quot;first_type&quot; Script.expr_encoding)
       (req &quot;other_type&quot; Script.expr_encoding))
    (function Inconsistent_types (tya, tyb) -&gt; Some (tya, tyb) | _ -&gt; None)
    (fun (tya, tyb) -&gt; Inconsistent_types (tya, tyb)) ;
  (* -- Instruction typing errors ------------------- *)
  (* Invalid map body *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.invalid_map_body&quot;
    ~title:&quot;Invalid map body&quot;
    ~description:&quot;The body of a map block did not match the expected type&quot;
    (obj2 (req &quot;loc&quot; Script.location_encoding) (req &quot;body_type&quot; stack_ty_enc))
    (function Invalid_map_body (loc, stack) -&gt; Some (loc, stack) | _ -&gt; None)
    (fun (loc, stack) -&gt; Invalid_map_body (loc, stack)) ;
  (* Invalid map block FAIL *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.invalid_map_block_fail&quot;
    ~title:&quot;FAIL instruction occurred as body of map block&quot;
    ~description:
      &quot;FAIL cannot be the only instruction in the body. The propper type of \
       the return list cannot be inferred.&quot;
    (obj1 (req &quot;loc&quot; Script.location_encoding))
    (function Invalid_map_block_fail loc -&gt; Some loc | _ -&gt; None)
    (fun loc -&gt; Invalid_map_block_fail loc) ;
  (* Invalid ITER body *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.invalid_iter_body&quot;
    ~title:&quot;ITER body returned wrong stack type&quot;
    ~description:
      &quot;The body of an ITER instruction must result in the same stack type as \
       before the ITER.&quot;
    (obj3
       (req &quot;loc&quot; Script.location_encoding)
       (req &quot;bef_stack&quot; stack_ty_enc)
       (req &quot;aft_stack&quot; stack_ty_enc))
    (function
      | Invalid_iter_body (loc, bef, aft) -&gt; Some (loc, bef, aft) | _ -&gt; None)
    (fun (loc, bef, aft) -&gt; Invalid_iter_body (loc, bef, aft)) ;
  (* Type too large *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.type_too_large&quot;
    ~title:&quot;Stack item type too large&quot;
    ~description:&quot;An instruction generated a type larger than the limit.&quot;
    (obj3
       (req &quot;loc&quot; Script.location_encoding)
       (req &quot;type_size&quot; uint16)
       (req &quot;maximum_type_size&quot; uint16))
    (function
      | Type_too_large (loc, ts, maxts) -&gt; Some (loc, ts, maxts) | _ -&gt; None)
    (fun (loc, ts, maxts) -&gt; Type_too_large (loc, ts, maxts)) ;
  (* -- Toplevel errors ------------------- *)
  (* Ill typed data *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.ill_typed_data&quot;
    ~title:&quot;Ill typed data&quot;
    ~description:
      &quot;The toplevel error thrown when trying to typecheck a data expression \
       against a given type (always followed by more precise errors).&quot;
    (obj3
       (opt &quot;identifier&quot; string)
       (req &quot;expected_type&quot; Script.expr_encoding)
       (req &quot;ill_typed_expression&quot; Script.expr_encoding))
    (function
      | Ill_typed_data (name, expr, ty) -&gt; Some (name, ty, expr) | _ -&gt; None)
    (fun (name, ty, expr) -&gt; Ill_typed_data (name, expr, ty)) ;
  (* Ill formed type *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.ill_formed_type&quot;
    ~title:&quot;Ill formed type&quot;
    ~description:
      &quot;The toplevel error thrown when trying to parse a type expression \
       (always followed by more precise errors).&quot;
    (obj3
       (opt &quot;identifier&quot; string)
       (req &quot;ill_formed_expression&quot; Script.expr_encoding)
       (req &quot;location&quot; Script.location_encoding))
    (function
      | Ill_formed_type (name, expr, loc) -&gt; Some (name, expr, loc) | _ -&gt; None)
    (fun (name, expr, loc) -&gt; Ill_formed_type (name, expr, loc)) ;
  (* Ill typed contract *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.ill_typed_contract&quot;
    ~title:&quot;Ill typed contract&quot;
    ~description:
      &quot;The toplevel error thrown when trying to typecheck a contract code \
       against given input, output and storage types (always followed by more \
       precise errors).&quot;
    (obj2
       (req &quot;ill_typed_code&quot; Script.expr_encoding)
       (req &quot;type_map&quot; type_map_enc))
    (function
      | Ill_typed_contract (expr, type_map) -&gt;
          Some (expr, type_map)
      | _ -&gt;
          None)
    (fun (expr, type_map) -&gt; Ill_typed_contract (expr, type_map)) ;
  (* Cannot serialize error *)
  register_error_kind
    `Temporary
    ~id:&quot;michelson_v1.cannot_serialize_error&quot;
    ~title:&quot;Not enough gas to serialize error&quot;
    ~description:&quot;The error was too big to be serialized with the provided gas&quot;
    Data_encoding.empty
    (function Cannot_serialize_error -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Cannot_serialize_error) ;
  (* Deprecated instruction *)
  register_error_kind
    `Permanent
    ~id:&quot;michelson_v1.deprecated_instruction&quot;
    ~title:&quot;Script is using a deprecated instruction&quot;
    ~description:
      &quot;A deprecated instruction usage is disallowed in newly created contracts&quot;
    (obj1 (req &quot;prim&quot; prim_encoding))
    (function Deprecated_instruction prim -&gt; Some prim | _ -&gt; None)
    (fun prim -&gt; Deprecated_instruction prim)</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_tc_errors_registration.ml"><code>Script_tc_errors_registration.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Script_tc_errors.

Import Alpha_context.

Import Alpha_context.Script.

Import Script_tc_errors.

Definition type_map_enc
  : Data_encoding.encoding
    (list
      (Alpha_context.Script.location *
        (list (Alpha_context.Script.expr * list string) *
          list (Alpha_context.Script.expr * list string)))) :=
  let stack_enc :=
    Data_encoding.__list_value None
      (Data_encoding.tup2 Alpha_context.Script.expr_encoding
        (Data_encoding.__list_value None Data_encoding.__string_value)) in
  Data_encoding.__list_value None
    (Data_encoding.conv
      (fun function_parameter =&gt;
        let '(loc, (bef, aft)) := function_parameter in
        (loc, bef, aft))
      (fun function_parameter =&gt;
        let '(loc, bef, aft) := function_parameter in
        (loc, (bef, aft))) None
      (Data_encoding.obj3
        (Data_encoding.req None None &quot;location&quot;
          Alpha_context.Script.location_encoding)
        (Data_encoding.req None None &quot;stack_before&quot; stack_enc)
        (Data_encoding.req None None &quot;stack_after&quot; stack_enc))).

Definition stack_ty_enc
  : Data_encoding.encoding (list (Alpha_context.Script.expr * list string)) :=
  Data_encoding.__list_value None
    (Data_encoding.obj2
      (Data_encoding.req None None &quot;type&quot; Alpha_context.Script.expr_encoding)
      (Data_encoding.dft None None &quot;annots&quot;
        (Data_encoding.__list_value None Data_encoding.__string_value) nil)).

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_timestamp_repr.ml">
  <div style="margin: 20px;">
    <h3>Script_timestamp_repr</h3>
    <ul>
      <li>OCaml size: 57 lines</li>
      <li>Coq size: 57 lines (+0% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#script_timestamp_repr.ml"><code>script_timestamp_repr.ml</code></a>&nbsp;<span class="label label-warning">2 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = Z.t

let compare = Z.compare

let of_int64 = Z.of_int64

let of_string x =
  match Time_repr.of_notation x with
  | None -&gt; <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">(
    try Some (Z.of_string x) with _ -&gt; None )</abbr>
  | Some time -&gt;
      Some (of_int64 (Time_repr.to_seconds time))

let to_notation x =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try
    let notation = Time_repr.to_notation (Time.of_seconds (Z.to_int64 x)) in
    if String.equal notation &quot;out_of_range&quot; then None else Some notation
  with _ -&gt; None</abbr>

let to_num_str = Z.to_string

let to_string x = match to_notation x with None -&gt; to_num_str x | Some s -&gt; s

let diff x y = Script_int_repr.of_zint @@ Z.sub x y

let sub_delta t delta = Z.sub t (Script_int_repr.to_zint delta)

let add_delta t delta = Z.add t (Script_int_repr.to_zint delta)

let to_zint x = x

let of_zint x = x
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_timestamp_repr.ml"><code>Script_timestamp_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Script_int_repr.
Require Tezos.Time_repr.

Definition t : Set := Z.t.

Definition compare : Z.t -&gt; Z.t -&gt; int := Z.compare.

Definition of_int64 : int64 -&gt; Z.t := Z.of_int64.

Definition of_string (x : string) : option Z.t :=
  match Time_repr.of_notation x with
  | None =&gt;
    (* ‚ùå Try-with are not handled *)
    try (Some (Z.of_string x))
  | Some time =&gt; Some (of_int64 (Time_repr.to_seconds time))
  end.

Definition to_notation (x : Z.t) : option string :=
  (* ‚ùå Try-with are not handled *)
  try
    (let notation := Time_repr.to_notation (Time.of_seconds (Z.to_int64 x)) in
    if String.equal notation &quot;out_of_range&quot; then
      None
    else
      Some notation).

Definition to_num_str : Z.t -&gt; string := Z.to_string.

Definition to_string (x : Z.t) : string :=
  match to_notation x with
  | None =&gt; to_num_str x
  | Some s =&gt; s
  end.

Definition diff (x : Z.t) (y : Z.t) : Script_int_repr.num :=
  Script_int_repr.of_zint (Z.sub x y).

Definition sub_delta (__t_value : Z.t) (delta : Script_int_repr.num) : Z.t :=
  Z.sub __t_value (Script_int_repr.to_zint delta).

Definition add_delta (__t_value : Z.t) (delta : Script_int_repr.num) : Z.t :=
  Z.add __t_value (Script_int_repr.to_zint delta).

Definition to_zint {A : Set} (x : A) : A := x.

Definition of_zint {A : Set} (x : A) : A := x.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_timestamp_repr.mli">
  <div style="margin: 20px;">
    <h3>Script_timestamp_repr_mli</h3>
    <ul>
      <li>OCaml size: 53 lines</li>
      <li>Coq size: 38 lines (-29% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#script_timestamp_repr.mli"><code>script_timestamp_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Script_int_repr

type t

val of_int64 : int64 -&gt; t

val compare : t -&gt; t -&gt; int

(* Convert a timestamp to a notation if possible *)
val to_notation : t -&gt; string option

(* Convert a timestamp to a string representation of the seconds *)
val to_num_str : t -&gt; string

(* Convert to a notation if possible, or num if not *)
val to_string : t -&gt; string

val of_string : string -&gt; t option

val diff : t -&gt; t -&gt; num

val add_delta : t -&gt; num -&gt; t

val sub_delta : t -&gt; num -&gt; t

val to_zint : t -&gt; Z.t

val of_zint : Z.t -&gt; t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_timestamp_repr.mli"><code>Script_timestamp_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Script_int_repr.

Import Script_int_repr.

Parameter t : Set.

Parameter of_int64 : int64 -&gt; t.

Parameter compare : t -&gt; t -&gt; int.

Parameter to_notation : t -&gt; option string.

Parameter to_num_str : t -&gt; string.

Parameter to_string : t -&gt; string.

Parameter of_string : string -&gt; option t.

Parameter diff : t -&gt; t -&gt; Script_int_repr.num.

Parameter add_delta : t -&gt; Script_int_repr.num -&gt; t.

Parameter sub_delta : t -&gt; Script_int_repr.num -&gt; t.

Parameter to_zint : t -&gt; Z.t.

Parameter of_zint : Z.t -&gt; t.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="script_typed_ir.ml">
  <div style="margin: 20px;">
    <h3>Script_typed_ir</h3>
    <ul>
      <li>OCaml size: 407 lines</li>
      <li>Coq size: 376 lines (-8% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#script_typed_ir.ml"><code>script_typed_ir.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context
open Script_int

(* ---- Auxiliary types -----------------------------------------------------*)

type var_annot = Var_annot of string

type type_annot = Type_annot of string

type field_annot = Field_annot of string

type address = Contract.t * string

type ('a, 'b) pair = 'a * 'b

type ('a, 'b) union = L of 'a | R of 'b

type comb = Comb

type leaf = Leaf

type (_, _) comparable_struct =
  | Int_key : type_annot option -&gt; (num, _) comparable_struct
  | Nat_key : type_annot option -&gt; (num, _) comparable_struct
  | String_key : type_annot option -&gt; (string, _) comparable_struct
  | Bytes_key : type_annot option -&gt; (MBytes.t, _) comparable_struct
  | Mutez_key : type_annot option -&gt; (Tez.t, _) comparable_struct
  | Bool_key : type_annot option -&gt; (bool, _) comparable_struct
  | Key_hash_key : type_annot option -&gt; (public_key_hash, _) comparable_struct
  | Timestamp_key :
      type_annot option
      -&gt; (Script_timestamp.t, _) comparable_struct
  | Address_key : type_annot option -&gt; (address, _) comparable_struct
  | Pair_key :
      (('a, leaf) comparable_struct * field_annot option)
      * (('b, _) comparable_struct * field_annot option)
      * type_annot option
      -&gt; (('a, 'b) pair, comb) comparable_struct

type 'a comparable_ty = ('a, comb) comparable_struct

module type Boxed_set = sig
  type elt

  val elt_ty : elt comparable_ty

  module OPS : S.SET with type elt = elt

  val boxed : OPS.t

  val size : int
end

type 'elt set = (module Boxed_set with type elt = 'elt)

module type Boxed_map = sig
  type key

  type value

  val key_ty : key comparable_ty

  module OPS : S.MAP with type key = key

  val boxed : value OPS.t * int
end

type ('key, 'value) map =
  (module Boxed_map with type key = 'key and type value = 'value)

type operation = packed_internal_operation * Contract.big_map_diff option

type end_of_stack = unit

and 'ty ty =
  | Unit_t : type_annot option -&gt; unit ty
  | Int_t : type_annot option -&gt; num ty
  | Nat_t : type_annot option -&gt; num ty
  | Signature_t : type_annot option -&gt; signature ty
  | String_t : type_annot option -&gt; string ty
  | Bytes_t : type_annot option -&gt; MBytes.t ty
  | Mutez_t : type_annot option -&gt; Tez.t ty
  | Key_hash_t : type_annot option -&gt; public_key_hash ty
  | Key_t : type_annot option -&gt; public_key ty
  | Timestamp_t : type_annot option -&gt; Script_timestamp.t ty
  | Address_t : type_annot option -&gt; address ty
  | Bool_t : type_annot option -&gt; bool ty
  | Pair_t :
      ('a ty * field_annot option * var_annot option)
      * ('b ty * field_annot option * var_annot option)
      * type_annot option
      * bool
      -&gt; ('a, 'b) pair ty
  | Union_t :
      ('a ty * field_annot option)
      * ('b ty * field_annot option)
      * type_annot option
      * bool
      -&gt; ('a, 'b) union ty
  | Lambda_t : 'arg ty * 'ret ty * type_annot option -&gt; ('arg, 'ret) lambda ty
  | Option_t : 'v ty * type_annot option * bool -&gt; 'v option ty
  | List_t : 'v ty * type_annot option * bool -&gt; 'v list ty
  | Set_t : 'v comparable_ty * type_annot option -&gt; 'v set ty
  | Map_t :
      'k comparable_ty * 'v ty * type_annot option * bool
      -&gt; ('k, 'v) map ty
  | Big_map_t :
      'k comparable_ty * 'v ty * type_annot option
      -&gt; ('k, 'v) big_map ty
  | Contract_t : 'arg ty * type_annot option -&gt; 'arg typed_contract ty
  | Operation_t : type_annot option -&gt; operation ty
  | Chain_id_t : type_annot option -&gt; Chain_id.t ty

and 'ty stack_ty =
  | Item_t :
      'ty_ ty * 'rest stack_ty * var_annot option
      -&gt; ('ty_ * 'rest) stack_ty
  | Empty_t : end_of_stack stack_ty

and 'arg typed_contract = 'arg ty * address

and ('key, 'value) big_map = {
  id : Z.t option;
  diff : ('key, 'value option) map;
  key_type : 'key ty;
  value_type : 'value ty;
}

(* ---- Instructions --------------------------------------------------------*)

(* The low-level, typed instructions, as a GADT whose parameters
   encode the typing rules.

   The left parameter is the typed shape of the stack before the
   instruction, the right one the shape after. Any program whose
   construction is accepted by OCaml's type-checker is guaranteed to
   be type-safe. Overloadings of the concrete syntax are already
   resolved in this representation, either by using different
   constructors or type witness parameters. *)
and ('bef, 'aft) instr =
  (* stack ops *)
  | Drop : (_ * 'rest, 'rest) instr
  | Dup : ('top * 'rest, 'top * ('top * 'rest)) instr
  | Swap : ('tip * ('top * 'rest), 'top * ('tip * 'rest)) instr
  | Const : 'ty_ -&gt; ('rest, 'ty_ * 'rest) instr
  (* pairs *)
  | Cons_pair : ('car * ('cdr * 'rest), ('car, 'cdr) pair * 'rest) instr
  | Car : (('car, _) pair * 'rest, 'car * 'rest) instr
  | Cdr : ((_, 'cdr) pair * 'rest, 'cdr * 'rest) instr
  (* options *)
  | Cons_some : ('v * 'rest, 'v option * 'rest) instr
  | Cons_none : 'a ty -&gt; ('rest, 'a option * 'rest) instr
  | If_none :
      ('bef, 'aft) descr * ('a * 'bef, 'aft) descr
      -&gt; ('a option * 'bef, 'aft) instr
  (* unions *)
  | Left : ('l * 'rest, ('l, 'r) union * 'rest) instr
  | Right : ('r * 'rest, ('l, 'r) union * 'rest) instr
  | If_left :
      ('l * 'bef, 'aft) descr * ('r * 'bef, 'aft) descr
      -&gt; (('l, 'r) union * 'bef, 'aft) instr
  (* lists *)
  | Cons_list : ('a * ('a list * 'rest), 'a list * 'rest) instr
  | Nil : ('rest, 'a list * 'rest) instr
  | If_cons :
      ('a * ('a list * 'bef), 'aft) descr * ('bef, 'aft) descr
      -&gt; ('a list * 'bef, 'aft) instr
  | List_map :
      ('a * 'rest, 'b * 'rest) descr
      -&gt; ('a list * 'rest, 'b list * 'rest) instr
  | List_iter : ('a * 'rest, 'rest) descr -&gt; ('a list * 'rest, 'rest) instr
  | List_size : ('a list * 'rest, num * 'rest) instr
  (* sets *)
  | Empty_set : 'a comparable_ty -&gt; ('rest, 'a set * 'rest) instr
  | Set_iter : ('a * 'rest, 'rest) descr -&gt; ('a set * 'rest, 'rest) instr
  | Set_mem : ('elt * ('elt set * 'rest), bool * 'rest) instr
  | Set_update : ('elt * (bool * ('elt set * 'rest)), 'elt set * 'rest) instr
  | Set_size : ('a set * 'rest, num * 'rest) instr
  (* maps *)
  | Empty_map : 'a comparable_ty * 'v ty -&gt; ('rest, ('a, 'v) map * 'rest) instr
  | Map_map :
      (('a * 'v) * 'rest, 'r * 'rest) descr
      -&gt; (('a, 'v) map * 'rest, ('a, 'r) map * 'rest) instr
  | Map_iter :
      (('a * 'v) * 'rest, 'rest) descr
      -&gt; (('a, 'v) map * 'rest, 'rest) instr
  | Map_mem : ('a * (('a, 'v) map * 'rest), bool * 'rest) instr
  | Map_get : ('a * (('a, 'v) map * 'rest), 'v option * 'rest) instr
  | Map_update
      : ('a * ('v option * (('a, 'v) map * 'rest)), ('a, 'v) map * 'rest) instr
  | Map_size : (('a, 'b) map * 'rest, num * 'rest) instr
  (* big maps *)
  | Empty_big_map :
      'a comparable_ty * 'v ty
      -&gt; ('rest, ('a, 'v) big_map * 'rest) instr
  | Big_map_mem : ('a * (('a, 'v) big_map * 'rest), bool * 'rest) instr
  | Big_map_get : ('a * (('a, 'v) big_map * 'rest), 'v option * 'rest) instr
  | Big_map_update
      : ( 'key * ('value option * (('key, 'value) big_map * 'rest)),
          ('key, 'value) big_map * 'rest )
        instr
  (* string operations *)
  | Concat_string : (string list * 'rest, string * 'rest) instr
  | Concat_string_pair : (string * (string * 'rest), string * 'rest) instr
  | Slice_string
      : (num * (num * (string * 'rest)), string option * 'rest) instr
  | String_size : (string * 'rest, num * 'rest) instr
  (* bytes operations *)
  | Concat_bytes : (MBytes.t list * 'rest, MBytes.t * 'rest) instr
  | Concat_bytes_pair : (MBytes.t * (MBytes.t * 'rest), MBytes.t * 'rest) instr
  | Slice_bytes
      : (num * (num * (MBytes.t * 'rest)), MBytes.t option * 'rest) instr
  | Bytes_size : (MBytes.t * 'rest, num * 'rest) instr
  (* timestamp operations *)
  | Add_seconds_to_timestamp
      : (num * (Script_timestamp.t * 'rest), Script_timestamp.t * 'rest) instr
  | Add_timestamp_to_seconds
      : (Script_timestamp.t * (num * 'rest), Script_timestamp.t * 'rest) instr
  | Sub_timestamp_seconds
      : (Script_timestamp.t * (num * 'rest), Script_timestamp.t * 'rest) instr
  | Diff_timestamps
      : (Script_timestamp.t * (Script_timestamp.t * 'rest), num * 'rest) instr
  (* tez operations *)
  | Add_tez : (Tez.t * (Tez.t * 'rest), Tez.t * 'rest) instr
  | Sub_tez : (Tez.t * (Tez.t * 'rest), Tez.t * 'rest) instr
  | Mul_teznat : (Tez.t * (num * 'rest), Tez.t * 'rest) instr
  | Mul_nattez : (num * (Tez.t * 'rest), Tez.t * 'rest) instr
  | Ediv_teznat
      : (Tez.t * (num * 'rest), (Tez.t, Tez.t) pair option * 'rest) instr
  | Ediv_tez
      : (Tez.t * (Tez.t * 'rest), (num, Tez.t) pair option * 'rest) instr
  (* boolean operations *)
  | Or : (bool * (bool * 'rest), bool * 'rest) instr
  | And : (bool * (bool * 'rest), bool * 'rest) instr
  | Xor : (bool * (bool * 'rest), bool * 'rest) instr
  | Not : (bool * 'rest, bool * 'rest) instr
  (* integer operations *)
  | Is_nat : (num * 'rest, num option * 'rest) instr
  | Neg_nat : (num * 'rest, num * 'rest) instr
  | Neg_int : (num * 'rest, num * 'rest) instr
  | Abs_int : (num * 'rest, num * 'rest) instr
  | Int_nat : (num * 'rest, num * 'rest) instr
  | Add_intint : (num * (num * 'rest), num * 'rest) instr
  | Add_intnat : (num * (num * 'rest), num * 'rest) instr
  | Add_natint : (num * (num * 'rest), num * 'rest) instr
  | Add_natnat : (num * (num * 'rest), num * 'rest) instr
  | Sub_int : (num * (num * 'rest), num * 'rest) instr
  | Mul_intint : (num * (num * 'rest), num * 'rest) instr
  | Mul_intnat : (num * (num * 'rest), num * 'rest) instr
  | Mul_natint : (num * (num * 'rest), num * 'rest) instr
  | Mul_natnat : (num * (num * 'rest), num * 'rest) instr
  | Ediv_intint : (num * (num * 'rest), (num, num) pair option * 'rest) instr
  | Ediv_intnat : (num * (num * 'rest), (num, num) pair option * 'rest) instr
  | Ediv_natint : (num * (num * 'rest), (num, num) pair option * 'rest) instr
  | Ediv_natnat : (num * (num * 'rest), (num, num) pair option * 'rest) instr
  | Lsl_nat : (num * (num * 'rest), num * 'rest) instr
  | Lsr_nat : (num * (num * 'rest), num * 'rest) instr
  | Or_nat : (num * (num * 'rest), num * 'rest) instr
  | And_nat : (num * (num * 'rest), num * 'rest) instr
  | And_int_nat : (num * (num * 'rest), num * 'rest) instr
  | Xor_nat : (num * (num * 'rest), num * 'rest) instr
  | Not_nat : (num * 'rest, num * 'rest) instr
  | Not_int : (num * 'rest, num * 'rest) instr
  (* control *)
  | Seq : ('bef, 'trans) descr * ('trans, 'aft) descr -&gt; ('bef, 'aft) instr
  | If : ('bef, 'aft) descr * ('bef, 'aft) descr -&gt; (bool * 'bef, 'aft) instr
  | Loop : ('rest, bool * 'rest) descr -&gt; (bool * 'rest, 'rest) instr
  | Loop_left :
      ('a * 'rest, ('a, 'b) union * 'rest) descr
      -&gt; (('a, 'b) union * 'rest, 'b * 'rest) instr
  | Dip : ('bef, 'aft) descr -&gt; ('top * 'bef, 'top * 'aft) instr
  | Exec : ('arg * (('arg, 'ret) lambda * 'rest), 'ret * 'rest) instr
  | Apply :
      'arg ty
      -&gt; ( 'arg * (('arg * 'remaining, 'ret) lambda * 'rest),
           ('remaining, 'ret) lambda * 'rest )
         instr
  | Lambda : ('arg, 'ret) lambda -&gt; ('rest, ('arg, 'ret) lambda * 'rest) instr
  | Failwith : 'a ty -&gt; ('a * 'rest, 'aft) instr
  | Nop : ('rest, 'rest) instr
  (* comparison *)
  | Compare : 'a comparable_ty -&gt; ('a * ('a * 'rest), num * 'rest) instr
  (* comparators *)
  | Eq : (num * 'rest, bool * 'rest) instr
  | Neq : (num * 'rest, bool * 'rest) instr
  | Lt : (num * 'rest, bool * 'rest) instr
  | Gt : (num * 'rest, bool * 'rest) instr
  | Le : (num * 'rest, bool * 'rest) instr
  | Ge : (num * 'rest, bool * 'rest) instr
  (* protocol *)
  | Address : (_ typed_contract * 'rest, address * 'rest) instr
  | Contract :
      'p ty * string
      -&gt; (address * 'rest, 'p typed_contract option * 'rest) instr
  | Transfer_tokens
      : ( 'arg * (Tez.t * ('arg typed_contract * 'rest)),
          operation * 'rest )
        instr
  | Create_account
      : ( public_key_hash * (public_key_hash option * (bool * (Tez.t * 'rest))),
          operation * (address * 'rest) )
        instr
  | Implicit_account
      : (public_key_hash * 'rest, unit typed_contract * 'rest) instr
  | Create_contract :
      'g ty * 'p ty * ('p * 'g, operation list * 'g) lambda * string option
      -&gt; ( public_key_hash
           * (public_key_hash option * (bool * (bool * (Tez.t * ('g * 'rest))))),
           operation * (address * 'rest) )
         instr
  | Create_contract_2 :
      'g ty * 'p ty * ('p * 'g, operation list * 'g) lambda * string option
      -&gt; ( public_key_hash option * (Tez.t * ('g * 'rest)),
           operation * (address * 'rest) )
         instr
  | Set_delegate : (public_key_hash option * 'rest, operation * 'rest) instr
  | Now : ('rest, Script_timestamp.t * 'rest) instr
  | Balance : ('rest, Tez.t * 'rest) instr
  | Check_signature
      : (public_key * (signature * (MBytes.t * 'rest)), bool * 'rest) instr
  | Hash_key : (public_key * 'rest, public_key_hash * 'rest) instr
  | Pack : 'a ty -&gt; ('a * 'rest, MBytes.t * 'rest) instr
  | Unpack : 'a ty -&gt; (MBytes.t * 'rest, 'a option * 'rest) instr
  | Blake2b : (MBytes.t * 'rest, MBytes.t * 'rest) instr
  | Sha256 : (MBytes.t * 'rest, MBytes.t * 'rest) instr
  | Sha512 : (MBytes.t * 'rest, MBytes.t * 'rest) instr
  | Steps_to_quota
      : (* TODO: check that it always returns a nat *)
      ('rest, num * 'rest) instr
  | Source : ('rest, address * 'rest) instr
  | Sender : ('rest, address * 'rest) instr
  | Self : 'p ty * string -&gt; ('rest, 'p typed_contract * 'rest) instr
  | Amount : ('rest, Tez.t * 'rest) instr
  | Dig :
      int * ('x * 'rest, 'rest, 'bef, 'aft) stack_prefix_preservation_witness
      -&gt; ('bef, 'x * 'aft) instr
  | Dug :
      int * ('rest, 'x * 'rest, 'bef, 'aft) stack_prefix_preservation_witness
      -&gt; ('x * 'bef, 'aft) instr
  | Dipn :
      int
      * ('fbef, 'faft, 'bef, 'aft) stack_prefix_preservation_witness
      * ('fbef, 'faft) descr
      -&gt; ('bef, 'aft) instr
  | Dropn :
      int * ('rest, 'rest, 'bef, _) stack_prefix_preservation_witness
      -&gt; ('bef, 'rest) instr
  | ChainId : ('rest, Chain_id.t * 'rest) instr

(* Type witness for operations that work deep in the stack ignoring
   (and preserving) a prefix.

   The two right parameters are the shape of the stack with the (same)
   prefix before and after the transformation. The two left
   parameters are the shape of the stack without the prefix before and
   after. The inductive definition makes it so by construction. *)
and ('bef, 'aft, 'bef_suffix, 'aft_suffix) stack_prefix_preservation_witness =
  | Prefix :
      ('fbef, 'faft, 'bef, 'aft) stack_prefix_preservation_witness
      -&gt; ('fbef, 'faft, 'x * 'bef, 'x * 'aft) stack_prefix_preservation_witness
  | Rest : ('bef, 'aft, 'bef, 'aft) stack_prefix_preservation_witness

and ('bef, 'aft) descr = {
  loc : Script.location;
  bef : 'bef stack_ty;
  aft : 'aft stack_ty;
  instr : ('bef, 'aft) instr;
}

and ('arg, 'ret) lambda = {
  lam : ('arg * end_of_stack, 'ret * end_of_stack) descr * Script.node;
}

and ('arg, 'storage) script = {
  code : (('arg, 'storage) pair, (operation list, 'storage) pair) lambda;
  arg_type : 'arg ty;
  storage : 'storage;
  storage_type : 'storage ty;
  root_name : string option;
}

type ex_big_map = Ex_bm : ('key, 'value) big_map -&gt; ex_big_map
</pre>
  </div>
  <div class="col-md-6">
    <a href="#script_typed_ir.ml"><code>Script_typed_ir.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.

Import Alpha_context.

Import Alpha_context.Script_int.

Inductive var_annot : Set :=
| Var_annot : string -&gt; var_annot.

Inductive type_annot : Set :=
| Type_annot : string -&gt; type_annot.

Inductive field_annot : Set :=
| Field_annot : string -&gt; field_annot.

Definition address : Set := Alpha_context.Contract.t * string.

Definition pair (a b : Set) : Set := a * b.

Inductive union (a b : Set) : Set :=
| L : a -&gt; union a b
| R : b -&gt; union a b.

Arguments L {_ _}.
Arguments R {_ _}.

Inductive comb : Set :=
| Comb : comb.

Inductive leaf : Set :=
| Leaf : leaf.

Inductive comparable_struct : Set :=
| Int_key : option type_annot -&gt; comparable_struct
| Nat_key : option type_annot -&gt; comparable_struct
| String_key : option type_annot -&gt; comparable_struct
| Bytes_key : option type_annot -&gt; comparable_struct
| Mutez_key : option type_annot -&gt; comparable_struct
| Bool_key : option type_annot -&gt; comparable_struct
| Key_hash_key : option type_annot -&gt; comparable_struct
| Timestamp_key : option type_annot -&gt; comparable_struct
| Address_key : option type_annot -&gt; comparable_struct
| Pair_key :
  comparable_struct * option field_annot -&gt;
  comparable_struct * option field_annot -&gt; option type_annot -&gt;
  comparable_struct.

Definition comparable_ty : Set := comparable_struct.

Module Boxed_set.
  Record signature {elt OPS_t : Set} : Set := {
    elt := elt;
    elt_ty : comparable_ty;
    OPS : S.SET.signature (elt := elt) (t := OPS_t);
    boxed : OPS.(S.SET.t);
    size : int;
  }.
End Boxed_set.

Definition set (elt : Set) : Set :=
  {OPS_t : Set @ Boxed_set.signature (elt := elt) (OPS_t := OPS_t)}.

Module Boxed_map.
  Record signature {key value : Set} {OPS_t : Set -&gt; Set} : Set := {
    key := key;
    value := value;
    key_ty : comparable_ty;
    OPS : S.MAP.signature (key := key) (t := OPS_t);
    boxed : OPS.(S.MAP.t) value * int;
  }.
End Boxed_map.

Definition map (key value : Set) : Set :=
  {OPS_t : Set -&gt; Set @
    Boxed_map.signature (key := key) (value := value) (OPS_t := OPS_t)}.

Definition operation : Set :=
  Alpha_context.packed_internal_operation *
    option Alpha_context.Contract.big_map_diff.

Module script.
  Record record {code arg_type storage storage_type root_name : Set} : Set := Build {
    code : code;
    arg_type : arg_type;
    storage : storage;
    storage_type : storage_type;
    root_name : root_name }.
  Arguments record : clear implicits.
  Definition with_code {t_code t_arg_type t_storage t_storage_type t_root_name}
    code (r : record t_code t_arg_type t_storage t_storage_type t_root_name) :=
    Build t_code t_arg_type t_storage t_storage_type t_root_name code
      r.(arg_type) r.(storage) r.(storage_type) r.(root_name).
  Definition with_arg_type
    {t_code t_arg_type t_storage t_storage_type t_root_name} arg_type
    (r : record t_code t_arg_type t_storage t_storage_type t_root_name) :=
    Build t_code t_arg_type t_storage t_storage_type t_root_name r.(code)
      arg_type r.(storage) r.(storage_type) r.(root_name).
  Definition with_storage
    {t_code t_arg_type t_storage t_storage_type t_root_name} storage
    (r : record t_code t_arg_type t_storage t_storage_type t_root_name) :=
    Build t_code t_arg_type t_storage t_storage_type t_root_name r.(code)
      r.(arg_type) storage r.(storage_type) r.(root_name).
  Definition with_storage_type
    {t_code t_arg_type t_storage t_storage_type t_root_name} storage_type
    (r : record t_code t_arg_type t_storage t_storage_type t_root_name) :=
    Build t_code t_arg_type t_storage t_storage_type t_root_name r.(code)
      r.(arg_type) r.(storage) storage_type r.(root_name).
  Definition with_root_name
    {t_code t_arg_type t_storage t_storage_type t_root_name} root_name
    (r : record t_code t_arg_type t_storage t_storage_type t_root_name) :=
    Build t_code t_arg_type t_storage t_storage_type t_root_name r.(code)
      r.(arg_type) r.(storage) r.(storage_type) root_name.
End script.
Definition script_skeleton := script.record.

Module lambda.
  Record record {lam : Set} : Set := Build {
    lam : lam }.
  Arguments record : clear implicits.
  Definition with_lam {t_lam} lam (r : record t_lam) :=
    Build t_lam lam.
End lambda.
Definition lambda_skeleton := lambda.record.

Module descr.
  Record record {loc bef aft instr : Set} : Set := Build {
    loc : loc;
    bef : bef;
    aft : aft;
    instr : instr }.
  Arguments record : clear implicits.
  Definition with_loc {t_loc t_bef t_aft t_instr} loc
    (r : record t_loc t_bef t_aft t_instr) :=
    Build t_loc t_bef t_aft t_instr loc r.(bef) r.(aft) r.(instr).
  Definition with_bef {t_loc t_bef t_aft t_instr} bef
    (r : record t_loc t_bef t_aft t_instr) :=
    Build t_loc t_bef t_aft t_instr r.(loc) bef r.(aft) r.(instr).
  Definition with_aft {t_loc t_bef t_aft t_instr} aft
    (r : record t_loc t_bef t_aft t_instr) :=
    Build t_loc t_bef t_aft t_instr r.(loc) r.(bef) aft r.(instr).
  Definition with_instr {t_loc t_bef t_aft t_instr} instr
    (r : record t_loc t_bef t_aft t_instr) :=
    Build t_loc t_bef t_aft t_instr r.(loc) r.(bef) r.(aft) instr.
End descr.
Definition descr_skeleton := descr.record.

Module big_map.
  Record record {id diff key_type value_type : Set} : Set := Build {
    id : id;
    diff : diff;
    key_type : key_type;
    value_type : value_type }.
  Arguments record : clear implicits.
  Definition with_id {t_id t_diff t_key_type t_value_type} id
    (r : record t_id t_diff t_key_type t_value_type) :=
    Build t_id t_diff t_key_type t_value_type id r.(diff) r.(key_type)
      r.(value_type).
  Definition with_diff {t_id t_diff t_key_type t_value_type} diff
    (r : record t_id t_diff t_key_type t_value_type) :=
    Build t_id t_diff t_key_type t_value_type r.(id) diff r.(key_type)
      r.(value_type).
  Definition with_key_type {t_id t_diff t_key_type t_value_type} key_type
    (r : record t_id t_diff t_key_type t_value_type) :=
    Build t_id t_diff t_key_type t_value_type r.(id) r.(diff) key_type
      r.(value_type).
  Definition with_value_type {t_id t_diff t_key_type t_value_type} value_type
    (r : record t_id t_diff t_key_type t_value_type) :=
    Build t_id t_diff t_key_type t_value_type r.(id) r.(diff) r.(key_type)
      value_type.
End big_map.
Definition big_map_skeleton := big_map.record.

Reserved Notation &quot;'end_of_stack&quot;.
Reserved Notation &quot;'typed_contract&quot;.
Reserved Notation &quot;'big_map&quot;.
Reserved Notation &quot;'descr&quot;.
Reserved Notation &quot;'lambda&quot;.
Reserved Notation &quot;'script&quot;.

Inductive ty : Set :=
| Unit_t : option type_annot -&gt; ty
| Int_t : option type_annot -&gt; ty
| Nat_t : option type_annot -&gt; ty
| Signature_t : option type_annot -&gt; ty
| String_t : option type_annot -&gt; ty
| Bytes_t : option type_annot -&gt; ty
| Mutez_t : option type_annot -&gt; ty
| Key_hash_t : option type_annot -&gt; ty
| Key_t : option type_annot -&gt; ty
| Timestamp_t : option type_annot -&gt; ty
| Address_t : option type_annot -&gt; ty
| Bool_t : option type_annot -&gt; ty
| Pair_t :
  ty * option field_annot * option var_annot -&gt;
  ty * option field_annot * option var_annot -&gt; option type_annot -&gt; bool -&gt; ty
| Union_t :
  ty * option field_annot -&gt; ty * option field_annot -&gt; option type_annot -&gt;
  bool -&gt; ty
| Lambda_t : ty -&gt; ty -&gt; option type_annot -&gt; ty
| Option_t : ty -&gt; option type_annot -&gt; bool -&gt; ty
| List_t : ty -&gt; option type_annot -&gt; bool -&gt; ty
| Set_t : comparable_ty -&gt; option type_annot -&gt; ty
| Map_t : comparable_ty -&gt; ty -&gt; option type_annot -&gt; bool -&gt; ty
| Big_map_t : comparable_ty -&gt; ty -&gt; option type_annot -&gt; ty
| Contract_t : ty -&gt; option type_annot -&gt; ty
| Operation_t : option type_annot -&gt; ty
| Chain_id_t : option type_annot -&gt; ty

with stack_ty : Set :=
| Item_t : ty -&gt; stack_ty -&gt; option var_annot -&gt; stack_ty
| Empty_t : stack_ty

with instr : Set :=
| Drop : instr
| Dup : instr
| Swap : instr
| Const : forall {ty_ : Set}, ty_ -&gt; instr
| Cons_pair : instr
| Car : instr
| Cdr : instr
| Cons_some : instr
| Cons_none : ty -&gt; instr
| If_none : 'descr -&gt; 'descr -&gt; instr
| Left : instr
| Right : instr
| If_left : 'descr -&gt; 'descr -&gt; instr
| Cons_list : instr
| Nil : instr
| If_cons : 'descr -&gt; 'descr -&gt; instr
| List_map : 'descr -&gt; instr
| List_iter : 'descr -&gt; instr
| List_size : instr
| Empty_set : comparable_ty -&gt; instr
| Set_iter : 'descr -&gt; instr
| Set_mem : instr
| Set_update : instr
| Set_size : instr
| Empty_map : comparable_ty -&gt; ty -&gt; instr
| Map_map : 'descr -&gt; instr
| Map_iter : 'descr -&gt; instr
| Map_mem : instr
| Map_get : instr
| Map_update : instr
| Map_size : instr
| Empty_big_map : comparable_ty -&gt; ty -&gt; instr
| Big_map_mem : instr
| Big_map_get : instr
| Big_map_update : instr
| Concat_string : instr
| Concat_string_pair : instr
| Slice_string : instr
| String_size : instr
| Concat_bytes : instr
| Concat_bytes_pair : instr
| Slice_bytes : instr
| Bytes_size : instr
| Add_seconds_to_timestamp : instr
| Add_timestamp_to_seconds : instr
| Sub_timestamp_seconds : instr
| Diff_timestamps : instr
| Add_tez : instr
| Sub_tez : instr
| Mul_teznat : instr
| Mul_nattez : instr
| Ediv_teznat : instr
| Ediv_tez : instr
| Or : instr
| And : instr
| Xor : instr
| Not : instr
| Is_nat : instr
| Neg_nat : instr
| Neg_int : instr
| Abs_int : instr
| Int_nat : instr
| Add_intint : instr
| Add_intnat : instr
| Add_natint : instr
| Add_natnat : instr
| Sub_int : instr
| Mul_intint : instr
| Mul_intnat : instr
| Mul_natint : instr
| Mul_natnat : instr
| Ediv_intint : instr
| Ediv_intnat : instr
| Ediv_natint : instr
| Ediv_natnat : instr
| Lsl_nat : instr
| Lsr_nat : instr
| Or_nat : instr
| And_nat : instr
| And_int_nat : instr
| Xor_nat : instr
| Not_nat : instr
| Not_int : instr
| Seq : 'descr -&gt; 'descr -&gt; instr
| If : 'descr -&gt; 'descr -&gt; instr
| Loop : 'descr -&gt; instr
| Loop_left : 'descr -&gt; instr
| Dip : 'descr -&gt; instr
| Exec : instr
| Apply : ty -&gt; instr
| Lambda : 'lambda -&gt; instr
| Failwith : ty -&gt; instr
| Nop : instr
| Compare : comparable_ty -&gt; instr
| Eq : instr
| Neq : instr
| Lt : instr
| Gt : instr
| Le : instr
| Ge : instr
| Address : instr
| Contract : ty -&gt; string -&gt; instr
| Transfer_tokens : instr
| Create_account : instr
| Implicit_account : instr
| Create_contract : ty -&gt; ty -&gt; 'lambda -&gt; option string -&gt; instr
| Create_contract_2 : ty -&gt; ty -&gt; 'lambda -&gt; option string -&gt; instr
| Set_delegate : instr
| Now : instr
| Balance : instr
| Check_signature : instr
| Hash_key : instr
| Pack : ty -&gt; instr
| Unpack : ty -&gt; instr
| Blake2b : instr
| Sha256 : instr
| Sha512 : instr
| Steps_to_quota : instr
| Source : instr
| Sender : instr
| Self : ty -&gt; string -&gt; instr
| Amount : instr
| Dig : int -&gt; stack_prefix_preservation_witness -&gt; instr
| Dug : int -&gt; stack_prefix_preservation_witness -&gt; instr
| Dipn : int -&gt; stack_prefix_preservation_witness -&gt; 'descr -&gt; instr
| Dropn : int -&gt; stack_prefix_preservation_witness -&gt; instr
| ChainId : instr

with stack_prefix_preservation_witness : Set :=
| Prefix :
  stack_prefix_preservation_witness -&gt; stack_prefix_preservation_witness
| Rest : stack_prefix_preservation_witness

where &quot;'end_of_stack&quot; := (unit)
and &quot;'typed_contract&quot; := (ty * address)
and &quot;'big_map&quot; := (fun (t_key t_value : Set) =&gt;
  big_map_skeleton (option Z.t) (map t_key (option t_value)) ty ty)
and &quot;'descr&quot; :=
  (descr_skeleton Alpha_context.Script.location stack_ty stack_ty instr)
and &quot;'lambda&quot; := (lambda_skeleton ('descr * Alpha_context.Script.node))
and &quot;'script&quot; := (fun (t_storage : Set) =&gt;
  script_skeleton 'lambda ty t_storage ty (option string)).

Definition end_of_stack := 'end_of_stack.
Definition typed_contract := 'typed_contract.
Definition big_map := 'big_map.
Definition descr := 'descr.
Definition lambda := 'lambda.
Definition script := 'script.

Inductive ex_big_map : Set :=
| Ex_bm : forall {key value : Set}, big_map key value -&gt; ex_big_map.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="seed_repr.ml">
  <div style="margin: 20px;">
    <h3>Seed_repr</h3>
    <ul>
      <li>OCaml size: 134 lines</li>
      <li>Coq size: 146 lines (+8% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#seed_repr.ml"><code>seed_repr.ml</code></a>&nbsp;<span class="label label-warning">4 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(* Tezos Protocol Implementation - Random number generation *)

type seed = B of State_hash.t

type t = T of State_hash.t

type sequence = S of State_hash.t

type nonce = MBytes.t

let nonce_encoding = Data_encoding.Fixed.bytes Constants_repr.nonce_length

let initial_seed = &quot;Laissez-faire les proprietaires.&quot;

let zero_bytes = MBytes.of_string (String.make Nonce_hash.size '\000')

let state_hash_encoding =
  let open Data_encoding in
  conv
    State_hash.to_bytes
    State_hash.of_bytes_exn
    (Fixed.bytes Nonce_hash.size)

let seed_encoding =
  let open Data_encoding in
  conv (fun (B b) -&gt; b) (fun b -&gt; B b) state_hash_encoding

let empty = B (State_hash.hash_bytes [MBytes.of_string initial_seed])

let nonce (B state) nonce =
  B (State_hash.hash_bytes [State_hash.to_bytes state; nonce])

let initialize_new (B state) append =
  T (State_hash.hash_bytes (State_hash.to_bytes state :: zero_bytes :: append))

let xor_higher_bits i b =
  let higher = MBytes.get_int32 b 0 in
  let r = Int32.logxor higher i in
  let res = MBytes.copy b in
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">MBytes.set_int32 res 0 r</abbr> ; res

let sequence (T state) n =
  State_hash.to_bytes state |&gt; xor_higher_bits n
  |&gt; fun b -&gt; S (State_hash.hash_bytes [b])

let take (S state) =
  let b = State_hash.to_bytes state in
  let h = State_hash.hash_bytes [b] in
  (State_hash.to_bytes h, S h)

let take_int32 s bound =
  if Compare.Int32.(bound &lt;= 0l) then invalid_arg &quot;Seed_repr.take_int32&quot;
    (* FIXME *)
  else
    let rec loop s =
      let (bytes, s) = take s in
      let r = Int32.abs (MBytes.get_int32 bytes 0) in
      let drop_if_over =
        Int32.sub Int32.max_int (Int32.rem Int32.max_int bound)
      in
      if Compare.Int32.(r &gt;= drop_if_over) then loop s
      else
        let v = Int32.rem r bound in
        (v, s)
    in
    loop s

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Unexpected_nonce_length</abbr> (* `Permanent *)

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  register_error_kind
    `Permanent
    ~id:&quot;unexpected_nonce_length&quot;
    ~title:&quot;Unexpected nonce length&quot;
    ~description:&quot;Nonce length is incorrect.&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf
        ppf
        &quot;Nonce length is not %i bytes long as it should.&quot;
        Constants_repr.nonce_length)
    Data_encoding.empty
    (function Unexpected_nonce_length -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Unexpected_nonce_length)</abbr>

let make_nonce nonce =
  if Compare.Int.(MBytes.length nonce &lt;&gt; Constants_repr.nonce_length) then
    error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Unexpected_nonce_length</abbr>
  else ok nonce

let hash nonce = Nonce_hash.hash_bytes [nonce]

let check_hash nonce hash =
  Compare.Int.(MBytes.length nonce = Constants_repr.nonce_length)
  &amp;&amp; Nonce_hash.equal (Nonce_hash.hash_bytes [nonce]) hash

let nonce_hash_key_part = Nonce_hash.to_path

let initial_nonce_0 = zero_bytes

let initial_nonce_hash_0 = hash initial_nonce_0

let deterministic_seed seed = nonce seed zero_bytes

let initial_seeds n =
  let rec loop acc elt i =
    if Compare.Int.(i = 1) then List.rev (elt :: acc)
    else loop (elt :: acc) (deterministic_seed elt) (i - 1)
  in
  loop [] (B (State_hash.hash_bytes [])) n
</pre>
  </div>
  <div class="col-md-6">
    <a href="#seed_repr.ml"><code>Seed_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Constants_repr.
Require Tezos.Nonce_hash.
Require Tezos.State_hash.

Inductive seed : Set :=
| B : State_hash.t -&gt; seed.

Inductive t : Set :=
| T : State_hash.t -&gt; t.

Inductive sequence : Set :=
| S : State_hash.t -&gt; sequence.

Definition nonce : Set := MBytes.t.

Definition nonce_encoding : Data_encoding.encoding MBytes.t :=
  Data_encoding.Fixed.__bytes_value Constants_repr.nonce_length.

Definition initial_seed : string := &quot;Laissez-faire les proprietaires.&quot;.

Definition zero_bytes : MBytes.t :=
  MBytes.of_string (String.make Nonce_hash.size &quot;000&quot; % char).

Definition state_hash_encoding : Data_encoding.encoding State_hash.t :=
  Data_encoding.conv State_hash.to_bytes State_hash.of_bytes_exn None
    (Data_encoding.Fixed.__bytes_value Nonce_hash.size).

Definition seed_encoding : Data_encoding.encoding seed :=
  Data_encoding.conv
    (fun function_parameter =&gt;
      let 'B __b_value := function_parameter in
      __b_value) (fun __b_value =&gt; B __b_value) None state_hash_encoding.

Definition empty : seed :=
  B (State_hash.hash_bytes None [ MBytes.of_string initial_seed ]).

Definition __nonce_value (function_parameter : seed) : MBytes.t -&gt; seed :=
  let 'B state := function_parameter in
  fun __nonce_value =&gt;
    B (State_hash.hash_bytes None [ State_hash.to_bytes state; __nonce_value ]).

Definition initialize_new (function_parameter : seed) : list MBytes.t -&gt; t :=
  let 'B state := function_parameter in
  fun append =&gt;
    T
      (State_hash.hash_bytes None
        (cons (State_hash.to_bytes state) (cons zero_bytes append))).

Definition xor_higher_bits (i : int32) (__b_value : MBytes.t) : MBytes.t :=
  let higher := MBytes.get_int32 __b_value 0 in
  let __r_value := Int32.logxor higher i in
  let res := MBytes.copy __b_value in
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  res.

Definition __sequence_value (function_parameter : t) : int32 -&gt; sequence :=
  let 'T state := function_parameter in
  fun n =&gt;
    (fun __b_value =&gt; S (State_hash.hash_bytes None [ __b_value ]))
      ((xor_higher_bits n) (State_hash.to_bytes state)).

Definition take (function_parameter : sequence) : MBytes.t * sequence :=
  let 'S state := function_parameter in
  let __b_value := State_hash.to_bytes state in
  let h := State_hash.hash_bytes None [ __b_value ] in
  ((State_hash.to_bytes h), (S h)).

Definition take_int32 (s : sequence) (bound : (|Compare.Int32|).(Compare.S.t))
  : int32 * sequence :=
  if
    (|Compare.Int32|).(Compare.S.op_lteq) bound
      (* ‚ùå Constant of type int32 is converted to int *)
      0 then
    Pervasives.invalid_arg &quot;Seed_repr.take_int32&quot;
  else
    let fix loop (s : sequence) {struct s} : int32 * sequence :=
      let '(__bytes_value, s) := take s in
      let __r_value := Int32.abs (MBytes.get_int32 __bytes_value 0) in
      let drop_if_over :=
        Int32.sub Int32.max_int (Int32.rem Int32.max_int bound) in
      if (|Compare.Int32|).(Compare.S.op_gteq) __r_value drop_if_over then
        loop s
      else
        let v := Int32.rem __r_value bound in
        (v, s) in
    loop s.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition make_nonce (__nonce_value : MBytes.t)
  : Error_monad.tzresult MBytes.t :=
  if
    (|Compare.Int|).(Compare.S.op_ltgt) (MBytes.length __nonce_value)
      Constants_repr.nonce_length then
    Error_monad.__error_value extensible_type_value
  else
    Error_monad.ok __nonce_value.

Definition __hash_value (__nonce_value : MBytes.t) : Nonce_hash.t :=
  Nonce_hash.hash_bytes None [ __nonce_value ].

Definition check_hash (__nonce_value : MBytes.t) (__hash_value : Nonce_hash.t)
  : bool :=
  Pervasives.op_andand
    ((|Compare.Int|).(Compare.S.op_eq) (MBytes.length __nonce_value)
      Constants_repr.nonce_length)
    (Nonce_hash.equal (Nonce_hash.hash_bytes None [ __nonce_value ])
      __hash_value).

Definition nonce_hash_key_part : Nonce_hash.t -&gt; list string -&gt; list string :=
  Nonce_hash.to_path.

Definition initial_nonce_0 : MBytes.t := zero_bytes.

Definition initial_nonce_hash_0 : Nonce_hash.t := __hash_value initial_nonce_0.

Definition deterministic_seed (__seed_value : seed) : seed :=
  __nonce_value __seed_value zero_bytes.

Definition initial_seeds (n : (|Compare.Int|).(Compare.S.t)) : list seed :=
  let fix loop
    (acc : list seed) (__elt_value : seed) (i : (|Compare.Int|).(Compare.S.t))
    {struct acc} : list seed :=
    if (|Compare.Int|).(Compare.S.op_eq) i 1 then
      List.rev (cons __elt_value acc)
    else
      loop (cons __elt_value acc) (deterministic_seed __elt_value)
        (Pervasives.op_minus i 1) in
  loop nil (B (State_hash.hash_bytes None nil)) n.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="seed_repr.mli">
  <div style="margin: 20px;">
    <h3>Seed_repr_mli</h3>
    <ul>
      <li>OCaml size: 100 lines</li>
      <li>Coq size: 52 lines (-48% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#seed_repr.mli"><code>seed_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Tezos Protocol Implementation - Random number generation

    This is not expected to be a good cryptographic random number
    generator. In particular this is supposed to be used in situations
    where the seed is a globaly known information.

    The only expected property is: It should be difficult to find a
    seed such that the generated sequence is a given one. *)

(** {2 Random Generation} *)

(** The state of the random number generator *)
type t

(** A random seed, to derive random sequences from *)
type seed

(** A random sequence, to derive random values from *)
type sequence

(** [initialize_new state ident] returns a new generator *)
val initialize_new : seed -&gt; MBytes.t list -&gt; t

(** [sequence state n] prepares the n-th sequence of a state  *)
val sequence : t -&gt; int32 -&gt; sequence

(** Generates the next random value in the sequence *)
val take : sequence -&gt; MBytes.t * sequence

(** Generates the next random value as a bounded [int32] *)
val take_int32 : sequence -&gt; int32 -&gt; int32 * sequence

(** {2 Predefined seeds} *)

val empty : seed

(** Returns a new seed by hashing the one passed with a constant. *)
val deterministic_seed : seed -&gt; seed

(** [intial_seeds n] generates the first [n] seeds for which there are no nonces.
    The first seed is a constant value. The kth seed is the hash of seed (k-1)
    concatenated with a constant. *)
val initial_seeds : int -&gt; seed list

(** {2 Entropy} *)

(** A nonce for adding entropy to the generator *)
type nonce

(** Add entropy to the seed generator *)
val nonce : seed -&gt; nonce -&gt; seed

(** Use a byte sequence as a nonce *)
val make_nonce : MBytes.t -&gt; nonce tzresult

(** Compute the has of a nonce *)
val hash : nonce -&gt; Nonce_hash.t

(** [check_hash nonce hash] is true if the nonce correspond to the hash *)
val check_hash : nonce -&gt; Nonce_hash.t -&gt; bool

(** For using nonce hashes as keys in the hierarchical database *)
val nonce_hash_key_part : Nonce_hash.t -&gt; string list -&gt; string list

(** {2 Predefined nonce} *)

val initial_nonce_0 : nonce

val initial_nonce_hash_0 : Nonce_hash.t

(** {2 Serializers} *)

val nonce_encoding : nonce Data_encoding.t

val seed_encoding : seed Data_encoding.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#seed_repr.mli"><code>Seed_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Nonce_hash.

Parameter t : Set.

Parameter seed : Set.

Parameter sequence : Set.

Parameter initialize_new : seed -&gt; list MBytes.t -&gt; t.

Parameter __sequence_value : t -&gt; int32 -&gt; sequence.

Parameter take : sequence -&gt; MBytes.t * sequence.

Parameter take_int32 : sequence -&gt; int32 -&gt; int32 * sequence.

Parameter empty : seed.

Parameter deterministic_seed : seed -&gt; seed.

Parameter initial_seeds : int -&gt; list seed.

Parameter nonce : Set.

Parameter __nonce_value : seed -&gt; nonce -&gt; seed.

Parameter make_nonce : MBytes.t -&gt; Error_monad.tzresult nonce.

Parameter __hash_value : nonce -&gt; Nonce_hash.t.

Parameter check_hash : nonce -&gt; Nonce_hash.t -&gt; bool.

Parameter nonce_hash_key_part : Nonce_hash.t -&gt; list string -&gt; list string.

Parameter initial_nonce_0 : nonce.

Parameter initial_nonce_hash_0 : Nonce_hash.t.

Parameter nonce_encoding : Data_encoding.t nonce.

Parameter seed_encoding : Data_encoding.t seed.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="seed_storage.ml">
  <div style="margin: 20px;">
    <h3>Seed_storage</h3>
    <ul>
      <li>OCaml size: 148 lines</li>
      <li>Coq size: 134 lines (-10% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#seed_storage.ml"><code>seed_storage.ml</code></a>&nbsp;<span class="label label-warning">4 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Misc

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error +=
  | Unknown of {
      oldest : Cycle_repr.t;
      cycle : Cycle_repr.t;
      latest : Cycle_repr.t;
    }</abbr>

(* `Permanent *)

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  register_error_kind
    `Permanent
    ~id:&quot;seed.unknown_seed&quot;
    ~title:&quot;Unknown seed&quot;
    ~description:&quot;The requested seed is not available&quot;
    ~pp:(fun ppf (oldest, cycle, latest) -&gt;
      if Cycle_repr.(cycle &lt; oldest) then
        Format.fprintf
          ppf
          &quot;The seed for cycle %a has been cleared from the context  (oldest \
           known seed is for cycle %a)&quot;
          Cycle_repr.pp
          cycle
          Cycle_repr.pp
          oldest
      else
        Format.fprintf
          ppf
          &quot;The seed for cycle %a has not been computed yet  (latest known \
           seed is for cycle %a)&quot;
          Cycle_repr.pp
          cycle
          Cycle_repr.pp
          latest)
    Data_encoding.(
      obj3
        (req &quot;oldest&quot; Cycle_repr.encoding)
        (req &quot;requested&quot; Cycle_repr.encoding)
        (req &quot;latest&quot; Cycle_repr.encoding))
    (function
      | Unknown {oldest; cycle; latest} -&gt;
          Some (oldest, cycle, latest)
      | _ -&gt;
          None)
    (fun (oldest, cycle, latest) -&gt; Unknown {oldest; cycle; latest})</abbr>

let compute_for_cycle c ~revealed cycle =
  match Cycle_repr.pred cycle with
  | None -&gt;
      <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr> (* should not happen *)
  | Some previous_cycle -&gt;
      let levels = Level_storage.levels_with_commitments_in_cycle c revealed in
      let combine (c, random_seed, unrevealed) level =
        Storage.Seed.Nonce.get c level
        &gt;&gt;=? function
        | Revealed nonce -&gt;
            Storage.Seed.Nonce.delete c level
            &gt;&gt;=? fun c -&gt;
            return (c, Seed_repr.nonce random_seed nonce, unrevealed)
        | Unrevealed u -&gt;
            Storage.Seed.Nonce.delete c level
            &gt;&gt;=? fun c -&gt; return (c, random_seed, u :: unrevealed)
      in
      Storage.Seed.For_cycle.get c previous_cycle
      &gt;&gt;=? fun prev_seed -&gt;
      let seed = Seed_repr.deterministic_seed prev_seed in
      fold_left_s combine (c, seed, []) levels
      &gt;&gt;=? fun (c, seed, unrevealed) -&gt;
      Storage.Seed.For_cycle.init c cycle seed
      &gt;&gt;=? fun c -&gt; return (c, unrevealed)

let for_cycle ctxt cycle =
  let preserved = Constants_storage.preserved_cycles ctxt in
  let current_level = Level_storage.current ctxt in
  let current_cycle = current_level.cycle in
  let latest =
    if Cycle_repr.(current_cycle = root) then
      Cycle_repr.add current_cycle (preserved + 1)
    else Cycle_repr.add current_cycle preserved
  in
  let oldest =
    match Cycle_repr.sub current_cycle preserved with
    | None -&gt;
        Cycle_repr.root
    | Some oldest -&gt;
        oldest
  in
  fail_unless
    Cycle_repr.(oldest &lt;= cycle &amp;&amp; cycle &lt;= latest)
    <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Unknown {oldest; cycle; latest})</abbr>
  &gt;&gt;=? fun () -&gt; Storage.Seed.For_cycle.get ctxt cycle

let clear_cycle c cycle = Storage.Seed.For_cycle.delete c cycle

let init ctxt =
  let preserved = Constants_storage.preserved_cycles ctxt in
  List.fold_left2
    (fun ctxt c seed -&gt;
      ctxt
      &gt;&gt;=? fun ctxt -&gt;
      let cycle = Cycle_repr.of_int32_exn (Int32.of_int c) in
      Storage.Seed.For_cycle.init ctxt cycle seed)
    (return ctxt)
    (0 --&gt; (preserved + 1))
    (Seed_repr.initial_seeds (preserved + 2))

let cycle_end ctxt last_cycle =
  let preserved = Constants_storage.preserved_cycles ctxt in
  ( match Cycle_repr.sub last_cycle preserved with
  | None -&gt;
      return ctxt
  | Some cleared_cycle -&gt;
      clear_cycle ctxt cleared_cycle )
  &gt;&gt;=? fun ctxt -&gt;
  match Cycle_repr.pred last_cycle with
  | None -&gt;
      return (ctxt, [])
  | Some revealed -&gt;
      (* cycle with revelations *)
      let inited_seed_cycle = Cycle_repr.add last_cycle (preserved + 1) in
      compute_for_cycle ctxt ~revealed inited_seed_cycle
</pre>
  </div>
  <div class="col-md-6">
    <a href="#seed_storage.ml"><code>Seed_storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Constants_storage.
Require Tezos.Cycle_repr.
Require Tezos.Level_repr.
Require Tezos.Level_storage.
Require Tezos.Misc.
Require Tezos.Raw_context.
Require Tezos.Seed_repr.
Require Tezos.Storage_mli. Module Storage := Storage_mli.
Require Tezos.Storage_sigs.

Import Misc.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition compute_for_cycle
  (c : Raw_context.t) (revealed : Cycle_repr.t) (cycle : Cycle_repr.cycle)
  : Lwt.t (Error_monad.tzresult (Raw_context.t * list Storage.unrevealed_nonce)) :=
  match Cycle_repr.pred cycle with
  | None =&gt;
    (* ‚ùå Assert instruction is not handled. *)
    assert
      (Lwt.t
        (Error_monad.tzresult (Raw_context.t * list Storage.unrevealed_nonce)))
      false
  | Some previous_cycle =&gt;
    let levels := Level_storage.levels_with_commitments_in_cycle c revealed in
    let combine
      (function_parameter :
        (|Storage.Seed.Nonce|).(Storage_sigs.Non_iterable_indexed_data_storage.context)
          * Seed_repr.seed * list Storage.unrevealed_nonce)
      : Level_repr.t -&gt;
      Lwt.t
        (Error_monad.tzresult
          (Raw_context.t * Seed_repr.seed * list Storage.unrevealed_nonce)) :=
      let '(c, random_seed, unrevealed) := function_parameter in
      fun level =&gt;
        let=? function_parameter :=
          (|Storage.Seed.Nonce|).(Storage_sigs.Non_iterable_indexed_data_storage.get)
            c level in
        match function_parameter with
        | Storage.Revealed __nonce_value =&gt;
          let=? c :=
            (|Storage.Seed.Nonce|).(Storage_sigs.Non_iterable_indexed_data_storage.delete)
              c level in
          Error_monad.__return
            (c, (Seed_repr.__nonce_value random_seed __nonce_value), unrevealed)
        | Storage.Unrevealed u =&gt;
          let=? c :=
            (|Storage.Seed.Nonce|).(Storage_sigs.Non_iterable_indexed_data_storage.delete)
              c level in
          Error_monad.__return (c, random_seed, (cons u unrevealed))
        end in
    let=? prev_seed :=
      (|Storage.Seed.For_cycle|).(Storage.For_cycle_sig.get) c previous_cycle in
    let __seed_value := Seed_repr.deterministic_seed prev_seed in
    let=? '(c, __seed_value, unrevealed) :=
      Error_monad.fold_left_s combine (c, __seed_value, nil) levels in
    let=? c :=
      (|Storage.Seed.For_cycle|).(Storage.For_cycle_sig.init) c cycle
        __seed_value in
    Error_monad.__return (c, unrevealed)
  end.

Definition for_cycle (ctxt : Raw_context.context) (cycle : Cycle_repr.t)
  : Lwt.t (Error_monad.tzresult Seed_repr.seed) :=
  let preserved := Constants_storage.preserved_cycles ctxt in
  let current_level := Level_storage.current ctxt in
  let current_cycle := current_level.(Level_repr.t.cycle) in
  let latest :=
    if Cycle_repr.op_eq current_cycle Cycle_repr.root then
      Cycle_repr.add current_cycle (Pervasives.op_plus preserved 1)
    else
      Cycle_repr.add current_cycle preserved in
  let oldest :=
    match Cycle_repr.sub current_cycle preserved with
    | None =&gt; Cycle_repr.root
    | Some oldest =&gt; oldest
    end in
  let=? '_ :=
    Error_monad.fail_unless
      (Pervasives.op_andand (Cycle_repr.op_lteq oldest cycle)
        (Cycle_repr.op_lteq cycle latest)) extensible_type_value in
  (|Storage.Seed.For_cycle|).(Storage.For_cycle_sig.get) ctxt cycle.

Definition clear_cycle (c : Raw_context.t) (cycle : Cycle_repr.t)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  (|Storage.Seed.For_cycle|).(Storage.For_cycle_sig.delete) c cycle.

Definition init (ctxt : Raw_context.context)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let preserved := Constants_storage.preserved_cycles ctxt in
  List.fold_left2
    (fun ctxt =&gt;
      fun c =&gt;
        fun __seed_value =&gt;
          let=? ctxt := ctxt in
          let cycle := Cycle_repr.of_int32_exn (Int32.of_int c) in
          (|Storage.Seed.For_cycle|).(Storage.For_cycle_sig.init) ctxt cycle
            __seed_value) (Error_monad.__return ctxt)
    (Misc.op_minusminusgt 0 (Pervasives.op_plus preserved 1))
    (Seed_repr.initial_seeds (Pervasives.op_plus preserved 2)).

Definition cycle_end
  (ctxt : Raw_context.context) (last_cycle : Cycle_repr.cycle)
  : Lwt.t
    (Error_monad.tzresult (Raw_context.context * list Storage.unrevealed_nonce)) :=
  let preserved := Constants_storage.preserved_cycles ctxt in
  let=? ctxt :=
    match Cycle_repr.sub last_cycle preserved with
    | None =&gt; Error_monad.__return ctxt
    | Some cleared_cycle =&gt; clear_cycle ctxt cleared_cycle
    end in
  match Cycle_repr.pred last_cycle with
  | None =&gt; Error_monad.__return (ctxt, nil)
  | Some revealed =&gt;
    let inited_seed_cycle :=
      Cycle_repr.add last_cycle (Pervasives.op_plus preserved 1) in
    compute_for_cycle ctxt revealed inited_seed_cycle
  end.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="seed_storage.mli">
  <div style="margin: 20px;">
    <h3>Seed_storage_mli</h3>
    <ul>
      <li>OCaml size: 47 lines</li>
      <li>Coq size: 26 lines (-45% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#seed_storage.mli"><code>seed_storage.mli</code></a>&nbsp;<span class="label label-warning">1 warning</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

<abbr class="mark-warning" title="Extensible types are not handled.">type error +=
  | Unknown of {
      oldest : Cycle_repr.t;
      cycle : Cycle_repr.t;
      latest : Cycle_repr.t;
    }</abbr>

(* `Permanent *)

(** Generates the first [preserved_cycles+2] seeds for which
    there are no nonces. *)
val init : Raw_context.t -&gt; Raw_context.t tzresult Lwt.t

val for_cycle : Raw_context.t -&gt; Cycle_repr.t -&gt; Seed_repr.seed tzresult Lwt.t

(** If it is the end of the cycle, computes and stores the seed of cycle at
    distance [preserved_cycle+2] in the future using the seed of the previous
    cycle and the revelations of the current one.  *)
val cycle_end :
  Raw_context.t -&gt;
  Cycle_repr.t -&gt;
  (Raw_context.t * Nonce_storage.unrevealed list) tzresult Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#seed_storage.mli"><code>Seed_storage_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Cycle_repr.
Require Tezos.Nonce_storage.
Require Tezos.Raw_context.
Require Tezos.Seed_repr.

(* extensible_type_definition `error` *)

Parameter init : Raw_context.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter for_cycle :
  Raw_context.t -&gt; Cycle_repr.t -&gt; Lwt.t (Error_monad.tzresult Seed_repr.seed).

Parameter cycle_end :
  Raw_context.t -&gt; Cycle_repr.t -&gt;
  Lwt.t (Error_monad.tzresult (Raw_context.t * list Nonce_storage.unrevealed)).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="services_registration.ml">
  <div style="margin: 20px;">
    <h3>Services_registration</h3>
    <ul>
      <li>OCaml size: 94 lines</li>
      <li>Coq size: 164 lines (+74% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#services_registration.ml"><code>services_registration.ml</code></a>&nbsp;<span class="label label-warning">1 warning</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

type rpc_context = {
  block_hash : Block_hash.t;
  block_header : Block_header.shell_header;
  context : Alpha_context.t;
}

let rpc_init ({block_hash; block_header; context} : Updater.rpc_context) =
  let level = block_header.level in
  let timestamp = block_header.timestamp in
  let fitness = block_header.fitness in
  Alpha_context.prepare
    ~level
    ~predecessor_timestamp:timestamp
    ~timestamp
    ~fitness
    context
  &gt;&gt;=? fun context -&gt; return {block_hash; block_header; context}

let rpc_services =
  ref (RPC_directory.empty : Updater.rpc_context RPC_directory.t)

let register0_fullctxt s f =
  rpc_services :=
    RPC_directory.register !rpc_services s (fun ctxt q i -&gt;
        rpc_init ctxt &gt;&gt;=? fun ctxt -&gt; f ctxt q i)

let opt_register0_fullctxt s f =
  rpc_services :=
    RPC_directory.opt_register !rpc_services s (fun ctxt q i -&gt;
        rpc_init ctxt &gt;&gt;=? fun ctxt -&gt; f ctxt q i)

let register0 s f = register0_fullctxt s (fun {context; _} -&gt; f context)

let register0_noctxt s f =
  rpc_services := RPC_directory.register !rpc_services s (fun _ q i -&gt; f q i)

let register1_fullctxt s f =
  rpc_services :=
    RPC_directory.register !rpc_services s (fun (ctxt, arg) q i -&gt;
        rpc_init ctxt &gt;&gt;=? fun ctxt -&gt; f ctxt arg q i)

let register1 s f = register1_fullctxt s (fun {context; _} x -&gt; f context x)

let register1_noctxt s f =
  rpc_services :=
    RPC_directory.register !rpc_services s (fun (_, arg) q i -&gt; f arg q i)

let register2_fullctxt s f =
  rpc_services :=
    RPC_directory.register !rpc_services s (fun ((ctxt, arg1), arg2) q i -&gt;
        rpc_init ctxt &gt;&gt;=? fun ctxt -&gt; f ctxt arg1 arg2 q i)

let register2 s f =
  register2_fullctxt s (fun {context; _} a1 a2 q i -&gt; f context a1 a2 q i)

let get_rpc_services () =
  let p =
    RPC_directory.map
      (fun c -&gt;
        rpc_init c
        &gt;&gt;= function Error _ -&gt; <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr> | Ok c -&gt; Lwt.return c.context)
      (Storage_description.build_directory Alpha_context.description)
  in
  RPC_directory.register_dynamic_directory
    !rpc_services
    RPC_path.(open_root / &quot;context&quot; / &quot;raw&quot; / &quot;json&quot;)
    (fun _ -&gt; Lwt.return p)
</pre>
  </div>
  <div class="col-md-6">
    <a href="#services_registration.ml"><code>Services_registration.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Storage_description.

Import Alpha_context.

Module rpc_context.
  Record record : Set := Build {
    block_hash : (|Block_hash|).(S.HASH.t);
    block_header : Alpha_context.Block_header.shell_header;
    context : Alpha_context.t }.
  Definition with_block_hash block_hash (r : record) :=
    Build block_hash r.(block_header) r.(context).
  Definition with_block_header block_header (r : record) :=
    Build r.(block_hash) block_header r.(context).
  Definition with_context context (r : record) :=
    Build r.(block_hash) r.(block_header) context.
End rpc_context.
Definition rpc_context := rpc_context.record.

Definition rpc_init (function_parameter : Updater.rpc_context)
  : Lwt.t (Error_monad.tzresult rpc_context) :=
  let '{|
    Updater.rpc_context.block_hash := block_hash;
      Updater.rpc_context.block_header := block_header;
      Updater.rpc_context.context := context
      |} := function_parameter in
  let level := block_header.(Block_header.shell_header.level) in
  let timestamp := block_header.(Block_header.shell_header.timestamp) in
  let fitness := block_header.(Block_header.shell_header.fitness) in
  let=? context :=
    Alpha_context.prepare context level timestamp timestamp fitness in
  Error_monad.__return
    {| rpc_context.block_hash := block_hash;
      rpc_context.block_header := block_header; rpc_context.context := context
      |}.

Definition rpc_services
  : Pervasives.ref (RPC_directory.t Updater.rpc_context) :=
  Pervasives.__ref_value RPC_directory.empty.

Definition register0_fullctxt {A B C : Set}
  (s : RPC_service.t Updater.rpc_context Updater.rpc_context A B C)
  (f : rpc_context -&gt; A -&gt; B -&gt; Lwt.t (Error_monad.tzresult C)) : unit :=
  Pervasives.op_coloneq rpc_services
    (RPC_directory.register (Pervasives.op_exclamation rpc_services) s
      (fun ctxt =&gt;
        fun q =&gt;
          fun i =&gt;
            let=? ctxt := rpc_init ctxt in
            f ctxt q i)).

Definition opt_register0_fullctxt {A B C : Set}
  (s : RPC_service.t Updater.rpc_context Updater.rpc_context A B C)
  (f : rpc_context -&gt; A -&gt; B -&gt; Lwt.t (Error_monad.tzresult (option C)))
  : unit :=
  Pervasives.op_coloneq rpc_services
    (RPC_directory.opt_register (Pervasives.op_exclamation rpc_services) s
      (fun ctxt =&gt;
        fun q =&gt;
          fun i =&gt;
            let=? ctxt := rpc_init ctxt in
            f ctxt q i)).

Definition register0 {A B C : Set}
  (s : RPC_service.t Updater.rpc_context Updater.rpc_context A B C)
  (f : Alpha_context.t -&gt; A -&gt; B -&gt; Lwt.t (Error_monad.tzresult C)) : unit :=
  register0_fullctxt s
    (fun function_parameter =&gt;
      let '{| rpc_context.context := context |} := function_parameter in
      f context).

Definition register0_noctxt {A B C D : Set}
  (s : RPC_service.t Updater.rpc_context A B C D)
  (f : B -&gt; C -&gt; Lwt.t (Error_monad.tzresult D)) : unit :=
  Pervasives.op_coloneq rpc_services
    (RPC_directory.register (Pervasives.op_exclamation rpc_services) s
      (fun function_parameter =&gt;
        let '_ := function_parameter in
        fun q =&gt; fun i =&gt; f q i)).

Definition register1_fullctxt {A B C D : Set}
  (s : RPC_service.t Updater.rpc_context (Updater.rpc_context * A) B C D)
  (f : rpc_context -&gt; A -&gt; B -&gt; C -&gt; Lwt.t (Error_monad.tzresult D)) : unit :=
  Pervasives.op_coloneq rpc_services
    (RPC_directory.register (Pervasives.op_exclamation rpc_services) s
      (fun function_parameter =&gt;
        let '(ctxt, arg) := function_parameter in
        fun q =&gt;
          fun i =&gt;
            let=? ctxt := rpc_init ctxt in
            f ctxt arg q i)).

Definition register1 {A B C D : Set}
  (s : RPC_service.t Updater.rpc_context (Updater.rpc_context * A) B C D)
  (f : Alpha_context.t -&gt; A -&gt; B -&gt; C -&gt; Lwt.t (Error_monad.tzresult D))
  : unit :=
  register1_fullctxt s
    (fun function_parameter =&gt;
      let '{| rpc_context.context := context |} := function_parameter in
      fun x =&gt; f context x).

Definition register1_noctxt {A B C D E : Set}
  (s : RPC_service.t Updater.rpc_context (A * B) C D E)
  (f : B -&gt; C -&gt; D -&gt; Lwt.t (Error_monad.tzresult E)) : unit :=
  Pervasives.op_coloneq rpc_services
    (RPC_directory.register (Pervasives.op_exclamation rpc_services) s
      (fun function_parameter =&gt;
        let '(_, arg) := function_parameter in
        fun q =&gt; fun i =&gt; f arg q i)).

Definition register2_fullctxt {A B C D E : Set}
  (s : RPC_service.t Updater.rpc_context ((Updater.rpc_context * A) * B) C D E)
  (f : rpc_context -&gt; A -&gt; B -&gt; C -&gt; D -&gt; Lwt.t (Error_monad.tzresult E))
  : unit :=
  Pervasives.op_coloneq rpc_services
    (RPC_directory.register (Pervasives.op_exclamation rpc_services) s
      (fun function_parameter =&gt;
        let '((ctxt, arg1), arg2) := function_parameter in
        fun q =&gt;
          fun i =&gt;
            let=? ctxt := rpc_init ctxt in
            f ctxt arg1 arg2 q i)).

Definition register2 {A B C D E : Set}
  (s : RPC_service.t Updater.rpc_context ((Updater.rpc_context * A) * B) C D E)
  (f : Alpha_context.t -&gt; A -&gt; B -&gt; C -&gt; D -&gt; Lwt.t (Error_monad.tzresult E))
  : unit :=
  register2_fullctxt s
    (fun function_parameter =&gt;
      let '{| rpc_context.context := context |} := function_parameter in
      fun a1 =&gt; fun a2 =&gt; fun q =&gt; fun i =&gt; f context a1 a2 q i).

Definition get_rpc_services (function_parameter : unit)
  : RPC_directory.directory Updater.rpc_context :=
  let '_ := function_parameter in
  let __p_value :=
    RPC_directory.map
      (fun c =&gt;
        let= function_parameter := rpc_init c in
        match function_parameter with
        | Pervasives.Error _ =&gt;
          (* ‚ùå Assert instruction is not handled. *)
          assert (Lwt.t Alpha_context.t) false
        | Pervasives.Ok c =&gt; Lwt.__return c.(rpc_context.context)
        end) (Storage_description.build_directory Alpha_context.description) in
  RPC_directory.register_dynamic_directory None
    (Pervasives.op_exclamation rpc_services)
    (RPC_path.op_div
      (RPC_path.op_div (RPC_path.op_div RPC_path.open_root &quot;context&quot;) &quot;raw&quot;)
      &quot;json&quot;)
    (fun function_parameter =&gt;
      let '_ := function_parameter in
      Lwt.__return __p_value).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="state_hash.ml">
  <div style="margin: 20px;">
    <h3>State_hash</h3>
    <ul>
      <li>OCaml size: 43 lines</li>
      <li>Coq size: 103 lines (+139% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#state_hash.ml"><code>state_hash.ml</code></a>&nbsp;<span class="label label-warning">1 warning</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

let random_state_hash = &quot;\076\064\204&quot; (* rng(53): never used... *)

module Blake2BModule =
  Blake2B.Make
    (Base58)
    (struct
      let name = &quot;random&quot;

      let title = &quot;A random generation state&quot;

      let b58check_prefix = random_state_hash

      let size = None
    end)

include Blake2BModule

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () = Base58.check_encoded_prefix b58check_encoding &quot;rng&quot; 53</abbr>
</pre>
  </div>
  <div class="col-md-6">
    <a href="#state_hash.ml"><code>State_hash.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.

Definition random_state_hash : string := &quot;L@\204&quot;.

Definition Blake2BModule :=
  (Blake2B.Make
    (existT (A := unit) (fun _ =&gt; _) tt
      {|
        Blake2B.SRegister.register_encoding {_} := Base58.register_encoding
      |}))
    (let name := &quot;random&quot; in
    let title := &quot;A random generation state&quot; in
    let b58check_prefix := random_state_hash in
    let size {A : Set} : option A :=
      None in
    existT (A := unit) (fun _ =&gt; _) tt
      {|
        Blake2B.PrefixedName.name := name;
        Blake2B.PrefixedName.title := title;
        Blake2B.PrefixedName.size := size;
        Blake2B.PrefixedName.b58check_prefix := b58check_prefix
      |}).

Definition t := (|Blake2BModule|).(S.HASH.t).

Definition name := (|Blake2BModule|).(S.HASH.name).

Definition title := (|Blake2BModule|).(S.HASH.title).

Definition pp := (|Blake2BModule|).(S.HASH.pp).

Definition pp_short := (|Blake2BModule|).(S.HASH.pp_short).

Definition op_eq := (|Blake2BModule|).(S.HASH.op_eq).

Definition op_ltgt := (|Blake2BModule|).(S.HASH.op_ltgt).

Definition op_lt := (|Blake2BModule|).(S.HASH.op_lt).

Definition op_lteq := (|Blake2BModule|).(S.HASH.op_lteq).

Definition op_gteq := (|Blake2BModule|).(S.HASH.op_gteq).

Definition op_gt := (|Blake2BModule|).(S.HASH.op_gt).

Definition compare := (|Blake2BModule|).(S.HASH.compare).

Definition equal := (|Blake2BModule|).(S.HASH.equal).

Definition max := (|Blake2BModule|).(S.HASH.max).

Definition min := (|Blake2BModule|).(S.HASH.min).

Definition hash_bytes := (|Blake2BModule|).(S.HASH.hash_bytes).

Definition hash_string := (|Blake2BModule|).(S.HASH.hash_string).

Definition zero := (|Blake2BModule|).(S.HASH.zero).

Definition size := (|Blake2BModule|).(S.HASH.size).

Definition to_bytes := (|Blake2BModule|).(S.HASH.to_bytes).

Definition of_bytes_opt := (|Blake2BModule|).(S.HASH.of_bytes_opt).

Definition of_bytes_exn := (|Blake2BModule|).(S.HASH.of_bytes_exn).

Definition to_b58check := (|Blake2BModule|).(S.HASH.to_b58check).

Definition to_short_b58check := (|Blake2BModule|).(S.HASH.to_short_b58check).

Definition of_b58check_exn := (|Blake2BModule|).(S.HASH.of_b58check_exn).

Definition of_b58check_opt := (|Blake2BModule|).(S.HASH.of_b58check_opt).

Definition b58check_encoding := (|Blake2BModule|).(S.HASH.b58check_encoding).

Definition encoding := (|Blake2BModule|).(S.HASH.encoding).

Definition rpc_arg := (|Blake2BModule|).(S.HASH.rpc_arg).

Definition to_path := (|Blake2BModule|).(S.HASH.to_path).

Definition of_path := (|Blake2BModule|).(S.HASH.of_path).

Definition of_path_exn := (|Blake2BModule|).(S.HASH.of_path_exn).

Definition prefix_path := (|Blake2BModule|).(S.HASH.prefix_path).

Definition path_length := (|Blake2BModule|).(S.HASH.path_length).

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="storage.ml">
  <div style="margin: 20px;">
    <h3>Storage</h3>
    <ul>
      <li>OCaml size: 999 lines</li>
      <li>Coq size: 2048 lines (+105% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#storage.ml"><code>storage.ml</code></a>&nbsp;<span class="label label-warning">8 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Storage_functors
open Storage_sigs

module Int = struct
  type t = int

  let encoding = Data_encoding.uint16
end

module Int32 = struct
  type t = Int32.t

  let encoding = Data_encoding.int32
end

module Z_value = struct
  type t = Z.t

  let encoding = Data_encoding.z
end

module Int_index = struct
  type t = int

  let path_length = 1

  let to_path c l = string_of_int c :: l

  let of_path = function
    | [] | _ :: _ :: _ -&gt;
        None
    | [c] -&gt;
        int_of_string_opt c

  type 'a ipath = 'a * t

  let args () =
    Storage_description.One
      {
        rpc_arg = RPC_arg.int;
        encoding = Data_encoding.int31;
        compare = Compare.Int.compare;
      }

  let infer_ipath (_ : 'a ipath) (x : 'a) : 'a = x
end

module Make_index (H : Storage_description.INDEX) :
  INDEX with type t = H.t and type 'a ipath = 'a * H.t = struct
  include H

  type 'a ipath = 'a * t

  let args () = Storage_description.One {rpc_arg; encoding; compare}

  let infer_ipath (_ : 'a ipath) (x : 'a) : 'a = x
end

module Block_priority =
  Make_single_data_storage (Registered) (Raw_context)
    (struct
      let name = [&quot;block_priority&quot;]
    end)
    (Int)

(** Contracts handling *)

module Contract = struct
  module Raw_context : Raw_context.T with type t = Raw_context.t =
    Make_subcontext (Registered) (Raw_context)
      (struct
        let name = [&quot;contracts&quot;]
      end)

  module Global_counter =
    Make_single_data_storage (Registered) (Raw_context)
      (struct
        let name = [&quot;global_counter&quot;]
      end)
      (Z_value)

  module Indexed_context =
    Make_indexed_subcontext
      (Make_subcontext (Registered) (Raw_context)
         (struct
           let name = [&quot;index&quot;]
         end))
         (Make_index (Contract_repr.Index))

  let fold = Indexed_context.fold_keys

  let list = Indexed_context.keys

  module Balance :
    Indexed_data_storage
      with type key = Contract_repr.t
       and type value = Tez_repr.t
       and type t := Raw_context.t =
    Indexed_context.Make_map
      (struct
        let name = [&quot;balance&quot;]
      end)
      (Tez_repr)

  module Frozen_balance_index =
    Make_indexed_subcontext
      (Make_subcontext (Registered) (Indexed_context.Raw_context)
         (struct
           let name = [&quot;frozen_balance&quot;]
         end))
         (Make_index (Cycle_repr.Index))

  module Frozen_deposits :
    Indexed_data_storage
      with type key = Cycle_repr.t
       and type value = Tez_repr.t
       and type t = Raw_context.t * Contract_repr.t =
    Frozen_balance_index.Make_map
      (struct
        let name = [&quot;deposits&quot;]
      end)
      (Tez_repr)

  module Frozen_fees :
    Indexed_data_storage
      with type key = Cycle_repr.t
       and type value = Tez_repr.t
       and type t = Raw_context.t * Contract_repr.t =
    Frozen_balance_index.Make_map
      (struct
        let name = [&quot;fees&quot;]
      end)
      (Tez_repr)

  module Frozen_rewards :
    Indexed_data_storage
      with type key = Cycle_repr.t
       and type value = Tez_repr.t
       and type t = Raw_context.t * Contract_repr.t =
    Frozen_balance_index.Make_map
      (struct
        let name = [&quot;rewards&quot;]
      end)
      (Tez_repr)

  module Manager :
    Indexed_data_storage
      with type key = Contract_repr.t
       and type value = Manager_repr.t
       and type t := Raw_context.t =
    Indexed_context.Make_map
      (struct
        let name = [&quot;manager&quot;]
      end)
      (Manager_repr)

  module Delegate :
    Indexed_data_storage
      with type key = Contract_repr.t
       and type value = Signature.Public_key_hash.t
       and type t := Raw_context.t =
    Indexed_context.Make_map
      (struct
        let name = [&quot;delegate&quot;]
      end)
      (Signature.Public_key_hash)

  module Inactive_delegate :
    Data_set_storage with type elt = Contract_repr.t and type t = Raw_context.t =
    Indexed_context.Make_set
      (Registered)
      (struct
        let name = [&quot;inactive_delegate&quot;]
      end)

  module Delegate_desactivation :
    Indexed_data_storage
      with type key = Contract_repr.t
       and type value = Cycle_repr.t
       and type t := Raw_context.t =
    Indexed_context.Make_map
      (struct
        let name = [&quot;delegate_desactivation&quot;]
      end)
      (Cycle_repr)

  module Delegated :
    Data_set_storage
      with type elt = Contract_repr.t
       and type t = Raw_context.t * Contract_repr.t =
    Make_data_set_storage
      (Make_subcontext (Registered) (Indexed_context.Raw_context)
         (struct
           let name = [&quot;delegated&quot;]
         end))
         (Make_index (Contract_repr.Index))

  module Counter :
    Indexed_data_storage
      with type key = Contract_repr.t
       and type value = Z.t
       and type t := Raw_context.t =
    Indexed_context.Make_map
      (struct
        let name = [&quot;counter&quot;]
      end)
      (Z_value)

  (* Consume gas for serilization and deserialization of expr in this
     module *)
  module Make_carbonated_map_expr (N : Storage_sigs.NAME) :
    Storage_sigs.Non_iterable_indexed_carbonated_data_storage
      with type key = Contract_repr.t
       and type value = Script_repr.lazy_expr
       and type t := Raw_context.t = struct
    module I =
      Indexed_context.Make_carbonated_map
        (N)
        (struct
          type t = Script_repr.lazy_expr

          let encoding = Script_repr.lazy_expr_encoding
        end)

    let tag_Non_iterable_indexed_carbonated_data_storage = ()

    type context = I.context

    type key = I.key

    type value = I.value

    let mem = I.mem

    let delete = I.delete

    let remove = I.remove

    let consume_deserialize_gas ctxt value =
      Lwt.return
      @@ ( Raw_context.check_enough_gas
             ctxt
             (Script_repr.minimal_deserialize_cost value)
         &gt;&gt;? fun () -&gt;
         Script_repr.force_decode value
         &gt;&gt;? fun (_value, value_cost) -&gt;
         Raw_context.consume_gas ctxt value_cost )

    let consume_serialize_gas ctxt value =
      Lwt.return
      @@ ( Script_repr.force_bytes value
         &gt;&gt;? fun (_value, value_cost) -&gt;
         Raw_context.consume_gas ctxt value_cost )

    let get ctxt contract =
      I.get ctxt contract
      &gt;&gt;=? fun (ctxt, value) -&gt;
      consume_deserialize_gas ctxt value &gt;&gt;|? fun ctxt -&gt; (ctxt, value)

    let get_option ctxt contract =
      I.get_option ctxt contract
      &gt;&gt;=? fun (ctxt, value_opt) -&gt;
      match value_opt with
      | None -&gt;
          return (ctxt, None)
      | Some value -&gt;
          consume_deserialize_gas ctxt value &gt;&gt;|? fun ctxt -&gt; (ctxt, value_opt)

    let set ctxt contract value =
      consume_serialize_gas ctxt value
      &gt;&gt;=? fun ctxt -&gt; I.set ctxt contract value

    let set_option ctxt contract value_opt =
      match value_opt with
      | None -&gt;
          I.set_option ctxt contract None
      | Some value -&gt;
          consume_serialize_gas ctxt value
          &gt;&gt;=? fun ctxt -&gt; I.set_option ctxt contract value_opt

    let init ctxt contract value =
      consume_serialize_gas ctxt value
      &gt;&gt;=? fun ctxt -&gt; I.init ctxt contract value

    let init_set ctxt contract value =
      consume_serialize_gas ctxt value
      &gt;&gt;=? fun ctxt -&gt; I.init_set ctxt contract value
  end

  module Code :
    Non_iterable_indexed_carbonated_data_storage
      with type key = Contract_repr.t
       and type value = Script_repr.lazy_expr
       and type t := Raw_context.t = Make_carbonated_map_expr (struct
    let name = [&quot;code&quot;]
  end)

  module Storage :
    Non_iterable_indexed_carbonated_data_storage
      with type key = Contract_repr.t
       and type value = Script_repr.lazy_expr
       and type t := Raw_context.t = Make_carbonated_map_expr (struct
    let name = [&quot;storage&quot;]
  end)

  module Paid_storage_space :
    Indexed_data_storage
      with type key = Contract_repr.t
       and type value = Z.t
       and type t := Raw_context.t =
    Indexed_context.Make_map
      (struct
        let name = [&quot;paid_bytes&quot;]
      end)
      (Z_value)

  module Used_storage_space :
    Indexed_data_storage
      with type key = Contract_repr.t
       and type value = Z.t
       and type t := Raw_context.t =
    Indexed_context.Make_map
      (struct
        let name = [&quot;used_bytes&quot;]
      end)
      (Z_value)

  module Roll_list =
    Indexed_context.Make_map
      (struct
        let name = [&quot;roll_list&quot;]
      end)
      (Roll_repr)

  module Change =
    Indexed_context.Make_map
      (struct
        let name = [&quot;change&quot;]
      end)
      (Tez_repr)
end

(** Big maps handling *)

module Big_map = struct
  module Raw_context =
    Make_subcontext (Registered) (Raw_context)
      (struct
        let name = [&quot;big_maps&quot;]
      end)

  module Next = struct
    module Single_data_storage =
      Make_single_data_storage (Registered) (Raw_context)
        (struct
          let name = [&quot;next&quot;]
        end)
        (Z_value)

    include Single_data_storage

    let incr ctxt =
      get ctxt
      &gt;&gt;=? fun i -&gt; set ctxt (Z.succ i) &gt;&gt;=? fun ctxt -&gt; return (ctxt, i)

    let init_with_default_value ctxt = init ctxt Z.zero
  end

  module Index = struct
    type t = Z.t

    let rpc_arg =
      let construct = Z.to_string in
      let destruct hash =
        match Z.of_string hash with
        | exception <abbr class="mark-warning" title="We do not support pattern-matching on exceptions">_</abbr> -&gt;
            Error &quot;Cannot parse big map id&quot;
        | id -&gt;
            Ok id
      in
      RPC_arg.make
        ~descr:&quot;A big map identifier&quot;
        ~name:&quot;big_map_id&quot;
        ~construct
        ~destruct
        ()

    let encoding =
      Data_encoding.def
        &quot;big_map_id&quot;
        ~title:&quot;Big map identifier&quot;
        ~description:&quot;A big map identifier&quot;
        Z_value.encoding

    let compare = Compare.Z.compare

    let path_length = 7

    let to_path c l =
      let raw_key = Data_encoding.Binary.to_bytes_exn encoding c in
      let (`Hex index_key) = MBytes.to_hex (Raw_hashes.blake2b raw_key) in
      String.sub index_key 0 2 :: String.sub index_key 2 2
      :: String.sub index_key 4 2 :: String.sub index_key 6 2
      :: String.sub index_key 8 2 :: String.sub index_key 10 2 :: Z.to_string c
      :: l

    let of_path = function
      | []
      | [_]
      | [_; _]
      | [_; _; _]
      | [_; _; _; _]
      | [_; _; _; _; _]
      | [_; _; _; _; _; _]
      | _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ :: _ -&gt;
          None
      | [index1; index2; index3; index4; index5; index6; key] -&gt;
          let c = Z.of_string key in
          let raw_key = Data_encoding.Binary.to_bytes_exn encoding c in
          let (`Hex index_key) = MBytes.to_hex (Raw_hashes.blake2b raw_key) in
          <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.String.(String.sub index_key 0 2 = index1))</abbr> ;
          <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.String.(String.sub index_key 2 2 = index2))</abbr> ;
          <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.String.(String.sub index_key 4 2 = index3))</abbr> ;
          <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.String.(String.sub index_key 6 2 = index4))</abbr> ;
          <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.String.(String.sub index_key 8 2 = index5))</abbr> ;
          <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">assert (Compare.String.(String.sub index_key 10 2 = index6))</abbr> ;
          Some c
  end

  module Indexed_context =
    Make_indexed_subcontext
      (Make_subcontext (Registered) (Raw_context)
         (struct
           let name = [&quot;index&quot;]
         end))
         (Make_index (Index))

  let rpc_arg = Index.rpc_arg

  let fold = Indexed_context.fold_keys

  let list = Indexed_context.keys

  let remove_rec ctxt n = Indexed_context.remove_rec ctxt n

  let copy ctxt ~from ~to_ = Indexed_context.copy ctxt ~from ~to_

  type key = Raw_context.t * Z.t

  module Total_bytes =
    Indexed_context.Make_map
      (struct
        let name = [&quot;total_bytes&quot;]
      end)
      (Z_value)

  module Key_type =
    Indexed_context.Make_map
      (struct
        let name = [&quot;key_type&quot;]
      end)
      (struct
        type t = Script_repr.expr

        let encoding = Script_repr.expr_encoding
      end)

  module Value_type =
    Indexed_context.Make_map
      (struct
        let name = [&quot;value_type&quot;]
      end)
      (struct
        type t = Script_repr.expr

        let encoding = Script_repr.expr_encoding
      end)

  module Contents = struct
    module I =
      Storage_functors.Make_indexed_carbonated_data_storage
        (Make_subcontext (Registered) (Indexed_context.Raw_context)
           (struct
             let name = [&quot;contents&quot;]
           end))
           (Make_index (Script_expr_hash))
           (struct
             type t = Script_repr.expr

             let encoding = Script_repr.expr_encoding
           end)

    let tag_Non_iterable_indexed_carbonated_data_storage = ()

    type context = I.context

    type key = I.key

    type value = I.value

    let mem = I.mem

    let delete = I.delete

    let remove = I.remove

    let set = I.set

    let set_option = I.set_option

    let init = I.init

    let init_set = I.init_set

    let consume_deserialize_gas ctxt value =
      Lwt.return
      @@ Raw_context.consume_gas ctxt (Script_repr.deserialized_cost value)

    let get ctxt contract =
      I.get ctxt contract
      &gt;&gt;=? fun (ctxt, value) -&gt;
      consume_deserialize_gas ctxt value &gt;&gt;|? fun ctxt -&gt; (ctxt, value)

    let get_option ctxt contract =
      I.get_option ctxt contract
      &gt;&gt;=? fun (ctxt, value_opt) -&gt;
      match value_opt with
      | None -&gt;
          return (ctxt, None)
      | Some value -&gt;
          consume_deserialize_gas ctxt value &gt;&gt;|? fun ctxt -&gt; (ctxt, value_opt)
  end
end

module Delegates =
  Make_data_set_storage
    (Make_subcontext (Registered) (Raw_context)
       (struct
         let name = [&quot;delegates&quot;]
       end))
       (Make_index (Signature.Public_key_hash))

module Active_delegates_with_rolls =
  Make_data_set_storage
    (Make_subcontext (Registered) (Raw_context)
       (struct
         let name = [&quot;active_delegates_with_rolls&quot;]
       end))
       (Make_index (Signature.Public_key_hash))

module Delegates_with_frozen_balance_index =
  Make_indexed_subcontext
    (Make_subcontext (Registered) (Raw_context)
       (struct
         let name = [&quot;delegates_with_frozen_balance&quot;]
       end))
       (Make_index (Cycle_repr.Index))

module Delegates_with_frozen_balance =
  Make_data_set_storage
    (Delegates_with_frozen_balance_index.Raw_context)
    (Make_index (Signature.Public_key_hash))

(** Rolls *)

type unrevealed_nonce = {
  nonce_hash : Nonce_hash.t;
  delegate : Signature.Public_key_hash.t;
  rewards : Tez_repr.t;
  fees : Tez_repr.t;
}

type nonce_status =
  | Unrevealed of unrevealed_nonce
  | Revealed of Seed_repr.nonce

module Cycle = struct
  module Indexed_context =
    Make_indexed_subcontext
      (Make_subcontext (Registered) (Raw_context)
         (struct
           let name = [&quot;cycle&quot;]
         end))
         (Make_index (Cycle_repr.Index))

  module Last_roll =
    Make_indexed_data_storage
      (Make_subcontext (Registered) (Indexed_context.Raw_context)
         (struct
           let name = [&quot;last_roll&quot;]
         end))
         (Int_index)
      (Roll_repr)

  module Roll_snapshot =
    Indexed_context.Make_map
      (struct
        let name = [&quot;roll_snapshot&quot;]
      end)
      (Int)

  let nonce_status_encoding =
    let open Data_encoding in
    union
      [ case
          (Tag 0)
          ~title:&quot;Unrevealed&quot;
          (tup4
             Nonce_hash.encoding
             Signature.Public_key_hash.encoding
             Tez_repr.encoding
             Tez_repr.encoding)
          (function
            | Unrevealed {nonce_hash; delegate; rewards; fees} -&gt;
                Some (nonce_hash, delegate, rewards, fees)
            | _ -&gt;
                None)
          (fun (nonce_hash, delegate, rewards, fees) -&gt;
            Unrevealed {nonce_hash; delegate; rewards; fees});
        case
          (Tag 1)
          ~title:&quot;Revealed&quot;
          Seed_repr.nonce_encoding
          (function Revealed nonce -&gt; Some nonce | _ -&gt; None)
          (fun nonce -&gt; Revealed nonce) ]

  module Nonce =
    Make_indexed_data_storage
      (Make_subcontext (Registered) (Indexed_context.Raw_context)
         (struct
           let name = [&quot;nonces&quot;]
         end))
         (Make_index (Raw_level_repr.Index))
         (struct
           type t = nonce_status

           let encoding = nonce_status_encoding
         end)

  module Seed =
    Indexed_context.Make_map
      (struct
        let name = [&quot;random_seed&quot;]
      end)
      (struct
        type t = Seed_repr.seed

        let encoding = Seed_repr.seed_encoding
      end)
end

module Roll = struct
  module Raw_context =
    Make_subcontext (Registered) (Raw_context)
      (struct
        let name = [&quot;rolls&quot;]
      end)

  module Indexed_context =
    Make_indexed_subcontext
      (Make_subcontext (Registered) (Raw_context)
         (struct
           let name = [&quot;index&quot;]
         end))
         (Make_index (Roll_repr.Index))

  module Next :
    Single_data_storage
      with type value = Roll_repr.t
       and type t := Raw_context.t =
    Make_single_data_storage (Registered) (Raw_context)
      (struct
        let name = [&quot;next&quot;]
      end)
      (Roll_repr)

  module Limbo :
    Single_data_storage
      with type value = Roll_repr.t
       and type t := Raw_context.t =
    Make_single_data_storage (Registered) (Raw_context)
      (struct
        let name = [&quot;limbo&quot;]
      end)
      (Roll_repr)

  module Delegate_roll_list :
    Indexed_data_storage
      with type key = Signature.Public_key_hash.t
       and type value = Roll_repr.t
       and type t := Raw_context.t =
    Wrap_indexed_data_storage
      (Contract.Roll_list)
      (struct
        type t = Signature.Public_key_hash.t

        let wrap = Contract_repr.implicit_contract

        let unwrap = Contract_repr.is_implicit
      end)

  module Successor :
    Indexed_data_storage
      with type key = Roll_repr.t
       and type value = Roll_repr.t
       and type t := Raw_context.t =
    Indexed_context.Make_map
      (struct
        let name = [&quot;successor&quot;]
      end)
      (Roll_repr)

  module Delegate_change :
    Indexed_data_storage
      with type key = Signature.Public_key_hash.t
       and type value = Tez_repr.t
       and type t := Raw_context.t =
    Wrap_indexed_data_storage
      (Contract.Change)
      (struct
        type t = Signature.Public_key_hash.t

        let wrap = Contract_repr.implicit_contract

        let unwrap = Contract_repr.is_implicit
      end)

  module Snapshoted_owner_index = struct
    type t = Cycle_repr.t * int

    let path_length = Cycle_repr.Index.path_length + 1

    let to_path (c, n) s = Cycle_repr.Index.to_path c (string_of_int n :: s)

    let of_path l =
      match Misc.take Cycle_repr.Index.path_length l with
      | None | Some (_, ([] | _ :: _ :: _)) -&gt;
          None
      | Some (l1, [l2]) -&gt; (
        match (Cycle_repr.Index.of_path l1, int_of_string_opt l2) with
        | (None, _) | (_, None) -&gt;
            None
        | (Some c, Some i) -&gt;
            Some (c, i) )

    type 'a ipath = ('a * Cycle_repr.t) * int

    let left_args =
      Storage_description.One
        {
          rpc_arg = Cycle_repr.rpc_arg;
          encoding = Cycle_repr.encoding;
          compare = Cycle_repr.compare;
        }

    let right_args =
      Storage_description.One
        {
          rpc_arg = RPC_arg.int;
          encoding = Data_encoding.int31;
          compare = Compare.Int.compare;
        }

    let args () = Storage_description.(Pair (left_args, right_args))

    let infer_ipath (_ : 'a ipath) (x : 'a) : 'a = x
  end

  module Owner :
    Indexed_data_snapshotable_storage
      with type key = Roll_repr.t
       and type snapshot = Cycle_repr.t * int
       and type value = Signature.Public_key.t
       and type t := Raw_context.t =
    Make_indexed_data_snapshotable_storage
      (Make_subcontext (Registered) (Raw_context)
         (struct
           let name = [&quot;owner&quot;]
         end))
         (Snapshoted_owner_index)
      (Make_index (Roll_repr.Index))
      (Signature.Public_key)

  module Snapshot_for_cycle :
    Indexed_data_storage
      with type key = Cycle_repr.t
       and type value = int
       and type t := Raw_context.t =
    Cycle.Roll_snapshot

  module Last_for_snapshot :
    Indexed_data_storage
      with type key = int
       and type value = Roll_repr.t
       and type t = Raw_context.t * Cycle_repr.t =
    Cycle.Last_roll

  let clear = Indexed_context.clear
end

(** Votes *)

module Vote = struct
  module Raw_context =
    Make_subcontext (Registered) (Raw_context)
      (struct
        let name = [&quot;votes&quot;]
      end)

  module Current_period_kind =
    Make_single_data_storage (Registered) (Raw_context)
      (struct
        let name = [&quot;current_period_kind&quot;]
      end)
      (struct
        type t = Voting_period_repr.kind

        let encoding = Voting_period_repr.kind_encoding
      end)

  module Participation_ema =
    Make_single_data_storage (Registered) (Raw_context)
      (struct
        let name = [&quot;participation_ema&quot;]
      end)
      (Int32)

  module Current_proposal =
    Make_single_data_storage (Registered) (Raw_context)
      (struct
        let name = [&quot;current_proposal&quot;]
      end)
      (Protocol_hash)

  module Listings_size =
    Make_single_data_storage (Registered) (Raw_context)
      (struct
        let name = [&quot;listings_size&quot;]
      end)
      (Int32)

  module Listings =
    Make_indexed_data_storage
      (Make_subcontext (Registered) (Raw_context)
         (struct
           let name = [&quot;listings&quot;]
         end))
         (Make_index (Signature.Public_key_hash))
         (Int32)

  module Proposals =
    Make_data_set_storage
      (Make_subcontext (Registered) (Raw_context)
         (struct
           let name = [&quot;proposals&quot;]
         end))
         (Pair
            (Make_index
               (Protocol_hash))
               (Make_index (Signature.Public_key_hash)))

  module Proposals_count =
    Make_indexed_data_storage
      (Make_subcontext (Registered) (Raw_context)
         (struct
           let name = [&quot;proposals_count&quot;]
         end))
         (Make_index (Signature.Public_key_hash))
         (Int)

  module Ballots =
    Make_indexed_data_storage
      (Make_subcontext (Registered) (Raw_context)
         (struct
           let name = [&quot;ballots&quot;]
         end))
         (Make_index (Signature.Public_key_hash))
         (struct
           type t = Vote_repr.ballot

           let encoding = Vote_repr.ballot_encoding
         end)
end

(** Seed *)

module type For_cycle_sig = sig
  val init :
    Raw_context.t -&gt;
    Cycle_repr.t -&gt;
    Seed_repr.seed -&gt;
    Raw_context.t tzresult Lwt.t

  val get : Raw_context.t -&gt; Cycle_repr.t -&gt; Seed_repr.seed tzresult Lwt.t

  val delete : Raw_context.t -&gt; Cycle_repr.t -&gt; Raw_context.t tzresult Lwt.t
end

module Seed = struct
  module Nonce :
    Storage_sigs.Non_iterable_indexed_data_storage
      with type key := Level_repr.t
       and type value := nonce_status
       and type t := Raw_context.t = struct
    <abbr class="mark-warning" title="Open not handled in module with a named signature">open Level_repr</abbr>

    let tag_Non_iterable_indexed_data_storage = ()

    type context = Raw_context.t

    let mem ctxt l = Cycle.Nonce.mem (ctxt, l.cycle) l.level

    let get ctxt l = Cycle.Nonce.get (ctxt, l.cycle) l.level

    let get_option ctxt l = Cycle.Nonce.get_option (ctxt, l.cycle) l.level

    let set ctxt l v = Cycle.Nonce.set (ctxt, l.cycle) l.level v

    let init ctxt l v = Cycle.Nonce.init (ctxt, l.cycle) l.level v

    let init_set ctxt l v = Cycle.Nonce.init_set (ctxt, l.cycle) l.level v

    let set_option ctxt l v = Cycle.Nonce.set_option (ctxt, l.cycle) l.level v

    let delete ctxt l = Cycle.Nonce.delete (ctxt, l.cycle) l.level

    let remove ctxt l = Cycle.Nonce.remove (ctxt, l.cycle) l.level
  end

  module For_cycle : For_cycle_sig = Cycle.Seed
end

(** Commitments *)

module Commitments =
  Make_indexed_data_storage
    (Make_subcontext (Registered) (Raw_context)
       (struct
         let name = [&quot;commitments&quot;]
       end))
       (Make_index (Blinded_public_key_hash.Index))
       (Tez_repr)

(** Ramp up security deposits... *)

module Ramp_up = struct
  module Rewards =
    Make_indexed_data_storage
      (Make_subcontext (Registered) (Raw_context)
         (struct
           let name = [&quot;ramp_up&quot;; &quot;rewards&quot;]
         end))
         (Make_index (Cycle_repr.Index))
         (struct
           type t = Tez_repr.t * Tez_repr.t

           let encoding =
             Data_encoding.tup2 Tez_repr.encoding Tez_repr.encoding
         end)

  module Security_deposits =
    Make_indexed_data_storage
      (Make_subcontext (Registered) (Raw_context)
         (struct
           let name = [&quot;ramp_up&quot;; &quot;deposits&quot;]
         end))
         (Make_index (Cycle_repr.Index))
         (struct
           type t = Tez_repr.t * Tez_repr.t

           let encoding =
             Data_encoding.tup2 Tez_repr.encoding Tez_repr.encoding
         end)
end
</pre>
  </div>
  <div class="col-md-6">
    <a href="#storage.ml"><code>Storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Blinded_public_key_hash.
Require Tezos.Contract_repr.
Require Tezos.Cycle_repr.
Require Tezos.Gas_limit_repr.
Require Tezos.Level_repr.
Require Tezos.Manager_repr.
Require Tezos.Misc.
Require Tezos.Nonce_hash.
Require Tezos.Raw_context.
Require Tezos.Raw_level_repr.
Require Tezos.Roll_repr.
Require Tezos.Script_expr_hash.
Require Tezos.Script_repr.
Require Tezos.Seed_repr.
Require Tezos.Storage_description.
Require Tezos.Storage_functors.
Require Tezos.Storage_sigs.
Require Tezos.Tez_repr.
Require Tezos.Vote_repr.
Require Tezos.Voting_period_repr.

Import Storage_functors.

Import Storage_sigs.

Definition Int :=
  let t : Set := int in
  let encoding := Data_encoding.uint16 in
  existT (A := unit) (fun _ =&gt; _) tt
    {|
      Storage_sigs.VALUE.encoding := encoding
    |}.

Definition Int32 :=
  let t : Set := Int32.t in
  let encoding := Data_encoding.__int32_value in
  existT (A := unit) (fun _ =&gt; _) tt
    {|
      Storage_sigs.VALUE.encoding := encoding
    |}.

Definition Z_value :=
  let t : Set := Z.t in
  let encoding := Data_encoding.z in
  existT (A := unit) (fun _ =&gt; _) tt
    {|
      Storage_sigs.VALUE.encoding := encoding
    |}.

Definition Int_index :=
  let t : Set := int in
  let path_length := 1 in
  let to_path (c : int) (l : list string) : list string :=
    cons (Pervasives.string_of_int c) l in
  let of_path (function_parameter : list string) : option int :=
    match function_parameter with
    | ([] | cons _ (cons _ _)) =&gt; None
    | cons c [] =&gt; Pervasives.int_of_string_opt c
    end in
  let ipath (a : Set) : Set := a * t in
  let args (function_parameter : unit) : Storage_description.args :=
    let '_ := function_parameter in
    Storage_description.One
      {| Storage_description.args.One.rpc_arg := RPC_arg.__int_value;
        Storage_description.args.One.encoding := Data_encoding.int31;
        Storage_description.args.One.compare :=
          (|Compare.Int|).(Compare.S.compare) |} in
  let infer_ipath {a : Set} (function_parameter : ipath a) : a -&gt; a :=
    let '_ := function_parameter in
    fun x =&gt; x in
  existT (A := unit) (fun _ =&gt; _) tt
    {|
      Storage_functors.INDEX.path_length := path_length;
      Storage_functors.INDEX.to_path := to_path;
      Storage_functors.INDEX.of_path := of_path;
      Storage_functors.INDEX.args := args;
      Storage_functors.INDEX.infer_ipath {_} := infer_ipath
    |}.

Definition Make_index :=
  fun (H : {t : Set &amp; Storage_description.INDEX.signature (t := t)}) =&gt;
    ((let t := (|H|).(Storage_description.INDEX.t) in
    let path_length := (|H|).(Storage_description.INDEX.path_length) in
    let to_path := (|H|).(Storage_description.INDEX.to_path) in
    let of_path := (|H|).(Storage_description.INDEX.of_path) in
    let rpc_arg := (|H|).(Storage_description.INDEX.rpc_arg) in
    let encoding := (|H|).(Storage_description.INDEX.encoding) in
    let compare := (|H|).(Storage_description.INDEX.compare) in
    let ipath (a : Set) : Set := a * t in
    let args (function_parameter : unit) : Storage_description.args :=
      let '_ := function_parameter in
      Storage_description.One
        {| Storage_description.args.One.rpc_arg := rpc_arg;
          Storage_description.args.One.encoding := encoding;
          Storage_description.args.One.compare := compare |} in
    let infer_ipath {a : Set} (function_parameter : ipath a) : a -&gt; a :=
      let '_ := function_parameter in
      fun x =&gt; x in
    existT (A := unit) (fun _ =&gt; _) tt
      {|
        Storage_functors.INDEX.path_length := path_length;
        Storage_functors.INDEX.to_path := to_path;
        Storage_functors.INDEX.of_path := of_path;
        Storage_functors.INDEX.args := args;
        Storage_functors.INDEX.infer_ipath {_} := infer_ipath
      |})
      :
        {_ : unit &amp;
          INDEX.signature (t := (|H|).(Storage_description.INDEX.t))
            (ipath :=
              (fun (a : Set) =&gt; a * (|H|).(Storage_description.INDEX.t)))}).

Definition Block_priority :=
  (((Storage_functors.Make_single_data_storage
    (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
    (existT (A := Set) _ _
      {|
        Raw_context.T.mem := Raw_context.mem;
        Raw_context.T.dir_mem := Raw_context.dir_mem;
        Raw_context.T.get := Raw_context.get;
        Raw_context.T.get_option := Raw_context.get_option;
        Raw_context.T.init := Raw_context.init;
        Raw_context.T.set := Raw_context.set;
        Raw_context.T.init_set := Raw_context.init_set;
        Raw_context.T.set_option := Raw_context.set_option;
        Raw_context.T.delete := Raw_context.delete;
        Raw_context.T.remove := Raw_context.remove;
        Raw_context.T.remove_rec := Raw_context.remove_rec;
        Raw_context.T.copy := Raw_context.copy;
        Raw_context.T.fold {_} := Raw_context.fold;
        Raw_context.T.keys := Raw_context.keys;
        Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
        Raw_context.T.project := Raw_context.project;
        Raw_context.T.absolute_key := Raw_context.absolute_key;
        Raw_context.T.consume_gas := Raw_context.consume_gas;
        Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
        Raw_context.T.description := Raw_context.description
      |}))
    (let name := [ &quot;block_priority&quot; ] in
    existT (A := unit) (fun _ =&gt; _) tt
      {|
        Storage_sigs.NAME.name := name
      |})) (existT (A := Set) _ _ (|Int|)).

Module Contract.
  Definition Raw_context :
    {_ : unit &amp; Raw_context.T.signature (t := Raw_context.t)} :=
    ((Storage_functors.Make_subcontext
      (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
      (existT (A := Set) _ _
        {|
          Raw_context.T.mem := Raw_context.mem;
          Raw_context.T.dir_mem := Raw_context.dir_mem;
          Raw_context.T.get := Raw_context.get;
          Raw_context.T.get_option := Raw_context.get_option;
          Raw_context.T.init := Raw_context.init;
          Raw_context.T.set := Raw_context.set;
          Raw_context.T.init_set := Raw_context.init_set;
          Raw_context.T.set_option := Raw_context.set_option;
          Raw_context.T.delete := Raw_context.delete;
          Raw_context.T.remove := Raw_context.remove;
          Raw_context.T.remove_rec := Raw_context.remove_rec;
          Raw_context.T.copy := Raw_context.copy;
          Raw_context.T.fold {_} := Raw_context.fold;
          Raw_context.T.keys := Raw_context.keys;
          Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
          Raw_context.T.project := Raw_context.project;
          Raw_context.T.absolute_key := Raw_context.absolute_key;
          Raw_context.T.consume_gas := Raw_context.consume_gas;
          Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
          Raw_context.T.description := Raw_context.description
        |}))
      (let name := [ &quot;contracts&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |}).
  
  Definition Global_counter :=
    (((Storage_functors.Make_single_data_storage
      (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
      (existT (A := Set) _ _ (|Raw_context|)))
      (let name := [ &quot;global_counter&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |})) (existT (A := Set) _ _ (|Z_value|)).
  
  Definition Indexed_context :=
    (Storage_functors.Make_indexed_subcontext
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _ (|Raw_context|)))
          (let name := [ &quot;index&quot; ] in
          existT (A := unit) (fun _ =&gt; _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result :=
        Make_index (existT (A := Set) _ _ (|Contract_repr.Index|)) in
      existT (A := [Set ** Set -&gt; Set]) _ [_, _] (|functor_result|)).
  
  Definition fold {A : Set}
    : (|Indexed_context|).(Storage_sigs.Indexed_raw_context.context) -&gt; A -&gt;
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.key) -&gt; A -&gt; Lwt.t A)
    -&gt; Lwt.t A :=
    (|Indexed_context|).(Storage_sigs.Indexed_raw_context.fold_keys).
  
  Definition __list_value
    : (|Indexed_context|).(Storage_sigs.Indexed_raw_context.context) -&gt;
    Lwt.t (list (|Indexed_context|).(Storage_sigs.Indexed_raw_context.key)) :=
    (|Indexed_context|).(Storage_sigs.Indexed_raw_context.keys).
  
  Definition Balance :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := (|Raw_context|).(Raw_context.T.t))
        (key := Contract_repr.t) (value := Tez_repr.t)} :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ &quot;balance&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Tez_repr.encoding
        |}).
  
  Definition Frozen_balance_index :=
    (Storage_functors.Make_indexed_subcontext
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _
            (|Indexed_context|).(Storage_sigs.Indexed_raw_context.Raw_context)))
          (let name := [ &quot;frozen_balance&quot; ] in
          existT (A := unit) (fun _ =&gt; _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result :=
        Make_index (existT (A := Set) _ _ (|Cycle_repr.Index|)) in
      existT (A := [Set ** Set -&gt; Set]) _ [_, _] (|functor_result|)).
  
  Definition Frozen_deposits :
    {_ : unit &amp;
      Indexed_data_storage.signature
        (t := ((|Raw_context|).(Raw_context.T.t) * Contract_repr.t))
        (key := Cycle_repr.t) (value := Tez_repr.t)} :=
    ((|Frozen_balance_index|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ &quot;deposits&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Tez_repr.encoding
        |}).
  
  Definition Frozen_fees :
    {_ : unit &amp;
      Indexed_data_storage.signature
        (t := ((|Raw_context|).(Raw_context.T.t) * Contract_repr.t))
        (key := Cycle_repr.t) (value := Tez_repr.t)} :=
    ((|Frozen_balance_index|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ &quot;fees&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Tez_repr.encoding
        |}).
  
  Definition Frozen_rewards :
    {_ : unit &amp;
      Indexed_data_storage.signature
        (t := ((|Raw_context|).(Raw_context.T.t) * Contract_repr.t))
        (key := Cycle_repr.t) (value := Tez_repr.t)} :=
    ((|Frozen_balance_index|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ &quot;rewards&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Tez_repr.encoding
        |}).
  
  Definition Manager :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := (|Raw_context|).(Raw_context.T.t))
        (key := Contract_repr.t) (value := Manager_repr.t)} :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ &quot;manager&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Manager_repr.encoding
        |}).
  
  Definition Delegate :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := (|Raw_context|).(Raw_context.T.t))
        (key := Contract_repr.t)
        (value := (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))} :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ &quot;delegate&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding :=
            (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding)
        |}).
  
  Definition Inactive_delegate :
    {_ : unit &amp;
      Data_set_storage.signature (t := (|Raw_context|).(Raw_context.T.t))
        (elt := Contract_repr.t)} :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_set)
      (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
      (let name := [ &quot;inactive_delegate&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |}).
  
  Definition Delegate_desactivation :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := (|Raw_context|).(Raw_context.T.t))
        (key := Contract_repr.t) (value := Cycle_repr.t)} :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ &quot;delegate_desactivation&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Cycle_repr.encoding
        |}).
  
  Definition Delegated :
    {_ : unit &amp;
      Data_set_storage.signature
        (t := ((|Raw_context|).(Raw_context.T.t) * Contract_repr.t))
        (elt := Contract_repr.t)} :=
    (Storage_functors.Make_data_set_storage
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _
            (|Indexed_context|).(Storage_sigs.Indexed_raw_context.Raw_context)))
          (let name := [ &quot;delegated&quot; ] in
          existT (A := unit) (fun _ =&gt; _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result :=
        Make_index (existT (A := Set) _ _ (|Contract_repr.Index|)) in
      existT (A := [Set ** Set -&gt; Set]) _ [_, _] (|functor_result|)).
  
  Definition Counter :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := (|Raw_context|).(Raw_context.T.t))
        (key := Contract_repr.t) (value := Z.t)} :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ &quot;counter&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |})) (existT (A := Set) _ _ (|Z_value|)).
  
  Definition Make_carbonated_map_expr :=
    fun (N : {_ : unit &amp; Storage_sigs.NAME.signature}) =&gt;
      ((let I :=
        ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_carbonated_map)
          (existT (A := unit) (fun _ =&gt; _) tt (|N|)))
          (let t : Set := Script_repr.lazy_expr in
          let encoding := Script_repr.lazy_expr_encoding in
          existT (A := Set) _ _
            {|
              Storage_sigs.VALUE.encoding := encoding
            |}) in
      let tag_Non_iterable_indexed_carbonated_data_storage := tt in
      let context : Set :=
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context)
        in
      let key : Set :=
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key) in
      let value : Set :=
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value)
        in
      let mem :=
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.mem) in
      let delete :=
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.delete)
        in
      let remove :=
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.remove)
        in
      let consume_deserialize_gas
        (ctxt : (|Raw_context|).(Raw_context.T.context))
        (value : Script_repr.lazy_expr)
        : Lwt.t (Error_monad.tzresult (|Raw_context|).(Raw_context.T.context)) :=
        Lwt.__return
          (let? '_ :=
            (|Raw_context|).(Raw_context.T.check_enough_gas) ctxt
              (Script_repr.minimal_deserialize_cost value) in
          let? '(_value, value_cost) := Script_repr.force_decode value in
          (|Raw_context|).(Raw_context.T.consume_gas) ctxt value_cost) in
      let consume_serialize_gas
        (ctxt : (|Raw_context|).(Raw_context.T.context))
        (value : Script_repr.lazy_expr)
        : Lwt.t (Error_monad.tzresult (|Raw_context|).(Raw_context.T.context)) :=
        Lwt.__return
          (let? '(_value, value_cost) := Script_repr.force_bytes value in
          (|Raw_context|).(Raw_context.T.consume_gas) ctxt value_cost) in
      let get
        (ctxt :
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context))
        (contract :
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
        : Lwt.t
          (Error_monad.tzresult
            ((|Raw_context|).(Raw_context.T.context) *
              (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value))) :=
        let=? '(ctxt, value) :=
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get)
            ctxt contract in
        Error_monad.op_gtgtpipequestion (consume_deserialize_gas ctxt value)
          (fun ctxt =&gt; (ctxt, value)) in
      let get_option
        (ctxt :
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context))
        (contract :
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
        : Lwt.t
          (Error_monad.tzresult
            (Raw_context.t *
              option
                (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value))) :=
        let=? '(ctxt, value_opt) :=
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get_option)
            ctxt contract in
        match value_opt with
        | None =&gt; Error_monad.__return (ctxt, None)
        | Some value =&gt;
          Error_monad.op_gtgtpipequestion (consume_deserialize_gas ctxt value)
            (fun ctxt =&gt; (ctxt, value_opt))
        end in
      let set
        (ctxt : (|Raw_context|).(Raw_context.T.context))
        (contract :
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
        (value : Script_repr.lazy_expr)
        : Lwt.t (Error_monad.tzresult (Raw_context.t * int)) :=
        let=? ctxt := consume_serialize_gas ctxt value in
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set)
          ctxt contract value in
      let set_option
        (ctxt :
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context))
        (contract :
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
        (value_opt :
          option
            (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value))
        : Lwt.t (Error_monad.tzresult (Raw_context.t * int * bool)) :=
        match value_opt with
        | None =&gt;
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set_option)
            ctxt contract None
        | Some value =&gt;
          let=? ctxt := consume_serialize_gas ctxt value in
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set_option)
            ctxt contract value_opt
        end in
      let init
        (ctxt : (|Raw_context|).(Raw_context.T.context))
        (contract :
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
        (value : Script_repr.lazy_expr)
        : Lwt.t (Error_monad.tzresult (Raw_context.t * int)) :=
        let=? ctxt := consume_serialize_gas ctxt value in
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.init)
          ctxt contract value in
      let init_set
        (ctxt : (|Raw_context|).(Raw_context.T.context))
        (contract :
          (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
        (value : Script_repr.lazy_expr)
        : Lwt.t (Error_monad.tzresult (Raw_context.t * int * bool)) :=
        let=? ctxt := consume_serialize_gas ctxt value in
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.init_set)
          ctxt contract value in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.tag_Non_iterable_indexed_carbonated_data_storage :=
            tag_Non_iterable_indexed_carbonated_data_storage;
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.mem := mem;
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get := get;
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get_option :=
            get_option;
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set := set;
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.init := init;
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.init_set :=
            init_set;
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set_option :=
            set_option;
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.delete :=
            delete;
          Storage_sigs.Non_iterable_indexed_carbonated_data_storage.remove :=
            remove
        |})
        :
          {_ : unit &amp;
            Storage_sigs.Non_iterable_indexed_carbonated_data_storage.signature
              (t := (|Raw_context|).(Raw_context.T.t)) (key := Contract_repr.t)
              (value := Script_repr.lazy_expr)}).
  
  Definition Code :
    {_ : unit &amp;
      Non_iterable_indexed_carbonated_data_storage.signature
        (t := (|Raw_context|).(Raw_context.T.t)) (key := Contract_repr.t)
        (value := Script_repr.lazy_expr)} :=
    Make_carbonated_map_expr
      (let name := [ &quot;code&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |}).
  
  Definition Storage :
    {_ : unit &amp;
      Non_iterable_indexed_carbonated_data_storage.signature
        (t := (|Raw_context|).(Raw_context.T.t)) (key := Contract_repr.t)
        (value := Script_repr.lazy_expr)} :=
    Make_carbonated_map_expr
      (let name := [ &quot;storage&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |}).
  
  Definition Paid_storage_space :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := (|Raw_context|).(Raw_context.T.t))
        (key := Contract_repr.t) (value := Z.t)} :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ &quot;paid_bytes&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |})) (existT (A := Set) _ _ (|Z_value|)).
  
  Definition Used_storage_space :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := (|Raw_context|).(Raw_context.T.t))
        (key := Contract_repr.t) (value := Z.t)} :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ &quot;used_bytes&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |})) (existT (A := Set) _ _ (|Z_value|)).
  
  Definition Roll_list :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ &quot;roll_list&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Roll_repr.encoding
        |}).
  
  Definition Change :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ &quot;change&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Tez_repr.encoding
        |}).
End Contract.

Module Big_map.
  Definition Raw_context :=
    ((Storage_functors.Make_subcontext
      (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
      (existT (A := Set) _ _
        {|
          Raw_context.T.mem := Raw_context.mem;
          Raw_context.T.dir_mem := Raw_context.dir_mem;
          Raw_context.T.get := Raw_context.get;
          Raw_context.T.get_option := Raw_context.get_option;
          Raw_context.T.init := Raw_context.init;
          Raw_context.T.set := Raw_context.set;
          Raw_context.T.init_set := Raw_context.init_set;
          Raw_context.T.set_option := Raw_context.set_option;
          Raw_context.T.delete := Raw_context.delete;
          Raw_context.T.remove := Raw_context.remove;
          Raw_context.T.remove_rec := Raw_context.remove_rec;
          Raw_context.T.copy := Raw_context.copy;
          Raw_context.T.fold {_} := Raw_context.fold;
          Raw_context.T.keys := Raw_context.keys;
          Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
          Raw_context.T.project := Raw_context.project;
          Raw_context.T.absolute_key := Raw_context.absolute_key;
          Raw_context.T.consume_gas := Raw_context.consume_gas;
          Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
          Raw_context.T.description := Raw_context.description
        |}))
      (let name := [ &quot;big_maps&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |}).
  
  Module Next.
    Definition Single_data_storage :=
      (((Storage_functors.Make_single_data_storage
        (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
        (existT (A := Set) _ _ (|Raw_context|)))
        (let name := [ &quot;next&quot; ] in
        existT (A := unit) (fun _ =&gt; _) tt
          {|
            Storage_sigs.NAME.name := name
          |})) (existT (A := Set) _ _ (|Z_value|)).
    
    Definition tag_Single_data_storage :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.tag_Single_data_storage).
    
    Definition t :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.t).
    
    Definition context :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.context).
    
    Definition value :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.value).
    
    Definition mem :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.mem).
    
    Definition get :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.get).
    
    Definition get_option :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.get_option).
    
    Definition init :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.init).
    
    Definition set :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.set).
    
    Definition init_set :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.init_set).
    
    Definition set_option :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.set_option).
    
    Definition delete :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.delete).
    
    Definition remove :=
      (|Single_data_storage|).(Storage_sigs.Single_data_storage.remove).
    
    Definition incr (ctxt : context)
      : Lwt.t (Error_monad.tzresult (Raw_context.t * value)) :=
      let=? i := get ctxt in
      let=? ctxt := set ctxt (Z.succ i) in
      Error_monad.__return (ctxt, i).
    
    Definition init_with_default_value (ctxt : context)
      : Lwt.t (Error_monad.tzresult Raw_context.t) := init ctxt Z.zero.
  End Next.
  
  Definition Index :=
    let t : Set := Z.t in
    let rpc_arg :=
      let construct := Z.to_string in
      let destruct (__hash_value : string) : Pervasives.result Z.t string :=
        let 'id := Z.of_string __hash_value in
        Pervasives.Ok id in
      RPC_arg.make (Some &quot;A big map identifier&quot;) &quot;big_map_id&quot; destruct construct
        tt in
    let encoding :=
      Data_encoding.def &quot;big_map_id&quot; (Some &quot;Big map identifier&quot;)
        (Some &quot;A big map identifier&quot;) (|Z_value|).(Storage_sigs.VALUE.encoding)
      in
    let compare := (|Compare.Z|).(Compare.S.compare) in
    let path_length := 7 in
    let to_path (c : Z.t) (l : list string) : list string :=
      let raw_key := Data_encoding.Binary.to_bytes_exn encoding c in
      let 'MBytes.Hex index_key := MBytes.to_hex (Raw_hashes.blake2b raw_key) in
      cons (String.sub index_key 0 2)
        (cons (String.sub index_key 2 2)
          (cons (String.sub index_key 4 2)
            (cons (String.sub index_key 6 2)
              (cons (String.sub index_key 8 2)
                (cons (String.sub index_key 10 2) (cons (Z.to_string c) l))))))
      in
    let of_path (function_parameter : list (|Compare.String|).(Compare.S.t))
      : option Z.t :=
      match function_parameter with
      |
        ([] | cons _ [] | cons _ (cons _ []) | cons _ (cons _ (cons _ [])) |
        cons _ (cons _ (cons _ (cons _ []))) |
        cons _ (cons _ (cons _ (cons _ (cons _ [])))) |
        cons _ (cons _ (cons _ (cons _ (cons _ (cons _ []))))) |
        cons _ (cons _ (cons _ (cons _ (cons _ (cons _ (cons _ (cons _ _))))))))
        =&gt; None
      |
        cons index1
          (cons index2
            (cons index3
              (cons index4 (cons index5 (cons index6 (cons __key_value []))))))
        =&gt;
        let c := Z.of_string __key_value in
        let raw_key := Data_encoding.Binary.to_bytes_exn encoding c in
        let 'MBytes.Hex index_key := MBytes.to_hex (Raw_hashes.blake2b raw_key)
          in
        (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
        (* ‚ùå instruction_sequence &quot;;&quot; *)
        (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
        (* ‚ùå instruction_sequence &quot;;&quot; *)
        (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
        (* ‚ùå instruction_sequence &quot;;&quot; *)
        (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
        (* ‚ùå instruction_sequence &quot;;&quot; *)
        (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
        (* ‚ùå instruction_sequence &quot;;&quot; *)
        (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
        (* ‚ùå instruction_sequence &quot;;&quot; *)
        Some c
      end in
    existT (A := unit) (fun _ =&gt; _) tt
      {|
        Storage_description.INDEX.rpc_arg := rpc_arg;
        Storage_description.INDEX.encoding := encoding;
        Storage_description.INDEX.compare := compare;
        Storage_description.INDEX.path_length := path_length;
        Storage_description.INDEX.to_path := to_path;
        Storage_description.INDEX.of_path := of_path
      |}.
  
  Definition Indexed_context :=
    (Storage_functors.Make_indexed_subcontext
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _ (|Raw_context|)))
          (let name := [ &quot;index&quot; ] in
          existT (A := unit) (fun _ =&gt; _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result := Make_index (existT (A := Set) _ _ (|Index|)) in
      existT (A := [Set ** Set -&gt; Set]) _ [_, _] (|functor_result|)).
  
  Definition rpc_arg : RPC_arg.arg Z.t :=
    (|Index|).(Storage_description.INDEX.rpc_arg).
  
  Definition fold {A : Set}
    : (|Indexed_context|).(Storage_sigs.Indexed_raw_context.context) -&gt; A -&gt;
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.key) -&gt; A -&gt; Lwt.t A)
    -&gt; Lwt.t A :=
    (|Indexed_context|).(Storage_sigs.Indexed_raw_context.fold_keys).
  
  Definition __list_value
    : (|Indexed_context|).(Storage_sigs.Indexed_raw_context.context) -&gt;
    Lwt.t (list (|Indexed_context|).(Storage_sigs.Indexed_raw_context.key)) :=
    (|Indexed_context|).(Storage_sigs.Indexed_raw_context.keys).
  
  Definition remove_rec
    (ctxt : (|Indexed_context|).(Storage_sigs.Indexed_raw_context.context))
    (n : (|Indexed_context|).(Storage_sigs.Indexed_raw_context.key))
    : Lwt.t (|Indexed_context|).(Storage_sigs.Indexed_raw_context.context) :=
    (|Indexed_context|).(Storage_sigs.Indexed_raw_context.remove_rec) ctxt n.
  
  Definition copy
    (ctxt : (|Indexed_context|).(Storage_sigs.Indexed_raw_context.context))
    (from : (|Indexed_context|).(Storage_sigs.Indexed_raw_context.key))
    (to_ : (|Indexed_context|).(Storage_sigs.Indexed_raw_context.key))
    : Lwt.t
      (Error_monad.tzresult
        (|Indexed_context|).(Storage_sigs.Indexed_raw_context.context)) :=
    (|Indexed_context|).(Storage_sigs.Indexed_raw_context.copy) ctxt from to_.
  
  Definition key : Set := (|Raw_context|).(Raw_context.T.t) * Z.t.
  
  Definition Total_bytes :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ &quot;total_bytes&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |})) (existT (A := Set) _ _ (|Z_value|)).
  
  Definition Key_type :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ &quot;key_type&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (let t : Set := Script_repr.expr in
      let encoding := Script_repr.expr_encoding in
      existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := encoding
        |}).
  
  Definition Value_type :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ &quot;value_type&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (let t : Set := Script_repr.expr in
      let encoding := Script_repr.expr_encoding in
      existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := encoding
        |}).
  
  Module Contents.
    Definition I :=
      ((Storage_functors.Make_indexed_carbonated_data_storage
        (let functor_result :=
          ((Storage_functors.Make_subcontext
            (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
            (existT (A := Set) _ _
              (|Indexed_context|).(Storage_sigs.Indexed_raw_context.Raw_context)))
            (let name := [ &quot;contents&quot; ] in
            existT (A := unit) (fun _ =&gt; _) tt
              {|
                Storage_sigs.NAME.name := name
              |}) in
        existT (A := Set) _ _ (|functor_result|)))
        (let functor_result :=
          Make_index
            (existT (A := Set) _ _
              {|
                Storage_description.INDEX.path_length :=
                  Script_expr_hash.path_length;
                Storage_description.INDEX.to_path := Script_expr_hash.to_path;
                Storage_description.INDEX.of_path := Script_expr_hash.of_path;
                Storage_description.INDEX.rpc_arg := Script_expr_hash.rpc_arg;
                Storage_description.INDEX.encoding := Script_expr_hash.encoding;
                Storage_description.INDEX.compare := Script_expr_hash.compare
              |}) in
        existT (A := [Set ** Set -&gt; Set]) _ [_, _] (|functor_result|)))
        (let t : Set := Script_repr.expr in
        let encoding := Script_repr.expr_encoding in
        existT (A := Set) _ _
          {|
            Storage_sigs.VALUE.encoding := encoding
          |}).
    
    Definition tag_Non_iterable_indexed_carbonated_data_storage : unit := tt.
    
    Definition context : Set :=
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context).
    
    Definition key : Set :=
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key).
    
    Definition value : Set :=
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value).
    
    Definition mem
      : (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context)
      -&gt;
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key) -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * bool)) :=
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.mem).
    
    Definition delete
      : (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context)
      -&gt;
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key) -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * int)) :=
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.delete).
    
    Definition remove
      : (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context)
      -&gt;
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key) -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * int * bool)) :=
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.remove).
    
    Definition set
      : (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context)
      -&gt;
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key) -&gt;
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value) -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * int)) :=
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set).
    
    Definition set_option
      : (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context)
      -&gt;
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key) -&gt;
      option
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value)
      -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * int * bool)) :=
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set_option).
    
    Definition init
      : (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context)
      -&gt;
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key) -&gt;
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value) -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * int)) :=
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.init).
    
    Definition init_set
      : (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context)
      -&gt;
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key) -&gt;
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value) -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * int * bool)) :=
      (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.init_set).
    
    Definition consume_deserialize_gas
      (ctxt : (|Raw_context|).(Raw_context.T.context))
      (value : Script_repr.expr)
      : Lwt.t (Error_monad.tzresult (|Raw_context|).(Raw_context.T.context)) :=
      Lwt.__return
        ((|Raw_context|).(Raw_context.T.consume_gas) ctxt
          (Script_repr.deserialized_cost value)).
    
    Definition get
      (ctxt :
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context))
      (contract :
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
      : Lwt.t
        (Error_monad.tzresult
          ((|Raw_context|).(Raw_context.T.context) *
            (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value))) :=
      let=? '(ctxt, value) :=
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get)
          ctxt contract in
      Error_monad.op_gtgtpipequestion (consume_deserialize_gas ctxt value)
        (fun ctxt =&gt; (ctxt, value)).
    
    Definition get_option
      (ctxt :
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.context))
      (contract :
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.key))
      : Lwt.t
        (Error_monad.tzresult
          (Raw_context.t *
            option
              (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.value))) :=
      let=? '(ctxt, value_opt) :=
        (|I|).(Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get_option)
          ctxt contract in
      match value_opt with
      | None =&gt; Error_monad.__return (ctxt, None)
      | Some value =&gt;
        Error_monad.op_gtgtpipequestion (consume_deserialize_gas ctxt value)
          (fun ctxt =&gt; (ctxt, value_opt))
      end.
  End Contents.
End Big_map.

Definition Delegates :=
  (Storage_functors.Make_data_set_storage
    (let functor_result :=
      ((Storage_functors.Make_subcontext
        (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
        (existT (A := Set) _ _
          {|
            Raw_context.T.mem := Raw_context.mem;
            Raw_context.T.dir_mem := Raw_context.dir_mem;
            Raw_context.T.get := Raw_context.get;
            Raw_context.T.get_option := Raw_context.get_option;
            Raw_context.T.init := Raw_context.init;
            Raw_context.T.set := Raw_context.set;
            Raw_context.T.init_set := Raw_context.init_set;
            Raw_context.T.set_option := Raw_context.set_option;
            Raw_context.T.delete := Raw_context.delete;
            Raw_context.T.remove := Raw_context.remove;
            Raw_context.T.remove_rec := Raw_context.remove_rec;
            Raw_context.T.copy := Raw_context.copy;
            Raw_context.T.fold {_} := Raw_context.fold;
            Raw_context.T.keys := Raw_context.keys;
            Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
            Raw_context.T.project := Raw_context.project;
            Raw_context.T.absolute_key := Raw_context.absolute_key;
            Raw_context.T.consume_gas := Raw_context.consume_gas;
            Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
            Raw_context.T.description := Raw_context.description
          |}))
        (let name := [ &quot;delegates&quot; ] in
        existT (A := unit) (fun _ =&gt; _) tt
          {|
            Storage_sigs.NAME.name := name
          |}) in
    existT (A := Set) _ _ (|functor_result|)))
    (let functor_result :=
      Make_index
        (existT (A := Set) _ _
          {|
            Storage_description.INDEX.path_length :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.path_length);
            Storage_description.INDEX.to_path :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.to_path);
            Storage_description.INDEX.of_path :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.of_path);
            Storage_description.INDEX.rpc_arg :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.rpc_arg);
            Storage_description.INDEX.encoding :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding);
            Storage_description.INDEX.compare :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.compare)
          |}) in
    existT (A := [Set ** Set -&gt; Set]) _ [_, _] (|functor_result|)).

Definition Active_delegates_with_rolls :=
  (Storage_functors.Make_data_set_storage
    (let functor_result :=
      ((Storage_functors.Make_subcontext
        (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
        (existT (A := Set) _ _
          {|
            Raw_context.T.mem := Raw_context.mem;
            Raw_context.T.dir_mem := Raw_context.dir_mem;
            Raw_context.T.get := Raw_context.get;
            Raw_context.T.get_option := Raw_context.get_option;
            Raw_context.T.init := Raw_context.init;
            Raw_context.T.set := Raw_context.set;
            Raw_context.T.init_set := Raw_context.init_set;
            Raw_context.T.set_option := Raw_context.set_option;
            Raw_context.T.delete := Raw_context.delete;
            Raw_context.T.remove := Raw_context.remove;
            Raw_context.T.remove_rec := Raw_context.remove_rec;
            Raw_context.T.copy := Raw_context.copy;
            Raw_context.T.fold {_} := Raw_context.fold;
            Raw_context.T.keys := Raw_context.keys;
            Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
            Raw_context.T.project := Raw_context.project;
            Raw_context.T.absolute_key := Raw_context.absolute_key;
            Raw_context.T.consume_gas := Raw_context.consume_gas;
            Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
            Raw_context.T.description := Raw_context.description
          |}))
        (let name := [ &quot;active_delegates_with_rolls&quot; ] in
        existT (A := unit) (fun _ =&gt; _) tt
          {|
            Storage_sigs.NAME.name := name
          |}) in
    existT (A := Set) _ _ (|functor_result|)))
    (let functor_result :=
      Make_index
        (existT (A := Set) _ _
          {|
            Storage_description.INDEX.path_length :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.path_length);
            Storage_description.INDEX.to_path :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.to_path);
            Storage_description.INDEX.of_path :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.of_path);
            Storage_description.INDEX.rpc_arg :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.rpc_arg);
            Storage_description.INDEX.encoding :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding);
            Storage_description.INDEX.compare :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.compare)
          |}) in
    existT (A := [Set ** Set -&gt; Set]) _ [_, _] (|functor_result|)).

Definition Delegates_with_frozen_balance_index :=
  (Storage_functors.Make_indexed_subcontext
    (let functor_result :=
      ((Storage_functors.Make_subcontext
        (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
        (existT (A := Set) _ _
          {|
            Raw_context.T.mem := Raw_context.mem;
            Raw_context.T.dir_mem := Raw_context.dir_mem;
            Raw_context.T.get := Raw_context.get;
            Raw_context.T.get_option := Raw_context.get_option;
            Raw_context.T.init := Raw_context.init;
            Raw_context.T.set := Raw_context.set;
            Raw_context.T.init_set := Raw_context.init_set;
            Raw_context.T.set_option := Raw_context.set_option;
            Raw_context.T.delete := Raw_context.delete;
            Raw_context.T.remove := Raw_context.remove;
            Raw_context.T.remove_rec := Raw_context.remove_rec;
            Raw_context.T.copy := Raw_context.copy;
            Raw_context.T.fold {_} := Raw_context.fold;
            Raw_context.T.keys := Raw_context.keys;
            Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
            Raw_context.T.project := Raw_context.project;
            Raw_context.T.absolute_key := Raw_context.absolute_key;
            Raw_context.T.consume_gas := Raw_context.consume_gas;
            Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
            Raw_context.T.description := Raw_context.description
          |}))
        (let name := [ &quot;delegates_with_frozen_balance&quot; ] in
        existT (A := unit) (fun _ =&gt; _) tt
          {|
            Storage_sigs.NAME.name := name
          |}) in
    existT (A := Set) _ _ (|functor_result|)))
    (let functor_result :=
      Make_index (existT (A := Set) _ _ (|Cycle_repr.Index|)) in
    existT (A := [Set ** Set -&gt; Set]) _ [_, _] (|functor_result|)).

Definition Delegates_with_frozen_balance :=
  (Storage_functors.Make_data_set_storage
    (existT (A := Set) _ _
      (|Delegates_with_frozen_balance_index|).(Storage_sigs.Indexed_raw_context.Raw_context)))
    (let functor_result :=
      Make_index
        (existT (A := Set) _ _
          {|
            Storage_description.INDEX.path_length :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.path_length);
            Storage_description.INDEX.to_path :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.to_path);
            Storage_description.INDEX.of_path :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.of_path);
            Storage_description.INDEX.rpc_arg :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.rpc_arg);
            Storage_description.INDEX.encoding :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding);
            Storage_description.INDEX.compare :=
              (|Signature.Public_key_hash|).(S.SPublic_key_hash.compare)
          |}) in
    existT (A := [Set ** Set -&gt; Set]) _ [_, _] (|functor_result|)).

Module unrevealed_nonce.
  Record record : Set := Build {
    nonce_hash : Nonce_hash.t;
    delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t);
    rewards : Tez_repr.t;
    fees : Tez_repr.t }.
  Definition with_nonce_hash nonce_hash (r : record) :=
    Build nonce_hash r.(delegate) r.(rewards) r.(fees).
  Definition with_delegate delegate (r : record) :=
    Build r.(nonce_hash) delegate r.(rewards) r.(fees).
  Definition with_rewards rewards (r : record) :=
    Build r.(nonce_hash) r.(delegate) rewards r.(fees).
  Definition with_fees fees (r : record) :=
    Build r.(nonce_hash) r.(delegate) r.(rewards) fees.
End unrevealed_nonce.
Definition unrevealed_nonce := unrevealed_nonce.record.

Inductive nonce_status : Set :=
| Unrevealed : unrevealed_nonce -&gt; nonce_status
| Revealed : Seed_repr.nonce -&gt; nonce_status.

Module Cycle.
  Definition Indexed_context :=
    (Storage_functors.Make_indexed_subcontext
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _
            {|
              Raw_context.T.mem := Raw_context.mem;
              Raw_context.T.dir_mem := Raw_context.dir_mem;
              Raw_context.T.get := Raw_context.get;
              Raw_context.T.get_option := Raw_context.get_option;
              Raw_context.T.init := Raw_context.init;
              Raw_context.T.set := Raw_context.set;
              Raw_context.T.init_set := Raw_context.init_set;
              Raw_context.T.set_option := Raw_context.set_option;
              Raw_context.T.delete := Raw_context.delete;
              Raw_context.T.remove := Raw_context.remove;
              Raw_context.T.remove_rec := Raw_context.remove_rec;
              Raw_context.T.copy := Raw_context.copy;
              Raw_context.T.fold {_} := Raw_context.fold;
              Raw_context.T.keys := Raw_context.keys;
              Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
              Raw_context.T.project := Raw_context.project;
              Raw_context.T.absolute_key := Raw_context.absolute_key;
              Raw_context.T.consume_gas := Raw_context.consume_gas;
              Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
              Raw_context.T.description := Raw_context.description
            |}))
          (let name := [ &quot;cycle&quot; ] in
          existT (A := unit) (fun _ =&gt; _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result :=
        Make_index (existT (A := Set) _ _ (|Cycle_repr.Index|)) in
      existT (A := [Set ** Set -&gt; Set]) _ [_, _] (|functor_result|)).
  
  Definition Last_roll :=
    ((Storage_functors.Make_indexed_data_storage
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _
            (|Indexed_context|).(Storage_sigs.Indexed_raw_context.Raw_context)))
          (let name := [ &quot;last_roll&quot; ] in
          existT (A := unit) (fun _ =&gt; _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (existT (A := [Set ** Set -&gt; Set]) _ [_, _] (|Int_index|)))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Roll_repr.encoding
        |}).
  
  Definition Roll_snapshot :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ &quot;roll_snapshot&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |})) (existT (A := Set) _ _ (|Int|)).
  
  Definition nonce_status_encoding : Data_encoding.encoding nonce_status :=
    Data_encoding.union None
      [
        Data_encoding.__case_value &quot;Unrevealed&quot; None (Data_encoding.Tag 0)
          (Data_encoding.tup4 Nonce_hash.encoding
            (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding)
            Tez_repr.encoding Tez_repr.encoding)
          (fun function_parameter =&gt;
            match function_parameter with
            |
              Unrevealed {|
                unrevealed_nonce.nonce_hash := nonce_hash;
                  unrevealed_nonce.delegate := delegate;
                  unrevealed_nonce.rewards := rewards;
                  unrevealed_nonce.fees := fees
                  |} =&gt;
              Some (nonce_hash, delegate, rewards, fees)
            | _ =&gt; None
            end)
          (fun function_parameter =&gt;
            let '(nonce_hash, delegate, rewards, fees) :=
              function_parameter in
            Unrevealed
              {| unrevealed_nonce.nonce_hash := nonce_hash;
                unrevealed_nonce.delegate := delegate;
                unrevealed_nonce.rewards := rewards;
                unrevealed_nonce.fees := fees |});
        Data_encoding.__case_value &quot;Revealed&quot; None (Data_encoding.Tag 1)
          Seed_repr.nonce_encoding
          (fun function_parameter =&gt;
            match function_parameter with
            | Revealed __nonce_value =&gt; Some __nonce_value
            | _ =&gt; None
            end) (fun __nonce_value =&gt; Revealed __nonce_value)
      ].
  
  Definition Nonce :=
    ((Storage_functors.Make_indexed_data_storage
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _
            (|Indexed_context|).(Storage_sigs.Indexed_raw_context.Raw_context)))
          (let name := [ &quot;nonces&quot; ] in
          existT (A := unit) (fun _ =&gt; _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result :=
        Make_index (existT (A := Set) _ _ (|Raw_level_repr.Index|)) in
      existT (A := [Set ** Set -&gt; Set]) _ [_, _] (|functor_result|)))
      (let t : Set := nonce_status in
      let encoding := nonce_status_encoding in
      existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := encoding
        |}).
  
  Definition Seed :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ &quot;random_seed&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (let t : Set := Seed_repr.seed in
      let encoding := Seed_repr.seed_encoding in
      existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := encoding
        |}).
End Cycle.

Module Roll.
  Definition Raw_context :=
    ((Storage_functors.Make_subcontext
      (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
      (existT (A := Set) _ _
        {|
          Raw_context.T.mem := Raw_context.mem;
          Raw_context.T.dir_mem := Raw_context.dir_mem;
          Raw_context.T.get := Raw_context.get;
          Raw_context.T.get_option := Raw_context.get_option;
          Raw_context.T.init := Raw_context.init;
          Raw_context.T.set := Raw_context.set;
          Raw_context.T.init_set := Raw_context.init_set;
          Raw_context.T.set_option := Raw_context.set_option;
          Raw_context.T.delete := Raw_context.delete;
          Raw_context.T.remove := Raw_context.remove;
          Raw_context.T.remove_rec := Raw_context.remove_rec;
          Raw_context.T.copy := Raw_context.copy;
          Raw_context.T.fold {_} := Raw_context.fold;
          Raw_context.T.keys := Raw_context.keys;
          Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
          Raw_context.T.project := Raw_context.project;
          Raw_context.T.absolute_key := Raw_context.absolute_key;
          Raw_context.T.consume_gas := Raw_context.consume_gas;
          Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
          Raw_context.T.description := Raw_context.description
        |}))
      (let name := [ &quot;rolls&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |}).
  
  Definition Indexed_context :=
    (Storage_functors.Make_indexed_subcontext
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _ (|Raw_context|)))
          (let name := [ &quot;index&quot; ] in
          existT (A := unit) (fun _ =&gt; _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result :=
        Make_index (existT (A := Set) _ _ (|Roll_repr.Index|)) in
      existT (A := [Set ** Set -&gt; Set]) _ [_, _] (|functor_result|)).
  
  Definition Next :
    {_ : unit &amp;
      Single_data_storage.signature (t := (|Raw_context|).(Raw_context.T.t))
        (value := Roll_repr.t)} :=
    (((Storage_functors.Make_single_data_storage
      (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
      (existT (A := Set) _ _ (|Raw_context|)))
      (let name := [ &quot;next&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Roll_repr.encoding
        |}).
  
  Definition Limbo :
    {_ : unit &amp;
      Single_data_storage.signature (t := (|Raw_context|).(Raw_context.T.t))
        (value := Roll_repr.t)} :=
    (((Storage_functors.Make_single_data_storage
      (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
      (existT (A := Set) _ _ (|Raw_context|)))
      (let name := [ &quot;limbo&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Roll_repr.encoding
        |}).
  
  Definition Delegate_roll_list :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := (|Raw_context|).(Raw_context.T.t))
        (key := (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
        (value := Roll_repr.t)} :=
    (Storage_functors.Wrap_indexed_data_storage
      (existT (A := [Set ** Set ** Set]) _ [_, _, _] (|Contract.Roll_list|)))
      (let t : Set := (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) in
      let wrap := Contract_repr.implicit_contract in
      let unwrap := Contract_repr.is_implicit in
      existT (A := Set) _ _
        {|
          Storage_functors.WRAPPER.wrap := wrap;
          Storage_functors.WRAPPER.unwrap := unwrap
        |}).
  
  Definition Successor :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := (|Raw_context|).(Raw_context.T.t))
        (key := Roll_repr.t) (value := Roll_repr.t)} :=
    ((|Indexed_context|).(Storage_sigs.Indexed_raw_context.Make_map)
      (let name := [ &quot;successor&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := Roll_repr.encoding
        |}).
  
  Definition Delegate_change :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := (|Raw_context|).(Raw_context.T.t))
        (key := (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
        (value := Tez_repr.t)} :=
    (Storage_functors.Wrap_indexed_data_storage
      (existT (A := [Set ** Set ** Set]) _ [_, _, _] (|Contract.Change|)))
      (let t : Set := (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) in
      let wrap := Contract_repr.implicit_contract in
      let unwrap := Contract_repr.is_implicit in
      existT (A := Set) _ _
        {|
          Storage_functors.WRAPPER.wrap := wrap;
          Storage_functors.WRAPPER.unwrap := unwrap
        |}).
  
  Module Snapshoted_owner_index.
    Definition t : Set := Cycle_repr.t * int.
    
    Definition path_length : int :=
      Pervasives.op_plus
        (|Cycle_repr.Index|).(Storage_description.INDEX.path_length) 1.
    
    Definition to_path
      (function_parameter :
        (|Cycle_repr.Index|).(Storage_description.INDEX.t) * int)
      : list string -&gt; list string :=
      let '(c, n) := function_parameter in
      fun s =&gt;
        (|Cycle_repr.Index|).(Storage_description.INDEX.to_path) c
          (cons (Pervasives.string_of_int n) s).
    
    Definition of_path (l : list string)
      : option ((|Cycle_repr.Index|).(Storage_description.INDEX.t) * int) :=
      match
        Misc.take (|Cycle_repr.Index|).(Storage_description.INDEX.path_length) l
        with
      | (None | Some (_, ([] | cons _ (cons _ _)))) =&gt; None
      | Some (l1, cons l2 []) =&gt;
        match
          (((|Cycle_repr.Index|).(Storage_description.INDEX.of_path) l1),
            (Pervasives.int_of_string_opt l2)) with
        | ((None, _) | (_, None)) =&gt; None
        | (Some c, Some i) =&gt; Some (c, i)
        end
      end.
    
    Definition ipath (a : Set) : Set := (a * Cycle_repr.t) * int.
    
    Definition left_args : Storage_description.args :=
      Storage_description.One
        {| Storage_description.args.One.rpc_arg := Cycle_repr.rpc_arg;
          Storage_description.args.One.encoding := Cycle_repr.encoding;
          Storage_description.args.One.compare := Cycle_repr.compare |}.
    
    Definition right_args : Storage_description.args :=
      Storage_description.One
        {| Storage_description.args.One.rpc_arg := RPC_arg.__int_value;
          Storage_description.args.One.encoding := Data_encoding.int31;
          Storage_description.args.One.compare :=
            (|Compare.Int|).(Compare.S.compare) |}.
    
    Definition args (function_parameter : unit) : Storage_description.args :=
      let '_ := function_parameter in
      Storage_description.Pair left_args right_args.
    
    Definition infer_ipath {a : Set} (function_parameter : ipath a) : a -&gt; a :=
      let '_ := function_parameter in
      fun x =&gt; x.
  End Snapshoted_owner_index.
  
  Definition Owner :
    {_ : unit &amp;
      Indexed_data_snapshotable_storage.signature
        (snapshot := (Cycle_repr.t * int)) (key := Roll_repr.t)
        (t := (|Raw_context|).(Raw_context.T.t))
        (value := (|Signature.Public_key|).(S.SPublic_key.t))} :=
    (((Storage_functors.Make_indexed_data_snapshotable_storage
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _ (|Raw_context|)))
          (let name := [ &quot;owner&quot; ] in
          existT (A := unit) (fun _ =&gt; _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (existT (A := [Set ** Set -&gt; Set]) _ [_, _]
        {|
          Storage_functors.INDEX.path_length :=
            Snapshoted_owner_index.path_length;
          Storage_functors.INDEX.to_path := Snapshoted_owner_index.to_path;
          Storage_functors.INDEX.of_path := Snapshoted_owner_index.of_path;
          Storage_functors.INDEX.args := Snapshoted_owner_index.args;
          Storage_functors.INDEX.infer_ipath {_} :=
            Snapshoted_owner_index.infer_ipath
        |}))
      (let functor_result :=
        Make_index (existT (A := Set) _ _ (|Roll_repr.Index|)) in
      existT (A := [Set ** Set -&gt; Set]) _ [_, _] (|functor_result|)))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding :=
            (|Signature.Public_key|).(S.SPublic_key.encoding)
        |}).
  
  Definition Snapshot_for_cycle :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := (|Raw_context|).(Raw_context.T.t))
        (key := Cycle_repr.t) (value := int)} :=
    existT (A := unit) (fun _ =&gt; _) tt (|Cycle.Roll_snapshot|).
  
  Definition Last_for_snapshot :
    {_ : unit &amp;
      Indexed_data_storage.signature
        (t := ((|Raw_context|).(Raw_context.T.t) * Cycle_repr.t)) (key := int)
        (value := Roll_repr.t)} :=
    existT (A := unit) (fun _ =&gt; _) tt (|Cycle.Last_roll|).
  
  Definition clear
    : (|Indexed_context|).(Storage_sigs.Indexed_raw_context.context) -&gt;
    Lwt.t Raw_context.t :=
    (|Indexed_context|).(Storage_sigs.Indexed_raw_context.clear).
End Roll.

Module Vote.
  Definition Raw_context :=
    ((Storage_functors.Make_subcontext
      (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
      (existT (A := Set) _ _
        {|
          Raw_context.T.mem := Raw_context.mem;
          Raw_context.T.dir_mem := Raw_context.dir_mem;
          Raw_context.T.get := Raw_context.get;
          Raw_context.T.get_option := Raw_context.get_option;
          Raw_context.T.init := Raw_context.init;
          Raw_context.T.set := Raw_context.set;
          Raw_context.T.init_set := Raw_context.init_set;
          Raw_context.T.set_option := Raw_context.set_option;
          Raw_context.T.delete := Raw_context.delete;
          Raw_context.T.remove := Raw_context.remove;
          Raw_context.T.remove_rec := Raw_context.remove_rec;
          Raw_context.T.copy := Raw_context.copy;
          Raw_context.T.fold {_} := Raw_context.fold;
          Raw_context.T.keys := Raw_context.keys;
          Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
          Raw_context.T.project := Raw_context.project;
          Raw_context.T.absolute_key := Raw_context.absolute_key;
          Raw_context.T.consume_gas := Raw_context.consume_gas;
          Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
          Raw_context.T.description := Raw_context.description
        |}))
      (let name := [ &quot;votes&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |}).
  
  Definition Current_period_kind :=
    (((Storage_functors.Make_single_data_storage
      (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
      (existT (A := Set) _ _ (|Raw_context|)))
      (let name := [ &quot;current_period_kind&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (let t : Set := Voting_period_repr.kind in
      let encoding := Voting_period_repr.kind_encoding in
      existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := encoding
        |}).
  
  Definition Participation_ema :=
    (((Storage_functors.Make_single_data_storage
      (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
      (existT (A := Set) _ _ (|Raw_context|)))
      (let name := [ &quot;participation_ema&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |})) (existT (A := Set) _ _ (|Int32|)).
  
  Definition Current_proposal :=
    (((Storage_functors.Make_single_data_storage
      (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
      (existT (A := Set) _ _ (|Raw_context|)))
      (let name := [ &quot;current_proposal&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |}))
      (existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := (|Protocol_hash|).(S.HASH.encoding)
        |}).
  
  Definition Listings_size :=
    (((Storage_functors.Make_single_data_storage
      (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
      (existT (A := Set) _ _ (|Raw_context|)))
      (let name := [ &quot;listings_size&quot; ] in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.NAME.name := name
        |})) (existT (A := Set) _ _ (|Int32|)).
  
  Definition Listings :=
    ((Storage_functors.Make_indexed_data_storage
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _ (|Raw_context|)))
          (let name := [ &quot;listings&quot; ] in
          existT (A := unit) (fun _ =&gt; _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result :=
        Make_index
          (existT (A := Set) _ _
            {|
              Storage_description.INDEX.path_length :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.path_length);
              Storage_description.INDEX.to_path :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.to_path);
              Storage_description.INDEX.of_path :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.of_path);
              Storage_description.INDEX.rpc_arg :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.rpc_arg);
              Storage_description.INDEX.encoding :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding);
              Storage_description.INDEX.compare :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.compare)
            |}) in
      existT (A := [Set ** Set -&gt; Set]) _ [_, _] (|functor_result|)))
      (existT (A := Set) _ _ (|Int32|)).
  
  Definition Proposals :=
    (Storage_functors.Make_data_set_storage
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _ (|Raw_context|)))
          (let name := [ &quot;proposals&quot; ] in
          existT (A := unit) (fun _ =&gt; _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result :=
        (Storage_functors.Pair
          (let functor_result :=
            Make_index
              (existT (A := Set) _ _
                {|
                  Storage_description.INDEX.path_length :=
                    (|Protocol_hash|).(S.HASH.path_length);
                  Storage_description.INDEX.to_path :=
                    (|Protocol_hash|).(S.HASH.to_path);
                  Storage_description.INDEX.of_path :=
                    (|Protocol_hash|).(S.HASH.of_path);
                  Storage_description.INDEX.rpc_arg :=
                    (|Protocol_hash|).(S.HASH.rpc_arg);
                  Storage_description.INDEX.encoding :=
                    (|Protocol_hash|).(S.HASH.encoding);
                  Storage_description.INDEX.compare :=
                    (|Protocol_hash|).(S.HASH.compare)
                |}) in
          existT (A := [Set ** Set -&gt; Set]) _ [_, _] (|functor_result|)))
          (let functor_result :=
            Make_index
              (existT (A := Set) _ _
                {|
                  Storage_description.INDEX.path_length :=
                    (|Signature.Public_key_hash|).(S.SPublic_key_hash.path_length);
                  Storage_description.INDEX.to_path :=
                    (|Signature.Public_key_hash|).(S.SPublic_key_hash.to_path);
                  Storage_description.INDEX.of_path :=
                    (|Signature.Public_key_hash|).(S.SPublic_key_hash.of_path);
                  Storage_description.INDEX.rpc_arg :=
                    (|Signature.Public_key_hash|).(S.SPublic_key_hash.rpc_arg);
                  Storage_description.INDEX.encoding :=
                    (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding);
                  Storage_description.INDEX.compare :=
                    (|Signature.Public_key_hash|).(S.SPublic_key_hash.compare)
                |}) in
          existT (A := [Set ** Set -&gt; Set]) _ [_, _] (|functor_result|)) in
      existT (A := [Set ** Set -&gt; Set]) _ [_, _] (|functor_result|)).
  
  Definition Proposals_count :=
    ((Storage_functors.Make_indexed_data_storage
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _ (|Raw_context|)))
          (let name := [ &quot;proposals_count&quot; ] in
          existT (A := unit) (fun _ =&gt; _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result :=
        Make_index
          (existT (A := Set) _ _
            {|
              Storage_description.INDEX.path_length :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.path_length);
              Storage_description.INDEX.to_path :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.to_path);
              Storage_description.INDEX.of_path :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.of_path);
              Storage_description.INDEX.rpc_arg :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.rpc_arg);
              Storage_description.INDEX.encoding :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding);
              Storage_description.INDEX.compare :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.compare)
            |}) in
      existT (A := [Set ** Set -&gt; Set]) _ [_, _] (|functor_result|)))
      (existT (A := Set) _ _ (|Int|)).
  
  Definition Ballots :=
    ((Storage_functors.Make_indexed_data_storage
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _ (|Raw_context|)))
          (let name := [ &quot;ballots&quot; ] in
          existT (A := unit) (fun _ =&gt; _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result :=
        Make_index
          (existT (A := Set) _ _
            {|
              Storage_description.INDEX.path_length :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.path_length);
              Storage_description.INDEX.to_path :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.to_path);
              Storage_description.INDEX.of_path :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.of_path);
              Storage_description.INDEX.rpc_arg :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.rpc_arg);
              Storage_description.INDEX.encoding :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding);
              Storage_description.INDEX.compare :=
                (|Signature.Public_key_hash|).(S.SPublic_key_hash.compare)
            |}) in
      existT (A := [Set ** Set -&gt; Set]) _ [_, _] (|functor_result|)))
      (let t : Set := Vote_repr.ballot in
      let encoding := Vote_repr.ballot_encoding in
      existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := encoding
        |}).
End Vote.

Module For_cycle_sig.
  Record signature : Set := {
    init :
      Raw_context.t -&gt; Cycle_repr.t -&gt; Seed_repr.seed -&gt;
      Lwt.t (Error_monad.tzresult Raw_context.t);
    get :
      Raw_context.t -&gt; Cycle_repr.t -&gt;
      Lwt.t (Error_monad.tzresult Seed_repr.seed);
    delete :
      Raw_context.t -&gt; Cycle_repr.t -&gt;
      Lwt.t (Error_monad.tzresult Raw_context.t);
  }.
End For_cycle_sig.

Module Seed.
  Definition Nonce :
    {_ : unit &amp;
      Storage_sigs.Non_iterable_indexed_data_storage.signature
        (t := Raw_context.t) (key := Level_repr.t) (value := nonce_status)} :=
    (* ‚ùå open *)
    let tag_Non_iterable_indexed_data_storage := tt in
    let context : Set := Raw_context.t in
    let mem
      (ctxt : (|Cycle.Indexed_context|).(Storage_sigs.Indexed_raw_context.t))
      (l : Level_repr.t) : Lwt.t bool :=
      (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.mem)
        (ctxt, l.(Level_repr.t.cycle)) l.(Level_repr.t.level) in
    let get
      (ctxt : (|Cycle.Indexed_context|).(Storage_sigs.Indexed_raw_context.t))
      (l : Level_repr.t)
      : Lwt.t
        (Error_monad.tzresult
          (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.value)) :=
      (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.get)
        (ctxt, l.(Level_repr.t.cycle)) l.(Level_repr.t.level) in
    let get_option
      (ctxt : (|Cycle.Indexed_context|).(Storage_sigs.Indexed_raw_context.t))
      (l : Level_repr.t)
      : Lwt.t
        (Error_monad.tzresult
          (option (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.value))) :=
      (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.get_option)
        (ctxt, l.(Level_repr.t.cycle)) l.(Level_repr.t.level) in
    let set
      (ctxt : (|Cycle.Indexed_context|).(Storage_sigs.Indexed_raw_context.t))
      (l : Level_repr.t)
      (v : (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.value))
      : Lwt.t (Error_monad.tzresult Raw_context.t) :=
      (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.set)
        (ctxt, l.(Level_repr.t.cycle)) l.(Level_repr.t.level) v in
    let init
      (ctxt : (|Cycle.Indexed_context|).(Storage_sigs.Indexed_raw_context.t))
      (l : Level_repr.t)
      (v : (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.value))
      : Lwt.t (Error_monad.tzresult Raw_context.t) :=
      (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.init)
        (ctxt, l.(Level_repr.t.cycle)) l.(Level_repr.t.level) v in
    let init_set
      (ctxt : (|Cycle.Indexed_context|).(Storage_sigs.Indexed_raw_context.t))
      (l : Level_repr.t)
      (v : (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.value))
      : Lwt.t Raw_context.t :=
      (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.init_set)
        (ctxt, l.(Level_repr.t.cycle)) l.(Level_repr.t.level) v in
    let set_option
      (ctxt : (|Cycle.Indexed_context|).(Storage_sigs.Indexed_raw_context.t))
      (l : Level_repr.t)
      (v : option (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.value))
      : Lwt.t Raw_context.t :=
      (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.set_option)
        (ctxt, l.(Level_repr.t.cycle)) l.(Level_repr.t.level) v in
    let delete
      (ctxt : (|Cycle.Indexed_context|).(Storage_sigs.Indexed_raw_context.t))
      (l : Level_repr.t) : Lwt.t (Error_monad.tzresult Raw_context.t) :=
      (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.delete)
        (ctxt, l.(Level_repr.t.cycle)) l.(Level_repr.t.level) in
    let remove
      (ctxt : (|Cycle.Indexed_context|).(Storage_sigs.Indexed_raw_context.t))
      (l : Level_repr.t) : Lwt.t Raw_context.t :=
      (|Cycle.Nonce|).(Storage_sigs.Indexed_data_storage.remove)
        (ctxt, l.(Level_repr.t.cycle)) l.(Level_repr.t.level) in
    existT (A := unit) (fun _ =&gt; _) tt
      {|
        Storage_sigs.Non_iterable_indexed_data_storage.tag_Non_iterable_indexed_data_storage :=
          tag_Non_iterable_indexed_data_storage;
        Storage_sigs.Non_iterable_indexed_data_storage.mem := mem;
        Storage_sigs.Non_iterable_indexed_data_storage.get := get;
        Storage_sigs.Non_iterable_indexed_data_storage.get_option := get_option;
        Storage_sigs.Non_iterable_indexed_data_storage.set := set;
        Storage_sigs.Non_iterable_indexed_data_storage.init := init;
        Storage_sigs.Non_iterable_indexed_data_storage.init_set := init_set;
        Storage_sigs.Non_iterable_indexed_data_storage.set_option := set_option;
        Storage_sigs.Non_iterable_indexed_data_storage.delete := delete;
        Storage_sigs.Non_iterable_indexed_data_storage.remove := remove
      |}.
  
  Definition For_cycle : {_ : unit &amp; For_cycle_sig.signature} :=
    existT (A := unit) (fun _ =&gt; _) tt
      {|
        For_cycle_sig.init :=
          (|Cycle.Seed|).(Storage_sigs.Indexed_data_storage.init);
        For_cycle_sig.get :=
          (|Cycle.Seed|).(Storage_sigs.Indexed_data_storage.get);
        For_cycle_sig.delete :=
          (|Cycle.Seed|).(Storage_sigs.Indexed_data_storage.delete)
      |}.
End Seed.

Definition Commitments :=
  ((Storage_functors.Make_indexed_data_storage
    (let functor_result :=
      ((Storage_functors.Make_subcontext
        (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
        (existT (A := Set) _ _
          {|
            Raw_context.T.mem := Raw_context.mem;
            Raw_context.T.dir_mem := Raw_context.dir_mem;
            Raw_context.T.get := Raw_context.get;
            Raw_context.T.get_option := Raw_context.get_option;
            Raw_context.T.init := Raw_context.init;
            Raw_context.T.set := Raw_context.set;
            Raw_context.T.init_set := Raw_context.init_set;
            Raw_context.T.set_option := Raw_context.set_option;
            Raw_context.T.delete := Raw_context.delete;
            Raw_context.T.remove := Raw_context.remove;
            Raw_context.T.remove_rec := Raw_context.remove_rec;
            Raw_context.T.copy := Raw_context.copy;
            Raw_context.T.fold {_} := Raw_context.fold;
            Raw_context.T.keys := Raw_context.keys;
            Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
            Raw_context.T.project := Raw_context.project;
            Raw_context.T.absolute_key := Raw_context.absolute_key;
            Raw_context.T.consume_gas := Raw_context.consume_gas;
            Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
            Raw_context.T.description := Raw_context.description
          |}))
        (let name := [ &quot;commitments&quot; ] in
        existT (A := unit) (fun _ =&gt; _) tt
          {|
            Storage_sigs.NAME.name := name
          |}) in
    existT (A := Set) _ _ (|functor_result|)))
    (let functor_result :=
      Make_index (existT (A := Set) _ _ (|Blinded_public_key_hash.Index|)) in
    existT (A := [Set ** Set -&gt; Set]) _ [_, _] (|functor_result|)))
    (existT (A := Set) _ _
      {|
        Storage_sigs.VALUE.encoding := Tez_repr.encoding
      |}).

Module Ramp_up.
  Definition Rewards :=
    ((Storage_functors.Make_indexed_data_storage
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _
            {|
              Raw_context.T.mem := Raw_context.mem;
              Raw_context.T.dir_mem := Raw_context.dir_mem;
              Raw_context.T.get := Raw_context.get;
              Raw_context.T.get_option := Raw_context.get_option;
              Raw_context.T.init := Raw_context.init;
              Raw_context.T.set := Raw_context.set;
              Raw_context.T.init_set := Raw_context.init_set;
              Raw_context.T.set_option := Raw_context.set_option;
              Raw_context.T.delete := Raw_context.delete;
              Raw_context.T.remove := Raw_context.remove;
              Raw_context.T.remove_rec := Raw_context.remove_rec;
              Raw_context.T.copy := Raw_context.copy;
              Raw_context.T.fold {_} := Raw_context.fold;
              Raw_context.T.keys := Raw_context.keys;
              Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
              Raw_context.T.project := Raw_context.project;
              Raw_context.T.absolute_key := Raw_context.absolute_key;
              Raw_context.T.consume_gas := Raw_context.consume_gas;
              Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
              Raw_context.T.description := Raw_context.description
            |}))
          (let name := [ &quot;ramp_up&quot;; &quot;rewards&quot; ] in
          existT (A := unit) (fun _ =&gt; _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result :=
        Make_index (existT (A := Set) _ _ (|Cycle_repr.Index|)) in
      existT (A := [Set ** Set -&gt; Set]) _ [_, _] (|functor_result|)))
      (let t : Set := Tez_repr.t * Tez_repr.t in
      let encoding := Data_encoding.tup2 Tez_repr.encoding Tez_repr.encoding in
      existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := encoding
        |}).
  
  Definition Security_deposits :=
    ((Storage_functors.Make_indexed_data_storage
      (let functor_result :=
        ((Storage_functors.Make_subcontext
          (existT (A := unit) (fun _ =&gt; _) tt (|Storage_functors.Registered|)))
          (existT (A := Set) _ _
            {|
              Raw_context.T.mem := Raw_context.mem;
              Raw_context.T.dir_mem := Raw_context.dir_mem;
              Raw_context.T.get := Raw_context.get;
              Raw_context.T.get_option := Raw_context.get_option;
              Raw_context.T.init := Raw_context.init;
              Raw_context.T.set := Raw_context.set;
              Raw_context.T.init_set := Raw_context.init_set;
              Raw_context.T.set_option := Raw_context.set_option;
              Raw_context.T.delete := Raw_context.delete;
              Raw_context.T.remove := Raw_context.remove;
              Raw_context.T.remove_rec := Raw_context.remove_rec;
              Raw_context.T.copy := Raw_context.copy;
              Raw_context.T.fold {_} := Raw_context.fold;
              Raw_context.T.keys := Raw_context.keys;
              Raw_context.T.fold_keys {_} := Raw_context.fold_keys;
              Raw_context.T.project := Raw_context.project;
              Raw_context.T.absolute_key := Raw_context.absolute_key;
              Raw_context.T.consume_gas := Raw_context.consume_gas;
              Raw_context.T.check_enough_gas := Raw_context.check_enough_gas;
              Raw_context.T.description := Raw_context.description
            |}))
          (let name := [ &quot;ramp_up&quot;; &quot;deposits&quot; ] in
          existT (A := unit) (fun _ =&gt; _) tt
            {|
              Storage_sigs.NAME.name := name
            |}) in
      existT (A := Set) _ _ (|functor_result|)))
      (let functor_result :=
        Make_index (existT (A := Set) _ _ (|Cycle_repr.Index|)) in
      existT (A := [Set ** Set -&gt; Set]) _ [_, _] (|functor_result|)))
      (let t : Set := Tez_repr.t * Tez_repr.t in
      let encoding := Data_encoding.tup2 Tez_repr.encoding Tez_repr.encoding in
      existT (A := Set) _ _
        {|
          Storage_sigs.VALUE.encoding := encoding
        |}).
End Ramp_up.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="storage.mli">
  <div style="margin: 20px;">
    <h3>Storage_mli</h3>
    <ul>
      <li>OCaml size: 398 lines</li>
      <li>Coq size: 338 lines (-16% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#storage.mli"><code>storage.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Tezos Protocol Implementation - Typed storage

    This module hides the hierarchical (key x value) database under
    pre-allocated typed accessors for all persistent entities of the
    tezos context.

    This interface enforces no invariant on the contents of the
    database. Its goal is to centralize all accessors in order to have
    a complete view over the database contents and avoid key
    collisions. *)

open Storage_sigs

module Block_priority : sig
  val get : Raw_context.t -&gt; int tzresult Lwt.t

  val set : Raw_context.t -&gt; int -&gt; Raw_context.t tzresult Lwt.t

  val init : Raw_context.t -&gt; int -&gt; Raw_context.t tzresult Lwt.t
end

module Roll : sig
  (** Storage from this submodule must only be accessed through the
      module `Roll`. *)

  module Owner :
    Indexed_data_snapshotable_storage
      with type key = Roll_repr.t
       and type snapshot = Cycle_repr.t * int
       and type value = Signature.Public_key.t
       and type t := Raw_context.t

  val clear : Raw_context.t -&gt; Raw_context.t Lwt.t

  (** The next roll to be allocated. *)
  module Next :
    Single_data_storage
      with type value = Roll_repr.t
       and type t := Raw_context.t

  (** Rolls linked lists represent both account owned and free rolls.
      All rolls belongs either to the limbo list or to an owned list. *)

  (** Head of the linked list of rolls in limbo *)
  module Limbo :
    Single_data_storage
      with type value = Roll_repr.t
       and type t := Raw_context.t

  (** Rolls associated to contracts, a linked list per contract *)
  module Delegate_roll_list :
    Indexed_data_storage
      with type key = Signature.Public_key_hash.t
       and type value = Roll_repr.t
       and type t := Raw_context.t

  (** Use this to iter on a linked list of rolls *)
  module Successor :
    Indexed_data_storage
      with type key = Roll_repr.t
       and type value = Roll_repr.t
       and type t := Raw_context.t

  (** The tez of a contract that are not assigned to rolls *)
  module Delegate_change :
    Indexed_data_storage
      with type key = Signature.Public_key_hash.t
       and type value = Tez_repr.t
       and type t := Raw_context.t

  (** Index of the randomly selected roll snapshot of a given cycle. *)
  module Snapshot_for_cycle :
    Indexed_data_storage
      with type key = Cycle_repr.t
       and type value = int
       and type t := Raw_context.t

  (** Last roll in the snapshoted roll allocation of a given cycle. *)
  module Last_for_snapshot :
    Indexed_data_storage
      with type key = int
       and type value = Roll_repr.t
       and type t = Raw_context.t * Cycle_repr.t
end

module Contract : sig
  (** Storage from this submodule must only be accessed through the
      module `Contract`. *)

  module Global_counter : sig
    val get : Raw_context.t -&gt; Z.t tzresult Lwt.t

    val set : Raw_context.t -&gt; Z.t -&gt; Raw_context.t tzresult Lwt.t

    val init : Raw_context.t -&gt; Z.t -&gt; Raw_context.t tzresult Lwt.t
  end

  (** The domain of alive contracts *)
  val fold :
    Raw_context.t -&gt;
    init:'a -&gt;
    f:(Contract_repr.t -&gt; 'a -&gt; 'a Lwt.t) -&gt;
    'a Lwt.t

  val list : Raw_context.t -&gt; Contract_repr.t list Lwt.t

  (** All the tez possesed by a contract, including rolls and change *)
  module Balance :
    Indexed_data_storage
      with type key = Contract_repr.t
       and type value = Tez_repr.t
       and type t := Raw_context.t

  (** Frozen balance, see 'delegate_storage.mli' for more explanation.
      Always update `Delegates_with_frozen_balance` accordingly. *)
  module Frozen_deposits :
    Indexed_data_storage
      with type key = Cycle_repr.t
       and type value = Tez_repr.t
       and type t = Raw_context.t * Contract_repr.t

  module Frozen_fees :
    Indexed_data_storage
      with type key = Cycle_repr.t
       and type value = Tez_repr.t
       and type t = Raw_context.t * Contract_repr.t

  module Frozen_rewards :
    Indexed_data_storage
      with type key = Cycle_repr.t
       and type value = Tez_repr.t
       and type t = Raw_context.t * Contract_repr.t

  (** The manager of a contract *)
  module Manager :
    Indexed_data_storage
      with type key = Contract_repr.t
       and type value = Manager_repr.t
       and type t := Raw_context.t

  (** The delegate of a contract, if any. *)
  module Delegate :
    Indexed_data_storage
      with type key = Contract_repr.t
       and type value = Signature.Public_key_hash.t
       and type t := Raw_context.t

  (** All contracts (implicit and originated) that are delegated, if any  *)
  module Delegated :
    Data_set_storage
      with type elt = Contract_repr.t
       and type t = Raw_context.t * Contract_repr.t

  module Inactive_delegate :
    Data_set_storage with type elt = Contract_repr.t and type t = Raw_context.t

  (** The cycle where the delegate should be desactivated. *)
  module Delegate_desactivation :
    Indexed_data_storage
      with type key = Contract_repr.t
       and type value = Cycle_repr.t
       and type t := Raw_context.t

  module Counter :
    Indexed_data_storage
      with type key = Contract_repr.t
       and type value = Z.t
       and type t := Raw_context.t

  module Code :
    Non_iterable_indexed_carbonated_data_storage
      with type key = Contract_repr.t
       and type value = Script_repr.lazy_expr
       and type t := Raw_context.t

  module Storage :
    Non_iterable_indexed_carbonated_data_storage
      with type key = Contract_repr.t
       and type value = Script_repr.lazy_expr
       and type t := Raw_context.t

  (** Current storage space in bytes.
      Includes code, global storage and big map elements. *)
  module Used_storage_space :
    Indexed_data_storage
      with type key = Contract_repr.t
       and type value = Z.t
       and type t := Raw_context.t

  (** Maximal space available without needing to burn new fees. *)
  module Paid_storage_space :
    Indexed_data_storage
      with type key = Contract_repr.t
       and type value = Z.t
       and type t := Raw_context.t
end

module Big_map : sig
  module Next : sig
    val incr : Raw_context.t -&gt; (Raw_context.t * Z.t) tzresult Lwt.t

    val init_with_default_value : Raw_context.t -&gt; Raw_context.t tzresult Lwt.t
  end

  (** The domain of alive big maps *)
  val fold : Raw_context.t -&gt; init:'a -&gt; f:(Z.t -&gt; 'a -&gt; 'a Lwt.t) -&gt; 'a Lwt.t

  val list : Raw_context.t -&gt; Z.t list Lwt.t

  val remove_rec : Raw_context.t -&gt; Z.t -&gt; Raw_context.t Lwt.t

  val copy :
    Raw_context.t -&gt; from:Z.t -&gt; to_:Z.t -&gt; Raw_context.t tzresult Lwt.t

  type key = Raw_context.t * Z.t

  val rpc_arg : Z.t RPC_arg.t

  module Contents :
    Non_iterable_indexed_carbonated_data_storage
      with type key = Script_expr_hash.t
       and type value = Script_repr.expr
       and type t := key

  module Total_bytes :
    Indexed_data_storage
      with type key = Z.t
       and type value = Z.t
       and type t := Raw_context.t

  module Key_type :
    Indexed_data_storage
      with type key = Z.t
       and type value = Script_repr.expr
       and type t := Raw_context.t

  module Value_type :
    Indexed_data_storage
      with type key = Z.t
       and type value = Script_repr.expr
       and type t := Raw_context.t
end

(** Set of all registered delegates. *)
module Delegates :
  Data_set_storage
    with type t := Raw_context.t
     and type elt = Signature.Public_key_hash.t

(** Set of all active delegates with rolls. *)
module Active_delegates_with_rolls :
  Data_set_storage
    with type t := Raw_context.t
     and type elt = Signature.Public_key_hash.t

(** Set of all the delegates with frozen rewards/bonds/fees for a given cycle. *)
module Delegates_with_frozen_balance :
  Data_set_storage
    with type t = Raw_context.t * Cycle_repr.t
     and type elt = Signature.Public_key_hash.t

(** Votes *)

module Vote : sig
  module Current_period_kind :
    Single_data_storage
      with type value = Voting_period_repr.kind
       and type t := Raw_context.t

  (** Participation exponential moving average, in centile of percentage *)
  module Participation_ema :
    Single_data_storage with type value = int32 and type t := Raw_context.t

  module Current_proposal :
    Single_data_storage
      with type value = Protocol_hash.t
       and type t := Raw_context.t

  (** Sum of all rolls of all delegates. *)
  module Listings_size :
    Single_data_storage with type value = int32 and type t := Raw_context.t

  (** Contains all delegates with their assigned number of rolls. *)
  module Listings :
    Indexed_data_storage
      with type key = Signature.Public_key_hash.t
       and type value = int32
       and type t := Raw_context.t

  (** Set of protocol proposal with corresponding proposer delegate *)
  module Proposals :
    Data_set_storage
      with type elt = Protocol_hash.t * Signature.Public_key_hash.t
       and type t := Raw_context.t

  (** Keeps for each delegate the number of proposed protocols *)
  module Proposals_count :
    Indexed_data_storage
      with type key = Signature.Public_key_hash.t
       and type value = int
       and type t := Raw_context.t

  (** Contains for each delegate its ballot *)
  module Ballots :
    Indexed_data_storage
      with type key = Signature.Public_key_hash.t
       and type value = Vote_repr.ballot
       and type t := Raw_context.t
end

(** Seed *)

type unrevealed_nonce = {
  nonce_hash : Nonce_hash.t;
  delegate : Signature.Public_key_hash.t;
  rewards : Tez_repr.t;
  fees : Tez_repr.t;
}

type nonce_status =
  | Unrevealed of unrevealed_nonce
  | Revealed of Seed_repr.nonce

module type For_cycle_sig = sig
  val init :
    Raw_context.t -&gt;
    Cycle_repr.t -&gt;
    Seed_repr.seed -&gt;
    Raw_context.t tzresult Lwt.t

  val get : Raw_context.t -&gt; Cycle_repr.t -&gt; Seed_repr.seed tzresult Lwt.t

  val delete : Raw_context.t -&gt; Cycle_repr.t -&gt; Raw_context.t tzresult Lwt.t
end

module Seed : sig
  (** Storage from this submodule must only be accessed through the
      module `Seed`. *)

  module Nonce :
    Non_iterable_indexed_data_storage
      with type key := Level_repr.t
       and type value := nonce_status
       and type t := Raw_context.t

  module For_cycle : For_cycle_sig
end

(** Commitments *)

module Commitments :
  Indexed_data_storage
    with type key = Blinded_public_key_hash.t
     and type value = Tez_repr.t
     and type t := Raw_context.t

(** Ramp up security deposits... *)

module Ramp_up : sig
  module Rewards :
    Indexed_data_storage
      with type key = Cycle_repr.t
       and type value = Tez_repr.t * Tez_repr.t
      (* baking * endorsement *)
       and type t := Raw_context.t

  module Security_deposits :
    Indexed_data_storage
      with type key = Cycle_repr.t
       and type value = Tez_repr.t * Tez_repr.t
      (* baking * endorsement *)
       and type t := Raw_context.t
end
</pre>
  </div>
  <div class="col-md-6">
    <a href="#storage.mli"><code>Storage_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Blinded_public_key_hash.
Require Tezos.Contract_repr.
Require Tezos.Cycle_repr.
Require Tezos.Level_repr.
Require Tezos.Manager_repr.
Require Tezos.Nonce_hash.
Require Tezos.Raw_context.
Require Tezos.Roll_repr.
Require Tezos.Script_expr_hash.
Require Tezos.Script_repr.
Require Tezos.Seed_repr.
Require Tezos.Storage_sigs.
Require Tezos.Tez_repr.
Require Tezos.Vote_repr.
Require Tezos.Voting_period_repr.

Import Storage_sigs.

Module Block_priority.
  Parameter get : Raw_context.t -&gt; Lwt.t (Error_monad.tzresult int).
  
  Parameter set :
    Raw_context.t -&gt; int -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).
  
  Parameter init :
    Raw_context.t -&gt; int -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).
End Block_priority.

Module Roll.
  Parameter Owner :
    {_ : unit &amp;
      Indexed_data_snapshotable_storage.signature
        (snapshot := (Cycle_repr.t * int)) (key := Roll_repr.t)
        (t := Raw_context.t)
        (value := (|Signature.Public_key|).(S.SPublic_key.t))}.
  
  Parameter clear : Raw_context.t -&gt; Lwt.t Raw_context.t.
  
  Parameter Next :
    {_ : unit &amp;
      Single_data_storage.signature (t := Raw_context.t) (value := Roll_repr.t)}.
  
  Parameter Limbo :
    {_ : unit &amp;
      Single_data_storage.signature (t := Raw_context.t) (value := Roll_repr.t)}.
  
  Parameter Delegate_roll_list :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := Raw_context.t)
        (key := (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
        (value := Roll_repr.t)}.
  
  Parameter Successor :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := Raw_context.t) (key := Roll_repr.t)
        (value := Roll_repr.t)}.
  
  Parameter Delegate_change :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := Raw_context.t)
        (key := (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
        (value := Tez_repr.t)}.
  
  Parameter Snapshot_for_cycle :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := Raw_context.t) (key := Cycle_repr.t)
        (value := int)}.
  
  Parameter Last_for_snapshot :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := (Raw_context.t * Cycle_repr.t))
        (key := int) (value := Roll_repr.t)}.
End Roll.

Module Contract.
  Module Global_counter.
    Parameter get : Raw_context.t -&gt; Lwt.t (Error_monad.tzresult Z.t).
    
    Parameter set :
      Raw_context.t -&gt; Z.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).
    
    Parameter init :
      Raw_context.t -&gt; Z.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).
  End Global_counter.
  
  Parameter fold : forall {a : Set},
    Raw_context.t -&gt; a -&gt; (Contract_repr.t -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a.
  
  Parameter __list_value : Raw_context.t -&gt; Lwt.t (list Contract_repr.t).
  
  Parameter Balance :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := Raw_context.t)
        (key := Contract_repr.t) (value := Tez_repr.t)}.
  
  Parameter Frozen_deposits :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := (Raw_context.t * Contract_repr.t))
        (key := Cycle_repr.t) (value := Tez_repr.t)}.
  
  Parameter Frozen_fees :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := (Raw_context.t * Contract_repr.t))
        (key := Cycle_repr.t) (value := Tez_repr.t)}.
  
  Parameter Frozen_rewards :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := (Raw_context.t * Contract_repr.t))
        (key := Cycle_repr.t) (value := Tez_repr.t)}.
  
  Parameter Manager :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := Raw_context.t)
        (key := Contract_repr.t) (value := Manager_repr.t)}.
  
  Parameter Delegate :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := Raw_context.t)
        (key := Contract_repr.t)
        (value := (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))}.
  
  Parameter Delegated :
    {_ : unit &amp;
      Data_set_storage.signature (t := (Raw_context.t * Contract_repr.t))
        (elt := Contract_repr.t)}.
  
  Parameter Inactive_delegate :
    {_ : unit &amp;
      Data_set_storage.signature (t := Raw_context.t) (elt := Contract_repr.t)}.
  
  Parameter Delegate_desactivation :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := Raw_context.t)
        (key := Contract_repr.t) (value := Cycle_repr.t)}.
  
  Parameter Counter :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := Raw_context.t)
        (key := Contract_repr.t) (value := Z.t)}.
  
  Parameter Code :
    {_ : unit &amp;
      Non_iterable_indexed_carbonated_data_storage.signature
        (t := Raw_context.t) (key := Contract_repr.t)
        (value := Script_repr.lazy_expr)}.
  
  Parameter Storage :
    {_ : unit &amp;
      Non_iterable_indexed_carbonated_data_storage.signature
        (t := Raw_context.t) (key := Contract_repr.t)
        (value := Script_repr.lazy_expr)}.
  
  Parameter Used_storage_space :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := Raw_context.t)
        (key := Contract_repr.t) (value := Z.t)}.
  
  Parameter Paid_storage_space :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := Raw_context.t)
        (key := Contract_repr.t) (value := Z.t)}.
End Contract.

Module Big_map.
  Module Next.
    Parameter incr :
      Raw_context.t -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * Z.t)).
    
    Parameter init_with_default_value :
      Raw_context.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).
  End Next.
  
  Parameter fold : forall {a : Set},
    Raw_context.t -&gt; a -&gt; (Z.t -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a.
  
  Parameter __list_value : Raw_context.t -&gt; Lwt.t (list Z.t).
  
  Parameter remove_rec : Raw_context.t -&gt; Z.t -&gt; Lwt.t Raw_context.t.
  
  Parameter copy :
    Raw_context.t -&gt; Z.t -&gt; Z.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).
  
  Definition key : Set := Raw_context.t * Z.t.
  
  Parameter rpc_arg : RPC_arg.t Z.t.
  
  Parameter Contents :
    {_ : unit &amp;
      Non_iterable_indexed_carbonated_data_storage.signature (t := key)
        (key := Script_expr_hash.t) (value := Script_repr.expr)}.
  
  Parameter Total_bytes :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := Raw_context.t) (key := Z.t)
        (value := Z.t)}.
  
  Parameter Key_type :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := Raw_context.t) (key := Z.t)
        (value := Script_repr.expr)}.
  
  Parameter Value_type :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := Raw_context.t) (key := Z.t)
        (value := Script_repr.expr)}.
End Big_map.

Parameter Delegates :
  {_ : unit &amp;
    Data_set_storage.signature (t := Raw_context.t)
      (elt := (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))}.

Parameter Active_delegates_with_rolls :
  {_ : unit &amp;
    Data_set_storage.signature (t := Raw_context.t)
      (elt := (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))}.

Parameter Delegates_with_frozen_balance :
  {_ : unit &amp;
    Data_set_storage.signature (t := (Raw_context.t * Cycle_repr.t))
      (elt := (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))}.

Module Vote.
  Parameter Current_period_kind :
    {_ : unit &amp;
      Single_data_storage.signature (t := Raw_context.t)
        (value := Voting_period_repr.kind)}.
  
  Parameter Participation_ema :
    {_ : unit &amp;
      Single_data_storage.signature (t := Raw_context.t) (value := int32)}.
  
  Parameter Current_proposal :
    {_ : unit &amp;
      Single_data_storage.signature (t := Raw_context.t)
        (value := (|Protocol_hash|).(S.HASH.t))}.
  
  Parameter Listings_size :
    {_ : unit &amp;
      Single_data_storage.signature (t := Raw_context.t) (value := int32)}.
  
  Parameter Listings :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := Raw_context.t)
        (key := (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
        (value := int32)}.
  
  Parameter Proposals :
    {_ : unit &amp;
      Data_set_storage.signature (t := Raw_context.t)
        (elt :=
          ((|Protocol_hash|).(S.HASH.t) *
            (|Signature.Public_key_hash|).(S.SPublic_key_hash.t)))}.
  
  Parameter Proposals_count :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := Raw_context.t)
        (key := (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
        (value := int)}.
  
  Parameter Ballots :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := Raw_context.t)
        (key := (|Signature.Public_key_hash|).(S.SPublic_key_hash.t))
        (value := Vote_repr.ballot)}.
End Vote.

Module unrevealed_nonce.
  Record record : Set := Build {
    nonce_hash : Nonce_hash.t;
    delegate : (|Signature.Public_key_hash|).(S.SPublic_key_hash.t);
    rewards : Tez_repr.t;
    fees : Tez_repr.t }.
  Definition with_nonce_hash nonce_hash (r : record) :=
    Build nonce_hash r.(delegate) r.(rewards) r.(fees).
  Definition with_delegate delegate (r : record) :=
    Build r.(nonce_hash) delegate r.(rewards) r.(fees).
  Definition with_rewards rewards (r : record) :=
    Build r.(nonce_hash) r.(delegate) rewards r.(fees).
  Definition with_fees fees (r : record) :=
    Build r.(nonce_hash) r.(delegate) r.(rewards) fees.
End unrevealed_nonce.
Definition unrevealed_nonce := unrevealed_nonce.record.

Inductive nonce_status : Set :=
| Unrevealed : unrevealed_nonce -&gt; nonce_status
| Revealed : Seed_repr.nonce -&gt; nonce_status.

Module For_cycle_sig.
  Record signature : Set := {
    init :
      Raw_context.t -&gt; Cycle_repr.t -&gt; Seed_repr.seed -&gt;
      Lwt.t (Error_monad.tzresult Raw_context.t);
    get :
      Raw_context.t -&gt; Cycle_repr.t -&gt;
      Lwt.t (Error_monad.tzresult Seed_repr.seed);
    delete :
      Raw_context.t -&gt; Cycle_repr.t -&gt;
      Lwt.t (Error_monad.tzresult Raw_context.t);
  }.
End For_cycle_sig.

Module Seed.
  Parameter Nonce :
    {_ : unit &amp;
      Non_iterable_indexed_data_storage.signature (t := Raw_context.t)
        (key := Level_repr.t) (value := nonce_status)}.
  
  Parameter For_cycle : {_ : unit &amp; For_cycle_sig.signature}.
End Seed.

Parameter Commitments :
  {_ : unit &amp;
    Indexed_data_storage.signature (t := Raw_context.t)
      (key := Blinded_public_key_hash.t) (value := Tez_repr.t)}.

Module Ramp_up.
  Parameter Rewards :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := Raw_context.t) (key := Cycle_repr.t)
        (value := (Tez_repr.t * Tez_repr.t))}.
  
  Parameter Security_deposits :
    {_ : unit &amp;
      Indexed_data_storage.signature (t := Raw_context.t) (key := Cycle_repr.t)
        (value := (Tez_repr.t * Tez_repr.t))}.
End Ramp_up.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="storage_description.ml">
  <div style="margin: 20px;">
    <h3>Storage_description</h3>
    <ul>
      <li>OCaml size: 339 lines</li>
      <li>Coq size: 678 lines (+100% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#storage_description.ml"><code>storage_description.ml</code></a>&nbsp;<span class="label label-warning">8 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

module StringMap = Map.Make (String)

type 'key description =
  | Empty : 'key description
  | Value : {
      get : 'key -&gt; 'a option tzresult Lwt.t;
      encoding : 'a Data_encoding.t;
    }
      -&gt; 'key description
  | NamedDir : 'key t StringMap.t -&gt; 'key description
  | IndexedDir : {
      arg : 'a RPC_arg.t;
      arg_encoding : 'a Data_encoding.t;
      list : 'key -&gt; 'a list tzresult Lwt.t;
      subdir : ('key * 'a) t;
    }
      -&gt; 'key description

and 'key t = 'key description ref

let rec register_named_subcontext : type r. r t -&gt; string list -&gt; r t =
 fun dir names -&gt;
  match (!dir, names) with
  | (_, []) -&gt;
      dir
  | (Value _, _) -&gt;
      invalid_arg &quot;&quot;
  | (IndexedDir _, _) -&gt;
      invalid_arg &quot;&quot;
  | (Empty, name :: names) -&gt;
      let subdir = ref Empty in
      <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">dir := NamedDir (StringMap.singleton name subdir)</abbr> ;
      register_named_subcontext subdir names
  | (NamedDir map, name :: names) -&gt;
      let subdir =
        match StringMap.find_opt name map with
        | Some subdir -&gt;
            subdir
        | None -&gt;
            let subdir = ref Empty in
            <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">dir := NamedDir (StringMap.add name subdir map)</abbr> ;
            subdir
      in
      register_named_subcontext subdir names

type (_, _, _) args =
  | One : {
      rpc_arg : 'a RPC_arg.t;
      encoding : 'a Data_encoding.t;
      compare : 'a -&gt; 'a -&gt; int;
    }
      -&gt; ('key, 'a, 'key * 'a) args
  | Pair :
      ('key, 'a, 'inter_key) args * ('inter_key, 'b, 'sub_key) args
      -&gt; ('key, 'a * 'b, 'sub_key) args

let rec unpack : type a b c. (a, b, c) args -&gt; c -&gt; a * b =
 fun v x -&gt;
  match[@coq_match_gadt_with_result] v with
  | One _ -&gt;
      x
  | Pair (l, r) -&gt;
      let (c, d) = (unpack [@coq_implicit &quot;(a := unit) (b := unit)&quot;]) r x in
      let (b, a) = (unpack [@coq_implicit &quot;(a := unit) (b := unit)&quot;]) l c in
      (b, (a, d))

let rec pack : type a b c. (a, b, c) args -&gt; a -&gt; b -&gt; c =
 fun v x y -&gt;
  match[@coq_match_gadt_with_result] (v, y) with
  | (One _, _) -&gt;
      (x, y)
  | (Pair (l, r), (y : _ * _)) -&gt;
      let (a, d) = y in
      let c = (pack [@coq_implicit &quot;(c := unit)&quot;]) l x a in
      (pack [@coq_implicit &quot;(c := unit)&quot;]) r c d

let rec compare : type a b c. (a, b, c) args -&gt; b -&gt; b -&gt; int =
 fun v x1 x2 -&gt;
  match[@coq_match_gadt] (v, x1, x2) with
  | (One {compare = compare'; _}, _, _) -&gt;
      compare' x1 x2
  | (Pair (l, r), (x1 : _ * _), (x2 : _ * _)) -&gt; (
      let (a1, b1) = x1 in
      let (a2, b2) = x2 in
      match compare l a1 a2 with 0 -&gt; compare r b1 b2 | x -&gt; x )

let destutter equal l =
  match l with
  | [] -&gt;
      []
  | (i, _) :: l -&gt;
      let rec loop acc i = function
        | [] -&gt;
            acc
        | (j, _) :: l -&gt;
            if equal i j then loop acc i l else loop (j :: acc) j l
      in
      loop [i] i l

let rec register_indexed_subcontext :
    type r a b.
    r t -&gt; list:(r -&gt; a list tzresult Lwt.t) -&gt; (r, a, b) args -&gt; b t =
 fun dir ~list path -&gt;
  match[@coq_match_gadt] (path, list) with
  | (Pair (left, right), (list : _ -&gt; (_ * _) list tzresult Lwt.t)) -&gt;
      let compare_left = compare left in
      let equal_left x y = Compare.Int.(compare_left x y = 0) in
      let list_left r = list r &gt;&gt;=? fun l -&gt; return (destutter equal_left l) in
      register_indexed_subcontext
        (register_indexed_subcontext dir ~list:list_left left)
        ~list:(fun r -&gt;
          let (a, k) = (unpack [@coq_implicit &quot;(c := unit)&quot;]) left r in
          list a
          &gt;&gt;=? fun l -&gt;
          return (List.map snd (List.filter (fun (x, _) -&gt; equal_left x k) l)))
        right
  | (One {rpc_arg = arg; encoding = arg_encoding; _}, _) -&gt; (
    match !dir with
    | Value _ -&gt;
        invalid_arg &quot;&quot;
    | NamedDir _ -&gt;
        invalid_arg &quot;&quot;
    | Empty -&gt;
        let subdir = ref Empty in
        <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">dir := IndexedDir {arg; arg_encoding; list; subdir}</abbr> ;
        subdir
    | IndexedDir {arg = inner_arg; subdir; _} -&gt; (
      match[@coq_match_gadt_with_result] RPC_arg.eq arg inner_arg with
      | None -&gt;
          (invalid_arg [@coq_implicit &quot;(a := t b)&quot;]) &quot;&quot;
      | Some RPC_arg.Eq -&gt;
          subdir ) )

let register_value :
    type a b.
    a t -&gt; get:(a -&gt; b option tzresult Lwt.t) -&gt; b Data_encoding.t -&gt; unit =
 fun dir ~get encoding -&gt;
  match !dir with Empty -&gt; dir := Value {get; encoding} | _ -&gt; invalid_arg &quot;&quot;

let create () = ref Empty

let rec pp : type a. Format.formatter -&gt; a t -&gt; unit =
 fun ppf dir -&gt;
  match !dir with
  | Empty -&gt;
      Format.fprintf ppf &quot;EMPTY&quot;
  | Value _e -&gt;
      Format.fprintf ppf &quot;Value&quot;
  | NamedDir map -&gt;
      Format.fprintf
        ppf
        &quot;@[&lt;v&gt;%a@]&quot;
        (Format.pp_print_list pp_item)
        (StringMap.bindings map)
  | IndexedDir {arg; subdir; _} -&gt;
      let name = Format.asprintf &quot;&lt;%s&gt;&quot; (RPC_arg.descr arg).name in
      pp_item ppf (name, subdir)

and pp_item : type a. Format.formatter -&gt; string * a t -&gt; unit =
 fun ppf (name, dir) -&gt; Format.fprintf ppf &quot;@[&lt;v 2&gt;%s@ %a@]&quot; name pp dir

module type INDEX = sig
  type t

  val path_length : int

  val to_path : t -&gt; string list -&gt; string list

  val of_path : string list -&gt; t option

  val rpc_arg : t RPC_arg.t

  val encoding : t Data_encoding.t

  val compare : t -&gt; t -&gt; int
end

type _ handler =
  | Handler : {
      encoding : 'a Data_encoding.t;
      get : 'key -&gt; int -&gt; 'a tzresult Lwt.t;
    }
      -&gt; 'key handler

type _ opt_handler =
  | Opt_handler : {
      encoding : 'a Data_encoding.t;
      get : 'key -&gt; int -&gt; 'a option tzresult Lwt.t;
    }
      -&gt; 'key opt_handler

let rec combine_object = function
  | [] -&gt;
      Handler {encoding = Data_encoding.unit; get = (fun _ _ -&gt; return_unit)}
  | (name, Opt_handler handler) :: fields -&gt; (
    match combine_object fields with
    | Handler handlers -&gt;
        Handler
          {
            encoding =
              Data_encoding.merge_objs
                Data_encoding.(obj1 (opt name (dynamic_size handler.encoding)))
                handlers.encoding;
            get =
              (fun k i -&gt;
                handler.get k i
                &gt;&gt;=? fun v1 -&gt; handlers.get k i &gt;&gt;=? fun v2 -&gt; return (v1, v2));
          } )

type query = {depth : int}

let depth_query =
  let open RPC_query in
  query (fun depth -&gt; {depth})
  |+ field &quot;depth&quot; RPC_arg.int 0 (fun t -&gt; t.depth)
  |&gt; seal

let build_directory : type key. key t -&gt; key RPC_directory.t =
 fun dir -&gt;
  let rpc_dir = ref (RPC_directory.empty : key RPC_directory.t) in
  let register : type ikey. (key, ikey) RPC_path.t -&gt; ikey opt_handler -&gt; unit
      =
   fun path -&gt; function
    | Opt_handler {encoding; get} -&gt;
        let service =
          RPC_service.get_service ~query:depth_query ~output:encoding path
        in
        rpc_dir :=
          RPC_directory.register !rpc_dir service (fun k q () -&gt;
              get k (q.depth + 1)
              &gt;&gt;=? function None -&gt; raise <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Not_found</abbr> | Some x -&gt; return x)
  in
  let rec build_handler :
      type ikey. ikey t -&gt; (key, ikey) RPC_path.t -&gt; ikey opt_handler =
   fun dir path -&gt;
    match !dir with
    | Empty -&gt;
        Opt_handler
          {encoding = Data_encoding.unit; get = (fun _ _ -&gt; return_none)}
    | Value {get; encoding} -&gt;
        let handler =
          Opt_handler
            {
              encoding;
              get =
                (fun k i -&gt; if Compare.Int.(i &lt; 0) then return_none else get k);
            }
        in
        <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register path handler</abbr> ; handler
    | NamedDir map -&gt;
        let fields = StringMap.bindings map in
        let fields =
          List.map
            (fun (name, dir) -&gt;
              (name, build_handler dir RPC_path.(path / name)))
            fields
        in
        let (Handler handler) = combine_object fields in
        let handler =
          Opt_handler
            {
              encoding = handler.encoding;
              get =
                (fun k i -&gt;
                  if Compare.Int.(i &lt; 0) then return_none
                  else handler.get k (i - 1) &gt;&gt;=? fun v -&gt; return_some v);
            }
        in
        <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register path handler</abbr> ; handler
    | IndexedDir {arg; arg_encoding; list; subdir} -&gt; (
      match build_handler subdir RPC_path.(path /: arg) with
      | Opt_handler handler -&gt;
          let encoding =
            let open Data_encoding in
            union
              [ case
                  (Tag 0)
                  ~title:&quot;Leaf&quot;
                  (dynamic_size arg_encoding)
                  (function (key, None) -&gt; Some key | _ -&gt; None)
                  (fun key -&gt; (key, None));
                case
                  (Tag 1)
                  ~title:&quot;Dir&quot;
                  (tup2
                     (dynamic_size arg_encoding)
                     (dynamic_size handler.encoding))
                  (function
                    | (key, Some value) -&gt; Some (key, value) | _ -&gt; None)
                  (fun (key, value) -&gt; (key, Some value)) ]
          in
          let get k i =
            if Compare.Int.(i &lt; 0) then return_none
            else if Compare.Int.(i = 0) then return_some []
            else
              list k
              &gt;&gt;=? fun keys -&gt;
              map_s
                (fun key -&gt;
                  if Compare.Int.(i = 1) then return (key, None)
                  else
                    handler.get (k, key) (i - 1)
                    &gt;&gt;=? fun value -&gt; return (key, value))
                keys
              &gt;&gt;=? fun values -&gt; return_some values
          in
          let handler =
            Opt_handler
              {encoding = Data_encoding.(list (dynamic_size encoding)); get}
          in
          <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register path handler</abbr> ; handler )
  in
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">ignore (build_handler dir RPC_path.open_root : key opt_handler)</abbr> ;
  !rpc_dir
</pre>
  </div>
  <div class="col-md-6">
    <a href="#storage_description.ml"><code>Storage_description.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.
Unset Positivity Checking.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.

Definition StringMap :=
  Map.Make
    (existT (A := Set) _ _
      {|
        Compare.COMPARABLE.compare := String.compare
      |}).

Module ConstructorRecords_description.
  Module description.
    Module Value.
      Record record {get encoding : Set} : Set := Build {
        get : get;
        encoding : encoding }.
      Arguments record : clear implicits.
      Definition with_get {t_get t_encoding} get
        (r : record t_get t_encoding) :=
        Build t_get t_encoding get r.(encoding).
      Definition with_encoding {t_get t_encoding} encoding
        (r : record t_get t_encoding) :=
        Build t_get t_encoding r.(get) encoding.
    End Value.
    Definition Value_skeleton := Value.record.
    
    Module IndexedDir.
      Record record {arg arg_encoding list subdir : Set} : Set := Build {
        arg : arg;
        arg_encoding : arg_encoding;
        list : list;
        subdir : subdir }.
      Arguments record : clear implicits.
      Definition with_arg {t_arg t_arg_encoding t_list t_subdir} arg
        (r : record t_arg t_arg_encoding t_list t_subdir) :=
        Build t_arg t_arg_encoding t_list t_subdir arg r.(arg_encoding) r.(list)
          r.(subdir).
      Definition with_arg_encoding {t_arg t_arg_encoding t_list t_subdir}
        arg_encoding (r : record t_arg t_arg_encoding t_list t_subdir) :=
        Build t_arg t_arg_encoding t_list t_subdir r.(arg) arg_encoding r.(list)
          r.(subdir).
      Definition with_list {t_arg t_arg_encoding t_list t_subdir} list
        (r : record t_arg t_arg_encoding t_list t_subdir) :=
        Build t_arg t_arg_encoding t_list t_subdir r.(arg) r.(arg_encoding) list
          r.(subdir).
      Definition with_subdir {t_arg t_arg_encoding t_list t_subdir} subdir
        (r : record t_arg t_arg_encoding t_list t_subdir) :=
        Build t_arg t_arg_encoding t_list t_subdir r.(arg) r.(arg_encoding)
          r.(list) subdir.
    End IndexedDir.
    Definition IndexedDir_skeleton := IndexedDir.record.
  End description.
End ConstructorRecords_description.
Import ConstructorRecords_description.

Reserved Notation &quot;'description.Value&quot;.
Reserved Notation &quot;'description.IndexedDir&quot;.
Reserved Notation &quot;'t&quot;.

Inductive description (key : Set) : Set :=
| Empty : description key
| Value : forall {a : Set}, 'description.Value a key -&gt; description key
| NamedDir : (|StringMap|).(S.MAP.t) ('t key) -&gt; description key
| IndexedDir : forall {a : Set},
  'description.IndexedDir a key -&gt; description key

where &quot;'t&quot; := (fun (t_key : Set) =&gt; Pervasives.ref (description t_key))
and &quot;'description.Value&quot; := (fun (t_a t_key : Set) =&gt;
  description.Value_skeleton
    (t_key -&gt; Lwt.t (Error_monad.tzresult (option t_a))) (Data_encoding.t t_a))
and &quot;'description.IndexedDir&quot; := (fun (t_a t_key : Set) =&gt;
  description.IndexedDir_skeleton (RPC_arg.t t_a) (Data_encoding.t t_a)
    (t_key -&gt; Lwt.t (Error_monad.tzresult (list t_a))) ('t (t_key * t_a))).

Module description.
  Include ConstructorRecords_description.description.
  Definition Value := 'description.Value.
  Definition IndexedDir := 'description.IndexedDir.
End description.

Definition t := 't.

Arguments Empty {_}.
Arguments Value {_ _}.
Arguments NamedDir {_}.
Arguments IndexedDir {_ _}.

Fixpoint register_named_subcontext {r : Set} (dir : t r) (names : list string)
  {struct dir} : t r :=
  match ((Pervasives.op_exclamation dir), names) with
  | (_, []) =&gt; dir
  | (Value _, _) =&gt; Pervasives.invalid_arg &quot;&quot;
  | (IndexedDir _, _) =&gt; Pervasives.invalid_arg &quot;&quot;
  | (Empty, cons name names) =&gt;
    let subdir := Pervasives.__ref_value Empty in
    (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
    (* ‚ùå instruction_sequence &quot;;&quot; *)
    register_named_subcontext subdir names
  | (NamedDir map, cons name names) =&gt;
    let subdir :=
      match (|StringMap|).(S.MAP.find_opt) name map with
      | Some subdir =&gt; subdir
      | None =&gt;
        let subdir := Pervasives.__ref_value Empty in
        (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
        (* ‚ùå instruction_sequence &quot;;&quot; *)
        subdir
      end in
    register_named_subcontext subdir names
  end.

Module ConstructorRecords_args.
  Module args.
    Module One.
      Record record {rpc_arg encoding compare : Set} : Set := Build {
        rpc_arg : rpc_arg;
        encoding : encoding;
        compare : compare }.
      Arguments record : clear implicits.
      Definition with_rpc_arg {t_rpc_arg t_encoding t_compare} rpc_arg
        (r : record t_rpc_arg t_encoding t_compare) :=
        Build t_rpc_arg t_encoding t_compare rpc_arg r.(encoding) r.(compare).
      Definition with_encoding {t_rpc_arg t_encoding t_compare} encoding
        (r : record t_rpc_arg t_encoding t_compare) :=
        Build t_rpc_arg t_encoding t_compare r.(rpc_arg) encoding r.(compare).
      Definition with_compare {t_rpc_arg t_encoding t_compare} compare
        (r : record t_rpc_arg t_encoding t_compare) :=
        Build t_rpc_arg t_encoding t_compare r.(rpc_arg) r.(encoding) compare.
    End One.
    Definition One_skeleton := One.record.
  End args.
End ConstructorRecords_args.
Import ConstructorRecords_args.

Reserved Notation &quot;'args.One&quot;.

Inductive args : Set :=
| One : forall {a : Set}, 'args.One a -&gt; args
| Pair : args -&gt; args -&gt; args

where &quot;'args.One&quot; := (fun (t_a : Set) =&gt;
  args.One_skeleton (RPC_arg.t t_a) (Data_encoding.t t_a) (t_a -&gt; t_a -&gt; int)).

Module args.
  Include ConstructorRecords_args.args.
  Definition One := 'args.One.
End args.

Fixpoint unpack {a b c : Set} (v : args) (x : c) {struct v} : a * b :=
  match v with
  | One _ =&gt; cast (a * b) x
  | Pair l __r_value =&gt;
    let '[l, __r_value] := cast [args ** args] [l, __r_value] in
    cast (a * b)
    (let '(c, d) := (unpack (a := unit) (b := unit)) __r_value x in
    let '(__b_value, __a_value) := (unpack (a := unit) (b := unit)) l c in
    (__b_value, (__a_value, d)))
  end.

Fixpoint __pack {a b c : Set} (v : args) (x : a) (y : b) {struct v} : c :=
  match (v, y) with
  | (One _, _) =&gt; cast c (x, y)
  | (Pair l __r_value, _ as y) =&gt;
    let 'existT _ [__0, __1] [l, __r_value, y] :=
      cast_exists (Es := [Set ** Set])
        (fun '[__0, __1] =&gt; [args ** args ** __0 * __1]) [l, __r_value, y] in
    cast c
    (let '(__a_value, d) := y in
    let c := (__pack (c := unit)) l x __a_value in
    (__pack (c := unit)) __r_value c d)
  end.

Fixpoint compare {b : Set} (v : args) (x1 : b) (x2 : b) {struct v} : int :=
  match (v, x1, x2) with
  | (One {| args.One.compare := compare' |}, _, _) =&gt;
    let compare' := cast (b -&gt; b -&gt; int) compare' in
    compare' x1 x2
  | (Pair l __r_value, _ as x1, _ as x2) =&gt;
    let 'existT _ [__0, __1] [l, __r_value, x1, x2] :=
      cast_exists (Es := [Set ** Set])
        (fun '[__0, __1] =&gt; [args ** args ** __0 * __1 ** __0 * __1])
        [l, __r_value, x1, x2] in
    let '(a1, b1) := x1 in
    let '(a2, b2) := x2 in
    match compare l a1 a2 with
    | 0 =&gt; compare __r_value b1 b2
    | x =&gt; x
    end
  end.

Definition destutter {A B : Set} (equal : A -&gt; A -&gt; bool) (l : list (A * B))
  : list A :=
  match l with
  | [] =&gt; nil
  | cons (i, _) l =&gt;
    let fix loop {C : Set}
      (acc : list A) (i : A) (function_parameter : list (A * C)) {struct acc}
      : list A :=
      match function_parameter with
      | [] =&gt; acc
      | cons (j, _) l =&gt;
        if equal i j then
          loop acc i l
        else
          loop (cons j acc) j l
      end in
    loop [ i ] i l
  end.

Fixpoint register_indexed_subcontext {a b r : Set}
  (dir : t r) (__list_value : r -&gt; Lwt.t (Error_monad.tzresult (list a)))
  (path : args) {struct dir} : t b :=
  match (path, __list_value) with
  | (Pair __left __right, _ as __list_value) =&gt;
    let 'existT _ [__0, __1] [__left, __right, __list_value] :=
      cast_exists (Es := [Set ** Set])
        (fun '[__0, __1] =&gt;
          [args ** args ** r -&gt; Lwt.t (Error_monad.tzresult (list (__0 * __1)))])
        [__left, __right, __list_value] in
    let compare_left := compare __left in
    let equal_left (x : __0) (y : __0) : bool :=
      (|Compare.Int|).(Compare.S.op_eq) (compare_left x y) 0 in
    let list_left (__r_value : r) : Lwt.t (Error_monad.tzresult (list __0)) :=
      let=? l := __list_value __r_value in
      Error_monad.__return (destutter equal_left l) in
    register_indexed_subcontext
      (register_indexed_subcontext dir list_left __left)
      (fun __r_value =&gt;
        let '(__a_value, k) := (unpack (c := unit)) __left __r_value in
        let=? l := __list_value __a_value in
        Error_monad.__return
          (List.map Pervasives.snd
            (List.filter
              (fun function_parameter =&gt;
                let '(x, _) := function_parameter in
                equal_left x k) l))) __right
  | (One {| args.One.rpc_arg := arg; args.One.encoding := arg_encoding |}, _) =&gt;
    let '[arg, arg_encoding] :=
      cast [RPC_arg.t a ** Data_encoding.t a] [arg, arg_encoding] in
    match Pervasives.op_exclamation dir with
    | Value _ =&gt; Pervasives.invalid_arg &quot;&quot;
    | NamedDir _ =&gt; Pervasives.invalid_arg &quot;&quot;
    | Empty =&gt;
      let subdir := Pervasives.__ref_value Empty in
      (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
      (* ‚ùå instruction_sequence &quot;;&quot; *)
      subdir
    |
      IndexedDir {|
        description.IndexedDir.arg := inner_arg;
          description.IndexedDir.subdir := subdir
          |} =&gt;
      let 'existT _ __IndexedDir_'a [inner_arg, subdir] :=
        existT (A := Set)
          (fun __IndexedDir_'a =&gt;
            [RPC_arg.t __IndexedDir_'a ** t (r * __IndexedDir_'a)]) _
          [inner_arg, subdir] in
      match RPC_arg.__eq_value arg inner_arg with
      | None =&gt; cast (t b) ((Pervasives.invalid_arg (a := t b)) &quot;&quot;)
      | Some RPC_arg.Eq =&gt; cast (t b) subdir
      end
    end
  end.

Definition register_value {a b : Set}
  (dir : t a) (get : a -&gt; Lwt.t (Error_monad.tzresult (option b)))
  (encoding : Data_encoding.t b) : unit :=
  match Pervasives.op_exclamation dir with
  | Empty =&gt;
    Pervasives.op_coloneq dir
      (Value
        {| description.Value.get := get; description.Value.encoding := encoding
          |})
  | _ =&gt; Pervasives.invalid_arg &quot;&quot;
  end.

Definition create {A : Set} (function_parameter : unit)
  : Pervasives.ref (description A) :=
  let '_ := function_parameter in
  Pervasives.__ref_value Empty.

Fixpoint pp {a : Set} (ppf : Format.formatter) (dir : t a) {struct ppf}
  : unit :=
  match Pervasives.op_exclamation dir with
  | Empty =&gt;
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;EMPTY&quot;
          CamlinternalFormatBasics.End_of_format) &quot;EMPTY&quot;)
  | Value _e =&gt;
    let 'existT _ __Value_'a _e :=
      existT (A := Set) (fun __Value_'a =&gt; description.Value __Value_'a a) _ _e
      in
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.String_literal &quot;Value&quot;
          CamlinternalFormatBasics.End_of_format) &quot;Value&quot;)
  | NamedDir map =&gt;
    Format.fprintf ppf
      (CamlinternalFormatBasics.Format
        (CamlinternalFormatBasics.Formatting_gen
          (CamlinternalFormatBasics.Open_box
            (CamlinternalFormatBasics.Format
              (CamlinternalFormatBasics.String_literal &quot;&lt;v&gt;&quot;
                CamlinternalFormatBasics.End_of_format) &quot;&lt;v&gt;&quot;))
          (CamlinternalFormatBasics.Alpha
            (CamlinternalFormatBasics.Formatting_lit
              CamlinternalFormatBasics.Close_box
              CamlinternalFormatBasics.End_of_format))) &quot;@[&lt;v&gt;%a@]&quot;)
      (Format.pp_print_list None pp_item) ((|StringMap|).(S.MAP.bindings) map)
  |
    IndexedDir {|
      description.IndexedDir.arg := arg;
        description.IndexedDir.subdir := subdir
        |} =&gt;
    let 'existT _ __IndexedDir_'a [arg, subdir] :=
      existT (A := Set)
        (fun __IndexedDir_'a =&gt;
          [RPC_arg.t __IndexedDir_'a ** t (a * __IndexedDir_'a)]) _
        [arg, subdir] in
    let name :=
      Format.asprintf
        (CamlinternalFormatBasics.Format
          (CamlinternalFormatBasics.Char_literal &quot;&lt;&quot; % char
            (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
              (CamlinternalFormatBasics.Char_literal &quot;&gt;&quot; % char
                CamlinternalFormatBasics.End_of_format))) &quot;&lt;%s&gt;&quot;)
        (RPC_arg.__descr_value arg).(RPC_arg.descr.name) in
    pp_item ppf (name, subdir)
  end

with pp_item {a : Set}
  (ppf : Format.formatter) (function_parameter : string * t a) {struct ppf}
  : unit :=
  let '(name, dir) := function_parameter in
  Format.fprintf ppf
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.Formatting_gen
        (CamlinternalFormatBasics.Open_box
          (CamlinternalFormatBasics.Format
            (CamlinternalFormatBasics.String_literal &quot;&lt;v 2&gt;&quot;
              CamlinternalFormatBasics.End_of_format) &quot;&lt;v 2&gt;&quot;))
        (CamlinternalFormatBasics.String CamlinternalFormatBasics.No_padding
          (CamlinternalFormatBasics.Formatting_lit
            (CamlinternalFormatBasics.Break &quot;@ &quot; 1 0)
            (CamlinternalFormatBasics.Alpha
              (CamlinternalFormatBasics.Formatting_lit
                CamlinternalFormatBasics.Close_box
                CamlinternalFormatBasics.End_of_format))))) &quot;@[&lt;v 2&gt;%s@ %a@]&quot;)
    name pp dir.

Module INDEX.
  Record signature {t : Set} : Set := {
    t := t;
    path_length : int;
    to_path : t -&gt; list string -&gt; list string;
    of_path : list string -&gt; option t;
    rpc_arg : RPC_arg.t t;
    encoding : Data_encoding.t t;
    compare : t -&gt; t -&gt; int;
  }.
End INDEX.

Module ConstructorRecords_handler.
  Module handler.
    Module Handler.
      Record record {encoding get : Set} : Set := Build {
        encoding : encoding;
        get : get }.
      Arguments record : clear implicits.
      Definition with_encoding {t_encoding t_get} encoding
        (r : record t_encoding t_get) :=
        Build t_encoding t_get encoding r.(get).
      Definition with_get {t_encoding t_get} get
        (r : record t_encoding t_get) :=
        Build t_encoding t_get r.(encoding) get.
    End Handler.
    Definition Handler_skeleton := Handler.record.
  End handler.
End ConstructorRecords_handler.
Import ConstructorRecords_handler.

Reserved Notation &quot;'handler.Handler&quot;.

Inductive handler (key : Set) : Set :=
| Handler : forall {a : Set}, 'handler.Handler a key -&gt; handler key

where &quot;'handler.Handler&quot; := (fun (t_a t_key : Set) =&gt;
  handler.Handler_skeleton (Data_encoding.t t_a)
    (t_key -&gt; int -&gt; Lwt.t (Error_monad.tzresult t_a))).

Module handler.
  Include ConstructorRecords_handler.handler.
  Definition Handler := 'handler.Handler.
End handler.

Arguments Handler {_ _}.

Module ConstructorRecords_opt_handler.
  Module opt_handler.
    Module Opt_handler.
      Record record {encoding get : Set} : Set := Build {
        encoding : encoding;
        get : get }.
      Arguments record : clear implicits.
      Definition with_encoding {t_encoding t_get} encoding
        (r : record t_encoding t_get) :=
        Build t_encoding t_get encoding r.(get).
      Definition with_get {t_encoding t_get} get
        (r : record t_encoding t_get) :=
        Build t_encoding t_get r.(encoding) get.
    End Opt_handler.
    Definition Opt_handler_skeleton := Opt_handler.record.
  End opt_handler.
End ConstructorRecords_opt_handler.
Import ConstructorRecords_opt_handler.

Reserved Notation &quot;'opt_handler.Opt_handler&quot;.

Inductive opt_handler (key : Set) : Set :=
| Opt_handler : forall {a : Set},
  'opt_handler.Opt_handler a key -&gt; opt_handler key

where &quot;'opt_handler.Opt_handler&quot; := (fun (t_a t_key : Set) =&gt;
  opt_handler.Opt_handler_skeleton (Data_encoding.t t_a)
    (t_key -&gt; int -&gt; Lwt.t (Error_monad.tzresult (option t_a)))).

Module opt_handler.
  Include ConstructorRecords_opt_handler.opt_handler.
  Definition Opt_handler := 'opt_handler.Opt_handler.
End opt_handler.

Arguments Opt_handler {_ _}.

Fixpoint combine_object {A : Set}
  (function_parameter : list (string * opt_handler A))
  {struct function_parameter} : handler A :=
  match function_parameter with
  | [] =&gt;
    Handler
      {| handler.Handler.encoding := Data_encoding.__unit_value;
        handler.Handler.get :=
          fun function_parameter =&gt;
            let '_ := function_parameter in
            fun function_parameter =&gt;
              let '_ := function_parameter in
              Error_monad.return_unit |}
  | cons (name, Opt_handler __handler_value) fields =&gt;
    let 'existT _ __Opt_handler_'a [name, __handler_value, fields] :=
      existT (A := Set)
        (fun __Opt_handler_'a =&gt;
          [string ** opt_handler.Opt_handler __Opt_handler_'a A **
            list (string * opt_handler A)]) _ [name, __handler_value, fields] in
    let 'Handler handlers := combine_object fields in
    let 'existT _ __Handler_'a handlers :=
      existT (A := Set) (fun __Handler_'a =&gt; handler.Handler __Handler_'a A) _
        handlers in
    Handler
      {|
        handler.Handler.encoding :=
          Data_encoding.merge_objs
            (Data_encoding.obj1
              (Data_encoding.opt None None name
                (Data_encoding.dynamic_size None
                  __handler_value.(opt_handler.Opt_handler.encoding))))
            handlers.(handler.Handler.encoding);
        handler.Handler.get :=
          fun k =&gt;
            fun i =&gt;
              let=? v1 := __handler_value.(opt_handler.Opt_handler.get) k i in
              let=? v2 := handlers.(handler.Handler.get) k i in
              Error_monad.__return (v1, v2) |}
  end.

Module query.
  Record record : Set := Build {
    depth : int }.
  Definition with_depth depth (r : record) :=
    Build depth.
End query.
Definition query := query.record.

Definition depth_query : RPC_query.t query :=
  RPC_query.seal
    (RPC_query.op_pipeplus
      (RPC_query.__query_value (fun depth =&gt; {| query.depth := depth |}))
      (RPC_query.__field_value None &quot;depth&quot; RPC_arg.__int_value 0
        (fun __t_value =&gt; __t_value.(query.depth)))).

Definition build_directory {key : Set} (dir : t key) : RPC_directory.t key :=
  let rpc_dir := Pervasives.__ref_value RPC_directory.empty in
  let register {ikey : Set}
    (path : RPC_path.t key ikey) (function_parameter : opt_handler ikey)
    : unit :=
    let
      'Opt_handler {|
        opt_handler.Opt_handler.encoding := encoding;
          opt_handler.Opt_handler.get := get
          |} := function_parameter in
    let 'existT _ __Opt_handler_'a [encoding, get] :=
      existT (A := Set)
        (fun __Opt_handler_'a =&gt;
          [Data_encoding.t __Opt_handler_'a **
            ikey -&gt; int -&gt;
            Lwt.t (Error_monad.tzresult (option __Opt_handler_'a))]) _
        [encoding, get] in
    let service := RPC_service.get_service None depth_query encoding path in
    Pervasives.op_coloneq rpc_dir
      (RPC_directory.register (Pervasives.op_exclamation rpc_dir) service
        (fun k =&gt;
          fun q =&gt;
            fun function_parameter =&gt;
              let '_ := function_parameter in
              let=? function_parameter :=
                get k (Pervasives.op_plus q.(query.depth) 1) in
              match function_parameter with
              | None =&gt; Pervasives.raise extensible_type_value
              | Some x =&gt; Error_monad.__return x
              end)) in
  let fix build_handler {ikey : Set} (dir : t ikey) (path : RPC_path.t key ikey)
    {struct dir} : opt_handler ikey :=
    match Pervasives.op_exclamation dir with
    | Empty =&gt;
      Opt_handler
        {| opt_handler.Opt_handler.encoding := Data_encoding.__unit_value;
          opt_handler.Opt_handler.get :=
            fun function_parameter =&gt;
              let '_ := function_parameter in
              fun function_parameter =&gt;
                let '_ := function_parameter in
                Error_monad.return_none |}
    |
      Value {|
        description.Value.get := get;
          description.Value.encoding := encoding
          |} =&gt;
      let 'existT _ __Value_'a [get, encoding] :=
        existT (A := Set)
          (fun __Value_'a =&gt;
            [ikey -&gt; Lwt.t (Error_monad.tzresult (option __Value_'a)) **
              Data_encoding.t __Value_'a]) _ [get, encoding] in
      let __handler_value :=
        Opt_handler
          {| opt_handler.Opt_handler.encoding := encoding;
            opt_handler.Opt_handler.get :=
              fun k =&gt;
                fun i =&gt;
                  if (|Compare.Int|).(Compare.S.op_lt) i 0 then
                    Error_monad.return_none
                  else
                    get k |} in
      (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
      (* ‚ùå instruction_sequence &quot;;&quot; *)
      __handler_value
    | NamedDir map =&gt;
      let fields := (|StringMap|).(S.MAP.bindings) map in
      let fields :=
        List.map
          (fun function_parameter =&gt;
            let '(name, dir) := function_parameter in
            (name, (build_handler dir (RPC_path.op_div path name)))) fields in
      let 'Handler __handler_value := combine_object fields in
      let 'existT _ __Handler_'a __handler_value :=
        existT (A := Set)
          (fun __Handler_'a =&gt; handler.Handler __Handler_'a ikey) _
          __handler_value in
      let __handler_value :=
        Opt_handler
          {|
            opt_handler.Opt_handler.encoding :=
              __handler_value.(handler.Handler.encoding);
            opt_handler.Opt_handler.get :=
              fun k =&gt;
                fun i =&gt;
                  if (|Compare.Int|).(Compare.S.op_lt) i 0 then
                    Error_monad.return_none
                  else
                    let=? v :=
                      __handler_value.(handler.Handler.get) k
                        (Pervasives.op_minus i 1) in
                    Error_monad.return_some v |} in
      (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
      (* ‚ùå instruction_sequence &quot;;&quot; *)
      __handler_value
    |
      IndexedDir {|
        description.IndexedDir.arg := arg;
          description.IndexedDir.arg_encoding := arg_encoding;
          description.IndexedDir.list := __list_value;
          description.IndexedDir.subdir := subdir
          |} =&gt;
      let 'existT _ __IndexedDir_'a [arg, arg_encoding, __list_value, subdir] :=
        existT (A := Set)
          (fun __IndexedDir_'a =&gt;
            [RPC_arg.t __IndexedDir_'a ** Data_encoding.t __IndexedDir_'a **
              ikey -&gt; Lwt.t (Error_monad.tzresult (list __IndexedDir_'a)) **
              t (ikey * __IndexedDir_'a)]) _
          [arg, arg_encoding, __list_value, subdir] in
      let 'Opt_handler __handler_value :=
        build_handler subdir (RPC_path.op_divcolon path arg) in
      let 'existT _ __Opt_handler_'a1 __handler_value :=
        existT (A := Set)
          (fun __Opt_handler_'a1 =&gt;
            opt_handler.Opt_handler __Opt_handler_'a1 (ikey * __IndexedDir_'a))
          _ __handler_value in
      let encoding :=
        Data_encoding.union None
          [
            Data_encoding.__case_value &quot;Leaf&quot; None (Data_encoding.Tag 0)
              (Data_encoding.dynamic_size None arg_encoding)
              (fun function_parameter =&gt;
                match function_parameter with
                | (__key_value, None) =&gt; Some __key_value
                | _ =&gt; None
                end) (fun __key_value =&gt; (__key_value, None));
            Data_encoding.__case_value &quot;Dir&quot; None (Data_encoding.Tag 1)
              (Data_encoding.tup2
                (Data_encoding.dynamic_size None arg_encoding)
                (Data_encoding.dynamic_size None
                  __handler_value.(opt_handler.Opt_handler.encoding)))
              (fun function_parameter =&gt;
                match function_parameter with
                | (__key_value, Some value) =&gt;
                  Some (__key_value, value)
                | _ =&gt; None
                end)
              (fun function_parameter =&gt;
                let '(__key_value, value) := function_parameter
                  in
                (__key_value, (Some value)))
          ] in
      let get (k : ikey) (i : (|Compare.Int|).(Compare.S.t))
        : Lwt.t
          (Error_monad.tzresult
            (option (list (__IndexedDir_'a * option __Opt_handler_'a1)))) :=
        if (|Compare.Int|).(Compare.S.op_lt) i 0 then
          Error_monad.return_none
        else
          if (|Compare.Int|).(Compare.S.op_eq) i 0 then
            Error_monad.return_some nil
          else
            let=? keys := __list_value k in
            let=? values :=
              Error_monad.map_s
                (fun __key_value =&gt;
                  if (|Compare.Int|).(Compare.S.op_eq) i 1 then
                    Error_monad.__return (__key_value, None)
                  else
                    let=? value :=
                      __handler_value.(opt_handler.Opt_handler.get)
                        (k, __key_value) (Pervasives.op_minus i 1) in
                    Error_monad.__return (__key_value, value)) keys in
            Error_monad.return_some values in
      let __handler_value :=
        Opt_handler
          {|
            opt_handler.Opt_handler.encoding :=
              Data_encoding.__list_value None
                (Data_encoding.dynamic_size None encoding);
            opt_handler.Opt_handler.get := get |} in
      (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
      (* ‚ùå instruction_sequence &quot;;&quot; *)
      __handler_value
    end in
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  Pervasives.op_exclamation rpc_dir.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="storage_description.mli">
  <div style="margin: 20px;">
    <h3>Storage_description_mli</h3>
    <ul>
      <li>OCaml size: 95 lines</li>
      <li>Coq size: 82 lines (-14% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#storage_description.mli"><code>storage_description.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Typed description of the key-value context. *)
type 'key t

(** Trivial display of the key-value context layout. *)
val pp : Format.formatter -&gt; 'key t -&gt; unit

(** Export an RPC hierarchy for querying the context. There is one service
    by possible path in the context. Services for &quot;directory&quot; are able to
    aggregate in one JSON object the whole subtree. *)
val build_directory : 'key t -&gt; 'key RPC_directory.t

(** Create a empty context description,
    keys will be registred by side effects. *)
val create : unit -&gt; 'key t

(** Register a single key accessor at a given path. *)
val register_value :
  'key t -&gt;
  get:('key -&gt; 'a option tzresult Lwt.t) -&gt;
  'a Data_encoding.t -&gt;
  unit

(** Return a description for a prefixed fragment of the given context.
    All keys registred in the subcontext will be shared by the external
    context *)
val register_named_subcontext : 'key t -&gt; string list -&gt; 'key t

(** Description of an index as a sequence of `RPC_arg.t`. *)
type (_, _, _) args =
  | One : {
      rpc_arg : 'a RPC_arg.t;
      encoding : 'a Data_encoding.t;
      compare : 'a -&gt; 'a -&gt; int;
    }
      -&gt; ('key, 'a, 'key * 'a) args
  | Pair :
      ('key, 'a, 'inter_key) args * ('inter_key, 'b, 'sub_key) args
      -&gt; ('key, 'a * 'b, 'sub_key) args

(** Return a description for a indexed sub-context.
    All keys registred in the subcontext will be shared by the external
    context. One should provide a function to list all the registred
    index in the context. *)
val register_indexed_subcontext :
  'key t -&gt;
  list:('key -&gt; 'arg list tzresult Lwt.t) -&gt;
  ('key, 'arg, 'sub_key) args -&gt;
  'sub_key t

(** Helpers for manipulating and defining indexes. *)

val pack : ('key, 'a, 'sub_key) args -&gt; 'key -&gt; 'a -&gt; 'sub_key

val unpack : ('key, 'a, 'sub_key) args -&gt; 'sub_key -&gt; 'key * 'a

module type INDEX = sig
  type t

  val path_length : int

  val to_path : t -&gt; string list -&gt; string list

  val of_path : string list -&gt; t option

  val rpc_arg : t RPC_arg.t

  val encoding : t Data_encoding.t

  val compare : t -&gt; t -&gt; int
end
</pre>
  </div>
  <div class="col-md-6">
    <a href="#storage_description.mli"><code>Storage_description_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.

Parameter t : forall (key : Set), Set.

Parameter pp : forall {key : Set}, Format.formatter -&gt; t key -&gt; unit.

Parameter build_directory : forall {key : Set}, t key -&gt; RPC_directory.t key.

Parameter create : forall {key : Set}, unit -&gt; t key.

Parameter register_value : forall {a key : Set},
  t key -&gt; (key -&gt; Lwt.t (Error_monad.tzresult (option a))) -&gt;
  Data_encoding.t a -&gt; unit.

Parameter register_named_subcontext : forall {key : Set},
  t key -&gt; list string -&gt; t key.

Module ConstructorRecords_args.
  Module args.
    Module One.
      Record record {rpc_arg encoding compare : Set} : Set := Build {
        rpc_arg : rpc_arg;
        encoding : encoding;
        compare : compare }.
      Arguments record : clear implicits.
      Definition with_rpc_arg {t_rpc_arg t_encoding t_compare} rpc_arg
        (r : record t_rpc_arg t_encoding t_compare) :=
        Build t_rpc_arg t_encoding t_compare rpc_arg r.(encoding) r.(compare).
      Definition with_encoding {t_rpc_arg t_encoding t_compare} encoding
        (r : record t_rpc_arg t_encoding t_compare) :=
        Build t_rpc_arg t_encoding t_compare r.(rpc_arg) encoding r.(compare).
      Definition with_compare {t_rpc_arg t_encoding t_compare} compare
        (r : record t_rpc_arg t_encoding t_compare) :=
        Build t_rpc_arg t_encoding t_compare r.(rpc_arg) r.(encoding) compare.
    End One.
    Definition One_skeleton := One.record.
  End args.
End ConstructorRecords_args.
Import ConstructorRecords_args.

Reserved Notation &quot;'args.One&quot;.

Inductive args : Set :=
| One : forall {a : Set}, 'args.One a -&gt; args
| Pair : args -&gt; args -&gt; args

where &quot;'args.One&quot; := (fun (t_a : Set) =&gt;
  args.One_skeleton (RPC_arg.t t_a) (Data_encoding.t t_a) (t_a -&gt; t_a -&gt; int)).

Module args.
  Include ConstructorRecords_args.args.
  Definition One := 'args.One.
End args.

Parameter register_indexed_subcontext : forall {arg key sub_key : Set},
  t key -&gt; (key -&gt; Lwt.t (Error_monad.tzresult (list arg))) -&gt; args -&gt; t sub_key.

Parameter __pack : forall {a key sub_key : Set}, args -&gt; key -&gt; a -&gt; sub_key.

Parameter unpack : forall {a key sub_key : Set}, args -&gt; sub_key -&gt; key * a.

Module INDEX.
  Record signature {t : Set} : Set := {
    t := t;
    path_length : int;
    to_path : t -&gt; list string -&gt; list string;
    of_path : list string -&gt; option t;
    rpc_arg : RPC_arg.t t;
    encoding : Data_encoding.t t;
    compare : t -&gt; t -&gt; int;
  }.
End INDEX.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="storage_functors.ml">
  <div style="margin: 20px;">
    <h3>Storage_functors</h3>
    <ul>
      <li>OCaml size: 1213 lines</li>
      <li>Coq size: 1915 lines (+57% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#storage_functors.ml"><code>storage_functors.ml</code></a>&nbsp;<span class="label label-warning">22 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Storage_sigs

module Registered = struct
  let ghost = false
end

module Ghost = struct
  let ghost = true
end

module type ENCODER = sig
  type t

  val of_bytes : key:string list -&gt; MBytes.t -&gt; t tzresult

  val to_bytes : t -&gt; MBytes.t
end

module Make_encoder (V : VALUE) : ENCODER with type t := V.t = struct
  let of_bytes ~key b =
    match Data_encoding.Binary.of_bytes V.encoding b with
    | None -&gt;
        error <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Raw_context.Storage_error (Corrupted_data key))</abbr>
    | Some v -&gt;
        Ok v

  let to_bytes v =
    match Data_encoding.Binary.to_bytes V.encoding v with
    | Some b -&gt;
        b
    | None -&gt;
        MBytes.create 0
end

let len_name = &quot;len&quot;

let data_name = &quot;data&quot;

let encode_len_value bytes =
  let length = MBytes.length bytes in
  Data_encoding.(Binary.to_bytes_exn int31) length

let decode_len_value key len =
  match Data_encoding.(Binary.of_bytes int31) len with
  | None -&gt;
      fail <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">(Raw_context.Storage_error (Corrupted_data key))</abbr>
  | Some len -&gt;
      return len

let map_key (f : Context.key -&gt; Context.key) = function
  | `Key k -&gt;
      `Key (f k)
  | `Dir k -&gt;
      `Dir (f k)

module Make_subcontext (R : REGISTER) (C : Raw_context.T) (N : NAME) :
  Raw_context.T with type t = C.t = struct
  type t = C.t

  type context = t

  let name_length = List.length N.name

  let to_key k = N.name @ k

  let of_key k = Misc.remove_elem_from_list name_length k

  let mem t k = C.mem t (to_key k)

  let dir_mem t k = C.dir_mem t (to_key k)

  let get t k = C.get t (to_key k)

  let get_option t k = C.get_option t (to_key k)

  let init t k v = C.init t (to_key k) v

  let set t k v = C.set t (to_key k) v

  let init_set t k v = C.init_set t (to_key k) v

  let set_option t k v = C.set_option t (to_key k) v

  let delete t k = C.delete t (to_key k)

  let remove t k = C.remove t (to_key k)

  let remove_rec t k = C.remove_rec t (to_key k)

  let copy t ~from ~to_ = C.copy t ~from:(to_key from) ~to_:(to_key to_)

  let fold t k ~init ~f =
    C.fold t (to_key k) ~init ~f:(fun k acc -&gt; f (map_key of_key k) acc)

  let keys t k = C.keys t (to_key k) &gt;|= fun keys -&gt; List.map of_key keys

  let fold_keys t k ~init ~f =
    C.fold_keys t (to_key k) ~init ~f:(fun k acc -&gt; f (of_key k) acc)

  let project = C.project

  let absolute_key c k = C.absolute_key c (to_key k)

  let consume_gas = C.consume_gas

  let check_enough_gas = C.check_enough_gas

  let description =
    let description =
      if R.ghost then Storage_description.create () else C.description
    in
    Storage_description.register_named_subcontext description N.name
end

module Make_single_data_storage
    (R : REGISTER)
    (C : Raw_context.T)
    (N : NAME)
    (V : VALUE) : Single_data_storage with type t = C.t and type value = V.t =
struct
  let tag_Single_data_storage = ()

  type t = C.t

  type context = t

  type value = V.t

  let mem t = C.mem t N.name

  module Encoder = Make_encoder (V)
  include Encoder

  let get t =
    C.get t N.name
    &gt;&gt;=? fun b -&gt;
    let key = C.absolute_key t N.name in
    Lwt.return (of_bytes ~key b)

  let get_option t =
    C.get_option t N.name
    &gt;&gt;= function
    | None -&gt;
        return_none
    | Some b -&gt; (
        let key = C.absolute_key t N.name in
        match of_bytes ~key b with
        | Ok v -&gt;
            return_some v
        | Error error -&gt;
            Lwt.return (Error error) )

  let init t v =
    C.init t N.name (to_bytes v) &gt;&gt;=? fun t -&gt; return (C.project t)

  let set t v = C.set t N.name (to_bytes v) &gt;&gt;=? fun t -&gt; return (C.project t)

  let init_set t v =
    C.init_set t N.name (to_bytes v) &gt;&gt;= fun t -&gt; Lwt.return (C.project t)

  let set_option t v =
    C.set_option t N.name (Option.map ~f:to_bytes v)
    &gt;&gt;= fun t -&gt; Lwt.return (C.project t)

  let remove t = C.remove t N.name &gt;&gt;= fun t -&gt; Lwt.return (C.project t)

  let delete t = C.delete t N.name &gt;&gt;=? fun t -&gt; return (C.project t)

  <abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
    let open Storage_description in
    let description =
      if R.ghost then Storage_description.create () else C.description
    in
    register_value
      ~get:get_option
      (register_named_subcontext description N.name)
      V.encoding</abbr>
end

module type INDEX = sig
  type t

  val path_length : int

  val to_path : t -&gt; string list -&gt; string list

  val of_path : string list -&gt; t option

  type 'a ipath

  val args : unit -&gt; ('a, t, 'a ipath) Storage_description.args

  val infer_ipath : 'a ipath -&gt; 'a -&gt; 'a
end

module Pair (I1 : INDEX) (I2 : INDEX) : INDEX with type t = I1.t * I2.t =
struct
  type t = I1.t * I2.t

  let path_length = I1.path_length + I2.path_length

  let to_path (x, y) l = I1.to_path x (I2.to_path y l)

  let of_path l =
    match Misc.take I1.path_length l with
    | None -&gt;
        None
    | Some (l1, l2) -&gt; (
      match (I1.of_path l1, I2.of_path l2) with
      | (Some x, Some y) -&gt;
          Some (x, y)
      | _ -&gt;
          None )

  type 'a ipath = 'a I1.ipath I2.ipath

  let args () = Storage_description.Pair (I1.args (), I2.args ())

  let infer_ipath (_ : 'a ipath) (x : 'a) : 'a = x
end

module Make_data_set_storage (C : Raw_context.T) (I : INDEX) :
  Data_set_storage with type t = C.t and type elt = I.t = struct
  type t = C.t

  type context = t

  type elt = I.t

  let inited = MBytes.of_string &quot;inited&quot;

  let mem s i = C.mem s (I.to_path i [])

  let add s i =
    C.init_set s (I.to_path i []) inited &gt;&gt;= fun t -&gt; Lwt.return (C.project t)

  let del s i =
    C.remove s (I.to_path i []) &gt;&gt;= fun t -&gt; Lwt.return (C.project t)

  let set s i = function true -&gt; add s i | false -&gt; del s i

  let clear s = C.remove_rec s [] &gt;&gt;= fun t -&gt; Lwt.return (C.project t)

  let fold s ~init ~f =
    let rec dig i path acc =
      if Compare.Int.(i &lt;= 1) then
        C.fold s path ~init:acc ~f:(fun k acc -&gt;
            match k with
            | `Dir _ -&gt;
                Lwt.return acc
            | `Key file -&gt; (
              match I.of_path file with
              | None -&gt;
                  <abbr class="mark-warning" title="Assert instruction is not handled.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

The placeholders `_` in types are not handled">assert false</abbr>
              | Some p -&gt;
                  f p acc ))
      else
        C.fold s path ~init:acc ~f:(fun k acc -&gt;
            match k with
            | `Dir k -&gt;
                dig (i - 1) k acc
            | `Key _ -&gt;
                Lwt.return acc)
    in
    dig I.path_length [] init

  let elements s =
    fold s ~init:([] [@coq_implicit &quot;(A := elt)&quot;]) ~f:(fun p acc -&gt;
        Lwt.return (p :: acc))

  <abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
    let open Storage_description in
    let unpack = unpack (I.args ()) in
    register_value (* TODO fixme 'elements...' *)
      ~get:(fun c -&gt;
        let (c, k) = unpack c in
        mem c k &gt;&gt;= function true -&gt; return_some true | false -&gt; return_none)
      (register_indexed_subcontext
         ~list:(fun c -&gt; elements c &gt;&gt;= return)
         C.description
         (I.args ()))
      Data_encoding.bool</abbr>
end

module Make_indexed_data_storage (C : Raw_context.T) (I : INDEX) (V : VALUE) :
  Indexed_data_storage
    with type t = C.t
     and type key = I.t
     and type value = V.t = struct
  let tag_Non_iterable_indexed_data_storage = ()

  type t = C.t

  type context = t

  type key = I.t

  type value = V.t

  module Encoder = Make_encoder (V)
  include Encoder

  let mem s i = C.mem s (I.to_path i [])

  let get s i =
    C.get s (I.to_path i [])
    &gt;&gt;=? fun b -&gt;
    let key = C.absolute_key s (I.to_path i []) in
    Lwt.return (of_bytes ~key b)

  let get_option s i =
    C.get_option s (I.to_path i [])
    &gt;&gt;= function
    | None -&gt;
        return_none
    | Some b -&gt; (
        let key = C.absolute_key s (I.to_path i []) in
        match of_bytes ~key b with
        | Ok v -&gt;
            return_some v
        | Error error -&gt;
            Lwt.return (Error error) )

  let set s i v =
    C.set s (I.to_path i []) (to_bytes v) &gt;&gt;=? fun t -&gt; return (C.project t)

  let init s i v =
    C.init s (I.to_path i []) (to_bytes v) &gt;&gt;=? fun t -&gt; return (C.project t)

  let init_set s i v =
    C.init_set s (I.to_path i []) (to_bytes v)
    &gt;&gt;= fun t -&gt; Lwt.return (C.project t)

  let set_option s i v =
    C.set_option s (I.to_path i []) (Option.map ~f:to_bytes v)
    &gt;&gt;= fun t -&gt; Lwt.return (C.project t)

  let remove s i =
    C.remove s (I.to_path i []) &gt;&gt;= fun t -&gt; Lwt.return (C.project t)

  let delete s i =
    C.delete s (I.to_path i []) &gt;&gt;=? fun t -&gt; return (C.project t)

  let clear s = C.remove_rec s [] &gt;&gt;= fun t -&gt; Lwt.return (C.project t)

  let fold_keys s ~init ~f =
    let rec dig i path acc =
      if Compare.Int.(i &lt;= 1) then
        C.fold s path ~init:acc ~f:(fun k acc -&gt;
            match k with
            | `Dir _ -&gt;
                Lwt.return acc
            | `Key file -&gt; (
              match I.of_path file with
              | None -&gt;
                  <abbr class="mark-warning" title="Assert instruction is not handled.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

The placeholders `_` in types are not handled">assert false</abbr>
              | Some path -&gt;
                  f path acc ))
      else
        C.fold s path ~init:acc ~f:(fun k acc -&gt;
            match k with
            | `Dir k -&gt;
                dig (i - 1) k acc
            | `Key _ -&gt;
                Lwt.return acc)
    in
    dig I.path_length [] init

  let fold s ~init ~f =
    let f path acc =
      get s path
      &gt;&gt;= function
      | Error _ -&gt;
          (* FIXME: silently ignore unparsable data *)
          Lwt.return acc
      | Ok v -&gt;
          f path v acc
    in
    fold_keys s ~init ~f

  let bindings s =
    fold s ~init:([] [@coq_implicit &quot;(A := key * value)&quot;]) ~f:(fun p v acc -&gt;
        Lwt.return ((p, v) :: acc))

  let keys s =
    fold_keys s ~init:([] [@coq_implicit &quot;(A := key)&quot;]) ~f:(fun p acc -&gt;
        Lwt.return (p :: acc))

  <abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
    let open Storage_description in
    let unpack = unpack (I.args ()) in
    register_value
      ~get:(fun c -&gt;
        let (c, k) = unpack c in
        get_option c k)
      (register_indexed_subcontext
         ~list:(fun c -&gt; keys c &gt;&gt;= return)
         C.description
         (I.args ()))
      V.encoding</abbr>
end

module Make_indexed_carbonated_data_storage
    (C : Raw_context.T)
    (I : INDEX)
    (V : VALUE) :
  Non_iterable_indexed_carbonated_data_storage
    with type t = C.t
     and type key = I.t
     and type value = V.t = struct
  let tag_Non_iterable_indexed_carbonated_data_storage = ()

  type t = C.t

  type context = t

  type key = I.t

  type value = V.t

  module Encoder = Make_encoder (V)
  include Encoder

  let data_key i = I.to_path i [data_name]

  let len_key i = I.to_path i [len_name]

  let consume_mem_gas c =
    Lwt.return (C.consume_gas c (Gas_limit_repr.read_bytes_cost Z.zero))

  let existing_size c i =
    C.get_option c (len_key i)
    &gt;&gt;= function
    | None -&gt;
        return (0, false)
    | Some len -&gt;
        decode_len_value (len_key i) len &gt;&gt;=? fun len -&gt; return (len, true)

  let consume_read_gas get c i =
    get c (len_key i)
    &gt;&gt;=? fun len -&gt;
    decode_len_value (len_key i) len
    &gt;&gt;=? fun len -&gt;
    Lwt.return
      (C.consume_gas c (Gas_limit_repr.read_bytes_cost (Z.of_int len)))

  let consume_serialize_write_gas set c i v =
    let bytes = to_bytes v in
    let len = MBytes.length bytes in
    Lwt.return (C.consume_gas c (Gas_limit_repr.alloc_mbytes_cost len))
    &gt;&gt;=? fun c -&gt;
    Lwt.return
      (C.consume_gas c (Gas_limit_repr.write_bytes_cost (Z.of_int len)))
    &gt;&gt;=? fun c -&gt;
    set c (len_key i) (encode_len_value bytes) &gt;&gt;=? fun c -&gt; return (c, bytes)

  let consume_remove_gas del c i =
    Lwt.return (C.consume_gas c (Gas_limit_repr.write_bytes_cost Z.zero))
    &gt;&gt;=? fun c -&gt; del c (len_key i)

  let mem s i =
    consume_mem_gas s
    &gt;&gt;=? fun s -&gt;
    C.mem s (data_key i) &gt;&gt;= fun exists -&gt; return (C.project s, exists)

  let get s i =
    consume_read_gas C.get s i
    &gt;&gt;=? fun s -&gt;
    C.get s (data_key i)
    &gt;&gt;=? fun b -&gt;
    let key = C.absolute_key s (data_key i) in
    Lwt.return (of_bytes ~key b) &gt;&gt;=? fun v -&gt; return (C.project s, v)

  let get_option s i =
    consume_mem_gas s
    &gt;&gt;=? fun s -&gt;
    C.mem s (data_key i)
    &gt;&gt;= fun exists -&gt;
    if exists then get s i &gt;&gt;=? fun (s, v) -&gt; return (s, Some v)
    else return (C.project s, None)

  let set s i v =
    existing_size s i
    &gt;&gt;=? fun (prev_size, _) -&gt;
    consume_serialize_write_gas C.set s i v
    &gt;&gt;=? fun (s, bytes) -&gt;
    C.set s (data_key i) bytes
    &gt;&gt;=? fun t -&gt;
    let size_diff = MBytes.length bytes - prev_size in
    return (C.project t, size_diff)

  let init s i v =
    consume_serialize_write_gas C.init s i v
    &gt;&gt;=? fun (s, bytes) -&gt;
    C.init s (data_key i) bytes
    &gt;&gt;=? fun t -&gt;
    let size = MBytes.length bytes in
    return (C.project t, size)

  let init_set s i v =
    let init_set s i v = C.init_set s i v &gt;&gt;= return in
    existing_size s i
    &gt;&gt;=? fun (prev_size, existed) -&gt;
    consume_serialize_write_gas init_set s i v
    &gt;&gt;=? fun (s, bytes) -&gt;
    init_set s (data_key i) bytes
    &gt;&gt;=? fun t -&gt;
    let size_diff = MBytes.length bytes - prev_size in
    return (C.project t, size_diff, existed)

  let remove s i =
    let remove s i = C.remove s i &gt;&gt;= return in
    existing_size s i
    &gt;&gt;=? fun (prev_size, existed) -&gt;
    consume_remove_gas remove s i
    &gt;&gt;=? fun s -&gt;
    remove s (data_key i) &gt;&gt;=? fun t -&gt; return (C.project t, prev_size, existed)

  let delete s i =
    existing_size s i
    &gt;&gt;=? fun (prev_size, _) -&gt;
    consume_remove_gas C.delete s i
    &gt;&gt;=? fun s -&gt;
    C.delete s (data_key i) &gt;&gt;=? fun t -&gt; return (C.project t, prev_size)

  let set_option s i v =
    match v with None -&gt; remove s i | Some v -&gt; init_set s i v

  let fold_keys_unaccounted s ~init ~f =
    let rec dig i path acc =
      if Compare.Int.(i &lt;= 0) then
        C.fold s path ~init:acc ~f:(fun k acc -&gt;
            match k with
            | `Dir _ -&gt;
                Lwt.return acc
            | `Key file -&gt; (
              match List.rev file with
              | last :: _ when Compare.String.(last = len_name) -&gt;
                  Lwt.return acc
              | last :: rest when Compare.String.(last = data_name) -&gt; (
                  let file = List.rev rest in
                  match I.of_path file with
                  | None -&gt;
                      <abbr class="mark-warning" title="Assert instruction is not handled.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

The placeholders `_` in types are not handled">assert false</abbr>
                  | Some path -&gt;
                      f path acc )
              | _ -&gt;
                  <abbr class="mark-warning" title="Assert instruction is not handled.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

The placeholders `_` in types are not handled">assert false</abbr> ))
      else
        C.fold s path ~init:acc ~f:(fun k acc -&gt;
            match k with
            | `Dir k -&gt;
                dig (i - 1) k acc
            | `Key _ -&gt;
                Lwt.return acc)
    in
    dig I.path_length [] init

  let keys_unaccounted s =
    fold_keys_unaccounted
      s
      ~init:([] [@coq_implicit &quot;(A := key)&quot;])
      ~f:(fun p acc -&gt; Lwt.return (p :: acc))

  <abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
    let open Storage_description in
    let unpack = unpack (I.args ()) in
    register_value (* TODO export consumed gas ?? *)
      ~get:(fun c -&gt;
        let (c, k) = unpack c in
        get_option c k &gt;&gt;=? fun (_, v) -&gt; return v)
      (register_indexed_subcontext
         ~list:(fun c -&gt; keys_unaccounted c &gt;&gt;= return)
         C.description
         (I.args ()))
      V.encoding</abbr>
end

module Make_indexed_data_snapshotable_storage
    (C : Raw_context.T)
    (Snapshot_index : INDEX)
    (I : INDEX)
    (V : VALUE) :
  Indexed_data_snapshotable_storage
    with type t = C.t
     and type snapshot = Snapshot_index.t
     and type key = I.t
     and type value = V.t = struct
  type snapshot = Snapshot_index.t

  let data_name = [&quot;current&quot;]

  let snapshot_name = [&quot;snapshot&quot;]

  module C_data =
    Make_subcontext (Registered) (C)
      (struct
        let name = data_name
      end)

  module C_snapshot =
    Make_subcontext (Registered) (C)
      (struct
        let name = snapshot_name
      end)

  module Data_storage = Make_indexed_data_storage (C_data) (I) (V)
  include Data_storage
  module Pair_Snapshot_index_I = Pair (Snapshot_index) (I)
  module Snapshot =
    Make_indexed_data_storage (C_snapshot) (Pair_Snapshot_index_I) (V)

  let snapshot_path id = snapshot_name @ Snapshot_index.to_path id []

  let snapshot_exists s id = C.dir_mem s (snapshot_path id)

  let snapshot s id =
    C.copy s ~from:data_name ~to_:(snapshot_path id)
    &gt;&gt;=? fun t -&gt; return (C.project t)

  let delete_snapshot s id =
    C.remove_rec s (snapshot_path id) &gt;&gt;= fun t -&gt; Lwt.return (C.project t)
end

module Make_indexed_subcontext (C : Raw_context.T) (I : INDEX) :
  Indexed_raw_context
    with type t = C.t
     and type key = I.t
     and type 'a ipath = 'a I.ipath = struct
  type t = C.t

  type context = t

  type key = I.t

  type 'a ipath = 'a I.ipath

  let clear t = C.remove_rec t [] &gt;&gt;= fun t -&gt; Lwt.return (C.project t)

  let fold_keys t ~init ~f =
    let rec dig i path acc =
      if Compare.Int.(i &lt;= 0) then
        match I.of_path path with
        | None -&gt;
            <abbr class="mark-warning" title="Assert instruction is not handled.

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

The placeholders `_` in types are not handled">assert false</abbr>
        | Some path -&gt;
            f path acc
      else
        C.fold t path ~init:acc ~f:(fun k acc -&gt;
            match k with
            | `Dir k -&gt;
                dig (i - 1) k acc
            | `Key _ -&gt;
                Lwt.return acc)
    in
    dig I.path_length [] init

  let keys t =
    fold_keys t ~init:([] [@coq_implicit &quot;(A := key)&quot;]) ~f:(fun i acc -&gt;
        Lwt.return (i :: acc))

  let list t k = C.fold t k ~init:[] ~f:(fun k acc -&gt; Lwt.return (k :: acc))

  let remove_rec t k = C.remove_rec t (I.to_path k [])

  let copy t ~from ~to_ =
    C.copy t ~from:(I.to_path from []) ~to_:(I.to_path to_ [])

  let description =
    Storage_description.register_indexed_subcontext
      ~list:(fun c -&gt; keys c &gt;&gt;= return)
      C.description
      (I.args ())

  let unpack = Storage_description.unpack (I.args ())

  let pack = Storage_description.pack (I.args ())

  module Raw_context : Raw_context.T with type t = t ipath = struct
    type t = C.t I.ipath

    type context = t

    let to_key i k = I.to_path i k

    let of_key k = Misc.remove_elem_from_list I.path_length k

    let mem c k =
      let (t, i) = unpack c in
      C.mem t (to_key i k)

    let dir_mem c k =
      let (t, i) = unpack c in
      C.dir_mem t (to_key i k)

    let get c k =
      let (t, i) = unpack c in
      C.get t (to_key i k)

    let get_option c k =
      let (t, i) = unpack c in
      C.get_option t (to_key i k)

    let init c k v =
      let (t, i) = unpack c in
      C.init t (to_key i k) v &gt;&gt;=? fun t -&gt; return (pack t i)

    let set c k v =
      let (t, i) = unpack c in
      C.set t (to_key i k) v &gt;&gt;=? fun t -&gt; return (pack t i)

    let init_set c k v =
      let (t, i) = unpack c in
      C.init_set t (to_key i k) v &gt;&gt;= fun t -&gt; Lwt.return (pack t i)

    let set_option c k v =
      let (t, i) = unpack c in
      C.set_option t (to_key i k) v &gt;&gt;= fun t -&gt; Lwt.return (pack t i)

    let delete c k =
      let (t, i) = unpack c in
      C.delete t (to_key i k) &gt;&gt;=? fun t -&gt; return (pack t i)

    let remove c k =
      let (t, i) = unpack c in
      C.remove t (to_key i k) &gt;&gt;= fun t -&gt; Lwt.return (pack t i)

    let remove_rec c k =
      let (t, i) = unpack c in
      C.remove_rec t (to_key i k) &gt;&gt;= fun t -&gt; Lwt.return (pack t i)

    let copy c ~from ~to_ =
      let (t, i) = unpack c in
      C.copy t ~from:(to_key i from) ~to_:(to_key i to_)
      &gt;&gt;=? fun t -&gt; return (pack t i)

    let fold c k ~init ~f =
      let (t, i) = unpack c in
      C.fold t (to_key i k) ~init ~f:(fun k acc -&gt; f (map_key of_key k) acc)

    let keys c k =
      let (t, i) = unpack c in
      C.keys t (to_key i k) &gt;|= fun keys -&gt; List.map of_key keys

    let fold_keys c k ~init ~f =
      let (t, i) = unpack c in
      C.fold_keys t (to_key i k) ~init ~f:(fun k acc -&gt; f (of_key k) acc)

    let project c =
      let (t, _) = unpack c in
      C.project t

    let absolute_key c k =
      let (t, i) = unpack c in
      C.absolute_key t (to_key i k)

    let consume_gas c g =
      let (t, i) = unpack c in
      C.consume_gas t g &gt;&gt;? fun t -&gt; ok (pack t i)

    let check_enough_gas c g =
      let (t, _i) = unpack c in
      C.check_enough_gas t g

    let description = description
  end

  let resolve t prefix =
    let rec loop i prefix = function
      | [] when Compare.Int.(i = I.path_length) -&gt; (
        match I.of_path prefix with
        | None -&gt;
            <abbr class="mark-warning" title="Assert instruction is not handled.">assert false</abbr>
        | Some path -&gt;
            Lwt.return [path] )
      | [] -&gt;
          list t prefix
          &gt;&gt;= fun prefixes -&gt;
          Lwt_list.map_s
            (function `Key prefix | `Dir prefix -&gt; loop (i + 1) prefix [])
            prefixes
          &gt;|= List.flatten
      | [d] when Compare.Int.(i = I.path_length - 1) -&gt;
          <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if Compare.Int.(i &gt;= I.path_length) then invalid_arg &quot;IO.resolve&quot;</abbr> ;
          list t prefix
          &gt;&gt;= fun prefixes -&gt;
          Lwt_list.map_s
            (function
              | `Key prefix | `Dir prefix -&gt; (
                match
                  Misc.remove_prefix ~prefix:d (List.hd (List.rev prefix))
                with
                | None -&gt;
                    Lwt.return_nil
                | Some _ -&gt;
                    loop (i + 1) prefix [] ))
            prefixes
          &gt;|= List.flatten
      | &quot;&quot; :: ds -&gt;
          list t prefix
          &gt;&gt;= fun prefixes -&gt;
          Lwt_list.map_s
            (function `Key prefix | `Dir prefix -&gt; loop (i + 1) prefix ds)
            prefixes
          &gt;|= List.flatten
      | d :: ds -&gt; (
          <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">if Compare.Int.(i &gt;= I.path_length) then invalid_arg &quot;IO.resolve&quot;</abbr> ;
          C.dir_mem t (prefix @ [d])
          &gt;&gt;= function
          | true -&gt; loop (i + 1) (prefix @ [d]) ds | false -&gt; Lwt.return_nil )
    in
    loop 0 [] prefix

  module Make_set (R : REGISTER) (N : NAME) :
    Data_set_storage with type t = t and type elt = key = struct
    type t = C.t

    type context = t

    type elt = I.t

    let inited = MBytes.of_string &quot;inited&quot;

    let mem s i = Raw_context.mem (pack s i) N.name

    let add s i =
      Raw_context.init_set (pack s i) N.name inited
      &gt;&gt;= fun c -&gt;
      let (s, _) = unpack c in
      Lwt.return (C.project s)

    let del s i =
      Raw_context.remove (pack s i) N.name
      &gt;&gt;= fun c -&gt;
      let (s, _) = unpack c in
      Lwt.return (C.project s)

    let set s i = function true -&gt; add s i | false -&gt; del s i

    let clear s =
      fold_keys s ~init:s ~f:(fun i s -&gt;
          Raw_context.remove (pack s i) N.name
          &gt;&gt;= fun c -&gt;
          let (s, _) = unpack c in
          Lwt.return s)
      &gt;&gt;= fun t -&gt; Lwt.return (C.project t)

    let fold s ~init ~f =
      fold_keys s ~init ~f:(fun i acc -&gt;
          mem s i &gt;&gt;= function true -&gt; f i acc | false -&gt; Lwt.return acc)

    let elements s =
      fold s ~init:([] [@coq_implicit &quot;(A := elt)&quot;]) ~f:(fun p acc -&gt;
          Lwt.return (p :: acc))

    <abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
      let open Storage_description in
      let unpack = unpack (I.args ()) in
      let description =
        if R.ghost then Storage_description.create ()
        else Raw_context.description
      in
      register_value
        ~get:(fun c -&gt;
          let (c, k) = unpack c in
          mem c k
          &gt;&gt;= function true -&gt; return_some true | false -&gt; return_none)
        (register_named_subcontext description N.name)
        Data_encoding.bool</abbr>
  end

  module Make_map (N : NAME) (V : VALUE) :
    Indexed_data_storage
      with type t = t
       and type key = key
       and type value = V.t = struct
    let tag_Non_iterable_indexed_data_storage = ()

    type t = C.t

    type context = t

    type key = I.t

    type value = V.t

    module Encoder = Make_encoder (V)
    include Encoder

    let mem s i = Raw_context.mem (pack s i) N.name

    let get s i =
      Raw_context.get (pack s i) N.name
      &gt;&gt;=? fun b -&gt;
      let key = Raw_context.absolute_key (pack s i) N.name in
      Lwt.return (of_bytes ~key b)

    let get_option s i =
      Raw_context.get_option (pack s i) N.name
      &gt;&gt;= function
      | None -&gt;
          return_none
      | Some b -&gt; (
          let key = Raw_context.absolute_key (pack s i) N.name in
          match of_bytes ~key b with
          | Ok v -&gt;
              return_some v
          | Error error -&gt;
              Lwt.return (Error error) )

    let set s i v =
      Raw_context.set (pack s i) N.name (to_bytes v)
      &gt;&gt;=? fun c -&gt;
      let (s, _) = unpack c in
      return (C.project s)

    let init s i v =
      Raw_context.init (pack s i) N.name (to_bytes v)
      &gt;&gt;=? fun c -&gt;
      let (s, _) = unpack c in
      return (C.project s)

    let init_set s i v =
      Raw_context.init_set (pack s i) N.name (to_bytes v)
      &gt;&gt;= fun c -&gt;
      let (s, _) = unpack c in
      Lwt.return (C.project s)

    let set_option s i v =
      Raw_context.set_option (pack s i) N.name (Option.map ~f:to_bytes v)
      &gt;&gt;= fun c -&gt;
      let (s, _) = unpack c in
      Lwt.return (C.project s)

    let remove s i =
      Raw_context.remove (pack s i) N.name
      &gt;&gt;= fun c -&gt;
      let (s, _) = unpack c in
      Lwt.return (C.project s)

    let delete s i =
      Raw_context.delete (pack s i) N.name
      &gt;&gt;=? fun c -&gt;
      let (s, _) = unpack c in
      return (C.project s)

    let clear s =
      fold_keys s ~init:s ~f:(fun i s -&gt;
          Raw_context.remove (pack s i) N.name
          &gt;&gt;= fun c -&gt;
          let (s, _) = unpack c in
          Lwt.return s)
      &gt;&gt;= fun t -&gt; Lwt.return (C.project t)

    let fold s ~init ~f =
      fold_keys s ~init ~f:(fun i acc -&gt;
          get s i &gt;&gt;= function Error _ -&gt; Lwt.return acc | Ok v -&gt; f i v acc)

    let bindings s =
      fold s ~init:([] [@coq_implicit &quot;(A := key * value)&quot;]) ~f:(fun p v acc -&gt;
          Lwt.return ((p, v) :: acc))

    let fold_keys s ~init ~f =
      fold_keys s ~init ~f:(fun i acc -&gt;
          mem s i &gt;&gt;= function false -&gt; Lwt.return acc | true -&gt; f i acc)

    let keys s =
      fold_keys s ~init:([] [@coq_implicit &quot;(A := key)&quot;]) ~f:(fun p acc -&gt;
          Lwt.return (p :: acc))

    <abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
      let open Storage_description in
      let unpack = unpack (I.args ()) in
      register_value
        ~get:(fun c -&gt;
          let (c, k) = unpack c in
          get_option c k)
        (register_named_subcontext Raw_context.description N.name)
        V.encoding</abbr>
  end

  module Make_carbonated_map (N : NAME) (V : VALUE) :
    Non_iterable_indexed_carbonated_data_storage
      with type t = t
       and type key = key
       and type value = V.t = struct
    let tag_Non_iterable_indexed_carbonated_data_storage = ()

    type t = C.t

    type context = t

    type key = I.t

    type value = V.t

    module Encoder = Make_encoder (V)
    include Encoder

    let len_name = len_name :: N.name

    let data_name = data_name :: N.name

    let consume_mem_gas c =
      Lwt.return
        (Raw_context.consume_gas c (Gas_limit_repr.read_bytes_cost Z.zero))

    let existing_size c =
      Raw_context.get_option c len_name
      &gt;&gt;= function
      | None -&gt;
          return (0, false)
      | Some len -&gt;
          decode_len_value len_name len &gt;&gt;=? fun len -&gt; return (len, true)

    let consume_read_gas get c =
      get c len_name
      &gt;&gt;=? fun len -&gt;
      decode_len_value len_name len
      &gt;&gt;=? fun len -&gt;
      Lwt.return
        (Raw_context.consume_gas
           c
           (Gas_limit_repr.read_bytes_cost (Z.of_int len)))

    let consume_write_gas set c v =
      let bytes = to_bytes v in
      let len = MBytes.length bytes in
      Lwt.return
        (Raw_context.consume_gas
           c
           (Gas_limit_repr.write_bytes_cost (Z.of_int len)))
      &gt;&gt;=? fun c -&gt;
      set c len_name (encode_len_value bytes) &gt;&gt;=? fun c -&gt; return (c, bytes)

    let consume_remove_gas del c =
      Lwt.return
        (Raw_context.consume_gas c (Gas_limit_repr.write_bytes_cost Z.zero))
      &gt;&gt;=? fun c -&gt; del c len_name

    let mem s i =
      consume_mem_gas (pack s i)
      &gt;&gt;=? fun c -&gt;
      Raw_context.mem c data_name
      &gt;&gt;= fun res -&gt; return (Raw_context.project c, res)

    let get s i =
      consume_read_gas Raw_context.get (pack s i)
      &gt;&gt;=? fun c -&gt;
      Raw_context.get c data_name
      &gt;&gt;=? fun b -&gt;
      let key = Raw_context.absolute_key c data_name in
      Lwt.return (of_bytes ~key b)
      &gt;&gt;=? fun v -&gt; return (Raw_context.project c, v)

    let get_option s i =
      consume_mem_gas (pack s i)
      &gt;&gt;=? fun c -&gt;
      let (s, _) = unpack c in
      Raw_context.mem (pack s i) data_name
      &gt;&gt;= fun exists -&gt;
      if exists then get s i &gt;&gt;=? fun (s, v) -&gt; return (s, Some v)
      else return (C.project s, None)

    let set s i v =
      existing_size (pack s i)
      &gt;&gt;=? fun (prev_size, _) -&gt;
      consume_write_gas Raw_context.set (pack s i) v
      &gt;&gt;=? fun (c, bytes) -&gt;
      Raw_context.set c data_name bytes
      &gt;&gt;=? fun c -&gt;
      let size_diff = MBytes.length bytes - prev_size in
      return (Raw_context.project c, size_diff)

    let init s i v =
      consume_write_gas Raw_context.init (pack s i) v
      &gt;&gt;=? fun (c, bytes) -&gt;
      Raw_context.init c data_name bytes
      &gt;&gt;=? fun c -&gt;
      let size = MBytes.length bytes in
      return (Raw_context.project c, size)

    let init_set s i v =
      let init_set c k v = Raw_context.init_set c k v &gt;&gt;= return in
      existing_size (pack s i)
      &gt;&gt;=? fun (prev_size, existed) -&gt;
      consume_write_gas init_set (pack s i) v
      &gt;&gt;=? fun (c, bytes) -&gt;
      init_set c data_name bytes
      &gt;&gt;=? fun c -&gt;
      let size_diff = MBytes.length bytes - prev_size in
      return (Raw_context.project c, size_diff, existed)

    let remove s i =
      let remove c k = Raw_context.remove c k &gt;&gt;= return in
      existing_size (pack s i)
      &gt;&gt;=? fun (prev_size, existed) -&gt;
      consume_remove_gas remove (pack s i)
      &gt;&gt;=? fun c -&gt;
      remove c data_name
      &gt;&gt;=? fun c -&gt; return (Raw_context.project c, prev_size, existed)

    let delete s i =
      existing_size (pack s i)
      &gt;&gt;=? fun (prev_size, _) -&gt;
      consume_remove_gas Raw_context.delete (pack s i)
      &gt;&gt;=? fun c -&gt;
      Raw_context.delete c data_name
      &gt;&gt;=? fun c -&gt; return (Raw_context.project c, prev_size)

    let set_option s i v =
      match v with None -&gt; remove s i | Some v -&gt; init_set s i v

    <abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
      let open Storage_description in
      let unpack = unpack (I.args ()) in
      register_value
        ~get:(fun c -&gt;
          let (c, k) = unpack c in
          get_option c k &gt;&gt;=? fun (_, v) -&gt; return v)
        (register_named_subcontext Raw_context.description N.name)
        V.encoding</abbr>
  end
end

module type WRAPPER = sig
  type t

  type key

  val wrap : t -&gt; key

  val unwrap : key -&gt; t option
end

module Wrap_indexed_data_storage
    (C : Indexed_data_storage)
    (K : WRAPPER with type key := C.key) :
  Indexed_data_storage
    with type t = C.t
     and type key = K.t
     and type value = C.value = struct
  let tag_Non_iterable_indexed_data_storage = ()

  type t = C.t

  type context = C.t

  type key = K.t

  type value = C.value

  let mem ctxt k = C.mem ctxt (K.wrap k)

  let get ctxt k = C.get ctxt (K.wrap k)

  let get_option ctxt k = C.get_option ctxt (K.wrap k)

  let set ctxt k v = C.set ctxt (K.wrap k) v

  let init ctxt k v = C.init ctxt (K.wrap k) v

  let init_set ctxt k v = C.init_set ctxt (K.wrap k) v

  let set_option ctxt k v = C.set_option ctxt (K.wrap k) v

  let delete ctxt k = C.delete ctxt (K.wrap k)

  let remove ctxt k = C.remove ctxt (K.wrap k)

  let clear ctxt = C.clear ctxt

  let fold ctxt ~init ~f =
    C.fold ctxt ~init ~f:(fun k v acc -&gt;
        match K.unwrap k with None -&gt; Lwt.return acc | Some k -&gt; f k v acc)

  let bindings s =
    fold s ~init:([] [@coq_implicit &quot;(A := key * value)&quot;]) ~f:(fun p v acc -&gt;
        Lwt.return ((p, v) :: acc))

  let fold_keys s ~init ~f =
    C.fold_keys s ~init ~f:(fun k acc -&gt;
        match K.unwrap k with None -&gt; Lwt.return acc | Some k -&gt; f k acc)

  let keys s =
    fold_keys s ~init:([] [@coq_implicit &quot;(A := key)&quot;]) ~f:(fun p acc -&gt;
        Lwt.return (p :: acc))
end
</pre>
  </div>
  <div class="col-md-6">
    <a href="#storage_functors.ml"><code>Storage_functors.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.
Unset Guard Checking.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Gas_limit_repr.
Require Tezos.Misc.
Require Tezos.Raw_context.
Require Tezos.Storage_description.
Require Tezos.Storage_sigs.

Import Storage_sigs.

Definition Registered :=
  let ghost := false in
  existT (A := unit) (fun _ =&gt; _) tt
    {|
      Storage_sigs.REGISTER.ghost := ghost
    |}.

Definition Ghost :=
  let ghost := true in
  existT (A := unit) (fun _ =&gt; _) tt
    {|
      Storage_sigs.REGISTER.ghost := ghost
    |}.

Module ENCODER.
  Record signature {t : Set} : Set := {
    t := t;
    of_bytes : list string -&gt; MBytes.t -&gt; Error_monad.tzresult t;
    to_bytes : t -&gt; MBytes.t;
  }.
End ENCODER.

Definition Make_encoder :=
  fun (V : {t : Set &amp; VALUE.signature (t := t)}) =&gt;
    ((let of_bytes (__key_value : list string) (__b_value : MBytes.t)
      : Error_monad.tzresult (|V|).(Storage_sigs.VALUE.t) :=
      match
        Data_encoding.Binary.of_bytes (|V|).(Storage_sigs.VALUE.encoding)
          __b_value with
      | None =&gt; Error_monad.__error_value extensible_type_value
      | Some v =&gt; Pervasives.Ok v
      end in
    let to_bytes (v : (|V|).(Storage_sigs.VALUE.t)) : MBytes.t :=
      match Data_encoding.Binary.to_bytes (|V|).(Storage_sigs.VALUE.encoding) v
        with
      | Some __b_value =&gt; __b_value
      | None =&gt; MBytes.create 0
      end in
    existT (A := unit) (fun _ =&gt; _) tt
      {|
        ENCODER.of_bytes := of_bytes;
        ENCODER.to_bytes := to_bytes
      |}) : {_ : unit &amp; ENCODER.signature (t := (|V|).(Storage_sigs.VALUE.t))}).

Definition len_name : string := &quot;len&quot;.

Definition data_name : string := &quot;data&quot;.

Definition encode_len_value (__bytes_value : MBytes.t) : MBytes.t :=
  let length := MBytes.length __bytes_value in
  (Data_encoding.Binary.to_bytes_exn Data_encoding.int31) length.

Definition decode_len_value (__key_value : list string) (len : MBytes.t)
  : Lwt.t (Error_monad.tzresult int) :=
  match (Data_encoding.Binary.of_bytes Data_encoding.int31) len with
  | None =&gt; Error_monad.fail extensible_type_value
  | Some len =&gt; Error_monad.__return len
  end.

Definition map_key
  (f : Context.key -&gt; Context.key) (function_parameter : Context.dir_or_key)
  : Context.dir_or_key :=
  match function_parameter with
  | Context.Key k =&gt; Context.Key (f k)
  | Context.Dir k =&gt; Context.Dir (f k)
  end.

Definition Make_subcontext :=
  fun (R : {_ : unit &amp; REGISTER.signature}) =&gt;
    fun (C : {t : Set &amp; Raw_context.T.signature (t := t)}) =&gt;
      fun (N : {_ : unit &amp; NAME.signature}) =&gt;
        ((let t : Set := (|C|).(Raw_context.T.t) in
        let context : Set := t in
        let name_length := List.length (|N|).(Storage_sigs.NAME.name) in
        let to_key (k : list string) : list string :=
          Pervasives.op_at (|N|).(Storage_sigs.NAME.name) k in
        let of_key {A : Set} (k : list A) : list A :=
          Misc.remove_elem_from_list name_length k in
        let mem (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          : Lwt.t bool :=
          (|C|).(Raw_context.T.mem) __t_value (to_key k) in
        let dir_mem
          (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          : Lwt.t bool :=
          (|C|).(Raw_context.T.dir_mem) __t_value (to_key k) in
        let get (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          : Lwt.t (Error_monad.tzresult Raw_context.value) :=
          (|C|).(Raw_context.T.get) __t_value (to_key k) in
        let get_option
          (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          : Lwt.t (option Raw_context.value) :=
          (|C|).(Raw_context.T.get_option) __t_value (to_key k) in
        let init
          (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          (v : Raw_context.value)
          : Lwt.t (Error_monad.tzresult (|C|).(Raw_context.T.context)) :=
          (|C|).(Raw_context.T.init) __t_value (to_key k) v in
        let set
          (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          (v : Raw_context.value)
          : Lwt.t (Error_monad.tzresult (|C|).(Raw_context.T.context)) :=
          (|C|).(Raw_context.T.set) __t_value (to_key k) v in
        let init_set
          (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          (v : Raw_context.value) : Lwt.t (|C|).(Raw_context.T.context) :=
          (|C|).(Raw_context.T.init_set) __t_value (to_key k) v in
        let set_option
          (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          (v : option Raw_context.value)
          : Lwt.t (|C|).(Raw_context.T.context) :=
          (|C|).(Raw_context.T.set_option) __t_value (to_key k) v in
        let delete (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          : Lwt.t (Error_monad.tzresult (|C|).(Raw_context.T.context)) :=
          (|C|).(Raw_context.T.delete) __t_value (to_key k) in
        let remove (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          : Lwt.t (|C|).(Raw_context.T.context) :=
          (|C|).(Raw_context.T.remove) __t_value (to_key k) in
        let remove_rec
          (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          : Lwt.t (|C|).(Raw_context.T.context) :=
          (|C|).(Raw_context.T.remove_rec) __t_value (to_key k) in
        let copy
          (__t_value : (|C|).(Raw_context.T.context)) (from : list string)
          (to_ : list string)
          : Lwt.t (Error_monad.tzresult (|C|).(Raw_context.T.context)) :=
          (|C|).(Raw_context.T.copy) __t_value (to_key from) (to_key to_) in
        let fold {A : Set}
          (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          (init : A) (f : Context.dir_or_key -&gt; A -&gt; Lwt.t A) : Lwt.t A :=
          (|C|).(Raw_context.T.fold) __t_value (to_key k) init
            (fun k =&gt; fun acc =&gt; f (map_key of_key k) acc) in
        let keys (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          : Lwt.t (list (list string)) :=
          Error_monad.op_gtpipeeq
            ((|C|).(Raw_context.T.keys) __t_value (to_key k))
            (fun keys =&gt; List.map of_key keys) in
        let fold_keys {A : Set}
          (__t_value : (|C|).(Raw_context.T.context)) (k : list string)
          (init : A) (f : list string -&gt; A -&gt; Lwt.t A) : Lwt.t A :=
          (|C|).(Raw_context.T.fold_keys) __t_value (to_key k) init
            (fun k =&gt; fun acc =&gt; f (of_key k) acc) in
        let project := (|C|).(Raw_context.T.project) in
        let absolute_key (c : (|C|).(Raw_context.T.context)) (k : list string)
          : Raw_context.key :=
          (|C|).(Raw_context.T.absolute_key) c (to_key k) in
        let consume_gas := (|C|).(Raw_context.T.consume_gas) in
        let check_enough_gas := (|C|).(Raw_context.T.check_enough_gas) in
        let description :=
          let description :=
            if (|R|).(Storage_sigs.REGISTER.ghost) then
              Storage_description.create tt
            else
              (|C|).(Raw_context.T.description) in
          Storage_description.register_named_subcontext description
            (|N|).(Storage_sigs.NAME.name) in
        existT (A := unit) (fun _ =&gt; _) tt
          {|
            Raw_context.T.mem := mem;
            Raw_context.T.dir_mem := dir_mem;
            Raw_context.T.get := get;
            Raw_context.T.get_option := get_option;
            Raw_context.T.init := init;
            Raw_context.T.set := set;
            Raw_context.T.init_set := init_set;
            Raw_context.T.set_option := set_option;
            Raw_context.T.delete := delete;
            Raw_context.T.remove := remove;
            Raw_context.T.remove_rec := remove_rec;
            Raw_context.T.copy := copy;
            Raw_context.T.fold {_} := fold;
            Raw_context.T.keys := keys;
            Raw_context.T.fold_keys {_} := fold_keys;
            Raw_context.T.project := project;
            Raw_context.T.absolute_key := absolute_key;
            Raw_context.T.consume_gas := consume_gas;
            Raw_context.T.check_enough_gas := check_enough_gas;
            Raw_context.T.description := description
          |})
          : {_ : unit &amp; Raw_context.T.signature (t := (|C|).(Raw_context.T.t))}).

Definition Make_single_data_storage :=
  fun (R : {_ : unit &amp; REGISTER.signature}) =&gt;
    fun (C : {t : Set &amp; Raw_context.T.signature (t := t)}) =&gt;
      fun (N : {_ : unit &amp; NAME.signature}) =&gt;
        fun (V : {t : Set &amp; VALUE.signature (t := t)}) =&gt;
          ((let tag_Single_data_storage := tt in
          let t : Set := (|C|).(Raw_context.T.t) in
          let context : Set := t in
          let value : Set := (|V|).(Storage_sigs.VALUE.t) in
          let mem (__t_value : (|C|).(Raw_context.T.context)) : Lwt.t bool :=
            (|C|).(Raw_context.T.mem) __t_value (|N|).(Storage_sigs.NAME.name)
            in
          let Encoder := Make_encoder (existT (A := Set) _ _ (|V|)) in
          let of_bytes := (|Encoder|).(ENCODER.of_bytes) in
          let to_bytes := (|Encoder|).(ENCODER.to_bytes) in
          let get (__t_value : (|C|).(Raw_context.T.context))
            : Lwt.t (Error_monad.tzresult (|V|).(Storage_sigs.VALUE.t)) :=
            let=? __b_value :=
              (|C|).(Raw_context.T.get) __t_value (|N|).(Storage_sigs.NAME.name)
              in
            let __key_value :=
              (|C|).(Raw_context.T.absolute_key) __t_value
                (|N|).(Storage_sigs.NAME.name) in
            Lwt.__return (of_bytes __key_value __b_value) in
          let get_option (__t_value : (|C|).(Raw_context.T.context))
            : Lwt.t (Error_monad.tzresult (option (|V|).(Storage_sigs.VALUE.t))) :=
            let= function_parameter :=
              (|C|).(Raw_context.T.get_option) __t_value
                (|N|).(Storage_sigs.NAME.name) in
            match function_parameter with
            | None =&gt; Error_monad.return_none
            | Some __b_value =&gt;
              let __key_value :=
                (|C|).(Raw_context.T.absolute_key) __t_value
                  (|N|).(Storage_sigs.NAME.name) in
              match of_bytes __key_value __b_value with
              | Pervasives.Ok v =&gt; Error_monad.return_some v
              | Pervasives.Error __error_value =&gt;
                Lwt.__return (Pervasives.Error __error_value)
              end
            end in
          let init
            (__t_value : (|C|).(Raw_context.T.context))
            (v : (|V|).(Storage_sigs.VALUE.t))
            : Lwt.t (Error_monad.tzresult Raw_context.root_context) :=
            let=? __t_value :=
              (|C|).(Raw_context.T.init) __t_value
                (|N|).(Storage_sigs.NAME.name) (to_bytes v) in
            Error_monad.__return ((|C|).(Raw_context.T.project) __t_value) in
          let set
            (__t_value : (|C|).(Raw_context.T.context))
            (v : (|V|).(Storage_sigs.VALUE.t))
            : Lwt.t (Error_monad.tzresult Raw_context.root_context) :=
            let=? __t_value :=
              (|C|).(Raw_context.T.set) __t_value (|N|).(Storage_sigs.NAME.name)
                (to_bytes v) in
            Error_monad.__return ((|C|).(Raw_context.T.project) __t_value) in
          let init_set
            (__t_value : (|C|).(Raw_context.T.context))
            (v : (|V|).(Storage_sigs.VALUE.t))
            : Lwt.t Raw_context.root_context :=
            let= __t_value :=
              (|C|).(Raw_context.T.init_set) __t_value
                (|N|).(Storage_sigs.NAME.name) (to_bytes v) in
            Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
          let set_option
            (__t_value : (|C|).(Raw_context.T.context))
            (v : option (|V|).(Storage_sigs.VALUE.t))
            : Lwt.t Raw_context.root_context :=
            let= __t_value :=
              (|C|).(Raw_context.T.set_option) __t_value
                (|N|).(Storage_sigs.NAME.name) (Option.map to_bytes v) in
            Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
          let remove (__t_value : (|C|).(Raw_context.T.context))
            : Lwt.t Raw_context.root_context :=
            let= __t_value :=
              (|C|).(Raw_context.T.remove) __t_value
                (|N|).(Storage_sigs.NAME.name) in
            Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
          let delete (__t_value : (|C|).(Raw_context.T.context))
            : Lwt.t (Error_monad.tzresult Raw_context.root_context) :=
            let=? __t_value :=
              (|C|).(Raw_context.T.delete) __t_value
                (|N|).(Storage_sigs.NAME.name) in
            Error_monad.__return ((|C|).(Raw_context.T.project) __t_value) in
          (* ‚ùå top_level_evaluation *)
          existT (A := unit) (fun _ =&gt; _) tt
            {|
              Storage_sigs.Single_data_storage.tag_Single_data_storage :=
                tag_Single_data_storage;
              Storage_sigs.Single_data_storage.mem := mem;
              Storage_sigs.Single_data_storage.get := get;
              Storage_sigs.Single_data_storage.get_option := get_option;
              Storage_sigs.Single_data_storage.init := init;
              Storage_sigs.Single_data_storage.set := set;
              Storage_sigs.Single_data_storage.init_set := init_set;
              Storage_sigs.Single_data_storage.set_option := set_option;
              Storage_sigs.Single_data_storage.delete := delete;
              Storage_sigs.Single_data_storage.remove := remove
            |})
            :
              {_ : unit &amp;
                Single_data_storage.signature (t := (|C|).(Raw_context.T.t))
                  (value := (|V|).(Storage_sigs.VALUE.t))}).

Module INDEX.
  Record signature {t : Set} {ipath : Set -&gt; Set} : Set := {
    t := t;
    path_length : int;
    to_path : t -&gt; list string -&gt; list string;
    of_path : list string -&gt; option t;
    ipath := ipath;
    args : unit -&gt; Storage_description.args;
    infer_ipath : forall {a : Set}, ipath a -&gt; a -&gt; a;
  }.
End INDEX.

Definition Pair :=
  fun
    (I1 :
      {'[t, ipath] : [Set ** Set -&gt; Set] &amp;
        INDEX.signature (t := t) (ipath := ipath)}) =&gt;
    fun
      (I2 :
        {'[t, ipath] : [Set ** Set -&gt; Set] &amp;
          INDEX.signature (t := t) (ipath := ipath)}) =&gt;
      ((let t : Set := (|I1|).(INDEX.t) * (|I2|).(INDEX.t) in
      let path_length :=
        Pervasives.op_plus (|I1|).(INDEX.path_length) (|I2|).(INDEX.path_length)
        in
      let to_path (function_parameter : (|I1|).(INDEX.t) * (|I2|).(INDEX.t))
        : list string -&gt; list string :=
        let '(x, y) := function_parameter in
        fun l =&gt; (|I1|).(INDEX.to_path) x ((|I2|).(INDEX.to_path) y l) in
      let of_path (l : list string)
        : option ((|I1|).(INDEX.t) * (|I2|).(INDEX.t)) :=
        match Misc.take (|I1|).(INDEX.path_length) l with
        | None =&gt; None
        | Some (l1, l2) =&gt;
          match (((|I1|).(INDEX.of_path) l1), ((|I2|).(INDEX.of_path) l2)) with
          | (Some x, Some y) =&gt; Some (x, y)
          | _ =&gt; None
          end
        end in
      let ipath (a : Set) : Set := (|I2|).(INDEX.ipath) ((|I1|).(INDEX.ipath) a)
        in
      let args (function_parameter : unit) : Storage_description.args :=
        let '_ := function_parameter in
        Storage_description.Pair ((|I1|).(INDEX.args) tt)
          ((|I2|).(INDEX.args) tt) in
      let infer_ipath {a : Set} (function_parameter : ipath a) : a -&gt; a :=
        let '_ := function_parameter in
        fun x =&gt; x in
      existT (A := Set -&gt; Set) _ _
        {|
          INDEX.path_length := path_length;
          INDEX.to_path := to_path;
          INDEX.of_path := of_path;
          INDEX.args := args;
          INDEX.infer_ipath {_} := infer_ipath
        |})
        :
          {ipath : Set -&gt; Set &amp;
            INDEX.signature (t := ((|I1|).(INDEX.t) * (|I2|).(INDEX.t)))
              (ipath := ipath)}).

Definition Make_data_set_storage :=
  fun (C : {t : Set &amp; Raw_context.T.signature (t := t)}) =&gt;
    fun
      (I :
        {'[t, ipath] : [Set ** Set -&gt; Set] &amp;
          INDEX.signature (t := t) (ipath := ipath)}) =&gt;
      ((let t : Set := (|C|).(Raw_context.T.t) in
      let context : Set := t in
      let elt : Set := (|I|).(INDEX.t) in
      let inited := MBytes.of_string &quot;inited&quot; in
      let mem (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
        : Lwt.t bool :=
        (|C|).(Raw_context.T.mem) s ((|I|).(INDEX.to_path) i nil) in
      let add (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
        : Lwt.t Raw_context.root_context :=
        let= __t_value :=
          (|C|).(Raw_context.T.init_set) s ((|I|).(INDEX.to_path) i nil) inited
          in
        Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
      let del (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
        : Lwt.t Raw_context.root_context :=
        let= __t_value :=
          (|C|).(Raw_context.T.remove) s ((|I|).(INDEX.to_path) i nil) in
        Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
      let set
        (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
        (function_parameter : bool) : Lwt.t Raw_context.root_context :=
        match function_parameter with
        | true =&gt; add s i
        | false =&gt; del s i
        end in
      let clear (s : (|C|).(Raw_context.T.context))
        : Lwt.t Raw_context.root_context :=
        let= __t_value := (|C|).(Raw_context.T.remove_rec) s nil in
        Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
      let fold {A : Set}
        (s : (|C|).(Raw_context.T.context)) (init : A)
        (f : (|I|).(INDEX.t) -&gt; A -&gt; Lwt.t A) : Lwt.t A :=
        let fix dig
          (i : (|Compare.Int|).(Compare.S.t)) (path : Raw_context.key) (acc : A)
          {struct i} : Lwt.t A :=
          if (|Compare.Int|).(Compare.S.op_lteq) i 1 then
            (|C|).(Raw_context.T.fold) s path acc
              (fun k =&gt;
                fun acc =&gt;
                  match k with
                  | Context.Dir _ =&gt; Lwt.__return acc
                  | Context.Key file =&gt;
                    match (|I|).(INDEX.of_path) file with
                    | None =&gt;
                      (* ‚ùå Assert instruction is not handled. *)
                      assert (Lwt.t _) false
                    | Some __p_value =&gt; f __p_value acc
                    end
                  end)
          else
            (|C|).(Raw_context.T.fold) s path acc
              (fun k =&gt;
                fun acc =&gt;
                  match k with
                  | Context.Dir k =&gt; dig (Pervasives.op_minus i 1) k acc
                  | Context.Key _ =&gt; Lwt.__return acc
                  end) in
        dig (|I|).(INDEX.path_length) nil init in
      let elements (s : (|C|).(Raw_context.T.context))
        : Lwt.t (list (|I|).(INDEX.t)) :=
        fold s (nil (A := elt))
          (fun __p_value =&gt; fun acc =&gt; Lwt.__return (cons __p_value acc)) in
      (* ‚ùå top_level_evaluation *)
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.Data_set_storage.mem := mem;
          Storage_sigs.Data_set_storage.add := add;
          Storage_sigs.Data_set_storage.del := del;
          Storage_sigs.Data_set_storage.set := set;
          Storage_sigs.Data_set_storage.elements := elements;
          Storage_sigs.Data_set_storage.fold {_} := fold;
          Storage_sigs.Data_set_storage.clear := clear
        |})
        :
          {_ : unit &amp;
            Data_set_storage.signature (t := (|C|).(Raw_context.T.t))
              (elt := (|I|).(INDEX.t))}).

Definition Make_indexed_data_storage :=
  fun (C : {t : Set &amp; Raw_context.T.signature (t := t)}) =&gt;
    fun
      (I :
        {'[t, ipath] : [Set ** Set -&gt; Set] &amp;
          INDEX.signature (t := t) (ipath := ipath)}) =&gt;
      fun (V : {t : Set &amp; VALUE.signature (t := t)}) =&gt;
        ((let tag_Non_iterable_indexed_data_storage := tt in
        let t : Set := (|C|).(Raw_context.T.t) in
        let context : Set := t in
        let key : Set := (|I|).(INDEX.t) in
        let value : Set := (|V|).(Storage_sigs.VALUE.t) in
        let Encoder := Make_encoder (existT (A := Set) _ _ (|V|)) in
        let of_bytes := (|Encoder|).(ENCODER.of_bytes) in
        let to_bytes := (|Encoder|).(ENCODER.to_bytes) in
        let mem (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          : Lwt.t bool :=
          (|C|).(Raw_context.T.mem) s ((|I|).(INDEX.to_path) i nil) in
        let get (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          : Lwt.t (Error_monad.tzresult (|V|).(Storage_sigs.VALUE.t)) :=
          let=? __b_value :=
            (|C|).(Raw_context.T.get) s ((|I|).(INDEX.to_path) i nil) in
          let __key_value :=
            (|C|).(Raw_context.T.absolute_key) s ((|I|).(INDEX.to_path) i nil)
            in
          Lwt.__return (of_bytes __key_value __b_value) in
        let get_option (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          : Lwt.t (Error_monad.tzresult (option (|V|).(Storage_sigs.VALUE.t))) :=
          let= function_parameter :=
            (|C|).(Raw_context.T.get_option) s ((|I|).(INDEX.to_path) i nil) in
          match function_parameter with
          | None =&gt; Error_monad.return_none
          | Some __b_value =&gt;
            let __key_value :=
              (|C|).(Raw_context.T.absolute_key) s ((|I|).(INDEX.to_path) i nil)
              in
            match of_bytes __key_value __b_value with
            | Pervasives.Ok v =&gt; Error_monad.return_some v
            | Pervasives.Error __error_value =&gt;
              Lwt.__return (Pervasives.Error __error_value)
            end
          end in
        let set
          (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          (v : (|V|).(Storage_sigs.VALUE.t))
          : Lwt.t (Error_monad.tzresult Raw_context.root_context) :=
          let=? __t_value :=
            (|C|).(Raw_context.T.set) s ((|I|).(INDEX.to_path) i nil)
              (to_bytes v) in
          Error_monad.__return ((|C|).(Raw_context.T.project) __t_value) in
        let init
          (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          (v : (|V|).(Storage_sigs.VALUE.t))
          : Lwt.t (Error_monad.tzresult Raw_context.root_context) :=
          let=? __t_value :=
            (|C|).(Raw_context.T.init) s ((|I|).(INDEX.to_path) i nil)
              (to_bytes v) in
          Error_monad.__return ((|C|).(Raw_context.T.project) __t_value) in
        let init_set
          (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          (v : (|V|).(Storage_sigs.VALUE.t)) : Lwt.t Raw_context.root_context :=
          let= __t_value :=
            (|C|).(Raw_context.T.init_set) s ((|I|).(INDEX.to_path) i nil)
              (to_bytes v) in
          Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
        let set_option
          (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          (v : option (|V|).(Storage_sigs.VALUE.t))
          : Lwt.t Raw_context.root_context :=
          let= __t_value :=
            (|C|).(Raw_context.T.set_option) s ((|I|).(INDEX.to_path) i nil)
              (Option.map to_bytes v) in
          Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
        let remove (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          : Lwt.t Raw_context.root_context :=
          let= __t_value :=
            (|C|).(Raw_context.T.remove) s ((|I|).(INDEX.to_path) i nil) in
          Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
        let delete (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          : Lwt.t (Error_monad.tzresult Raw_context.root_context) :=
          let=? __t_value :=
            (|C|).(Raw_context.T.delete) s ((|I|).(INDEX.to_path) i nil) in
          Error_monad.__return ((|C|).(Raw_context.T.project) __t_value) in
        let clear (s : (|C|).(Raw_context.T.context))
          : Lwt.t Raw_context.root_context :=
          let= __t_value := (|C|).(Raw_context.T.remove_rec) s nil in
          Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
        let fold_keys {A : Set}
          (s : (|C|).(Raw_context.T.context)) (init : A)
          (f : (|I|).(INDEX.t) -&gt; A -&gt; Lwt.t A) : Lwt.t A :=
          let fix dig
            (i : (|Compare.Int|).(Compare.S.t)) (path : Raw_context.key)
            (acc : A) {struct i} : Lwt.t A :=
            if (|Compare.Int|).(Compare.S.op_lteq) i 1 then
              (|C|).(Raw_context.T.fold) s path acc
                (fun k =&gt;
                  fun acc =&gt;
                    match k with
                    | Context.Dir _ =&gt; Lwt.__return acc
                    | Context.Key file =&gt;
                      match (|I|).(INDEX.of_path) file with
                      | None =&gt;
                        (* ‚ùå Assert instruction is not handled. *)
                        assert (Lwt.t _) false
                      | Some path =&gt; f path acc
                      end
                    end)
            else
              (|C|).(Raw_context.T.fold) s path acc
                (fun k =&gt;
                  fun acc =&gt;
                    match k with
                    | Context.Dir k =&gt; dig (Pervasives.op_minus i 1) k acc
                    | Context.Key _ =&gt; Lwt.__return acc
                    end) in
          dig (|I|).(INDEX.path_length) nil init in
        let fold {A : Set}
          (s : (|C|).(Raw_context.T.context)) (init : A)
          (f : (|I|).(INDEX.t) -&gt; (|V|).(Storage_sigs.VALUE.t) -&gt; A -&gt; Lwt.t A)
          : Lwt.t A :=
          let f (path : (|I|).(INDEX.t)) (acc : A) : Lwt.t A :=
            let= function_parameter := get s path in
            match function_parameter with
            | Pervasives.Error _ =&gt; Lwt.__return acc
            | Pervasives.Ok v =&gt; f path v acc
            end in
          fold_keys s init f in
        let bindings (s : (|C|).(Raw_context.T.context))
          : Lwt.t (list ((|I|).(INDEX.t) * (|V|).(Storage_sigs.VALUE.t))) :=
          fold s (nil (A := key * value))
            (fun __p_value =&gt;
              fun v =&gt; fun acc =&gt; Lwt.__return (cons (__p_value, v) acc)) in
        let keys (s : (|C|).(Raw_context.T.context))
          : Lwt.t (list (|I|).(INDEX.t)) :=
          fold_keys s (nil (A := key))
            (fun __p_value =&gt; fun acc =&gt; Lwt.__return (cons __p_value acc)) in
        (* ‚ùå top_level_evaluation *)
        existT (A := unit) (fun _ =&gt; _) tt
          {|
            Storage_sigs.Indexed_data_storage.tag_Non_iterable_indexed_data_storage :=
              tag_Non_iterable_indexed_data_storage;
            Storage_sigs.Indexed_data_storage.mem := mem;
            Storage_sigs.Indexed_data_storage.get := get;
            Storage_sigs.Indexed_data_storage.get_option := get_option;
            Storage_sigs.Indexed_data_storage.set := set;
            Storage_sigs.Indexed_data_storage.init := init;
            Storage_sigs.Indexed_data_storage.init_set := init_set;
            Storage_sigs.Indexed_data_storage.set_option := set_option;
            Storage_sigs.Indexed_data_storage.delete := delete;
            Storage_sigs.Indexed_data_storage.remove := remove;
            Storage_sigs.Indexed_data_storage.clear := clear;
            Storage_sigs.Indexed_data_storage.keys := keys;
            Storage_sigs.Indexed_data_storage.bindings := bindings;
            Storage_sigs.Indexed_data_storage.fold {_} := fold;
            Storage_sigs.Indexed_data_storage.fold_keys {_} := fold_keys
          |})
          :
            {_ : unit &amp;
              Indexed_data_storage.signature (t := (|C|).(Raw_context.T.t))
                (key := (|I|).(INDEX.t)) (value := (|V|).(Storage_sigs.VALUE.t))}).

Definition Make_indexed_carbonated_data_storage :=
  fun (C : {t : Set &amp; Raw_context.T.signature (t := t)}) =&gt;
    fun
      (I :
        {'[t, ipath] : [Set ** Set -&gt; Set] &amp;
          INDEX.signature (t := t) (ipath := ipath)}) =&gt;
      fun (V : {t : Set &amp; VALUE.signature (t := t)}) =&gt;
        ((let tag_Non_iterable_indexed_carbonated_data_storage := tt in
        let t : Set := (|C|).(Raw_context.T.t) in
        let context : Set := t in
        let key : Set := (|I|).(INDEX.t) in
        let value : Set := (|V|).(Storage_sigs.VALUE.t) in
        let Encoder := Make_encoder (existT (A := Set) _ _ (|V|)) in
        let of_bytes := (|Encoder|).(ENCODER.of_bytes) in
        let to_bytes := (|Encoder|).(ENCODER.to_bytes) in
        let data_key (i : (|I|).(INDEX.t)) : list string :=
          (|I|).(INDEX.to_path) i [ data_name ] in
        let len_key (i : (|I|).(INDEX.t)) : list string :=
          (|I|).(INDEX.to_path) i [ len_name ] in
        let consume_mem_gas (c : (|C|).(Raw_context.T.context))
          : Lwt.t (Error_monad.tzresult (|C|).(Raw_context.T.context)) :=
          Lwt.__return
            ((|C|).(Raw_context.T.consume_gas) c
              (Gas_limit_repr.read_bytes_cost Z.zero)) in
        let existing_size
          (c : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          : Lwt.t (Error_monad.tzresult (int * bool)) :=
          let= function_parameter :=
            (|C|).(Raw_context.T.get_option) c (len_key i) in
          match function_parameter with
          | None =&gt; Error_monad.__return (0, false)
          | Some len =&gt;
            let=? len := decode_len_value (len_key i) len in
            Error_monad.__return (len, true)
          end in
        let consume_read_gas
          (get :
            (|C|).(Raw_context.T.context) -&gt; list string -&gt;
            Lwt.t (Error_monad.tzresult MBytes.t))
          (c : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          : Lwt.t (Error_monad.tzresult (|C|).(Raw_context.T.context)) :=
          let=? len := get c (len_key i) in
          let=? len := decode_len_value (len_key i) len in
          Lwt.__return
            ((|C|).(Raw_context.T.consume_gas) c
              (Gas_limit_repr.read_bytes_cost (Z.of_int len))) in
        let consume_serialize_write_gas {A : Set}
          (set :
            (|C|).(Raw_context.T.context) -&gt; list string -&gt; MBytes.t -&gt;
            Lwt.t (Error_monad.tzresult A)) (c : (|C|).(Raw_context.T.context))
          (i : (|I|).(INDEX.t)) (v : (|V|).(Storage_sigs.VALUE.t))
          : Lwt.t (Error_monad.tzresult (A * MBytes.t)) :=
          let __bytes_value := to_bytes v in
          let len := MBytes.length __bytes_value in
          let=? c :=
            Lwt.__return
              ((|C|).(Raw_context.T.consume_gas) c
                (Gas_limit_repr.alloc_mbytes_cost len)) in
          let=? c :=
            Lwt.__return
              ((|C|).(Raw_context.T.consume_gas) c
                (Gas_limit_repr.write_bytes_cost (Z.of_int len))) in
          let=? c := set c (len_key i) (encode_len_value __bytes_value) in
          Error_monad.__return (c, __bytes_value) in
        let consume_remove_gas {A : Set}
          (del :
            (|C|).(Raw_context.T.context) -&gt; list string -&gt;
            Lwt.t (Error_monad.tzresult A)) (c : (|C|).(Raw_context.T.context))
          (i : (|I|).(INDEX.t)) : Lwt.t (Error_monad.tzresult A) :=
          let=? c :=
            Lwt.__return
              ((|C|).(Raw_context.T.consume_gas) c
                (Gas_limit_repr.write_bytes_cost Z.zero)) in
          del c (len_key i) in
        let mem (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          : Lwt.t (Error_monad.tzresult (Raw_context.root_context * bool)) :=
          let=? s := consume_mem_gas s in
          let= __exists := (|C|).(Raw_context.T.mem) s (data_key i) in
          Error_monad.__return (((|C|).(Raw_context.T.project) s), __exists) in
        let get (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          : Lwt.t
            (Error_monad.tzresult
              (Raw_context.root_context * (|V|).(Storage_sigs.VALUE.t))) :=
          let=? s := consume_read_gas (|C|).(Raw_context.T.get) s i in
          let=? __b_value := (|C|).(Raw_context.T.get) s (data_key i) in
          let __key_value := (|C|).(Raw_context.T.absolute_key) s (data_key i)
            in
          let=? v := Lwt.__return (of_bytes __key_value __b_value) in
          Error_monad.__return (((|C|).(Raw_context.T.project) s), v) in
        let get_option (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          : Lwt.t
            (Error_monad.tzresult
              (Raw_context.root_context * option (|V|).(Storage_sigs.VALUE.t))) :=
          let=? s := consume_mem_gas s in
          let= __exists := (|C|).(Raw_context.T.mem) s (data_key i) in
          if __exists then
            let=? '(s, v) := get s i in
            Error_monad.__return (s, (Some v))
          else
            Error_monad.__return (((|C|).(Raw_context.T.project) s), None) in
        let set
          (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          (v : (|V|).(Storage_sigs.VALUE.t))
          : Lwt.t (Error_monad.tzresult (Raw_context.root_context * int)) :=
          let=? '(prev_size, _) := existing_size s i in
          let=? '(s, __bytes_value) :=
            consume_serialize_write_gas (|C|).(Raw_context.T.set) s i v in
          let=? __t_value :=
            (|C|).(Raw_context.T.set) s (data_key i) __bytes_value in
          let size_diff :=
            Pervasives.op_minus (MBytes.length __bytes_value) prev_size in
          Error_monad.__return
            (((|C|).(Raw_context.T.project) __t_value), size_diff) in
        let init
          (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          (v : (|V|).(Storage_sigs.VALUE.t))
          : Lwt.t (Error_monad.tzresult (Raw_context.root_context * int)) :=
          let=? '(s, __bytes_value) :=
            consume_serialize_write_gas (|C|).(Raw_context.T.init) s i v in
          let=? __t_value :=
            (|C|).(Raw_context.T.init) s (data_key i) __bytes_value in
          let size := MBytes.length __bytes_value in
          Error_monad.__return (((|C|).(Raw_context.T.project) __t_value), size)
          in
        let init_set
          (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          (v : (|V|).(Storage_sigs.VALUE.t))
          : Lwt.t (Error_monad.tzresult (Raw_context.root_context * int * bool)) :=
          let init_set
            (s : (|C|).(Raw_context.T.context)) (i : Raw_context.key)
            (v : Raw_context.value)
            : Lwt.t (Error_monad.tzresult (|C|).(Raw_context.T.context)) :=
            Error_monad.op_gtgteq ((|C|).(Raw_context.T.init_set) s i v)
              Error_monad.__return in
          let=? '(prev_size, existed) := existing_size s i in
          let=? '(s, __bytes_value) :=
            consume_serialize_write_gas init_set s i v in
          let=? __t_value := init_set s (data_key i) __bytes_value in
          let size_diff :=
            Pervasives.op_minus (MBytes.length __bytes_value) prev_size in
          Error_monad.__return
            (((|C|).(Raw_context.T.project) __t_value), size_diff, existed) in
        let remove (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          : Lwt.t (Error_monad.tzresult (Raw_context.root_context * int * bool)) :=
          let remove (s : (|C|).(Raw_context.T.context)) (i : Raw_context.key)
            : Lwt.t (Error_monad.tzresult (|C|).(Raw_context.T.context)) :=
            Error_monad.op_gtgteq ((|C|).(Raw_context.T.remove) s i)
              Error_monad.__return in
          let=? '(prev_size, existed) := existing_size s i in
          let=? s := consume_remove_gas remove s i in
          let=? __t_value := remove s (data_key i) in
          Error_monad.__return
            (((|C|).(Raw_context.T.project) __t_value), prev_size, existed) in
        let delete (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          : Lwt.t (Error_monad.tzresult (Raw_context.root_context * int)) :=
          let=? '(prev_size, _) := existing_size s i in
          let=? s := consume_remove_gas (|C|).(Raw_context.T.delete) s i in
          let=? __t_value := (|C|).(Raw_context.T.delete) s (data_key i) in
          Error_monad.__return
            (((|C|).(Raw_context.T.project) __t_value), prev_size) in
        let set_option
          (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
          (v : option (|V|).(Storage_sigs.VALUE.t))
          : Lwt.t (Error_monad.tzresult (Raw_context.root_context * int * bool)) :=
          match v with
          | None =&gt; remove s i
          | Some v =&gt; init_set s i v
          end in
        let fold_keys_unaccounted {A : Set}
          (s : (|C|).(Raw_context.T.context)) (init : A)
          (f : (|I|).(INDEX.t) -&gt; A -&gt; Lwt.t A) : Lwt.t A :=
          let fix dig
            (i : (|Compare.Int|).(Compare.S.t)) (path : Raw_context.key)
            (acc : A) {struct i} : Lwt.t A :=
            if (|Compare.Int|).(Compare.S.op_lteq) i 0 then
              (|C|).(Raw_context.T.fold) s path acc
                (fun k =&gt;
                  fun acc =&gt;
                    match k with
                    | Context.Dir _ =&gt; Lwt.__return acc
                    | Context.Key file =&gt;
                      match
                        ((List.rev file),
                          match List.rev file with
                          | cons last _ =&gt;
                            (|Compare.String|).(Compare.S.op_eq) last len_name
                          | _ =&gt; false
                          end,
                          match List.rev file with
                          | cons last rest =&gt;
                            (|Compare.String|).(Compare.S.op_eq) last data_name
                          | _ =&gt; false
                          end) with
                      | (cons last _, true, _) =&gt; Lwt.__return acc
                      | (cons last rest, _, true) =&gt;
                        let file := List.rev rest in
                        match (|I|).(INDEX.of_path) file with
                        | None =&gt;
                          (* ‚ùå Assert instruction is not handled. *)
                          assert (Lwt.t _) false
                        | Some path =&gt; f path acc
                        end
                      | (_, _, _) =&gt;
                        (* ‚ùå Assert instruction is not handled. *)
                        assert (Lwt.t _) false
                      end
                    end)
            else
              (|C|).(Raw_context.T.fold) s path acc
                (fun k =&gt;
                  fun acc =&gt;
                    match k with
                    | Context.Dir k =&gt; dig (Pervasives.op_minus i 1) k acc
                    | Context.Key _ =&gt; Lwt.__return acc
                    end) in
          dig (|I|).(INDEX.path_length) nil init in
        let keys_unaccounted (s : (|C|).(Raw_context.T.context))
          : Lwt.t (list (|I|).(INDEX.t)) :=
          fold_keys_unaccounted s (nil (A := key))
            (fun __p_value =&gt; fun acc =&gt; Lwt.__return (cons __p_value acc)) in
        (* ‚ùå top_level_evaluation *)
        existT (A := unit) (fun _ =&gt; _) tt
          {|
            Storage_sigs.Non_iterable_indexed_carbonated_data_storage.tag_Non_iterable_indexed_carbonated_data_storage :=
              tag_Non_iterable_indexed_carbonated_data_storage;
            Storage_sigs.Non_iterable_indexed_carbonated_data_storage.mem := mem;
            Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get := get;
            Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get_option :=
              get_option;
            Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set := set;
            Storage_sigs.Non_iterable_indexed_carbonated_data_storage.init :=
              init;
            Storage_sigs.Non_iterable_indexed_carbonated_data_storage.init_set :=
              init_set;
            Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set_option :=
              set_option;
            Storage_sigs.Non_iterable_indexed_carbonated_data_storage.delete :=
              delete;
            Storage_sigs.Non_iterable_indexed_carbonated_data_storage.remove :=
              remove
          |})
          :
            {_ : unit &amp;
              Non_iterable_indexed_carbonated_data_storage.signature
                (t := (|C|).(Raw_context.T.t)) (key := (|I|).(INDEX.t))
                (value := (|V|).(Storage_sigs.VALUE.t))}).

Definition Make_indexed_data_snapshotable_storage :=
  fun (C : {t : Set &amp; Raw_context.T.signature (t := t)}) =&gt;
    fun
      (Snapshot_index :
        {'[t, ipath] : [Set ** Set -&gt; Set] &amp;
          INDEX.signature (t := t) (ipath := ipath)}) =&gt;
      fun
        (I :
          {'[t, ipath] : [Set ** Set -&gt; Set] &amp;
            INDEX.signature (t := t) (ipath := ipath)}) =&gt;
        fun (V : {t : Set &amp; VALUE.signature (t := t)}) =&gt;
          ((let snapshot : Set := (|Snapshot_index|).(INDEX.t) in
          let data_name := [ &quot;current&quot; ] in
          let snapshot_name := [ &quot;snapshot&quot; ] in
          let C_data :=
            ((Make_subcontext
              (existT (A := unit) (fun _ =&gt; _) tt (|Registered|)))
              (existT (A := Set) _ _ (|C|)))
              (let name := data_name in
              existT (A := unit) (fun _ =&gt; _) tt
                {|
                  Storage_sigs.NAME.name := name
                |}) in
          let C_snapshot :=
            ((Make_subcontext
              (existT (A := unit) (fun _ =&gt; _) tt (|Registered|)))
              (existT (A := Set) _ _ (|C|)))
              (let name := snapshot_name in
              existT (A := unit) (fun _ =&gt; _) tt
                {|
                  Storage_sigs.NAME.name := name
                |}) in
          let Data_storage :=
            ((Make_indexed_data_storage (existT (A := Set) _ _ (|C_data|)))
              (existT (A := [Set ** Set -&gt; Set]) _ [_, _] (|I|)))
              (existT (A := Set) _ _ (|V|)) in
          let tag_Non_iterable_indexed_data_storage :=
            (|Data_storage|).(Storage_sigs.Indexed_data_storage.tag_Non_iterable_indexed_data_storage)
            in
          let t := (|Data_storage|).(Storage_sigs.Indexed_data_storage.t) in
          let context :=
            (|Data_storage|).(Storage_sigs.Indexed_data_storage.context) in
          let key := (|Data_storage|).(Storage_sigs.Indexed_data_storage.key) in
          let value :=
            (|Data_storage|).(Storage_sigs.Indexed_data_storage.value) in
          let mem := (|Data_storage|).(Storage_sigs.Indexed_data_storage.mem) in
          let get := (|Data_storage|).(Storage_sigs.Indexed_data_storage.get) in
          let get_option :=
            (|Data_storage|).(Storage_sigs.Indexed_data_storage.get_option) in
          let set := (|Data_storage|).(Storage_sigs.Indexed_data_storage.set) in
          let init := (|Data_storage|).(Storage_sigs.Indexed_data_storage.init)
            in
          let init_set :=
            (|Data_storage|).(Storage_sigs.Indexed_data_storage.init_set) in
          let set_option :=
            (|Data_storage|).(Storage_sigs.Indexed_data_storage.set_option) in
          let delete :=
            (|Data_storage|).(Storage_sigs.Indexed_data_storage.delete) in
          let remove :=
            (|Data_storage|).(Storage_sigs.Indexed_data_storage.remove) in
          let clear :=
            (|Data_storage|).(Storage_sigs.Indexed_data_storage.clear) in
          let keys := (|Data_storage|).(Storage_sigs.Indexed_data_storage.keys)
            in
          let bindings :=
            (|Data_storage|).(Storage_sigs.Indexed_data_storage.bindings) in
          let fold {a : Set} :=
            (|Data_storage|).(Storage_sigs.Indexed_data_storage.fold) in
          let fold_keys {a : Set} :=
            (|Data_storage|).(Storage_sigs.Indexed_data_storage.fold_keys) in
          let Pair_Snapshot_index_I :=
            (Pair
              (existT (A := [Set ** Set -&gt; Set]) _ [_, _] (|Snapshot_index|)))
              (existT (A := [Set ** Set -&gt; Set]) _ [_, _] (|I|)) in
          let Snapshot :=
            ((Make_indexed_data_storage (existT (A := Set) _ _ (|C_snapshot|)))
              (existT (A := [Set ** Set -&gt; Set]) _ [_, _]
                (|Pair_Snapshot_index_I|))) (existT (A := Set) _ _ (|V|)) in
          let snapshot_path (id : (|Snapshot_index|).(INDEX.t)) : list string :=
            Pervasives.op_at snapshot_name
              ((|Snapshot_index|).(INDEX.to_path) id nil) in
          let snapshot_exists
            (s : (|C|).(Raw_context.T.context))
            (id : (|Snapshot_index|).(INDEX.t)) : Lwt.t bool :=
            (|C|).(Raw_context.T.dir_mem) s (snapshot_path id) in
          let __snapshot_value
            (s : (|C|).(Raw_context.T.context))
            (id : (|Snapshot_index|).(INDEX.t))
            : Lwt.t (Error_monad.tzresult Raw_context.root_context) :=
            let=? __t_value :=
              (|C|).(Raw_context.T.copy) s data_name (snapshot_path id) in
            Error_monad.__return ((|C|).(Raw_context.T.project) __t_value) in
          let delete_snapshot
            (s : (|C|).(Raw_context.T.context))
            (id : (|Snapshot_index|).(INDEX.t))
            : Lwt.t Raw_context.root_context :=
            let= __t_value :=
              (|C|).(Raw_context.T.remove_rec) s (snapshot_path id) in
            Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
          existT (A := unit) (fun _ =&gt; _) tt
            {|
              Storage_sigs.Indexed_data_snapshotable_storage.tag_Non_iterable_indexed_data_storage :=
                tag_Non_iterable_indexed_data_storage;
              Storage_sigs.Indexed_data_snapshotable_storage.mem := mem;
              Storage_sigs.Indexed_data_snapshotable_storage.get := get;
              Storage_sigs.Indexed_data_snapshotable_storage.get_option :=
                get_option;
              Storage_sigs.Indexed_data_snapshotable_storage.set := set;
              Storage_sigs.Indexed_data_snapshotable_storage.init := init;
              Storage_sigs.Indexed_data_snapshotable_storage.init_set :=
                init_set;
              Storage_sigs.Indexed_data_snapshotable_storage.set_option :=
                set_option;
              Storage_sigs.Indexed_data_snapshotable_storage.delete := delete;
              Storage_sigs.Indexed_data_snapshotable_storage.remove := remove;
              Storage_sigs.Indexed_data_snapshotable_storage.clear := clear;
              Storage_sigs.Indexed_data_snapshotable_storage.keys := keys;
              Storage_sigs.Indexed_data_snapshotable_storage.bindings :=
                bindings;
              Storage_sigs.Indexed_data_snapshotable_storage.fold {_} := fold;
              Storage_sigs.Indexed_data_snapshotable_storage.fold_keys {_} :=
                fold_keys;
              Storage_sigs.Indexed_data_snapshotable_storage.Snapshot :=
                (|Snapshot|);
              Storage_sigs.Indexed_data_snapshotable_storage.snapshot_exists :=
                snapshot_exists;
              Storage_sigs.Indexed_data_snapshotable_storage.__snapshot_value :=
                __snapshot_value;
              Storage_sigs.Indexed_data_snapshotable_storage.delete_snapshot :=
                delete_snapshot
            |})
            :
              {_ : unit &amp;
                Indexed_data_snapshotable_storage.signature
                  (snapshot := (|Snapshot_index|).(INDEX.t))
                  (key := (|I|).(INDEX.t)) (t := (|C|).(Raw_context.T.t))
                  (value := (|V|).(Storage_sigs.VALUE.t))}).

Definition Make_indexed_subcontext :=
  fun (C : {t : Set &amp; Raw_context.T.signature (t := t)}) =&gt;
    fun
      (I :
        {'[t, ipath] : [Set ** Set -&gt; Set] &amp;
          INDEX.signature (t := t) (ipath := ipath)}) =&gt;
      ((let t : Set := (|C|).(Raw_context.T.t) in
      let context : Set := t in
      let key : Set := (|I|).(INDEX.t) in
      let ipath (a : Set) : Set := (|I|).(INDEX.ipath) a in
      let clear (__t_value : (|C|).(Raw_context.T.context))
        : Lwt.t Raw_context.root_context :=
        let= __t_value := (|C|).(Raw_context.T.remove_rec) __t_value nil in
        Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
      let fold_keys {A : Set}
        (__t_value : (|C|).(Raw_context.T.context)) (init : A)
        (f : (|I|).(INDEX.t) -&gt; A -&gt; Lwt.t A) : Lwt.t A :=
        let fix dig
          (i : (|Compare.Int|).(Compare.S.t)) (path : Raw_context.key) (acc : A)
          {struct i} : Lwt.t A :=
          if (|Compare.Int|).(Compare.S.op_lteq) i 0 then
            match (|I|).(INDEX.of_path) path with
            | None =&gt;
              (* ‚ùå Assert instruction is not handled. *)
              assert (Lwt.t _) false
            | Some path =&gt; f path acc
            end
          else
            (|C|).(Raw_context.T.fold) __t_value path acc
              (fun k =&gt;
                fun acc =&gt;
                  match k with
                  | Context.Dir k =&gt; dig (Pervasives.op_minus i 1) k acc
                  | Context.Key _ =&gt; Lwt.__return acc
                  end) in
        dig (|I|).(INDEX.path_length) nil init in
      let keys (__t_value : (|C|).(Raw_context.T.context))
        : Lwt.t (list (|I|).(INDEX.t)) :=
        fold_keys __t_value (nil (A := key))
          (fun i =&gt; fun acc =&gt; Lwt.__return (cons i acc)) in
      let __list_value
        (__t_value : (|C|).(Raw_context.T.context)) (k : Raw_context.key)
        : Lwt.t (list Context.dir_or_key) :=
        (|C|).(Raw_context.T.fold) __t_value k nil
          (fun k =&gt; fun acc =&gt; Lwt.__return (cons k acc)) in
      let remove_rec
        (__t_value : (|C|).(Raw_context.T.context)) (k : (|I|).(INDEX.t))
        : Lwt.t (|C|).(Raw_context.T.context) :=
        (|C|).(Raw_context.T.remove_rec) __t_value ((|I|).(INDEX.to_path) k nil)
        in
      let copy
        (__t_value : (|C|).(Raw_context.T.context)) (from : (|I|).(INDEX.t))
        (to_ : (|I|).(INDEX.t))
        : Lwt.t (Error_monad.tzresult (|C|).(Raw_context.T.context)) :=
        (|C|).(Raw_context.T.copy) __t_value ((|I|).(INDEX.to_path) from nil)
          ((|I|).(INDEX.to_path) to_ nil) in
      let description :=
        Storage_description.register_indexed_subcontext
          (|C|).(Raw_context.T.description)
          (fun c =&gt; Error_monad.op_gtgteq (keys c) Error_monad.__return)
          ((|I|).(INDEX.args) tt) in
      let unpack := Storage_description.unpack ((|I|).(INDEX.args) tt) in
      let __pack := Storage_description.__pack ((|I|).(INDEX.args) tt) in
      let Raw_context :=
        ((let t : Set := (|I|).(INDEX.ipath) (|C|).(Raw_context.T.t) in
        let context : Set := t in
        let to_key (i : (|I|).(INDEX.t)) (k : list string) : list string :=
          (|I|).(INDEX.to_path) i k in
        let of_key {A : Set} (k : list A) : list A :=
          Misc.remove_elem_from_list (|I|).(INDEX.path_length) k in
        let mem
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string) : Lwt.t bool :=
          let '(__t_value, i) := unpack c in
          (|C|).(Raw_context.T.mem) __t_value (to_key i k) in
        let dir_mem
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string) : Lwt.t bool :=
          let '(__t_value, i) := unpack c in
          (|C|).(Raw_context.T.dir_mem) __t_value (to_key i k) in
        let get
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string) : Lwt.t (Error_monad.tzresult Raw_context.value) :=
          let '(__t_value, i) := unpack c in
          (|C|).(Raw_context.T.get) __t_value (to_key i k) in
        let get_option
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string) : Lwt.t (option Raw_context.value) :=
          let '(__t_value, i) := unpack c in
          (|C|).(Raw_context.T.get_option) __t_value (to_key i k) in
        let init
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string) (v : Raw_context.value)
          : Lwt.t
            (Error_monad.tzresult
              ((|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))) :=
          let '(__t_value, i) := unpack c in
          let=? __t_value := (|C|).(Raw_context.T.init) __t_value (to_key i k) v
            in
          Error_monad.__return (__pack __t_value i) in
        let set
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string) (v : Raw_context.value)
          : Lwt.t
            (Error_monad.tzresult
              ((|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))) :=
          let '(__t_value, i) := unpack c in
          let=? __t_value := (|C|).(Raw_context.T.set) __t_value (to_key i k) v
            in
          Error_monad.__return (__pack __t_value i) in
        let init_set
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string) (v : Raw_context.value)
          : Lwt.t ((|I|).(INDEX.ipath) (|C|).(Raw_context.T.context)) :=
          let '(__t_value, i) := unpack c in
          let= __t_value :=
            (|C|).(Raw_context.T.init_set) __t_value (to_key i k) v in
          Lwt.__return (__pack __t_value i) in
        let set_option
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string) (v : option Raw_context.value)
          : Lwt.t ((|I|).(INDEX.ipath) (|C|).(Raw_context.T.context)) :=
          let '(__t_value, i) := unpack c in
          let= __t_value :=
            (|C|).(Raw_context.T.set_option) __t_value (to_key i k) v in
          Lwt.__return (__pack __t_value i) in
        let delete
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string)
          : Lwt.t
            (Error_monad.tzresult
              ((|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))) :=
          let '(__t_value, i) := unpack c in
          let=? __t_value := (|C|).(Raw_context.T.delete) __t_value (to_key i k)
            in
          Error_monad.__return (__pack __t_value i) in
        let remove
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string)
          : Lwt.t ((|I|).(INDEX.ipath) (|C|).(Raw_context.T.context)) :=
          let '(__t_value, i) := unpack c in
          let= __t_value := (|C|).(Raw_context.T.remove) __t_value (to_key i k)
            in
          Lwt.__return (__pack __t_value i) in
        let remove_rec
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string)
          : Lwt.t ((|I|).(INDEX.ipath) (|C|).(Raw_context.T.context)) :=
          let '(__t_value, i) := unpack c in
          let= __t_value :=
            (|C|).(Raw_context.T.remove_rec) __t_value (to_key i k) in
          Lwt.__return (__pack __t_value i) in
        let copy
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (from : list string) (to_ : list string)
          : Lwt.t
            (Error_monad.tzresult
              ((|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))) :=
          let '(__t_value, i) := unpack c in
          let=? __t_value :=
            (|C|).(Raw_context.T.copy) __t_value (to_key i from) (to_key i to_)
            in
          Error_monad.__return (__pack __t_value i) in
        let fold {A : Set}
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string) (init : A) (f : Context.dir_or_key -&gt; A -&gt; Lwt.t A)
          : Lwt.t A :=
          let '(__t_value, i) := unpack c in
          (|C|).(Raw_context.T.fold) __t_value (to_key i k) init
            (fun k =&gt; fun acc =&gt; f (map_key of_key k) acc) in
        let keys
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string) : Lwt.t (list (list string)) :=
          let '(__t_value, i) := unpack c in
          Error_monad.op_gtpipeeq
            ((|C|).(Raw_context.T.keys) __t_value (to_key i k))
            (fun keys =&gt; List.map of_key keys) in
        let fold_keys {A : Set}
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string) (init : A) (f : list string -&gt; A -&gt; Lwt.t A)
          : Lwt.t A :=
          let '(__t_value, i) := unpack c in
          (|C|).(Raw_context.T.fold_keys) __t_value (to_key i k) init
            (fun k =&gt; fun acc =&gt; f (of_key k) acc) in
        let project (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          : Raw_context.root_context :=
          let '(__t_value, _) := unpack c in
          (|C|).(Raw_context.T.project) __t_value in
        let absolute_key
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (k : list string) : Raw_context.key :=
          let '(__t_value, i) := unpack c in
          (|C|).(Raw_context.T.absolute_key) __t_value (to_key i k) in
        let consume_gas
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (g : Gas_limit_repr.cost)
          : Error_monad.tzresult
            ((|I|).(INDEX.ipath) (|C|).(Raw_context.T.context)) :=
          let '(__t_value, i) := unpack c in
          let? __t_value := (|C|).(Raw_context.T.consume_gas) __t_value g in
          Error_monad.ok (__pack __t_value i) in
        let check_enough_gas
          (c : (|I|).(INDEX.ipath) (|C|).(Raw_context.T.context))
          (g : Gas_limit_repr.cost) : Error_monad.tzresult unit :=
          let '(__t_value, _i) := unpack c in
          (|C|).(Raw_context.T.check_enough_gas) __t_value g in
        existT (A := unit) (fun _ =&gt; _) tt
          {|
            Raw_context.T.mem := mem;
            Raw_context.T.dir_mem := dir_mem;
            Raw_context.T.get := get;
            Raw_context.T.get_option := get_option;
            Raw_context.T.init := init;
            Raw_context.T.set := set;
            Raw_context.T.init_set := init_set;
            Raw_context.T.set_option := set_option;
            Raw_context.T.delete := delete;
            Raw_context.T.remove := remove;
            Raw_context.T.remove_rec := remove_rec;
            Raw_context.T.copy := copy;
            Raw_context.T.fold {_} := fold;
            Raw_context.T.keys := keys;
            Raw_context.T.fold_keys {_} := fold_keys;
            Raw_context.T.project := project;
            Raw_context.T.absolute_key := absolute_key;
            Raw_context.T.consume_gas := consume_gas;
            Raw_context.T.check_enough_gas := check_enough_gas;
            Raw_context.T.description := description
          |}) : {_ : unit &amp; Raw_context.T.signature (t := (ipath t))}) in
      let resolve
        (__t_value : (|C|).(Raw_context.T.context)) (prefix : list string)
        : Lwt.t (list (|I|).(INDEX.t)) :=
        let fix loop
          (i : (|Compare.Int|).(Compare.S.t)) (prefix : Raw_context.key)
          (function_parameter : list string) {struct i}
          : Lwt.t (list (|I|).(INDEX.t)) :=
          match
            (function_parameter,
              match function_parameter with
              | [] =&gt;
                (|Compare.Int|).(Compare.S.op_eq) i (|I|).(INDEX.path_length)
              | _ =&gt; false
              end,
              match function_parameter with
              | cons d [] =&gt;
                (|Compare.Int|).(Compare.S.op_eq) i
                  (Pervasives.op_minus (|I|).(INDEX.path_length) 1)
              | _ =&gt; false
              end) with
          | ([], true, _) =&gt;
            match (|I|).(INDEX.of_path) prefix with
            | None =&gt;
              (* ‚ùå Assert instruction is not handled. *)
              assert (Lwt.t (list (|I|).(INDEX.t))) false
            | Some path =&gt; Lwt.__return [ path ]
            end
          | ([], _, _) =&gt;
            let= prefixes := __list_value __t_value prefix in
            Error_monad.op_gtpipeeq
              (Lwt_list.map_s
                (fun function_parameter =&gt;
                  match function_parameter with
                  | (Context.Key prefix | Context.Dir prefix) =&gt;
                    loop (Pervasives.op_plus i 1) prefix nil
                  end) prefixes) List.flatten
          | (cons d [], _, true) =&gt;
            (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
            (* ‚ùå instruction_sequence &quot;;&quot; *)
            let= prefixes := __list_value __t_value prefix in
            Error_monad.op_gtpipeeq
              (Lwt_list.map_s
                (fun function_parameter =&gt;
                  match function_parameter with
                  | (Context.Key prefix | Context.Dir prefix) =&gt;
                    match Misc.remove_prefix d (List.hd (List.rev prefix)) with
                    | None =&gt; Lwt.return_nil
                    | Some _ =&gt; loop (Pervasives.op_plus i 1) prefix nil
                    end
                  end) prefixes) List.flatten
          | (cons &quot;&quot; ds, _, _) =&gt;
            let= prefixes := __list_value __t_value prefix in
            Error_monad.op_gtpipeeq
              (Lwt_list.map_s
                (fun function_parameter =&gt;
                  match function_parameter with
                  | (Context.Key prefix | Context.Dir prefix) =&gt;
                    loop (Pervasives.op_plus i 1) prefix ds
                  end) prefixes) List.flatten
          | (cons d ds, _, _) =&gt;
            (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
            (* ‚ùå instruction_sequence &quot;;&quot; *)
            let= function_parameter :=
              (|C|).(Raw_context.T.dir_mem) __t_value
                (Pervasives.op_at prefix [ d ]) in
            match function_parameter with
            | true =&gt;
              loop (Pervasives.op_plus i 1) (Pervasives.op_at prefix [ d ]) ds
            | false =&gt; Lwt.return_nil
            end
          end in
        loop 0 nil prefix in
      let Make_set :=
        fun (R : {_ : unit &amp; REGISTER.signature}) =&gt;
          fun (N : {_ : unit &amp; NAME.signature}) =&gt;
            ((let t : Set := (|C|).(Raw_context.T.t) in
            let context : Set := t in
            let elt : Set := (|I|).(INDEX.t) in
            let inited := MBytes.of_string &quot;inited&quot; in
            let mem (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              : Lwt.t bool :=
              (|Raw_context|).(Raw_context.T.mem) (__pack s i)
                (|N|).(Storage_sigs.NAME.name) in
            let add (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              : Lwt.t Raw_context.root_context :=
              let= c :=
                (|Raw_context|).(Raw_context.T.init_set) (__pack s i)
                  (|N|).(Storage_sigs.NAME.name) inited in
              let '(s, _) := unpack c in
              Lwt.__return ((|C|).(Raw_context.T.project) s) in
            let del (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              : Lwt.t Raw_context.root_context :=
              let= c :=
                (|Raw_context|).(Raw_context.T.remove) (__pack s i)
                  (|N|).(Storage_sigs.NAME.name) in
              let '(s, _) := unpack c in
              Lwt.__return ((|C|).(Raw_context.T.project) s) in
            let set
              (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              (function_parameter : bool) : Lwt.t Raw_context.root_context :=
              match function_parameter with
              | true =&gt; add s i
              | false =&gt; del s i
              end in
            let clear (s : (|C|).(Raw_context.T.context))
              : Lwt.t Raw_context.root_context :=
              let= __t_value :=
                fold_keys s s
                  (fun i =&gt;
                    fun s =&gt;
                      let= c :=
                        (|Raw_context|).(Raw_context.T.remove) (__pack s i)
                          (|N|).(Storage_sigs.NAME.name) in
                      let '(s, _) := unpack c in
                      Lwt.__return s) in
              Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
            let fold {A : Set}
              (s : (|C|).(Raw_context.T.context)) (init : A)
              (f : (|I|).(INDEX.t) -&gt; A -&gt; Lwt.t A) : Lwt.t A :=
              fold_keys s init
                (fun i =&gt;
                  fun acc =&gt;
                    let= function_parameter := mem s i in
                    match function_parameter with
                    | true =&gt; f i acc
                    | false =&gt; Lwt.__return acc
                    end) in
            let elements (s : (|C|).(Raw_context.T.context))
              : Lwt.t (list (|I|).(INDEX.t)) :=
              fold s (nil (A := elt))
                (fun __p_value =&gt; fun acc =&gt; Lwt.__return (cons __p_value acc))
              in
            (* ‚ùå top_level_evaluation *)
            existT (A := unit) (fun _ =&gt; _) tt
              {|
                Storage_sigs.Data_set_storage.mem := mem;
                Storage_sigs.Data_set_storage.add := add;
                Storage_sigs.Data_set_storage.del := del;
                Storage_sigs.Data_set_storage.set := set;
                Storage_sigs.Data_set_storage.elements := elements;
                Storage_sigs.Data_set_storage.fold {_} := fold;
                Storage_sigs.Data_set_storage.clear := clear
              |})
              : {_ : unit &amp; Data_set_storage.signature (t := t) (elt := key)})
        in
      let Make_map :=
        fun (N : {_ : unit &amp; NAME.signature}) =&gt;
          fun (V : {t : Set &amp; VALUE.signature (t := t)}) =&gt;
            ((let tag_Non_iterable_indexed_data_storage := tt in
            let t : Set := (|C|).(Raw_context.T.t) in
            let context : Set := t in
            let key : Set := (|I|).(INDEX.t) in
            let value : Set := (|V|).(Storage_sigs.VALUE.t) in
            let Encoder := Make_encoder (existT (A := Set) _ _ (|V|)) in
            let of_bytes := (|Encoder|).(ENCODER.of_bytes) in
            let to_bytes := (|Encoder|).(ENCODER.to_bytes) in
            let mem (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              : Lwt.t bool :=
              (|Raw_context|).(Raw_context.T.mem) (__pack s i)
                (|N|).(Storage_sigs.NAME.name) in
            let get (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              : Lwt.t (Error_monad.tzresult (|V|).(Storage_sigs.VALUE.t)) :=
              let=? __b_value :=
                (|Raw_context|).(Raw_context.T.get) (__pack s i)
                  (|N|).(Storage_sigs.NAME.name) in
              let __key_value :=
                (|Raw_context|).(Raw_context.T.absolute_key) (__pack s i)
                  (|N|).(Storage_sigs.NAME.name) in
              Lwt.__return (of_bytes __key_value __b_value) in
            let get_option
              (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              : Lwt.t
                (Error_monad.tzresult (option (|V|).(Storage_sigs.VALUE.t))) :=
              let= function_parameter :=
                (|Raw_context|).(Raw_context.T.get_option) (__pack s i)
                  (|N|).(Storage_sigs.NAME.name) in
              match function_parameter with
              | None =&gt; Error_monad.return_none
              | Some __b_value =&gt;
                let __key_value :=
                  (|Raw_context|).(Raw_context.T.absolute_key) (__pack s i)
                    (|N|).(Storage_sigs.NAME.name) in
                match of_bytes __key_value __b_value with
                | Pervasives.Ok v =&gt; Error_monad.return_some v
                | Pervasives.Error __error_value =&gt;
                  Lwt.__return (Pervasives.Error __error_value)
                end
              end in
            let set
              (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              (v : (|V|).(Storage_sigs.VALUE.t))
              : Lwt.t (Error_monad.tzresult Raw_context.root_context) :=
              let=? c :=
                (|Raw_context|).(Raw_context.T.set) (__pack s i)
                  (|N|).(Storage_sigs.NAME.name) (to_bytes v) in
              let '(s, _) := unpack c in
              Error_monad.__return ((|C|).(Raw_context.T.project) s) in
            let init
              (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              (v : (|V|).(Storage_sigs.VALUE.t))
              : Lwt.t (Error_monad.tzresult Raw_context.root_context) :=
              let=? c :=
                (|Raw_context|).(Raw_context.T.init) (__pack s i)
                  (|N|).(Storage_sigs.NAME.name) (to_bytes v) in
              let '(s, _) := unpack c in
              Error_monad.__return ((|C|).(Raw_context.T.project) s) in
            let init_set
              (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              (v : (|V|).(Storage_sigs.VALUE.t))
              : Lwt.t Raw_context.root_context :=
              let= c :=
                (|Raw_context|).(Raw_context.T.init_set) (__pack s i)
                  (|N|).(Storage_sigs.NAME.name) (to_bytes v) in
              let '(s, _) := unpack c in
              Lwt.__return ((|C|).(Raw_context.T.project) s) in
            let set_option
              (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              (v : option (|V|).(Storage_sigs.VALUE.t))
              : Lwt.t Raw_context.root_context :=
              let= c :=
                (|Raw_context|).(Raw_context.T.set_option) (__pack s i)
                  (|N|).(Storage_sigs.NAME.name) (Option.map to_bytes v) in
              let '(s, _) := unpack c in
              Lwt.__return ((|C|).(Raw_context.T.project) s) in
            let remove (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              : Lwt.t Raw_context.root_context :=
              let= c :=
                (|Raw_context|).(Raw_context.T.remove) (__pack s i)
                  (|N|).(Storage_sigs.NAME.name) in
              let '(s, _) := unpack c in
              Lwt.__return ((|C|).(Raw_context.T.project) s) in
            let delete (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              : Lwt.t (Error_monad.tzresult Raw_context.root_context) :=
              let=? c :=
                (|Raw_context|).(Raw_context.T.delete) (__pack s i)
                  (|N|).(Storage_sigs.NAME.name) in
              let '(s, _) := unpack c in
              Error_monad.__return ((|C|).(Raw_context.T.project) s) in
            let clear (s : (|C|).(Raw_context.T.context))
              : Lwt.t Raw_context.root_context :=
              let= __t_value :=
                fold_keys s s
                  (fun i =&gt;
                    fun s =&gt;
                      let= c :=
                        (|Raw_context|).(Raw_context.T.remove) (__pack s i)
                          (|N|).(Storage_sigs.NAME.name) in
                      let '(s, _) := unpack c in
                      Lwt.__return s) in
              Lwt.__return ((|C|).(Raw_context.T.project) __t_value) in
            let fold {A : Set}
              (s : (|C|).(Raw_context.T.context)) (init : A)
              (f :
                (|I|).(INDEX.t) -&gt; (|V|).(Storage_sigs.VALUE.t) -&gt; A -&gt; Lwt.t A)
              : Lwt.t A :=
              fold_keys s init
                (fun i =&gt;
                  fun acc =&gt;
                    let= function_parameter := get s i in
                    match function_parameter with
                    | Pervasives.Error _ =&gt; Lwt.__return acc
                    | Pervasives.Ok v =&gt; f i v acc
                    end) in
            let bindings (s : (|C|).(Raw_context.T.context))
              : Lwt.t (list ((|I|).(INDEX.t) * (|V|).(Storage_sigs.VALUE.t))) :=
              fold s (nil (A := key * value))
                (fun __p_value =&gt;
                  fun v =&gt; fun acc =&gt; Lwt.__return (cons (__p_value, v) acc)) in
            let fold_keys {A : Set}
              (s : (|C|).(Raw_context.T.context)) (init : A)
              (f : (|I|).(INDEX.t) -&gt; A -&gt; Lwt.t A) : Lwt.t A :=
              fold_keys s init
                (fun i =&gt;
                  fun acc =&gt;
                    let= function_parameter := mem s i in
                    match function_parameter with
                    | false =&gt; Lwt.__return acc
                    | true =&gt; f i acc
                    end) in
            let keys (s : (|C|).(Raw_context.T.context))
              : Lwt.t (list (|I|).(INDEX.t)) :=
              fold_keys s (nil (A := key))
                (fun __p_value =&gt; fun acc =&gt; Lwt.__return (cons __p_value acc))
              in
            (* ‚ùå top_level_evaluation *)
            existT (A := unit) (fun _ =&gt; _) tt
              {|
                Storage_sigs.Indexed_data_storage.tag_Non_iterable_indexed_data_storage :=
                  tag_Non_iterable_indexed_data_storage;
                Storage_sigs.Indexed_data_storage.mem := mem;
                Storage_sigs.Indexed_data_storage.get := get;
                Storage_sigs.Indexed_data_storage.get_option := get_option;
                Storage_sigs.Indexed_data_storage.set := set;
                Storage_sigs.Indexed_data_storage.init := init;
                Storage_sigs.Indexed_data_storage.init_set := init_set;
                Storage_sigs.Indexed_data_storage.set_option := set_option;
                Storage_sigs.Indexed_data_storage.delete := delete;
                Storage_sigs.Indexed_data_storage.remove := remove;
                Storage_sigs.Indexed_data_storage.clear := clear;
                Storage_sigs.Indexed_data_storage.keys := keys;
                Storage_sigs.Indexed_data_storage.bindings := bindings;
                Storage_sigs.Indexed_data_storage.fold {_} := fold;
                Storage_sigs.Indexed_data_storage.fold_keys {_} := fold_keys
              |})
              :
                {_ : unit &amp;
                  Indexed_data_storage.signature (t := t) (key := key)
                    (value := (|V|).(Storage_sigs.VALUE.t))}) in
      let Make_carbonated_map :=
        fun (N : {_ : unit &amp; NAME.signature}) =&gt;
          fun (V : {t : Set &amp; VALUE.signature (t := t)}) =&gt;
            ((let tag_Non_iterable_indexed_carbonated_data_storage := tt in
            let t : Set := (|C|).(Raw_context.T.t) in
            let context : Set := t in
            let key : Set := (|I|).(INDEX.t) in
            let value : Set := (|V|).(Storage_sigs.VALUE.t) in
            let Encoder := Make_encoder (existT (A := Set) _ _ (|V|)) in
            let of_bytes := (|Encoder|).(ENCODER.of_bytes) in
            let to_bytes := (|Encoder|).(ENCODER.to_bytes) in
            let len_name := cons len_name (|N|).(Storage_sigs.NAME.name) in
            let data_name := cons data_name (|N|).(Storage_sigs.NAME.name) in
            let consume_mem_gas (c : (|Raw_context|).(Raw_context.T.context))
              : Lwt.t
                (Error_monad.tzresult (|Raw_context|).(Raw_context.T.context)) :=
              Lwt.__return
                ((|Raw_context|).(Raw_context.T.consume_gas) c
                  (Gas_limit_repr.read_bytes_cost Z.zero)) in
            let existing_size (c : (|Raw_context|).(Raw_context.T.context))
              : Lwt.t (Error_monad.tzresult (int * bool)) :=
              let= function_parameter :=
                (|Raw_context|).(Raw_context.T.get_option) c len_name in
              match function_parameter with
              | None =&gt; Error_monad.__return (0, false)
              | Some len =&gt;
                let=? len := decode_len_value len_name len in
                Error_monad.__return (len, true)
              end in
            let consume_read_gas
              (get :
                (|Raw_context|).(Raw_context.T.context) -&gt; list string -&gt;
                Lwt.t (Error_monad.tzresult MBytes.t))
              (c : (|Raw_context|).(Raw_context.T.context))
              : Lwt.t
                (Error_monad.tzresult (|Raw_context|).(Raw_context.T.context)) :=
              let=? len := get c len_name in
              let=? len := decode_len_value len_name len in
              Lwt.__return
                ((|Raw_context|).(Raw_context.T.consume_gas) c
                  (Gas_limit_repr.read_bytes_cost (Z.of_int len))) in
            let consume_write_gas {A : Set}
              (set :
                (|Raw_context|).(Raw_context.T.context) -&gt; list string -&gt;
                MBytes.t -&gt; Lwt.t (Error_monad.tzresult A))
              (c : (|Raw_context|).(Raw_context.T.context))
              (v : (|V|).(Storage_sigs.VALUE.t))
              : Lwt.t (Error_monad.tzresult (A * MBytes.t)) :=
              let __bytes_value := to_bytes v in
              let len := MBytes.length __bytes_value in
              let=? c :=
                Lwt.__return
                  ((|Raw_context|).(Raw_context.T.consume_gas) c
                    (Gas_limit_repr.write_bytes_cost (Z.of_int len))) in
              let=? c := set c len_name (encode_len_value __bytes_value) in
              Error_monad.__return (c, __bytes_value) in
            let consume_remove_gas {A : Set}
              (del :
                (|Raw_context|).(Raw_context.T.context) -&gt; list string -&gt;
                Lwt.t (Error_monad.tzresult A))
              (c : (|Raw_context|).(Raw_context.T.context))
              : Lwt.t (Error_monad.tzresult A) :=
              let=? c :=
                Lwt.__return
                  ((|Raw_context|).(Raw_context.T.consume_gas) c
                    (Gas_limit_repr.write_bytes_cost Z.zero)) in
              del c len_name in
            let mem (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              : Lwt.t (Error_monad.tzresult (Raw_context.root_context * bool)) :=
              let=? c := consume_mem_gas (__pack s i) in
              let= res := (|Raw_context|).(Raw_context.T.mem) c data_name in
              Error_monad.__return
                (((|Raw_context|).(Raw_context.T.project) c), res) in
            let get (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              : Lwt.t
                (Error_monad.tzresult
                  (Raw_context.root_context * (|V|).(Storage_sigs.VALUE.t))) :=
              let=? c :=
                consume_read_gas (|Raw_context|).(Raw_context.T.get)
                  (__pack s i) in
              let=? __b_value := (|Raw_context|).(Raw_context.T.get) c data_name
                in
              let __key_value :=
                (|Raw_context|).(Raw_context.T.absolute_key) c data_name in
              let=? v := Lwt.__return (of_bytes __key_value __b_value) in
              Error_monad.__return
                (((|Raw_context|).(Raw_context.T.project) c), v) in
            let get_option
              (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              : Lwt.t
                (Error_monad.tzresult
                  (Raw_context.root_context *
                    option (|V|).(Storage_sigs.VALUE.t))) :=
              let=? c := consume_mem_gas (__pack s i) in
              let '(s, _) := unpack c in
              let= __exists :=
                (|Raw_context|).(Raw_context.T.mem) (__pack s i) data_name in
              if __exists then
                let=? '(s, v) := get s i in
                Error_monad.__return (s, (Some v))
              else
                Error_monad.__return (((|C|).(Raw_context.T.project) s), None)
              in
            let set
              (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              (v : (|V|).(Storage_sigs.VALUE.t))
              : Lwt.t (Error_monad.tzresult (Raw_context.root_context * int)) :=
              let=? '(prev_size, _) := existing_size (__pack s i) in
              let=? '(c, __bytes_value) :=
                consume_write_gas (|Raw_context|).(Raw_context.T.set)
                  (__pack s i) v in
              let=? c :=
                (|Raw_context|).(Raw_context.T.set) c data_name __bytes_value in
              let size_diff :=
                Pervasives.op_minus (MBytes.length __bytes_value) prev_size in
              Error_monad.__return
                (((|Raw_context|).(Raw_context.T.project) c), size_diff) in
            let init
              (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              (v : (|V|).(Storage_sigs.VALUE.t))
              : Lwt.t (Error_monad.tzresult (Raw_context.root_context * int)) :=
              let=? '(c, __bytes_value) :=
                consume_write_gas (|Raw_context|).(Raw_context.T.init)
                  (__pack s i) v in
              let=? c :=
                (|Raw_context|).(Raw_context.T.init) c data_name __bytes_value
                in
              let size := MBytes.length __bytes_value in
              Error_monad.__return
                (((|Raw_context|).(Raw_context.T.project) c), size) in
            let init_set
              (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              (v : (|V|).(Storage_sigs.VALUE.t))
              : Lwt.t
                (Error_monad.tzresult (Raw_context.root_context * int * bool)) :=
              let init_set
                (c : (|Raw_context|).(Raw_context.T.context))
                (k : Raw_context.key) (v : Raw_context.value)
                : Lwt.t
                  (Error_monad.tzresult (|Raw_context|).(Raw_context.T.context)) :=
                Error_monad.op_gtgteq
                  ((|Raw_context|).(Raw_context.T.init_set) c k v)
                  Error_monad.__return in
              let=? '(prev_size, existed) := existing_size (__pack s i) in
              let=? '(c, __bytes_value) :=
                consume_write_gas init_set (__pack s i) v in
              let=? c := init_set c data_name __bytes_value in
              let size_diff :=
                Pervasives.op_minus (MBytes.length __bytes_value) prev_size in
              Error_monad.__return
                (((|Raw_context|).(Raw_context.T.project) c), size_diff, existed)
              in
            let remove (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              : Lwt.t
                (Error_monad.tzresult (Raw_context.root_context * int * bool)) :=
              let remove
                (c : (|Raw_context|).(Raw_context.T.context))
                (k : Raw_context.key)
                : Lwt.t
                  (Error_monad.tzresult (|Raw_context|).(Raw_context.T.context)) :=
                Error_monad.op_gtgteq
                  ((|Raw_context|).(Raw_context.T.remove) c k)
                  Error_monad.__return in
              let=? '(prev_size, existed) := existing_size (__pack s i) in
              let=? c := consume_remove_gas remove (__pack s i) in
              let=? c := remove c data_name in
              Error_monad.__return
                (((|Raw_context|).(Raw_context.T.project) c), prev_size, existed)
              in
            let delete (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              : Lwt.t (Error_monad.tzresult (Raw_context.root_context * int)) :=
              let=? '(prev_size, _) := existing_size (__pack s i) in
              let=? c :=
                consume_remove_gas (|Raw_context|).(Raw_context.T.delete)
                  (__pack s i) in
              let=? c := (|Raw_context|).(Raw_context.T.delete) c data_name in
              Error_monad.__return
                (((|Raw_context|).(Raw_context.T.project) c), prev_size) in
            let set_option
              (s : (|C|).(Raw_context.T.context)) (i : (|I|).(INDEX.t))
              (v : option (|V|).(Storage_sigs.VALUE.t))
              : Lwt.t
                (Error_monad.tzresult (Raw_context.root_context * int * bool)) :=
              match v with
              | None =&gt; remove s i
              | Some v =&gt; init_set s i v
              end in
            (* ‚ùå top_level_evaluation *)
            existT (A := unit) (fun _ =&gt; _) tt
              {|
                Storage_sigs.Non_iterable_indexed_carbonated_data_storage.tag_Non_iterable_indexed_carbonated_data_storage :=
                  tag_Non_iterable_indexed_carbonated_data_storage;
                Storage_sigs.Non_iterable_indexed_carbonated_data_storage.mem :=
                  mem;
                Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get :=
                  get;
                Storage_sigs.Non_iterable_indexed_carbonated_data_storage.get_option :=
                  get_option;
                Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set :=
                  set;
                Storage_sigs.Non_iterable_indexed_carbonated_data_storage.init :=
                  init;
                Storage_sigs.Non_iterable_indexed_carbonated_data_storage.init_set :=
                  init_set;
                Storage_sigs.Non_iterable_indexed_carbonated_data_storage.set_option :=
                  set_option;
                Storage_sigs.Non_iterable_indexed_carbonated_data_storage.delete :=
                  delete;
                Storage_sigs.Non_iterable_indexed_carbonated_data_storage.remove :=
                  remove
              |})
              :
                {_ : unit &amp;
                  Non_iterable_indexed_carbonated_data_storage.signature
                    (t := t) (key := key)
                    (value := (|V|).(Storage_sigs.VALUE.t))}) in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.Indexed_raw_context.clear := clear;
          Storage_sigs.Indexed_raw_context.fold_keys {_} := fold_keys;
          Storage_sigs.Indexed_raw_context.keys := keys;
          Storage_sigs.Indexed_raw_context.resolve := resolve;
          Storage_sigs.Indexed_raw_context.remove_rec := remove_rec;
          Storage_sigs.Indexed_raw_context.copy := copy;
          Storage_sigs.Indexed_raw_context.Make_set := Make_set;
          Storage_sigs.Indexed_raw_context.Make_map := Make_map;
          Storage_sigs.Indexed_raw_context.Make_carbonated_map :=
            Make_carbonated_map;
          Storage_sigs.Indexed_raw_context.Raw_context := (|Raw_context|)
        |})
        :
          {_ : unit &amp;
            Indexed_raw_context.signature (t := (|C|).(Raw_context.T.t))
              (key := (|I|).(INDEX.t))
              (ipath := (fun (a : Set) =&gt; (|I|).(INDEX.ipath) a))}).

Module WRAPPER.
  Record signature {t key : Set} : Set := {
    t := t;
    key := key;
    wrap : t -&gt; key;
    unwrap : key -&gt; option t;
  }.
End WRAPPER.

Definition Wrap_indexed_data_storage :=
  fun
    (C :
      {'[t, key, value] : [Set ** Set ** Set] &amp;
        Indexed_data_storage.signature (t := t) (key := key) (value := value)})
    =&gt;
    fun
      (K :
        {t : Set &amp;
          WRAPPER.signature (t := t)
            (key := (|C|).(Storage_sigs.Indexed_data_storage.key))}) =&gt;
      ((let tag_Non_iterable_indexed_data_storage := tt in
      let t : Set := (|C|).(Storage_sigs.Indexed_data_storage.t) in
      let context : Set := (|C|).(Storage_sigs.Indexed_data_storage.t) in
      let key : Set := (|K|).(WRAPPER.t) in
      let value : Set := (|C|).(Storage_sigs.Indexed_data_storage.value) in
      let mem
        (ctxt : (|C|).(Storage_sigs.Indexed_data_storage.context))
        (k : (|K|).(WRAPPER.t)) : Lwt.t bool :=
        (|C|).(Storage_sigs.Indexed_data_storage.mem) ctxt
          ((|K|).(WRAPPER.wrap) k) in
      let get
        (ctxt : (|C|).(Storage_sigs.Indexed_data_storage.context))
        (k : (|K|).(WRAPPER.t))
        : Lwt.t
          (Error_monad.tzresult (|C|).(Storage_sigs.Indexed_data_storage.value)) :=
        (|C|).(Storage_sigs.Indexed_data_storage.get) ctxt
          ((|K|).(WRAPPER.wrap) k) in
      let get_option
        (ctxt : (|C|).(Storage_sigs.Indexed_data_storage.context))
        (k : (|K|).(WRAPPER.t))
        : Lwt.t
          (Error_monad.tzresult
            (option (|C|).(Storage_sigs.Indexed_data_storage.value))) :=
        (|C|).(Storage_sigs.Indexed_data_storage.get_option) ctxt
          ((|K|).(WRAPPER.wrap) k) in
      let set
        (ctxt : (|C|).(Storage_sigs.Indexed_data_storage.context))
        (k : (|K|).(WRAPPER.t))
        (v : (|C|).(Storage_sigs.Indexed_data_storage.value))
        : Lwt.t (Error_monad.tzresult Raw_context.t) :=
        (|C|).(Storage_sigs.Indexed_data_storage.set) ctxt
          ((|K|).(WRAPPER.wrap) k) v in
      let init
        (ctxt : (|C|).(Storage_sigs.Indexed_data_storage.context))
        (k : (|K|).(WRAPPER.t))
        (v : (|C|).(Storage_sigs.Indexed_data_storage.value))
        : Lwt.t (Error_monad.tzresult Raw_context.t) :=
        (|C|).(Storage_sigs.Indexed_data_storage.init) ctxt
          ((|K|).(WRAPPER.wrap) k) v in
      let init_set
        (ctxt : (|C|).(Storage_sigs.Indexed_data_storage.context))
        (k : (|K|).(WRAPPER.t))
        (v : (|C|).(Storage_sigs.Indexed_data_storage.value))
        : Lwt.t Raw_context.t :=
        (|C|).(Storage_sigs.Indexed_data_storage.init_set) ctxt
          ((|K|).(WRAPPER.wrap) k) v in
      let set_option
        (ctxt : (|C|).(Storage_sigs.Indexed_data_storage.context))
        (k : (|K|).(WRAPPER.t))
        (v : option (|C|).(Storage_sigs.Indexed_data_storage.value))
        : Lwt.t Raw_context.t :=
        (|C|).(Storage_sigs.Indexed_data_storage.set_option) ctxt
          ((|K|).(WRAPPER.wrap) k) v in
      let delete
        (ctxt : (|C|).(Storage_sigs.Indexed_data_storage.context))
        (k : (|K|).(WRAPPER.t)) : Lwt.t (Error_monad.tzresult Raw_context.t) :=
        (|C|).(Storage_sigs.Indexed_data_storage.delete) ctxt
          ((|K|).(WRAPPER.wrap) k) in
      let remove
        (ctxt : (|C|).(Storage_sigs.Indexed_data_storage.context))
        (k : (|K|).(WRAPPER.t)) : Lwt.t Raw_context.t :=
        (|C|).(Storage_sigs.Indexed_data_storage.remove) ctxt
          ((|K|).(WRAPPER.wrap) k) in
      let clear (ctxt : (|C|).(Storage_sigs.Indexed_data_storage.context))
        : Lwt.t Raw_context.t :=
        (|C|).(Storage_sigs.Indexed_data_storage.clear) ctxt in
      let fold {A : Set}
        (ctxt : (|C|).(Storage_sigs.Indexed_data_storage.context)) (init : A)
        (f :
          (|K|).(WRAPPER.t) -&gt;
          (|C|).(Storage_sigs.Indexed_data_storage.value) -&gt; A -&gt; Lwt.t A)
        : Lwt.t A :=
        (|C|).(Storage_sigs.Indexed_data_storage.fold) ctxt init
          (fun k =&gt;
            fun v =&gt;
              fun acc =&gt;
                match (|K|).(WRAPPER.unwrap) k with
                | None =&gt; Lwt.__return acc
                | Some k =&gt; f k v acc
                end) in
      let bindings (s : (|C|).(Storage_sigs.Indexed_data_storage.context))
        : Lwt.t
          (list
            ((|K|).(WRAPPER.t) * (|C|).(Storage_sigs.Indexed_data_storage.value))) :=
        fold s (nil (A := key * value))
          (fun __p_value =&gt;
            fun v =&gt; fun acc =&gt; Lwt.__return (cons (__p_value, v) acc)) in
      let fold_keys {A : Set}
        (s : (|C|).(Storage_sigs.Indexed_data_storage.context)) (init : A)
        (f : (|K|).(WRAPPER.t) -&gt; A -&gt; Lwt.t A) : Lwt.t A :=
        (|C|).(Storage_sigs.Indexed_data_storage.fold_keys) s init
          (fun k =&gt;
            fun acc =&gt;
              match (|K|).(WRAPPER.unwrap) k with
              | None =&gt; Lwt.__return acc
              | Some k =&gt; f k acc
              end) in
      let keys (s : (|C|).(Storage_sigs.Indexed_data_storage.context))
        : Lwt.t (list (|K|).(WRAPPER.t)) :=
        fold_keys s (nil (A := key))
          (fun __p_value =&gt; fun acc =&gt; Lwt.__return (cons __p_value acc)) in
      existT (A := unit) (fun _ =&gt; _) tt
        {|
          Storage_sigs.Indexed_data_storage.tag_Non_iterable_indexed_data_storage :=
            tag_Non_iterable_indexed_data_storage;
          Storage_sigs.Indexed_data_storage.mem := mem;
          Storage_sigs.Indexed_data_storage.get := get;
          Storage_sigs.Indexed_data_storage.get_option := get_option;
          Storage_sigs.Indexed_data_storage.set := set;
          Storage_sigs.Indexed_data_storage.init := init;
          Storage_sigs.Indexed_data_storage.init_set := init_set;
          Storage_sigs.Indexed_data_storage.set_option := set_option;
          Storage_sigs.Indexed_data_storage.delete := delete;
          Storage_sigs.Indexed_data_storage.remove := remove;
          Storage_sigs.Indexed_data_storage.clear := clear;
          Storage_sigs.Indexed_data_storage.keys := keys;
          Storage_sigs.Indexed_data_storage.bindings := bindings;
          Storage_sigs.Indexed_data_storage.fold {_} := fold;
          Storage_sigs.Indexed_data_storage.fold_keys {_} := fold_keys
        |})
        :
          {_ : unit &amp;
            Indexed_data_storage.signature
              (t := (|C|).(Storage_sigs.Indexed_data_storage.t))
              (key := (|K|).(WRAPPER.t))
              (value := (|C|).(Storage_sigs.Indexed_data_storage.value))}).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="storage_functors.mli">
  <div style="margin: 20px;">
    <h3>Storage_functors_mli</h3>
    <ul>
      <li>OCaml size: 112 lines</li>
      <li>Coq size: 136 lines (+21% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#storage_functors.mli"><code>storage_functors.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Tezos Protocol Implementation - Typed storage builders. *)

open Storage_sigs

module Registered : REGISTER

module Ghost : REGISTER

module Make_subcontext (R : REGISTER) (C : Raw_context.T) (N : NAME) :
  Raw_context.T with type t = C.t

module Make_single_data_storage
    (R : REGISTER)
    (C : Raw_context.T)
    (N : NAME)
    (V : VALUE) : Single_data_storage with type t = C.t and type value = V.t

module type INDEX = sig
  type t

  val path_length : int

  val to_path : t -&gt; string list -&gt; string list

  val of_path : string list -&gt; t option

  type 'a ipath

  val args : unit -&gt; ('a, t, 'a ipath) Storage_description.args

  val infer_ipath : 'a ipath -&gt; 'a -&gt; 'a
end

module Pair (I1 : INDEX) (I2 : INDEX) : INDEX with type t = I1.t * I2.t

module Make_data_set_storage (C : Raw_context.T) (I : INDEX) :
  Data_set_storage with type t = C.t and type elt = I.t

module Make_indexed_data_storage (C : Raw_context.T) (I : INDEX) (V : VALUE) :
  Indexed_data_storage
    with type t = C.t
     and type key = I.t
     and type value = V.t

module Make_indexed_carbonated_data_storage
    (C : Raw_context.T)
    (I : INDEX)
    (V : VALUE) :
  Non_iterable_indexed_carbonated_data_storage
    with type t = C.t
     and type key = I.t
     and type value = V.t

module Make_indexed_data_snapshotable_storage
    (C : Raw_context.T)
    (Snapshot : INDEX)
    (I : INDEX)
    (V : VALUE) :
  Indexed_data_snapshotable_storage
    with type t = C.t
     and type snapshot = Snapshot.t
     and type key = I.t
     and type value = V.t

module Make_indexed_subcontext (C : Raw_context.T) (I : INDEX) :
  Indexed_raw_context
    with type t = C.t
     and type key = I.t
     and type 'a ipath = 'a I.ipath

module type WRAPPER = sig
  type t

  type key

  val wrap : t -&gt; key

  val unwrap : key -&gt; t option
end

module Wrap_indexed_data_storage
    (C : Indexed_data_storage)
    (K : WRAPPER with type key := C.key) :
  Indexed_data_storage
    with type t = C.t
     and type key = K.t
     and type value = C.value
</pre>
  </div>
  <div class="col-md-6">
    <a href="#storage_functors.mli"><code>Storage_functors_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Raw_context.
Require Tezos.Storage_description.
Require Tezos.Storage_sigs.

Import Storage_sigs.

Parameter Registered : {_ : unit &amp; REGISTER.signature}.

Parameter Ghost : {_ : unit &amp; REGISTER.signature}.

Parameter Make_subcontext :
  forall (R : {_ : unit &amp; REGISTER.signature}),
    (forall (C : {t : Set &amp; Raw_context.T.signature (t := t)}),
      (forall (N : {_ : unit &amp; NAME.signature}),
        {_ : unit &amp; Raw_context.T.signature (t := (|C|).(Raw_context.T.t))})).

Parameter Make_single_data_storage :
  forall (R : {_ : unit &amp; REGISTER.signature}),
    (forall (C : {t : Set &amp; Raw_context.T.signature (t := t)}),
      (forall (N : {_ : unit &amp; NAME.signature}),
        (forall (V : {t : Set &amp; VALUE.signature (t := t)}),
          {_ : unit &amp;
            Single_data_storage.signature (t := (|C|).(Raw_context.T.t))
              (value := (|V|).(Storage_sigs.VALUE.t))}))).

Module INDEX.
  Record signature {t : Set} {ipath : Set -&gt; Set} : Set := {
    t := t;
    path_length : int;
    to_path : t -&gt; list string -&gt; list string;
    of_path : list string -&gt; option t;
    ipath := ipath;
    args : unit -&gt; Storage_description.args;
    infer_ipath : forall {a : Set}, ipath a -&gt; a -&gt; a;
  }.
End INDEX.

Parameter Pair :
  forall (I1 :
    {'[t, ipath] : [Set ** Set -&gt; Set] &amp;
      INDEX.signature (t := t) (ipath := ipath)}),
    (forall (I2 :
      {'[t, ipath] : [Set ** Set -&gt; Set] &amp;
        INDEX.signature (t := t) (ipath := ipath)}),
      {ipath : Set -&gt; Set &amp;
        INDEX.signature (t := ((|I1|).(INDEX.t) * (|I2|).(INDEX.t)))
          (ipath := ipath)}).

Parameter Make_data_set_storage :
  forall (C : {t : Set &amp; Raw_context.T.signature (t := t)}),
    (forall (I :
      {'[t, ipath] : [Set ** Set -&gt; Set] &amp;
        INDEX.signature (t := t) (ipath := ipath)}),
      {_ : unit &amp;
        Data_set_storage.signature (t := (|C|).(Raw_context.T.t))
          (elt := (|I|).(INDEX.t))}).

Parameter Make_indexed_data_storage :
  forall (C : {t : Set &amp; Raw_context.T.signature (t := t)}),
    (forall (I :
      {'[t, ipath] : [Set ** Set -&gt; Set] &amp;
        INDEX.signature (t := t) (ipath := ipath)}),
      (forall (V : {t : Set &amp; VALUE.signature (t := t)}),
        {_ : unit &amp;
          Indexed_data_storage.signature (t := (|C|).(Raw_context.T.t))
            (key := (|I|).(INDEX.t)) (value := (|V|).(Storage_sigs.VALUE.t))})).

Parameter Make_indexed_carbonated_data_storage :
  forall (C : {t : Set &amp; Raw_context.T.signature (t := t)}),
    (forall (I :
      {'[t, ipath] : [Set ** Set -&gt; Set] &amp;
        INDEX.signature (t := t) (ipath := ipath)}),
      (forall (V : {t : Set &amp; VALUE.signature (t := t)}),
        {_ : unit &amp;
          Non_iterable_indexed_carbonated_data_storage.signature
            (t := (|C|).(Raw_context.T.t)) (key := (|I|).(INDEX.t))
            (value := (|V|).(Storage_sigs.VALUE.t))})).

Parameter Make_indexed_data_snapshotable_storage :
  forall (C : {t : Set &amp; Raw_context.T.signature (t := t)}),
    (forall (Snapshot :
      {'[t, ipath] : [Set ** Set -&gt; Set] &amp;
        INDEX.signature (t := t) (ipath := ipath)}),
      (forall (I :
        {'[t, ipath] : [Set ** Set -&gt; Set] &amp;
          INDEX.signature (t := t) (ipath := ipath)}),
        (forall (V : {t : Set &amp; VALUE.signature (t := t)}),
          {_ : unit &amp;
            Indexed_data_snapshotable_storage.signature
              (snapshot := (|Snapshot|).(INDEX.t)) (key := (|I|).(INDEX.t))
              (t := (|C|).(Raw_context.T.t))
              (value := (|V|).(Storage_sigs.VALUE.t))}))).

Parameter Make_indexed_subcontext :
  forall (C : {t : Set &amp; Raw_context.T.signature (t := t)}),
    (forall (I :
      {'[t, ipath] : [Set ** Set -&gt; Set] &amp;
        INDEX.signature (t := t) (ipath := ipath)}),
      {_ : unit &amp;
        Indexed_raw_context.signature (t := (|C|).(Raw_context.T.t))
          (key := (|I|).(INDEX.t))
          (ipath := (fun (a : Set) =&gt; (|I|).(INDEX.ipath) a))}).

Module WRAPPER.
  Record signature {t key : Set} : Set := {
    t := t;
    key := key;
    wrap : t -&gt; key;
    unwrap : key -&gt; option t;
  }.
End WRAPPER.

Parameter Wrap_indexed_data_storage :
  forall (C :
    {'[t, key, value] : [Set ** Set ** Set] &amp;
      Indexed_data_storage.signature (t := t) (key := key) (value := value)}),
    (forall (K :
      {t : Set &amp;
        WRAPPER.signature (t := t)
          (key := (|C|).(Storage_sigs.Indexed_data_storage.key))}),
      {_ : unit &amp;
        Indexed_data_storage.signature
          (t := (|C|).(Storage_sigs.Indexed_data_storage.t))
          (key := (|K|).(WRAPPER.t))
          (value := (|C|).(Storage_sigs.Indexed_data_storage.value))}).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="storage_sigs.ml">
  <div style="margin: 20px;">
    <h3>Storage_sigs</h3>
    <ul>
      <li>OCaml size: 422 lines</li>
      <li>Coq size: 242 lines (-43% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#storage_sigs.ml"><code>storage_sigs.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

let depend_on_me () = ()

(** {1 Entity Accessor Signatures} *)

(** The generic signature of a single data accessor (a single value
    bound to a specific key in the hierarchical (key x value)
    database). *)
module type Single_data_storage = sig
  val tag_Single_data_storage : unit

  type t

  type context = t

  (** The type of the value *)
  type value

  (** Tells if the data is already defined *)
  val mem : context -&gt; bool Lwt.t

  (** Retrieve the value from the storage bucket ; returns a
      {!Storage_error} if the key is not set or if the deserialisation
      fails *)
  val get : context -&gt; value tzresult Lwt.t

  (** Retrieves the value from the storage bucket ; returns [None] if
      the data is not initialized, or {!Storage_helpers.Storage_error}
      if the deserialisation fails *)
  val get_option : context -&gt; value option tzresult Lwt.t

  (** Allocates the storage bucket and initializes it ; returns a
      {!Storage_error Existing_key} if the bucket exists *)
  val init : context -&gt; value -&gt; Raw_context.t tzresult Lwt.t

  (** Updates the content of the bucket ; returns a {!Storage_Error
      Missing_key} if the value does not exists *)
  val set : context -&gt; value -&gt; Raw_context.t tzresult Lwt.t

  (** Allocates the data and initializes it with a value ; just
      updates it if the bucket exists *)
  val init_set : context -&gt; value -&gt; Raw_context.t Lwt.t

  (** When the value is [Some v], allocates the data and initializes
      it with [v] ; just updates it if the bucket exists. When the
      valus is [None], delete the storage bucket when the value ; does
      nothing if the bucket does not exists. *)
  val set_option : context -&gt; value option -&gt; Raw_context.t Lwt.t

  (** Delete the storage bucket ; returns a {!Storage_error
      Missing_key} if the bucket does not exists *)
  val delete : context -&gt; Raw_context.t tzresult Lwt.t

  (** Removes the storage bucket and its contents ; does nothing if
      the bucket does not exists *)
  val remove : context -&gt; Raw_context.t Lwt.t
end

(** Variant of {!Single_data_storage} with gas accounting. *)
module type Single_carbonated_data_storage = sig
  val tag_Single_carbonated_data_storage : unit

  type t

  type context = t

  (** The type of the value *)
  type value

  (** Tells if the data is already defined.
      Consumes [Gas_repr.read_bytes_cost Z.zero]. *)
  val mem : context -&gt; (Raw_context.t * bool) tzresult Lwt.t

  (** Retrieve the value from the storage bucket ; returns a
      {!Storage_error} if the key is not set or if the deserialisation
      fails.
      Consumes [Gas_repr.read_bytes_cost &lt;size of the value&gt;]. *)
  val get : context -&gt; (Raw_context.t * value) tzresult Lwt.t

  (** Retrieves the value from the storage bucket ; returns [None] if
      the data is not initialized, or {!Storage_helpers.Storage_error}
      if the deserialisation fails.
      Consumes [Gas_repr.read_bytes_cost &lt;size of the value&gt;] if present
      or [Gas_repr.read_bytes_cost Z.zero]. *)
  val get_option : context -&gt; (Raw_context.t * value option) tzresult Lwt.t

  (** Allocates the storage bucket and initializes it ; returns a
      {!Storage_error Missing_key} if the bucket exists.
      Consumes [Gas_repr.write_bytes_cost &lt;size of the value&gt;].
      Returns the size. *)
  val init : context -&gt; value -&gt; (Raw_context.t * int) tzresult Lwt.t

  (** Updates the content of the bucket ; returns a {!Storage_Error
      Existing_key} if the value does not exists.
      Consumes [Gas_repr.write_bytes_cost &lt;size of the new value&gt;].
      Returns the difference from the old to the new size. *)
  val set : context -&gt; value -&gt; (Raw_context.t * int) tzresult Lwt.t

  (** Allocates the data and initializes it with a value ; just
      updates it if the bucket exists.
      Consumes [Gas_repr.write_bytes_cost &lt;size of the new value&gt;].
      Returns the difference from the old (maybe 0) to the new size, and a boolean
      indicating if a value was already associated to this key. *)
  val init_set :
    context -&gt; value -&gt; (Raw_context.t * int * bool) tzresult Lwt.t

  (** When the value is [Some v], allocates the data and initializes
      it with [v] ; just updates it if the bucket exists. When the
      valus is [None], delete the storage bucket when the value ; does
      nothing if the bucket does not exists.
      Consumes the same gas cost as either {!remove} or {!init_set}.
      Returns the difference from the old (maybe 0) to the new size, and a boolean
      indicating if a value was already associated to this key. *)
  val set_option :
    context -&gt; value option -&gt; (Raw_context.t * int * bool) tzresult Lwt.t

  (** Delete the storage bucket ; returns a {!Storage_error
      Missing_key} if the bucket does not exists.
      Consumes [Gas_repr.write_bytes_cost Z.zero].
      Returns the freed size. *)
  val delete : context -&gt; (Raw_context.t * int) tzresult Lwt.t

  (** Removes the storage bucket and its contents ; does nothing if
      the bucket does not exists.
      Consumes [Gas_repr.write_bytes_cost Z.zero].
      Returns the freed size, and a boolean
      indicating if a value was already associated to this key. *)
  val remove : context -&gt; (Raw_context.t * int * bool) tzresult Lwt.t
end

(** Restricted version of {!Indexed_data_storage} w/o iterators. *)
module type Non_iterable_indexed_data_storage = sig
  val tag_Non_iterable_indexed_data_storage : unit

  type t

  type context = t

  (** An abstract type for keys *)
  type key

  (** The type of values *)
  type value

  (** Tells if a given key is already bound to a storage bucket *)
  val mem : context -&gt; key -&gt; bool Lwt.t

  (** Retrieve a value from the storage bucket at a given key ;
      returns {!Storage_error Missing_key} if the key is not set ;
      returns {!Storage_error Corrupted_data} if the deserialisation
      fails. *)
  val get : context -&gt; key -&gt; value tzresult Lwt.t

  (** Retrieve a value from the storage bucket at a given key ;
      returns [None] if the value is not set ; returns {!Storage_error
      Corrupted_data} if the deserialisation fails. *)
  val get_option : context -&gt; key -&gt; value option tzresult Lwt.t

  (** Updates the content of a bucket ; returns A {!Storage_Error
      Missing_key} if the value does not exists. *)
  val set : context -&gt; key -&gt; value -&gt; Raw_context.t tzresult Lwt.t

  (** Allocates a storage bucket at the given key and initializes it ;
      returns a {!Storage_error Existing_key} if the bucket exists. *)
  val init : context -&gt; key -&gt; value -&gt; Raw_context.t tzresult Lwt.t

  (** Allocates a storage bucket at the given key and initializes it
      with a value ; just updates it if the bucket exists. *)
  val init_set : context -&gt; key -&gt; value -&gt; Raw_context.t Lwt.t

  (** When the value is [Some v], allocates the data and initializes
      it with [v] ; just updates it if the bucket exists. When the
      valus is [None], delete the storage bucket when the value ; does
      nothing if the bucket does not exists. *)
  val set_option : context -&gt; key -&gt; value option -&gt; Raw_context.t Lwt.t

  (** Delete a storage bucket and its contents ; returns a
      {!Storage_error Missing_key} if the bucket does not exists. *)
  val delete : context -&gt; key -&gt; Raw_context.t tzresult Lwt.t

  (** Removes a storage bucket and its contents ; does nothing if the
      bucket does not exists. *)
  val remove : context -&gt; key -&gt; Raw_context.t Lwt.t
end

(** Variant of {!Non_iterable_indexed_data_storage} with gas accounting. *)
module type Non_iterable_indexed_carbonated_data_storage = sig
  val tag_Non_iterable_indexed_carbonated_data_storage : unit

  type t

  type context = t

  (** An abstract type for keys *)
  type key

  (** The type of values *)
  type value

  (** Tells if a given key is already bound to a storage bucket.
      Consumes [Gas_repr.read_bytes_cost Z.zero]. *)
  val mem : context -&gt; key -&gt; (Raw_context.t * bool) tzresult Lwt.t

  (** Retrieve a value from the storage bucket at a given key ;
      returns {!Storage_error Missing_key} if the key is not set ;
      returns {!Storage_error Corrupted_data} if the deserialisation
      fails.
      Consumes [Gas_repr.read_bytes_cost &lt;size of the value&gt;]. *)
  val get : context -&gt; key -&gt; (Raw_context.t * value) tzresult Lwt.t

  (** Retrieve a value from the storage bucket at a given key ;
      returns [None] if the value is not set ; returns {!Storage_error
      Corrupted_data} if the deserialisation fails.
      Consumes [Gas_repr.read_bytes_cost &lt;size of the value&gt;] if present
      or [Gas_repr.read_bytes_cost Z.zero]. *)
  val get_option :
    context -&gt; key -&gt; (Raw_context.t * value option) tzresult Lwt.t

  (** Updates the content of a bucket ; returns A {!Storage_Error
      Missing_key} if the value does not exists.
      Consumes serialization cost.
      Consumes [Gas_repr.write_bytes_cost &lt;size of the new value&gt;].
      Returns the difference from the old to the new size. *)
  val set : context -&gt; key -&gt; value -&gt; (Raw_context.t * int) tzresult Lwt.t

  (** Allocates a storage bucket at the given key and initializes it ;
      returns a {!Storage_error Existing_key} if the bucket exists.
      Consumes serialization cost.
      Consumes [Gas_repr.write_bytes_cost &lt;size of the value&gt;].
      Returns the size. *)
  val init : context -&gt; key -&gt; value -&gt; (Raw_context.t * int) tzresult Lwt.t

  (** Allocates a storage bucket at the given key and initializes it
      with a value ; just updates it if the bucket exists.
      Consumes serialization cost.
      Consumes [Gas_repr.write_bytes_cost &lt;size of the new value&gt;].
      Returns the difference from the old (maybe 0) to the new size, and a boolean
      indicating if a value was already associated to this key. *)
  val init_set :
    context -&gt; key -&gt; value -&gt; (Raw_context.t * int * bool) tzresult Lwt.t

  (** When the value is [Some v], allocates the data and initializes
      it with [v] ; just updates it if the bucket exists. When the
      valus is [None], delete the storage bucket when the value ; does
      nothing if the bucket does not exists.
      Consumes serialization cost.
      Consumes the same gas cost as either {!remove} or {!init_set}.
      Returns the difference from the old (maybe 0) to the new size, and a boolean
      indicating if a value was already associated to this key. *)
  val set_option :
    context -&gt;
    key -&gt;
    value option -&gt;
    (Raw_context.t * int * bool) tzresult Lwt.t

  (** Delete a storage bucket and its contents ; returns a
      {!Storage_error Missing_key} if the bucket does not exists.
      Consumes [Gas_repr.write_bytes_cost Z.zero].
      Returns the freed size. *)
  val delete : context -&gt; key -&gt; (Raw_context.t * int) tzresult Lwt.t

  (** Removes a storage bucket and its contents ; does nothing if the
      bucket does not exists.
      Consumes [Gas_repr.write_bytes_cost Z.zero].
      Returns the freed size, and a boolean
      indicating if a value was already associated to this key. *)
  val remove : context -&gt; key -&gt; (Raw_context.t * int * bool) tzresult Lwt.t
end

(** The generic signature of indexed data accessors (a set of values
    of the same type indexed by keys of the same form in the
    hierarchical (key x value) database). *)
module type Indexed_data_storage = sig
  include Non_iterable_indexed_data_storage

  (** Empties all the keys and associated data. *)
  val clear : context -&gt; Raw_context.t Lwt.t

  (** Lists all the keys. *)
  val keys : context -&gt; key list Lwt.t

  (** Lists all the keys and associated data. *)
  val bindings : context -&gt; (key * value) list Lwt.t

  (** Iterates over all the keys and associated data. *)
  val fold :
    context -&gt; init:'a -&gt; f:(key -&gt; value -&gt; 'a -&gt; 'a Lwt.t) -&gt; 'a Lwt.t

  (** Iterate over all the keys. *)
  val fold_keys : context -&gt; init:'a -&gt; f:(key -&gt; 'a -&gt; 'a Lwt.t) -&gt; 'a Lwt.t
end

module type Indexed_data_snapshotable_storage = sig
  type snapshot

  type key

  include Indexed_data_storage with type key := key

  module Snapshot :
    Indexed_data_storage
      with type key = snapshot * key
       and type value = value
       and type t = t

  val snapshot_exists : context -&gt; snapshot -&gt; bool Lwt.t

  val snapshot : context -&gt; snapshot -&gt; Raw_context.t tzresult Lwt.t

  val delete_snapshot : context -&gt; snapshot -&gt; Raw_context.t Lwt.t
end

(** The generic signature of a data set accessor (a set of values
    bound to a specific key prefix in the hierarchical (key x value)
    database). *)
module type Data_set_storage = sig
  type t

  type context = t

  (** The type of elements. *)
  type elt

  (** Tells if a elt is a member of the set *)
  val mem : context -&gt; elt -&gt; bool Lwt.t

  (** Adds a elt is a member of the set *)
  val add : context -&gt; elt -&gt; Raw_context.t Lwt.t

  (** Removes a elt of the set ; does nothing if not a member *)
  val del : context -&gt; elt -&gt; Raw_context.t Lwt.t

  (** Adds/Removes a elt of the set *)
  val set : context -&gt; elt -&gt; bool -&gt; Raw_context.t Lwt.t

  (** Returns the elements of the set, deserialized in a list in no
      particular order. *)
  val elements : context -&gt; elt list Lwt.t

  (** Iterates over the elements of the set. *)
  val fold : context -&gt; init:'a -&gt; f:(elt -&gt; 'a -&gt; 'a Lwt.t) -&gt; 'a Lwt.t

  (** Removes all elements in the set *)
  val clear : context -&gt; Raw_context.t Lwt.t
end

module type NAME = sig
  val name : Raw_context.key
end

module type VALUE = sig
  type t

  val encoding : t Data_encoding.t
end

module type REGISTER = sig
  val ghost : bool
end

module type Indexed_raw_context = sig
  type t

  type context = t

  type key

  type 'a ipath

  val clear : context -&gt; Raw_context.t Lwt.t

  val fold_keys : context -&gt; init:'a -&gt; f:(key -&gt; 'a -&gt; 'a Lwt.t) -&gt; 'a Lwt.t

  val keys : context -&gt; key list Lwt.t

  val resolve : context -&gt; string list -&gt; key list Lwt.t

  val remove_rec : context -&gt; key -&gt; context Lwt.t

  val copy : context -&gt; from:key -&gt; to_:key -&gt; context tzresult Lwt.t

  module Make_set (R : REGISTER) (N : NAME) :
    Data_set_storage with type t = t and type elt = key

  module Make_map (N : NAME) (V : VALUE) :
    Indexed_data_storage
      with type t = t
       and type key = key
       and type value = V.t

  module Make_carbonated_map (N : NAME) (V : VALUE) :
    Non_iterable_indexed_carbonated_data_storage
      with type t = t
       and type key = key
       and type value = V.t

  module Raw_context : Raw_context.T with type t = t ipath
end
</pre>
  </div>
  <div class="col-md-6">
    <a href="#storage_sigs.ml"><code>Storage_sigs.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Raw_context.

Definition depend_on_me (function_parameter : unit) : unit :=
  let '_ := function_parameter in
  tt.

Module Single_data_storage.
  Record signature {t value : Set} : Set := {
    tag_Single_data_storage : unit;
    t := t;
    context := t;
    value := value;
    mem : context -&gt; Lwt.t bool;
    get : context -&gt; Lwt.t (Error_monad.tzresult value);
    get_option : context -&gt; Lwt.t (Error_monad.tzresult (option value));
    init : context -&gt; value -&gt; Lwt.t (Error_monad.tzresult Raw_context.t);
    set : context -&gt; value -&gt; Lwt.t (Error_monad.tzresult Raw_context.t);
    init_set : context -&gt; value -&gt; Lwt.t Raw_context.t;
    set_option : context -&gt; option value -&gt; Lwt.t Raw_context.t;
    delete : context -&gt; Lwt.t (Error_monad.tzresult Raw_context.t);
    remove : context -&gt; Lwt.t Raw_context.t;
  }.
End Single_data_storage.

Module Single_carbonated_data_storage.
  Record signature {t value : Set} : Set := {
    tag_Single_carbonated_data_storage : unit;
    t := t;
    context := t;
    value := value;
    mem : context -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * bool));
    get : context -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * value));
    get_option :
      context -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * option value));
    init :
      context -&gt; value -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * int));
    set :
      context -&gt; value -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * int));
    init_set :
      context -&gt; value -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * int * bool));
    set_option :
      context -&gt; option value -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * int * bool));
    delete : context -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * int));
    remove :
      context -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * int * bool));
  }.
End Single_carbonated_data_storage.

Module Non_iterable_indexed_data_storage.
  Record signature {t key value : Set} : Set := {
    tag_Non_iterable_indexed_data_storage : unit;
    t := t;
    context := t;
    key := key;
    value := value;
    mem : context -&gt; key -&gt; Lwt.t bool;
    get : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult value);
    get_option : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult (option value));
    set : context -&gt; key -&gt; value -&gt; Lwt.t (Error_monad.tzresult Raw_context.t);
    init :
      context -&gt; key -&gt; value -&gt; Lwt.t (Error_monad.tzresult Raw_context.t);
    init_set : context -&gt; key -&gt; value -&gt; Lwt.t Raw_context.t;
    set_option : context -&gt; key -&gt; option value -&gt; Lwt.t Raw_context.t;
    delete : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult Raw_context.t);
    remove : context -&gt; key -&gt; Lwt.t Raw_context.t;
  }.
End Non_iterable_indexed_data_storage.

Module Non_iterable_indexed_carbonated_data_storage.
  Record signature {t key value : Set} : Set := {
    tag_Non_iterable_indexed_carbonated_data_storage : unit;
    t := t;
    context := t;
    key := key;
    value := value;
    mem : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * bool));
    get :
      context -&gt; key -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * value));
    get_option :
      context -&gt; key -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * option value));
    set :
      context -&gt; key -&gt; value -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * int));
    init :
      context -&gt; key -&gt; value -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * int));
    init_set :
      context -&gt; key -&gt; value -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * int * bool));
    set_option :
      context -&gt; key -&gt; option value -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * int * bool));
    delete :
      context -&gt; key -&gt; Lwt.t (Error_monad.tzresult (Raw_context.t * int));
    remove :
      context -&gt; key -&gt;
      Lwt.t (Error_monad.tzresult (Raw_context.t * int * bool));
  }.
End Non_iterable_indexed_carbonated_data_storage.

Module Indexed_data_storage.
  Record signature {t key value : Set} : Set := {
    tag_Non_iterable_indexed_data_storage : unit;
    t := t;
    context := t;
    key := key;
    value := value;
    mem : context -&gt; key -&gt; Lwt.t bool;
    get : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult value);
    get_option : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult (option value));
    set : context -&gt; key -&gt; value -&gt; Lwt.t (Error_monad.tzresult Raw_context.t);
    init :
      context -&gt; key -&gt; value -&gt; Lwt.t (Error_monad.tzresult Raw_context.t);
    init_set : context -&gt; key -&gt; value -&gt; Lwt.t Raw_context.t;
    set_option : context -&gt; key -&gt; option value -&gt; Lwt.t Raw_context.t;
    delete : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult Raw_context.t);
    remove : context -&gt; key -&gt; Lwt.t Raw_context.t;
    clear : context -&gt; Lwt.t Raw_context.t;
    keys : context -&gt; Lwt.t (list key);
    bindings : context -&gt; Lwt.t (list (key * value));
    fold : forall {a : Set},
      context -&gt; a -&gt; (key -&gt; value -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a;
    fold_keys : forall {a : Set},
      context -&gt; a -&gt; (key -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a;
  }.
End Indexed_data_storage.

Module Indexed_data_snapshotable_storage.
  Record signature {snapshot key t value : Set} : Set := {
    snapshot := snapshot;
    key := key;
    tag_Non_iterable_indexed_data_storage : unit;
    t := t;
    context := t;
    value := value;
    mem : context -&gt; key -&gt; Lwt.t bool;
    get : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult value);
    get_option : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult (option value));
    set : context -&gt; key -&gt; value -&gt; Lwt.t (Error_monad.tzresult Raw_context.t);
    init :
      context -&gt; key -&gt; value -&gt; Lwt.t (Error_monad.tzresult Raw_context.t);
    init_set : context -&gt; key -&gt; value -&gt; Lwt.t Raw_context.t;
    set_option : context -&gt; key -&gt; option value -&gt; Lwt.t Raw_context.t;
    delete : context -&gt; key -&gt; Lwt.t (Error_monad.tzresult Raw_context.t);
    remove : context -&gt; key -&gt; Lwt.t Raw_context.t;
    clear : context -&gt; Lwt.t Raw_context.t;
    keys : context -&gt; Lwt.t (list key);
    bindings : context -&gt; Lwt.t (list (key * value));
    fold : forall {a : Set},
      context -&gt; a -&gt; (key -&gt; value -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a;
    fold_keys : forall {a : Set},
      context -&gt; a -&gt; (key -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a;
    Snapshot :
      Indexed_data_storage.signature (t := t) (key := (snapshot * key))
        (value := value);
    snapshot_exists : context -&gt; snapshot -&gt; Lwt.t bool;
    __snapshot_value :
      context -&gt; snapshot -&gt; Lwt.t (Error_monad.tzresult Raw_context.t);
    delete_snapshot : context -&gt; snapshot -&gt; Lwt.t Raw_context.t;
  }.
End Indexed_data_snapshotable_storage.

Module Data_set_storage.
  Record signature {t elt : Set} : Set := {
    t := t;
    context := t;
    elt := elt;
    mem : context -&gt; elt -&gt; Lwt.t bool;
    add : context -&gt; elt -&gt; Lwt.t Raw_context.t;
    del : context -&gt; elt -&gt; Lwt.t Raw_context.t;
    set : context -&gt; elt -&gt; bool -&gt; Lwt.t Raw_context.t;
    elements : context -&gt; Lwt.t (list elt);
    fold : forall {a : Set}, context -&gt; a -&gt; (elt -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a;
    clear : context -&gt; Lwt.t Raw_context.t;
  }.
End Data_set_storage.

Module NAME.
  Record signature : Set := {
    name : Raw_context.key;
  }.
End NAME.

Module VALUE.
  Record signature {t : Set} : Set := {
    t := t;
    encoding : Data_encoding.t t;
  }.
End VALUE.

Module REGISTER.
  Record signature : Set := {
    ghost : bool;
  }.
End REGISTER.

Module Indexed_raw_context.
  Record signature {t key : Set} {ipath : Set -&gt; Set} : Set := {
    t := t;
    context := t;
    key := key;
    ipath := ipath;
    clear : context -&gt; Lwt.t Raw_context.t;
    fold_keys : forall {a : Set},
      context -&gt; a -&gt; (key -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a;
    keys : context -&gt; Lwt.t (list key);
    resolve : context -&gt; list string -&gt; Lwt.t (list key);
    remove_rec : context -&gt; key -&gt; Lwt.t context;
    copy : context -&gt; key -&gt; key -&gt; Lwt.t (Error_monad.tzresult context);
    Make_set :
      forall (R : {_ : unit &amp; REGISTER.signature}),
        (forall (N : {_ : unit &amp; NAME.signature}),
          {_ : unit &amp; Data_set_storage.signature (t := t) (elt := key)});
    Make_map :
      forall (N : {_ : unit &amp; NAME.signature}),
        (forall (V : {t : Set &amp; VALUE.signature (t := t)}),
          {_ : unit &amp;
            Indexed_data_storage.signature (t := t) (key := key)
              (value := (|V|).(VALUE.t))});
    Make_carbonated_map :
      forall (N : {_ : unit &amp; NAME.signature}),
        (forall (V : {t : Set &amp; VALUE.signature (t := t)}),
          {_ : unit &amp;
            Non_iterable_indexed_carbonated_data_storage.signature (t := t)
              (key := key) (value := (|V|).(VALUE.t))});
    Raw_context : Raw_context.T.signature (t := (ipath t));
  }.
End Indexed_raw_context.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="tez_repr.ml">
  <div style="margin: 20px;">
    <h3>Tez_repr</h3>
    <ul>
      <li>OCaml size: 36 lines</li>
      <li>Coq size: 90 lines (+150% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#tez_repr.ml"><code>tez_repr.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

module QtyModule = Qty_repr.Make (struct
  let id = &quot;tez&quot;
end)

include QtyModule

type t = qty

type tez = qty

let encoding = Data_encoding.def &quot;mutez&quot; @@ qty_encoding
</pre>
  </div>
  <div class="col-md-6">
    <a href="#tez_repr.ml"><code>Tez_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Qty_repr.

Definition QtyModule :=
  Qty_repr.Make
    (let id := &quot;tez&quot; in
    existT (A := unit) (fun _ =&gt; _) tt
      {|
        Qty_repr.QTY.id := id
      |}).

Definition qty := (|QtyModule|).(Qty_repr.S.qty).

Definition id := (|QtyModule|).(Qty_repr.S.id).

Definition zero := (|QtyModule|).(Qty_repr.S.zero).

Definition one_mutez := (|QtyModule|).(Qty_repr.S.one_mutez).

Definition one_cent := (|QtyModule|).(Qty_repr.S.one_cent).

Definition fifty_cents := (|QtyModule|).(Qty_repr.S.fifty_cents).

Definition one := (|QtyModule|).(Qty_repr.S.one).

Definition op_minusquestion := (|QtyModule|).(Qty_repr.S.op_minusquestion).

Definition op_plusquestion := (|QtyModule|).(Qty_repr.S.op_plusquestion).

Definition op_starquestion := (|QtyModule|).(Qty_repr.S.op_starquestion).

Definition op_divquestion := (|QtyModule|).(Qty_repr.S.op_divquestion).

Definition to_mutez := (|QtyModule|).(Qty_repr.S.to_mutez).

Definition of_mutez := (|QtyModule|).(Qty_repr.S.of_mutez).

Definition of_mutez_exn := (|QtyModule|).(Qty_repr.S.of_mutez_exn).

Definition add_exn := (|QtyModule|).(Qty_repr.S.add_exn).

Definition mul_exn := (|QtyModule|).(Qty_repr.S.mul_exn).

Definition qty_encoding := (|QtyModule|).(Qty_repr.S.qty_encoding).

Definition to_int64 := (|QtyModule|).(Qty_repr.S.to_int64).

Definition op_eq := (|QtyModule|).(Qty_repr.S.op_eq).

Definition op_ltgt := (|QtyModule|).(Qty_repr.S.op_ltgt).

Definition op_lt := (|QtyModule|).(Qty_repr.S.op_lt).

Definition op_lteq := (|QtyModule|).(Qty_repr.S.op_lteq).

Definition op_gteq := (|QtyModule|).(Qty_repr.S.op_gteq).

Definition op_gt := (|QtyModule|).(Qty_repr.S.op_gt).

Definition compare := (|QtyModule|).(Qty_repr.S.compare).

Definition equal := (|QtyModule|).(Qty_repr.S.equal).

Definition max := (|QtyModule|).(Qty_repr.S.max).

Definition min := (|QtyModule|).(Qty_repr.S.min).

Definition pp := (|QtyModule|).(Qty_repr.S.pp).

Definition of_string := (|QtyModule|).(Qty_repr.S.of_string).

Definition to_string := (|QtyModule|).(Qty_repr.S.to_string).

Definition t : Set := qty.

Definition tez : Set := qty.

Definition encoding : Data_encoding.encoding qty :=
  (let arg := Data_encoding.def &quot;mutez&quot; in
  fun eta =&gt; arg None None eta) qty_encoding.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="tez_repr.mli">
  <div style="margin: 20px;">
    <h3>Tez_repr_mli</h3>
    <ul>
      <li>OCaml size: 32 lines</li>
      <li>Coq size: 87 lines (+171% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#tez_repr.mli"><code>tez_repr.mli</code></a>&nbsp;<span class="label label-warning">5 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t

type tez = t

<abbr class="mark-warning" title="Type extension not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Type extension not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Type extension not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Type extension not handled

‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî

Type extension not handled">include Qty_repr.S with type qty := t</abbr>

val encoding : t Data_encoding.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#tez_repr.mli"><code>Tez_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Qty_repr.

Parameter t : Set.

Definition tez : Set := t.

Parameter Included_S : {_ : unit &amp; Qty_repr.S.signature (qty := t)}.

Definition id : string := (|Included_S|).(Qty_repr.S.id).

Definition zero : t := (|Included_S|).(Qty_repr.S.zero).

Definition one_mutez : t := (|Included_S|).(Qty_repr.S.one_mutez).

Definition one_cent : t := (|Included_S|).(Qty_repr.S.one_cent).

Definition fifty_cents : t := (|Included_S|).(Qty_repr.S.fifty_cents).

Definition one : t := (|Included_S|).(Qty_repr.S.one).

Definition op_minusquestion : t -&gt; t -&gt; Error_monad.tzresult t :=
  (|Included_S|).(Qty_repr.S.op_minusquestion).

Definition op_plusquestion : t -&gt; t -&gt; Error_monad.tzresult t :=
  (|Included_S|).(Qty_repr.S.op_plusquestion).

Definition op_starquestion : t -&gt; int64 -&gt; Error_monad.tzresult t :=
  (|Included_S|).(Qty_repr.S.op_starquestion).

Definition op_divquestion : t -&gt; int64 -&gt; Error_monad.tzresult t :=
  (|Included_S|).(Qty_repr.S.op_divquestion).

Definition to_mutez : t -&gt; int64 := (|Included_S|).(Qty_repr.S.to_mutez).

Definition of_mutez : int64 -&gt; option t := (|Included_S|).(Qty_repr.S.of_mutez).

Definition of_mutez_exn : int64 -&gt; t :=
  (|Included_S|).(Qty_repr.S.of_mutez_exn).

Definition add_exn : t -&gt; t -&gt; t := (|Included_S|).(Qty_repr.S.add_exn).

Definition mul_exn : t -&gt; int -&gt; t := (|Included_S|).(Qty_repr.S.mul_exn).

Definition qty_encoding : Data_encoding.t t :=
  (|Included_S|).(Qty_repr.S.qty_encoding).

Definition to_int64 : t -&gt; int64 := (|Included_S|).(Qty_repr.S.to_int64).

Definition op_eq : t -&gt; t -&gt; bool := (|Included_S|).(Qty_repr.S.op_eq).

Definition op_ltgt : t -&gt; t -&gt; bool := (|Included_S|).(Qty_repr.S.op_ltgt).

Definition op_lt : t -&gt; t -&gt; bool := (|Included_S|).(Qty_repr.S.op_lt).

Definition op_lteq : t -&gt; t -&gt; bool := (|Included_S|).(Qty_repr.S.op_lteq).

Definition op_gteq : t -&gt; t -&gt; bool := (|Included_S|).(Qty_repr.S.op_gteq).

Definition op_gt : t -&gt; t -&gt; bool := (|Included_S|).(Qty_repr.S.op_gt).

Definition compare : t -&gt; t -&gt; int := (|Included_S|).(Qty_repr.S.compare).

Definition equal : t -&gt; t -&gt; bool := (|Included_S|).(Qty_repr.S.equal).

Definition max : t -&gt; t -&gt; t := (|Included_S|).(Qty_repr.S.max).

Definition min : t -&gt; t -&gt; t := (|Included_S|).(Qty_repr.S.min).

Definition pp : Format.formatter -&gt; t -&gt; unit := (|Included_S|).(Qty_repr.S.pp).

Definition of_string : string -&gt; option t :=
  (|Included_S|).(Qty_repr.S.of_string).

Definition to_string : t -&gt; string := (|Included_S|).(Qty_repr.S.to_string).

Parameter encoding : Data_encoding.t t.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="time_repr.ml">
  <div style="margin: 20px;">
    <h3>Time_repr</h3>
    <ul>
      <li>OCaml size: 65 lines</li>
      <li>Coq size: 43 lines (-34% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#time_repr.ml"><code>time_repr.ml</code></a>&nbsp;<span class="label label-warning">6 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

include Time

type time = t

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Timestamp_add</abbr> (* `Permanent *)

<abbr class="mark-warning" title="Structure item `typext` not handled.">type error += Timestamp_sub</abbr> (* `Permanent *)

<abbr class="mark-warning" title="Top-level evaluations are ignored">let () =
  register_error_kind
    `Permanent
    ~id:&quot;timestamp_add&quot;
    ~title:&quot;Timestamp add&quot;
    ~description:&quot;Overflow when adding timestamps.&quot;
    ~pp:(fun ppf () -&gt; Format.fprintf ppf &quot;Overflow when adding timestamps.&quot;)
    Data_encoding.empty
    (function Timestamp_add -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Timestamp_add) ;
  register_error_kind
    `Permanent
    ~id:&quot;timestamp_sub&quot;
    ~title:&quot;Timestamp sub&quot;
    ~description:&quot;Substracting timestamps resulted in negative period.&quot;
    ~pp:(fun ppf () -&gt;
      Format.fprintf ppf &quot;Substracting timestamps resulted in negative period.&quot;)
    Data_encoding.empty
    (function Timestamp_sub -&gt; Some () | _ -&gt; None)
    (fun () -&gt; Timestamp_sub)</abbr>

let of_seconds_string s =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try Some (of_seconds (Int64.of_string s)) with _ -&gt; None</abbr>

let to_seconds_string s = Int64.to_string (to_seconds s)

let pp = pp_hum

let ( +? ) x y =
  <abbr class="mark-warning" title="Try-with are not handled

Alternative: use sum types (&quot;option&quot;, &quot;result&quot;, ...) to represent an error case.">try ok (add x (Period_repr.to_seconds y)) with _exn -&gt; error Timestamp_add</abbr>

let ( -? ) x y = record_trace <abbr class="mark-warning" title="Values of extensible types are ignored.

They are sent to a unit type.">Timestamp_sub</abbr> (Period_repr.of_seconds (diff x y))
</pre>
  </div>
  <div class="col-md-6">
    <a href="#time_repr.ml"><code>Time_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Period_repr.

Include Time.

Definition time : Set := t.

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Structure item `typext` not handled. *)
(* type_extension *)

(* ‚ùå Top-level evaluations are ignored *)
(* top_level_evaluation *)

Definition of_seconds_string (s : string) : option t :=
  (* ‚ùå Try-with are not handled *)
  try (Some (of_seconds (Int64.of_string s))).

Definition to_seconds_string (s : t) : string := Int64.to_string (to_seconds s).

Definition pp : Format.formatter -&gt; t -&gt; unit := pp_hum.

Definition op_plusquestion (x : t) (y : Period_repr.period)
  : Error_monad.tzresult t :=
  (* ‚ùå Try-with are not handled *)
  try (Error_monad.ok (add x (Period_repr.to_seconds y))).

Definition op_minusquestion (x : t) (y : t)
  : Error_monad.tzresult Period_repr.period :=
  Error_monad.record_trace extensible_type_value
    (Period_repr.of_seconds (diff x y)).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="time_repr.mli">
  <div style="margin: 20px;">
    <h3>Time_repr_mli</h3>
    <ul>
      <li>OCaml size: 40 lines</li>
      <li>Coq size: 66 lines (+65% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#time_repr.mli"><code>time_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

include module type of struct
  include Time
end

type time = t

val pp : Format.formatter -&gt; t -&gt; unit

val of_seconds_string : string -&gt; time option

val to_seconds_string : time -&gt; string

val ( +? ) : time -&gt; Period_repr.t -&gt; time tzresult

val ( -? ) : time -&gt; time -&gt; Period_repr.t tzresult
</pre>
  </div>
  <div class="col-md-6">
    <a href="#time_repr.mli"><code>Time_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Period_repr.

Parameter t : Set.

Parameter op_eq : t -&gt; t -&gt; bool.

Parameter op_ltgt : t -&gt; t -&gt; bool.

Parameter op_lt : t -&gt; t -&gt; bool.

Parameter op_lteq : t -&gt; t -&gt; bool.

Parameter op_gteq : t -&gt; t -&gt; bool.

Parameter op_gt : t -&gt; t -&gt; bool.

Parameter compare : t -&gt; t -&gt; int.

Parameter equal : t -&gt; t -&gt; bool.

Parameter max : t -&gt; t -&gt; t.

Parameter min : t -&gt; t -&gt; t.

Parameter add : t -&gt; int64 -&gt; t.

Parameter diff : t -&gt; t -&gt; int64.

Parameter of_seconds : int64 -&gt; t.

Parameter to_seconds : t -&gt; int64.

Parameter of_notation : string -&gt; option t.

Parameter of_notation_exn : string -&gt; t.

Parameter to_notation : t -&gt; string.

Parameter encoding : Data_encoding.t t.

Parameter rfc_encoding : Data_encoding.t t.

Parameter pp_hum : Format.formatter -&gt; t -&gt; unit.

Definition time : Set := t.

Parameter pp : Format.formatter -&gt; t -&gt; unit.

Parameter of_seconds_string : string -&gt; option time.

Parameter to_seconds_string : time -&gt; string.

Parameter op_plusquestion : time -&gt; Period_repr.t -&gt; Error_monad.tzresult time.

Parameter op_minusquestion : time -&gt; time -&gt; Error_monad.tzresult Period_repr.t.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="vote_repr.ml">
  <div style="margin: 20px;">
    <h3>Vote_repr</h3>
    <ul>
      <li>OCaml size: 46 lines</li>
      <li>Coq size: 36 lines (-22% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#vote_repr.ml"><code>vote_repr.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type proposal = Protocol_hash.t

type ballot = Yay | Nay | Pass

let ballot_encoding =
  let of_int8 = function
    | 0 -&gt;
        Yay
    | 1 -&gt;
        Nay
    | 2 -&gt;
        Pass
    | _ -&gt;
        invalid_arg &quot;ballot_of_int8&quot;
  in
  let to_int8 = function Yay -&gt; 0 | Nay -&gt; 1 | Pass -&gt; 2 in
  let open Data_encoding in
  (* union *)
  splitted
    ~binary:(conv to_int8 of_int8 int8)
    ~json:(string_enum [(&quot;yay&quot;, Yay); (&quot;nay&quot;, Nay); (&quot;pass&quot;, Pass)])
</pre>
  </div>
  <div class="col-md-6">
    <a href="#vote_repr.ml"><code>Vote_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.

Definition proposal : Set := (|Protocol_hash|).(S.HASH.t).

Inductive ballot : Set :=
| Yay : ballot
| Nay : ballot
| Pass : ballot.

Definition ballot_encoding : Data_encoding.encoding ballot :=
  let of_int8 (function_parameter : int) : ballot :=
    match function_parameter with
    | 0 =&gt; Yay
    | 1 =&gt; Nay
    | 2 =&gt; Pass
    | _ =&gt; Pervasives.invalid_arg &quot;ballot_of_int8&quot;
    end in
  let to_int8 (function_parameter : ballot) : int :=
    match function_parameter with
    | Yay =&gt; 0
    | Nay =&gt; 1
    | Pass =&gt; 2
    end in
  Data_encoding.splitted
    (Data_encoding.string_enum [ (&quot;yay&quot;, Yay); (&quot;nay&quot;, Nay); (&quot;pass&quot;, Pass) ])
    (Data_encoding.conv to_int8 of_int8 None Data_encoding.int8).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="vote_repr.mli">
  <div style="margin: 20px;">
    <h3>Vote_repr_mli</h3>
    <ul>
      <li>OCaml size: 33 lines</li>
      <li>Coq size: 20 lines (-40% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#vote_repr.mli"><code>vote_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** a protocol change proposal *)
type proposal = Protocol_hash.t

(** votes can be for, against or neutral.
    Neutral serves to count towards a quorum *)
type ballot = Yay | Nay | Pass

val ballot_encoding : ballot Data_encoding.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#vote_repr.mli"><code>Vote_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.

Definition proposal : Set := (|Protocol_hash|).(S.HASH.t).

Inductive ballot : Set :=
| Yay : ballot
| Nay : ballot
| Pass : ballot.

Parameter ballot_encoding : Data_encoding.t ballot.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="vote_storage.ml">
  <div style="margin: 20px;">
    <h3>Vote_storage</h3>
    <ul>
      <li>OCaml size: 156 lines</li>
      <li>Coq size: 329 lines (+110% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#vote_storage.ml"><code>vote_storage.ml</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

let recorded_proposal_count_for_delegate ctxt proposer =
  Storage.Vote.Proposals_count.get_option ctxt proposer
  &gt;&gt;=? function None -&gt; return 0 | Some count -&gt; return count

let record_proposal ctxt proposal proposer =
  recorded_proposal_count_for_delegate ctxt proposer
  &gt;&gt;=? fun count -&gt;
  Storage.Vote.Proposals_count.init_set ctxt proposer (count + 1)
  &gt;&gt;= fun ctxt -&gt;
  Storage.Vote.Proposals.add ctxt (proposal, proposer)
  &gt;&gt;= fun ctxt -&gt; return ctxt

let get_proposals ctxt =
  Storage.Vote.Proposals.fold
    ctxt
    ~init:(ok Protocol_hash.Map.empty)
    ~f:(fun (proposal, delegate) acc -&gt;
      (* Assuming the same listings is used at votings *)
      Storage.Vote.Listings.get ctxt delegate
      &gt;&gt;=? fun weight -&gt;
      Lwt.return
        ( acc
        &gt;&gt;? fun acc -&gt;
        let previous =
          match Protocol_hash.Map.find_opt proposal acc with
          | None -&gt;
              0l
          | Some x -&gt;
              x
        in
        ok (Protocol_hash.Map.add proposal (Int32.add weight previous) acc) ))

let clear_proposals ctxt =
  Storage.Vote.Proposals_count.clear ctxt
  &gt;&gt;= fun ctxt -&gt; Storage.Vote.Proposals.clear ctxt

type ballots = {yay : int32; nay : int32; pass : int32}

let ballots_encoding =
  let open Data_encoding in
  conv
    (fun {yay; nay; pass} -&gt; (yay, nay, pass))
    (fun (yay, nay, pass) -&gt; {yay; nay; pass})
  @@ obj3 (req &quot;yay&quot; int32) (req &quot;nay&quot; int32) (req &quot;pass&quot; int32)

let has_recorded_ballot = Storage.Vote.Ballots.mem

let record_ballot = Storage.Vote.Ballots.init

let get_ballots ctxt =
  Storage.Vote.Ballots.fold
    ctxt
    ~f:(fun delegate ballot (ballots : ballots tzresult) -&gt;
      (* Assuming the same listings is used at votings *)
      Storage.Vote.Listings.get ctxt delegate
      &gt;&gt;=? fun weight -&gt;
      let count = Int32.add weight in
      Lwt.return
        ( ballots
        &gt;&gt;? fun ballots -&gt;
        match ballot with
        | Yay -&gt;
            ok {ballots with yay = count ballots.yay}
        | Nay -&gt;
            ok {ballots with nay = count ballots.nay}
        | Pass -&gt;
            ok {ballots with pass = count ballots.pass} ))
    ~init:(ok {yay = 0l; nay = 0l; pass = 0l})

let get_ballot_list = Storage.Vote.Ballots.bindings

let clear_ballots = Storage.Vote.Ballots.clear

let listings_encoding =
  Data_encoding.(
    list
      (obj2 (req &quot;pkh&quot; Signature.Public_key_hash.encoding) (req &quot;rolls&quot; int32)))

let freeze_listings ctxt =
  Roll_storage.fold ctxt (ctxt, 0l) ~f:(fun _roll delegate (ctxt, total) -&gt;
      (* TODO use snapshots *)
      let delegate = Signature.Public_key.hash delegate in
      Storage.Vote.Listings.get_option ctxt delegate
      &gt;&gt;=? (function None -&gt; return 0l | Some count -&gt; return count)
      &gt;&gt;=? fun count -&gt;
      Storage.Vote.Listings.init_set ctxt delegate (Int32.succ count)
      &gt;&gt;= fun ctxt -&gt; return (ctxt, Int32.succ total))
  &gt;&gt;=? fun (ctxt, total) -&gt;
  Storage.Vote.Listings_size.init ctxt total &gt;&gt;=? fun ctxt -&gt; return ctxt

let listing_size = Storage.Vote.Listings_size.get

let in_listings = Storage.Vote.Listings.mem

let get_listings = Storage.Vote.Listings.bindings

let clear_listings ctxt =
  Storage.Vote.Listings.clear ctxt
  &gt;&gt;= fun ctxt -&gt;
  Storage.Vote.Listings_size.remove ctxt &gt;&gt;= fun ctxt -&gt; return ctxt

let get_current_period_kind = Storage.Vote.Current_period_kind.get

let set_current_period_kind = Storage.Vote.Current_period_kind.set

let get_current_quorum ctxt =
  Storage.Vote.Participation_ema.get ctxt
  &gt;&gt;=? fun participation_ema -&gt;
  let quorum_min = Constants_storage.quorum_min ctxt in
  let quorum_max = Constants_storage.quorum_max ctxt in
  let quorum_diff = Int32.sub quorum_max quorum_min in
  return
    Int32.(add quorum_min (div (mul participation_ema quorum_diff) 100_00l))

let get_participation_ema = Storage.Vote.Participation_ema.get

let set_participation_ema = Storage.Vote.Participation_ema.set

let get_current_proposal = Storage.Vote.Current_proposal.get

let init_current_proposal = Storage.Vote.Current_proposal.init

let clear_current_proposal = Storage.Vote.Current_proposal.delete

let init ctxt =
  (* participation EMA is in centile of a percentage *)
  let participation_ema = Constants_storage.quorum_max ctxt in
  Storage.Vote.Participation_ema.init ctxt participation_ema
  &gt;&gt;=? fun ctxt -&gt;
  Storage.Vote.Current_period_kind.init ctxt Proposal
  &gt;&gt;=? fun ctxt -&gt; return ctxt
</pre>
  </div>
  <div class="col-md-6">
    <a href="#vote_storage.ml"><code>Vote_storage.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Constants_storage.
Require Tezos.Raw_context.
Require Tezos.Roll_storage.
Require Tezos.Storage_mli. Module Storage := Storage_mli.
Require Tezos.Storage_sigs.
Require Tezos.Vote_repr.
Require Tezos.Voting_period_repr.

Definition recorded_proposal_count_for_delegate
  (ctxt :
    (|Storage.Vote.Proposals_count|).(Storage_sigs.Indexed_data_storage.context))
  (proposer :
    (|Storage.Vote.Proposals_count|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t
    (Error_monad.tzresult
      (|Storage.Vote.Proposals_count|).(Storage_sigs.Indexed_data_storage.value)) :=
  let=? function_parameter :=
    (|Storage.Vote.Proposals_count|).(Storage_sigs.Indexed_data_storage.get_option)
      ctxt proposer in
  match function_parameter with
  | None =&gt; Error_monad.__return 0
  | Some count =&gt; Error_monad.__return count
  end.

Definition record_proposal
  (ctxt :
    (|Storage.Vote.Proposals_count|).(Storage_sigs.Indexed_data_storage.context))
  (proposal : (|Protocol_hash|).(S.HASH.t))
  (proposer :
    (|Storage.Vote.Proposals_count|).(Storage_sigs.Indexed_data_storage.key))
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let=? count := recorded_proposal_count_for_delegate ctxt proposer in
  let= ctxt :=
    (|Storage.Vote.Proposals_count|).(Storage_sigs.Indexed_data_storage.init_set)
      ctxt proposer (Pervasives.op_plus count 1) in
  let= ctxt :=
    (|Storage.Vote.Proposals|).(Storage_sigs.Data_set_storage.add) ctxt
      (proposal, proposer) in
  Error_monad.__return ctxt.

Definition get_proposals
  (ctxt : (|Storage.Vote.Proposals|).(Storage_sigs.Data_set_storage.context))
  : Lwt.t
    (Error_monad.tzresult
      ((|Protocol_hash|).(S.HASH.Map).(S.INDEXES_Map.t) int32)) :=
  (|Storage.Vote.Proposals|).(Storage_sigs.Data_set_storage.fold) ctxt
    (Error_monad.ok (|Protocol_hash|).(S.HASH.Map).(S.INDEXES_Map.empty))
    (fun function_parameter =&gt;
      let '(proposal, delegate) := function_parameter in
      fun acc =&gt;
        let=? weight :=
          (|Storage.Vote.Listings|).(Storage_sigs.Indexed_data_storage.get) ctxt
            delegate in
        Lwt.__return
          (let? acc := acc in
          let previous :=
            match
              (|Protocol_hash|).(S.HASH.Map).(S.INDEXES_Map.find_opt) proposal
                acc with
            | None =&gt;
              (* ‚ùå Constant of type int32 is converted to int *)
              0
            | Some x =&gt; x
            end in
          Error_monad.ok
            ((|Protocol_hash|).(S.HASH.Map).(S.INDEXES_Map.add) proposal
              (Int32.add weight previous) acc))).

Definition clear_proposals
  (ctxt :
    (|Storage.Vote.Proposals_count|).(Storage_sigs.Indexed_data_storage.context))
  : Lwt.t Raw_context.t :=
  let= ctxt :=
    (|Storage.Vote.Proposals_count|).(Storage_sigs.Indexed_data_storage.clear)
      ctxt in
  (|Storage.Vote.Proposals|).(Storage_sigs.Data_set_storage.clear) ctxt.

Module ballots.
  Record record : Set := Build {
    yay : int32;
    nay : int32;
    pass : int32 }.
  Definition with_yay yay (r : record) :=
    Build yay r.(nay) r.(pass).
  Definition with_nay nay (r : record) :=
    Build r.(yay) nay r.(pass).
  Definition with_pass pass (r : record) :=
    Build r.(yay) r.(nay) pass.
End ballots.
Definition ballots := ballots.record.

Definition ballots_encoding : Data_encoding.encoding ballots :=
  (let arg :=
    Data_encoding.conv
      (fun function_parameter =&gt;
        let '{|
          ballots.yay := yay; ballots.nay := nay; ballots.pass := pass |} :=
          function_parameter in
        (yay, nay, pass))
      (fun function_parameter =&gt;
        let '(yay, nay, pass) := function_parameter in
        {| ballots.yay := yay; ballots.nay := nay; ballots.pass := pass |}) in
  fun eta =&gt; arg None eta)
    (Data_encoding.obj3
      (Data_encoding.req None None &quot;yay&quot; Data_encoding.__int32_value)
      (Data_encoding.req None None &quot;nay&quot; Data_encoding.__int32_value)
      (Data_encoding.req None None &quot;pass&quot; Data_encoding.__int32_value)).

Definition has_recorded_ballot
  : (|Storage.Vote.Ballots|).(Storage_sigs.Indexed_data_storage.context) -&gt;
  (|Storage.Vote.Ballots|).(Storage_sigs.Indexed_data_storage.key) -&gt; Lwt.t bool :=
  (|Storage.Vote.Ballots|).(Storage_sigs.Indexed_data_storage.mem).

Definition record_ballot
  : (|Storage.Vote.Ballots|).(Storage_sigs.Indexed_data_storage.context) -&gt;
  (|Storage.Vote.Ballots|).(Storage_sigs.Indexed_data_storage.key) -&gt;
  (|Storage.Vote.Ballots|).(Storage_sigs.Indexed_data_storage.value) -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t) :=
  (|Storage.Vote.Ballots|).(Storage_sigs.Indexed_data_storage.init).

Definition get_ballots
  (ctxt : (|Storage.Vote.Ballots|).(Storage_sigs.Indexed_data_storage.context))
  : Lwt.t (Error_monad.tzresult ballots) :=
  (|Storage.Vote.Ballots|).(Storage_sigs.Indexed_data_storage.fold) ctxt
    (Error_monad.ok
      {|
        ballots.yay :=
          (* ‚ùå Constant of type int32 is converted to int *)
          0;
        ballots.nay :=
          (* ‚ùå Constant of type int32 is converted to int *)
          0;
        ballots.pass :=
          (* ‚ùå Constant of type int32 is converted to int *)
          0 |})
    (fun delegate =&gt;
      fun ballot =&gt;
        fun ballots =&gt;
          let=? weight :=
            (|Storage.Vote.Listings|).(Storage_sigs.Indexed_data_storage.get)
              ctxt delegate in
          let count := Int32.add weight in
          Lwt.__return
            (let? ballots := ballots in
            match ballot with
            | Vote_repr.Yay =&gt;
              Error_monad.ok
                (ballots.with_yay (count ballots.(ballots.yay)) ballots)
            | Vote_repr.Nay =&gt;
              Error_monad.ok
                (ballots.with_nay (count ballots.(ballots.nay)) ballots)
            | Vote_repr.Pass =&gt;
              Error_monad.ok
                (ballots.with_pass (count ballots.(ballots.pass)) ballots)
            end)).

Definition get_ballot_list
  : (|Storage.Vote.Ballots|).(Storage_sigs.Indexed_data_storage.context) -&gt;
  Lwt.t
    (list
      ((|Storage.Vote.Ballots|).(Storage_sigs.Indexed_data_storage.key) *
        (|Storage.Vote.Ballots|).(Storage_sigs.Indexed_data_storage.value))) :=
  (|Storage.Vote.Ballots|).(Storage_sigs.Indexed_data_storage.bindings).

Definition clear_ballots
  : (|Storage.Vote.Ballots|).(Storage_sigs.Indexed_data_storage.context) -&gt;
  Lwt.t Raw_context.t :=
  (|Storage.Vote.Ballots|).(Storage_sigs.Indexed_data_storage.clear).

Definition listings_encoding
  : Data_encoding.encoding
    (list ((|Signature.Public_key_hash|).(S.SPublic_key_hash.t) * int32)) :=
  Data_encoding.__list_value None
    (Data_encoding.obj2
      (Data_encoding.req None None &quot;pkh&quot;
        (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding))
      (Data_encoding.req None None &quot;rolls&quot; Data_encoding.__int32_value)).

Definition freeze_listings (ctxt : Raw_context.t)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let=? '(ctxt, total) :=
    Roll_storage.fold ctxt
      (fun _roll =&gt;
        fun delegate =&gt;
          fun function_parameter =&gt;
            let '(ctxt, total) := function_parameter in
            let delegate :=
              (|Signature.Public_key|).(S.SPublic_key.__hash_value) delegate in
            let=? count :=
              let=? function_parameter :=
                (|Storage.Vote.Listings|).(Storage_sigs.Indexed_data_storage.get_option)
                  ctxt delegate in
              match function_parameter with
              | None =&gt;
                Error_monad.__return
                  (* ‚ùå Constant of type int32 is converted to int *)
                  0
              | Some count =&gt; Error_monad.__return count
              end in
            let= ctxt :=
              (|Storage.Vote.Listings|).(Storage_sigs.Indexed_data_storage.init_set)
                ctxt delegate (Int32.succ count) in
            Error_monad.__return (ctxt, (Int32.succ total)))
      (ctxt,
        (* ‚ùå Constant of type int32 is converted to int *)
        0) in
  let=? ctxt :=
    (|Storage.Vote.Listings_size|).(Storage_sigs.Single_data_storage.init) ctxt
      total in
  Error_monad.__return ctxt.

Definition listing_size
  : (|Storage.Vote.Listings_size|).(Storage_sigs.Single_data_storage.context) -&gt;
  Lwt.t
    (Error_monad.tzresult
      (|Storage.Vote.Listings_size|).(Storage_sigs.Single_data_storage.value)) :=
  (|Storage.Vote.Listings_size|).(Storage_sigs.Single_data_storage.get).

Definition in_listings
  : (|Storage.Vote.Listings|).(Storage_sigs.Indexed_data_storage.context) -&gt;
  (|Storage.Vote.Listings|).(Storage_sigs.Indexed_data_storage.key) -&gt;
  Lwt.t bool :=
  (|Storage.Vote.Listings|).(Storage_sigs.Indexed_data_storage.mem).

Definition get_listings
  : (|Storage.Vote.Listings|).(Storage_sigs.Indexed_data_storage.context) -&gt;
  Lwt.t
    (list
      ((|Storage.Vote.Listings|).(Storage_sigs.Indexed_data_storage.key) *
        (|Storage.Vote.Listings|).(Storage_sigs.Indexed_data_storage.value))) :=
  (|Storage.Vote.Listings|).(Storage_sigs.Indexed_data_storage.bindings).

Definition clear_listings
  (ctxt : (|Storage.Vote.Listings|).(Storage_sigs.Indexed_data_storage.context))
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let= ctxt :=
    (|Storage.Vote.Listings|).(Storage_sigs.Indexed_data_storage.clear) ctxt in
  let= ctxt :=
    (|Storage.Vote.Listings_size|).(Storage_sigs.Single_data_storage.remove)
      ctxt in
  Error_monad.__return ctxt.

Definition get_current_period_kind
  : (|Storage.Vote.Current_period_kind|).(Storage_sigs.Single_data_storage.context)
  -&gt;
  Lwt.t
    (Error_monad.tzresult
      (|Storage.Vote.Current_period_kind|).(Storage_sigs.Single_data_storage.value)) :=
  (|Storage.Vote.Current_period_kind|).(Storage_sigs.Single_data_storage.get).

Definition set_current_period_kind
  : (|Storage.Vote.Current_period_kind|).(Storage_sigs.Single_data_storage.context)
  -&gt;
  (|Storage.Vote.Current_period_kind|).(Storage_sigs.Single_data_storage.value)
  -&gt; Lwt.t (Error_monad.tzresult Raw_context.t) :=
  (|Storage.Vote.Current_period_kind|).(Storage_sigs.Single_data_storage.set).

Definition get_current_quorum
  (ctxt :
    (|Storage.Vote.Participation_ema|).(Storage_sigs.Single_data_storage.context))
  : Lwt.t (Error_monad.tzresult int32) :=
  let=? participation_ema :=
    (|Storage.Vote.Participation_ema|).(Storage_sigs.Single_data_storage.get)
      ctxt in
  let quorum_min := Constants_storage.quorum_min ctxt in
  let quorum_max := Constants_storage.quorum_max ctxt in
  let quorum_diff := Int32.sub quorum_max quorum_min in
  Error_monad.__return
    (Int32.add quorum_min
      (Int32.div (Int32.mul participation_ema quorum_diff)
        (* ‚ùå Constant of type int32 is converted to int *)
        10000)).

Definition get_participation_ema
  : (|Storage.Vote.Participation_ema|).(Storage_sigs.Single_data_storage.context)
  -&gt;
  Lwt.t
    (Error_monad.tzresult
      (|Storage.Vote.Participation_ema|).(Storage_sigs.Single_data_storage.value)) :=
  (|Storage.Vote.Participation_ema|).(Storage_sigs.Single_data_storage.get).

Definition set_participation_ema
  : (|Storage.Vote.Participation_ema|).(Storage_sigs.Single_data_storage.context)
  -&gt;
  (|Storage.Vote.Participation_ema|).(Storage_sigs.Single_data_storage.value) -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t) :=
  (|Storage.Vote.Participation_ema|).(Storage_sigs.Single_data_storage.set).

Definition get_current_proposal
  : (|Storage.Vote.Current_proposal|).(Storage_sigs.Single_data_storage.context)
  -&gt;
  Lwt.t
    (Error_monad.tzresult
      (|Storage.Vote.Current_proposal|).(Storage_sigs.Single_data_storage.value)) :=
  (|Storage.Vote.Current_proposal|).(Storage_sigs.Single_data_storage.get).

Definition init_current_proposal
  : (|Storage.Vote.Current_proposal|).(Storage_sigs.Single_data_storage.context)
  -&gt;
  (|Storage.Vote.Current_proposal|).(Storage_sigs.Single_data_storage.value) -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t) :=
  (|Storage.Vote.Current_proposal|).(Storage_sigs.Single_data_storage.init).

Definition clear_current_proposal
  : (|Storage.Vote.Current_proposal|).(Storage_sigs.Single_data_storage.context)
  -&gt; Lwt.t (Error_monad.tzresult Raw_context.t) :=
  (|Storage.Vote.Current_proposal|).(Storage_sigs.Single_data_storage.delete).

Definition init (ctxt : Raw_context.context)
  : Lwt.t (Error_monad.tzresult Raw_context.t) :=
  let participation_ema := Constants_storage.quorum_max ctxt in
  let=? ctxt :=
    (|Storage.Vote.Participation_ema|).(Storage_sigs.Single_data_storage.init)
      ctxt participation_ema in
  let=? ctxt :=
    (|Storage.Vote.Current_period_kind|).(Storage_sigs.Single_data_storage.init)
      ctxt Voting_period_repr.Proposal in
  Error_monad.__return ctxt.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="vote_storage.mli">
  <div style="margin: 20px;">
    <h3>Vote_storage_mli</h3>
    <ul>
      <li>OCaml size: 106 lines</li>
      <li>Coq size: 113 lines (+6% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#vote_storage.mli"><code>vote_storage.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Manages all the voting related storage in Storage.Vote.  *)

(** Records a protocol proposal with the delegate that proposed it. *)
val record_proposal :
  Raw_context.t -&gt;
  Protocol_hash.t -&gt;
  Signature.Public_key_hash.t -&gt;
  Raw_context.t tzresult Lwt.t

val recorded_proposal_count_for_delegate :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; int tzresult Lwt.t

(** Computes for each proposal how many delegates proposed it. *)
val get_proposals : Raw_context.t -&gt; int32 Protocol_hash.Map.t tzresult Lwt.t

val clear_proposals : Raw_context.t -&gt; Raw_context.t Lwt.t

(** Counts of the votes *)
type ballots = {yay : int32; nay : int32; pass : int32}

val ballots_encoding : ballots Data_encoding.t

val has_recorded_ballot :
  Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; bool Lwt.t

(** Records a vote for a delegate, returns a {!Storage_error Existing_key} if
    the vote was already registered *)
val record_ballot :
  Raw_context.t -&gt;
  Signature.Public_key_hash.t -&gt;
  Vote_repr.ballot -&gt;
  Raw_context.t tzresult Lwt.t

(** Computes the sum of the current ballots weighted by stake. *)
val get_ballots : Raw_context.t -&gt; ballots tzresult Lwt.t

val get_ballot_list :
  Raw_context.t -&gt; (Signature.Public_key_hash.t * Vote_repr.ballot) list Lwt.t

val clear_ballots : Raw_context.t -&gt; Raw_context.t Lwt.t

val listings_encoding :
  (Signature.Public_key_hash.t * int32) list Data_encoding.t

(** Populates [!Storage.Vote.Listings] using the currently existing rolls and
    sets Listings_size. Delegates without rolls are not included in the listing. *)
val freeze_listings : Raw_context.t -&gt; Raw_context.t tzresult Lwt.t

val clear_listings : Raw_context.t -&gt; Raw_context.t tzresult Lwt.t

(** Returns the sum of all rolls of all delegates. *)
val listing_size : Raw_context.t -&gt; int32 tzresult Lwt.t

(** Verifies the presence of a delegate in the listing. *)
val in_listings : Raw_context.t -&gt; Signature.Public_key_hash.t -&gt; bool Lwt.t

val get_listings :
  Raw_context.t -&gt; (Signature.Public_key_hash.t * int32) list Lwt.t

val get_current_quorum : Raw_context.t -&gt; int32 tzresult Lwt.t

val get_participation_ema : Raw_context.t -&gt; int32 tzresult Lwt.t

val set_participation_ema :
  Raw_context.t -&gt; int32 -&gt; Raw_context.t tzresult Lwt.t

val get_current_period_kind :
  Raw_context.t -&gt; Voting_period_repr.kind tzresult Lwt.t

val set_current_period_kind :
  Raw_context.t -&gt; Voting_period_repr.kind -&gt; Raw_context.t tzresult Lwt.t

val get_current_proposal : Raw_context.t -&gt; Protocol_hash.t tzresult Lwt.t

val init_current_proposal :
  Raw_context.t -&gt; Protocol_hash.t -&gt; Raw_context.t tzresult Lwt.t

val clear_current_proposal : Raw_context.t -&gt; Raw_context.t tzresult Lwt.t

(** Sets the initial quorum to 80% and period kind to proposal. *)
val init : Raw_context.t -&gt; Raw_context.t tzresult Lwt.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#vote_storage.mli"><code>Vote_storage_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Raw_context.
Require Tezos.Vote_repr.
Require Tezos.Voting_period_repr.

Parameter record_proposal :
  Raw_context.t -&gt; (|Protocol_hash|).(S.HASH.t) -&gt;
  (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter recorded_proposal_count_for_delegate :
  Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t (Error_monad.tzresult int).

Parameter get_proposals :
  Raw_context.t -&gt;
  Lwt.t
    (Error_monad.tzresult
      ((|Protocol_hash|).(S.HASH.Map).(S.INDEXES_Map.t) int32)).

Parameter clear_proposals : Raw_context.t -&gt; Lwt.t Raw_context.t.

Module ballots.
  Record record : Set := Build {
    yay : int32;
    nay : int32;
    pass : int32 }.
  Definition with_yay yay (r : record) :=
    Build yay r.(nay) r.(pass).
  Definition with_nay nay (r : record) :=
    Build r.(yay) nay r.(pass).
  Definition with_pass pass (r : record) :=
    Build r.(yay) r.(nay) pass.
End ballots.
Definition ballots := ballots.record.

Parameter ballots_encoding : Data_encoding.t ballots.

Parameter has_recorded_ballot :
  Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t bool.

Parameter record_ballot :
  Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Vote_repr.ballot -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter get_ballots : Raw_context.t -&gt; Lwt.t (Error_monad.tzresult ballots).

Parameter get_ballot_list :
  Raw_context.t -&gt;
  Lwt.t
    (list
      ((|Signature.Public_key_hash|).(S.SPublic_key_hash.t) * Vote_repr.ballot)).

Parameter clear_ballots : Raw_context.t -&gt; Lwt.t Raw_context.t.

Parameter listings_encoding :
  Data_encoding.t
    (list ((|Signature.Public_key_hash|).(S.SPublic_key_hash.t) * int32)).

Parameter freeze_listings :
  Raw_context.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter clear_listings :
  Raw_context.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter listing_size : Raw_context.t -&gt; Lwt.t (Error_monad.tzresult int32).

Parameter in_listings :
  Raw_context.t -&gt; (|Signature.Public_key_hash|).(S.SPublic_key_hash.t) -&gt;
  Lwt.t bool.

Parameter get_listings :
  Raw_context.t -&gt;
  Lwt.t (list ((|Signature.Public_key_hash|).(S.SPublic_key_hash.t) * int32)).

Parameter get_current_quorum :
  Raw_context.t -&gt; Lwt.t (Error_monad.tzresult int32).

Parameter get_participation_ema :
  Raw_context.t -&gt; Lwt.t (Error_monad.tzresult int32).

Parameter set_participation_ema :
  Raw_context.t -&gt; int32 -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter get_current_period_kind :
  Raw_context.t -&gt; Lwt.t (Error_monad.tzresult Voting_period_repr.kind).

Parameter set_current_period_kind :
  Raw_context.t -&gt; Voting_period_repr.kind -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter get_current_proposal :
  Raw_context.t -&gt; Lwt.t (Error_monad.tzresult (|Protocol_hash|).(S.HASH.t)).

Parameter init_current_proposal :
  Raw_context.t -&gt; (|Protocol_hash|).(S.HASH.t) -&gt;
  Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter clear_current_proposal :
  Raw_context.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).

Parameter init : Raw_context.t -&gt; Lwt.t (Error_monad.tzresult Raw_context.t).
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="voting_period_repr.ml">
  <div style="margin: 20px;">
    <h3>Voting_period_repr</h3>
    <ul>
      <li>OCaml size: 91 lines</li>
      <li>Coq size: 123 lines (+35% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#voting_period_repr.ml"><code>voting_period_repr.ml</code></a>&nbsp;<span class="label label-warning">1 warning</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = int32

type voting_period = t

include (Compare.Int32 : Compare.S with type t := t)

let encoding = Data_encoding.int32

let pp ppf level = Format.fprintf ppf &quot;%ld&quot; level

let rpc_arg =
  let construct voting_period = Int32.to_string voting_period in
  let destruct str =
    match Int32.of_string str with
    | exception <abbr class="mark-warning" title="We do not support pattern-matching on exceptions">_</abbr> -&gt;
        Error &quot;Cannot parse voting period&quot;
    | voting_period -&gt;
        Ok voting_period
  in
  RPC_arg.make
    ~descr:&quot;A voting period&quot;
    ~name:&quot;voting_period&quot;
    ~construct
    ~destruct
    ()

let root = 0l

let succ = Int32.succ

let to_int32 l = l

let of_int32_exn l =
  if Compare.Int32.(l &gt;= 0l) then l
  else invalid_arg &quot;Voting_period_repr.of_int32&quot;

type kind = Proposal | Testing_vote | Testing | Promotion_vote

let kind_encoding =
  let open Data_encoding in
  union
    ~tag_size:`Uint8
    [ case
        (Tag 0)
        ~title:&quot;Proposal&quot;
        (constant &quot;proposal&quot;)
        (function Proposal -&gt; Some () | _ -&gt; None)
        (fun () -&gt; Proposal);
      case
        (Tag 1)
        ~title:&quot;Testing_vote&quot;
        (constant &quot;testing_vote&quot;)
        (function Testing_vote -&gt; Some () | _ -&gt; None)
        (fun () -&gt; Testing_vote);
      case
        (Tag 2)
        ~title:&quot;Testing&quot;
        (constant &quot;testing&quot;)
        (function Testing -&gt; Some () | _ -&gt; None)
        (fun () -&gt; Testing);
      case
        (Tag 3)
        ~title:&quot;Promotion_vote&quot;
        (constant &quot;promotion_vote&quot;)
        (function Promotion_vote -&gt; Some () | _ -&gt; None)
        (fun () -&gt; Promotion_vote) ]
</pre>
  </div>
  <div class="col-md-6">
    <a href="#voting_period_repr.ml"><code>Voting_period_repr.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.

Definition t : Set := int32.

Definition voting_period : Set := t.

Definition op_eq := (|Compare.Int32|).(Compare.S.op_eq).

Definition op_ltgt := (|Compare.Int32|).(Compare.S.op_ltgt).

Definition op_lt := (|Compare.Int32|).(Compare.S.op_lt).

Definition op_lteq := (|Compare.Int32|).(Compare.S.op_lteq).

Definition op_gteq := (|Compare.Int32|).(Compare.S.op_gteq).

Definition op_gt := (|Compare.Int32|).(Compare.S.op_gt).

Definition compare := (|Compare.Int32|).(Compare.S.compare).

Definition equal := (|Compare.Int32|).(Compare.S.equal).

Definition max := (|Compare.Int32|).(Compare.S.max).

Definition min := (|Compare.Int32|).(Compare.S.min).

Definition encoding : Data_encoding.encoding int32 :=
  Data_encoding.__int32_value.

Definition pp (ppf : Format.formatter) (level : int32) : unit :=
  Format.fprintf ppf
    (CamlinternalFormatBasics.Format
      (CamlinternalFormatBasics.Int32 CamlinternalFormatBasics.Int_d
        CamlinternalFormatBasics.No_padding
        CamlinternalFormatBasics.No_precision
        CamlinternalFormatBasics.End_of_format) &quot;%ld&quot;) level.

Definition rpc_arg : RPC_arg.arg int32 :=
  let construct (voting_period : int32) : string :=
    Int32.to_string voting_period in
  let destruct (str : string) : Pervasives.result int32 string :=
    let 'voting_period := Int32.of_string str in
    Pervasives.Ok voting_period in
  RPC_arg.make (Some &quot;A voting period&quot;) &quot;voting_period&quot; destruct construct tt.

Definition root : int32 :=
  (* ‚ùå Constant of type int32 is converted to int *)
  0.

Definition succ : int32 -&gt; int32 := Int32.succ.

Definition to_int32 {A : Set} (l : A) : A := l.

Definition of_int32_exn (l : (|Compare.Int32|).(Compare.S.t))
  : (|Compare.Int32|).(Compare.S.t) :=
  if
    (|Compare.Int32|).(Compare.S.op_gteq) l
      (* ‚ùå Constant of type int32 is converted to int *)
      0 then
    l
  else
    Pervasives.invalid_arg &quot;Voting_period_repr.of_int32&quot;.

Inductive kind : Set :=
| Proposal : kind
| Testing_vote : kind
| Testing : kind
| Promotion_vote : kind.

Definition kind_encoding : Data_encoding.encoding kind :=
  Data_encoding.union (Some Data_encoding.Uint8)
    [
      Data_encoding.__case_value &quot;Proposal&quot; None (Data_encoding.Tag 0)
        (Data_encoding.constant &quot;proposal&quot;)
        (fun function_parameter =&gt;
          match function_parameter with
          | Proposal =&gt; Some tt
          | _ =&gt; None
          end)
        (fun function_parameter =&gt;
          let '_ := function_parameter in
          Proposal);
      Data_encoding.__case_value &quot;Testing_vote&quot; None (Data_encoding.Tag 1)
        (Data_encoding.constant &quot;testing_vote&quot;)
        (fun function_parameter =&gt;
          match function_parameter with
          | Testing_vote =&gt; Some tt
          | _ =&gt; None
          end)
        (fun function_parameter =&gt;
          let '_ := function_parameter in
          Testing_vote);
      Data_encoding.__case_value &quot;Testing&quot; None (Data_encoding.Tag 2)
        (Data_encoding.constant &quot;testing&quot;)
        (fun function_parameter =&gt;
          match function_parameter with
          | Testing =&gt; Some tt
          | _ =&gt; None
          end)
        (fun function_parameter =&gt;
          let '_ := function_parameter in
          Testing);
      Data_encoding.__case_value &quot;Promotion_vote&quot; None (Data_encoding.Tag 3)
        (Data_encoding.constant &quot;promotion_vote&quot;)
        (fun function_parameter =&gt;
          match function_parameter with
          | Promotion_vote =&gt; Some tt
          | _ =&gt; None
          end)
        (fun function_parameter =&gt;
          let '_ := function_parameter in
          Promotion_vote)
    ].
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="voting_period_repr.mli">
  <div style="margin: 20px;">
    <h3>Voting_period_repr_mli</h3>
    <ul>
      <li>OCaml size: 55 lines</li>
      <li>Coq size: 69 lines (+25% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#voting_period_repr.mli"><code>voting_period_repr.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** A voting period can be of 4 kinds and is uniquely identified as a counter
    since the root. *)

type t

type voting_period = t

val encoding : voting_period Data_encoding.t

val rpc_arg : voting_period RPC_arg.arg

val pp : Format.formatter -&gt; voting_period -&gt; unit

include Compare.S with type t := voting_period

val to_int32 : voting_period -&gt; int32

val of_int32_exn : int32 -&gt; voting_period

val root : voting_period

val succ : voting_period -&gt; voting_period

type kind =
  | Proposal  (** protocols can be proposed *)
  | Testing_vote  (** a proposal can be voted *)
  | Testing  (** winning proposal is forked on a testnet *)
  | Promotion_vote  (** activation can be voted *)

val kind_encoding : kind Data_encoding.t
</pre>
  </div>
  <div class="col-md-6">
    <a href="#voting_period_repr.mli"><code>Voting_period_repr_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.

Parameter t : Set.

Definition voting_period : Set := t.

Parameter encoding : Data_encoding.t voting_period.

Parameter rpc_arg : RPC_arg.arg voting_period.

Parameter pp : Format.formatter -&gt; voting_period -&gt; unit.

Parameter Included_S : {_ : unit &amp; Compare.S.signature (t := voting_period)}.

Definition op_eq : voting_period -&gt; voting_period -&gt; bool :=
  (|Included_S|).(Compare.S.op_eq).

Definition op_ltgt : voting_period -&gt; voting_period -&gt; bool :=
  (|Included_S|).(Compare.S.op_ltgt).

Definition op_lt : voting_period -&gt; voting_period -&gt; bool :=
  (|Included_S|).(Compare.S.op_lt).

Definition op_lteq : voting_period -&gt; voting_period -&gt; bool :=
  (|Included_S|).(Compare.S.op_lteq).

Definition op_gteq : voting_period -&gt; voting_period -&gt; bool :=
  (|Included_S|).(Compare.S.op_gteq).

Definition op_gt : voting_period -&gt; voting_period -&gt; bool :=
  (|Included_S|).(Compare.S.op_gt).

Definition compare : voting_period -&gt; voting_period -&gt; int :=
  (|Included_S|).(Compare.S.compare).

Definition equal : voting_period -&gt; voting_period -&gt; bool :=
  (|Included_S|).(Compare.S.equal).

Definition max : voting_period -&gt; voting_period -&gt; voting_period :=
  (|Included_S|).(Compare.S.max).

Definition min : voting_period -&gt; voting_period -&gt; voting_period :=
  (|Included_S|).(Compare.S.min).

Parameter to_int32 : voting_period -&gt; int32.

Parameter of_int32_exn : int32 -&gt; voting_period.

Parameter root : voting_period.

Parameter succ : voting_period -&gt; voting_period.

Inductive kind : Set :=
| Proposal : kind
| Testing_vote : kind
| Testing : kind
| Promotion_vote : kind.

Parameter kind_encoding : Data_encoding.t kind.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="voting_services.ml">
  <div style="margin: 20px;">
    <h3>Voting_services</h3>
    <ul>
      <li>OCaml size: 123 lines</li>
      <li>Coq size: 145 lines (+17% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#voting_services.ml"><code>voting_services.ml</code></a>&nbsp;<span class="label label-warning">7 warnings</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

module S = struct
  let path = RPC_path.(open_root / &quot;votes&quot;)

  let ballots =
    RPC_service.get_service
      ~description:&quot;Sum of ballots casted so far during a voting period.&quot;
      ~query:RPC_query.empty
      ~output:Vote.ballots_encoding
      RPC_path.(path / &quot;ballots&quot;)

  let ballot_list =
    RPC_service.get_service
      ~description:&quot;Ballots casted so far during a voting period.&quot;
      ~query:RPC_query.empty
      ~output:
        Data_encoding.(
          list
            (obj2
               (req &quot;pkh&quot; Signature.Public_key_hash.encoding)
               (req &quot;ballot&quot; Vote.ballot_encoding)))
      RPC_path.(path / &quot;ballot_list&quot;)

  let current_period_kind =
    RPC_service.get_service
      ~description:&quot;Current period kind.&quot;
      ~query:RPC_query.empty
      ~output:Voting_period.kind_encoding
      RPC_path.(path / &quot;current_period_kind&quot;)

  let current_quorum =
    RPC_service.get_service
      ~description:&quot;Current expected quorum.&quot;
      ~query:RPC_query.empty
      ~output:Data_encoding.int32
      RPC_path.(path / &quot;current_quorum&quot;)

  let listings =
    RPC_service.get_service
      ~description:
        &quot;List of delegates with their voting weight, in number of rolls.&quot;
      ~query:RPC_query.empty
      ~output:Vote.listings_encoding
      RPC_path.(path / &quot;listings&quot;)

  let proposals =
    RPC_service.get_service
      ~description:&quot;List of proposals with number of supporters.&quot;
      ~query:RPC_query.empty
      ~output:(Protocol_hash.Map.encoding Data_encoding.int32)
      RPC_path.(path / &quot;proposals&quot;)

  let current_proposal =
    RPC_service.get_service
      ~description:&quot;Current proposal under evaluation.&quot;
      ~query:RPC_query.empty
      ~output:(Data_encoding.option Protocol_hash.encoding)
      RPC_path.(path / &quot;current_proposal&quot;)
end

let register () =
  let open Services_registration in
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.ballots (fun ctxt () () -&gt; Vote.get_ballots ctxt)</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.ballot_list (fun ctxt () () -&gt; Vote.get_ballot_list ctxt &gt;|= ok)</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.current_period_kind (fun ctxt () () -&gt;
      Vote.get_current_period_kind ctxt)</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.current_quorum (fun ctxt () () -&gt; Vote.get_current_quorum ctxt)</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.proposals (fun ctxt () () -&gt; Vote.get_proposals ctxt)</abbr> ;
  <abbr class="mark-warning" title="Sequences of instructions are ignored (operator &quot;;&quot;)

Alternative: use a monad to sequence side-effects.">register0 S.listings (fun ctxt () () -&gt; Vote.get_listings ctxt &gt;|= ok)</abbr> ;
  register0 S.current_proposal (fun ctxt () () -&gt;
      (* this would be better implemented using get_option in get_current_proposal *)
      Vote.get_current_proposal ctxt
      &gt;&gt;= function
      | Ok p -&gt;
          return_some p
      | Error (<abbr class="mark-warning" title="Patterns of extensible types are not handled">Raw_context.Storage_error (Missing_key _)</abbr> :: _) -&gt;
          return_none
      | Error error -&gt;
          Lwt.return (Error error))

let ballots ctxt block = RPC_context.make_call0 S.ballots ctxt block () ()

let ballot_list ctxt block =
  RPC_context.make_call0 S.ballot_list ctxt block () ()

let current_period_kind ctxt block =
  RPC_context.make_call0 S.current_period_kind ctxt block () ()

let current_quorum ctxt block =
  RPC_context.make_call0 S.current_quorum ctxt block () ()

let listings ctxt block = RPC_context.make_call0 S.listings ctxt block () ()

let proposals ctxt block = RPC_context.make_call0 S.proposals ctxt block () ()

let current_proposal ctxt block =
  RPC_context.make_call0 S.current_proposal ctxt block () ()
</pre>
  </div>
  <div class="col-md-6">
    <a href="#voting_services.ml"><code>Voting_services.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.
Require Tezos.Services_registration.

Import Alpha_context.

Module S.
  Definition path : RPC_path.path Updater.rpc_context Updater.rpc_context :=
    RPC_path.op_div RPC_path.open_root &quot;votes&quot;.
  
  Definition ballots
    : RPC_service.service Updater.rpc_context Updater.rpc_context unit unit
      Alpha_context.Vote.ballots :=
    RPC_service.get_service
      (Some &quot;Sum of ballots casted so far during a voting period.&quot;)
      RPC_query.empty Alpha_context.Vote.ballots_encoding
      (RPC_path.op_div path &quot;ballots&quot;).
  
  Definition ballot_list
    : RPC_service.service Updater.rpc_context Updater.rpc_context unit unit
      (list
        ((|Signature.Public_key_hash|).(S.SPublic_key_hash.t) *
          Alpha_context.Vote.ballot)) :=
    RPC_service.get_service
      (Some &quot;Ballots casted so far during a voting period.&quot;) RPC_query.empty
      (Data_encoding.__list_value None
        (Data_encoding.obj2
          (Data_encoding.req None None &quot;pkh&quot;
            (|Signature.Public_key_hash|).(S.SPublic_key_hash.encoding))
          (Data_encoding.req None None &quot;ballot&quot;
            Alpha_context.Vote.ballot_encoding)))
      (RPC_path.op_div path &quot;ballot_list&quot;).
  
  Definition current_period_kind
    : RPC_service.service Updater.rpc_context Updater.rpc_context unit unit
      Alpha_context.Voting_period.kind :=
    RPC_service.get_service (Some &quot;Current period kind.&quot;) RPC_query.empty
      Alpha_context.Voting_period.kind_encoding
      (RPC_path.op_div path &quot;current_period_kind&quot;).
  
  Definition current_quorum
    : RPC_service.service Updater.rpc_context Updater.rpc_context unit unit
      int32 :=
    RPC_service.get_service (Some &quot;Current expected quorum.&quot;) RPC_query.empty
      Data_encoding.__int32_value (RPC_path.op_div path &quot;current_quorum&quot;).
  
  Definition listings
    : RPC_service.service Updater.rpc_context Updater.rpc_context unit unit
      (list ((|Signature.Public_key_hash|).(S.SPublic_key_hash.t) * int32)) :=
    RPC_service.get_service
      (Some &quot;List of delegates with their voting weight, in number of rolls.&quot;)
      RPC_query.empty Alpha_context.Vote.listings_encoding
      (RPC_path.op_div path &quot;listings&quot;).
  
  Definition proposals
    : RPC_service.service Updater.rpc_context Updater.rpc_context unit unit
      ((|Protocol_hash|).(S.HASH.Map).(S.INDEXES_Map.t) int32) :=
    RPC_service.get_service
      (Some &quot;List of proposals with number of supporters.&quot;) RPC_query.empty
      ((|Protocol_hash|).(S.HASH.Map).(S.INDEXES_Map.encoding)
        Data_encoding.__int32_value) (RPC_path.op_div path &quot;proposals&quot;).
  
  Definition current_proposal
    : RPC_service.service Updater.rpc_context Updater.rpc_context unit unit
      (option (|Protocol_hash|).(S.HASH.t)) :=
    RPC_service.get_service (Some &quot;Current proposal under evaluation.&quot;)
      RPC_query.empty
      (Data_encoding.__option_value (|Protocol_hash|).(S.HASH.encoding))
      (RPC_path.op_div path &quot;current_proposal&quot;).
End S.

Definition register (function_parameter : unit) : unit :=
  let '_ := function_parameter in
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  (* ‚ùå Sequences of instructions are ignored (operator &quot;;&quot;) *)
  (* ‚ùå instruction_sequence &quot;;&quot; *)
  Services_registration.register0 S.current_proposal
    (fun ctxt =&gt;
      fun function_parameter =&gt;
        let '_ := function_parameter in
        fun function_parameter =&gt;
          let '_ := function_parameter in
          let= function_parameter :=
            Alpha_context.Vote.get_current_proposal ctxt in
          match function_parameter with
          | Pervasives.Ok __p_value =&gt; Error_monad.return_some __p_value
          | Pervasives.Error __error_value =&gt;
            Lwt.__return (Pervasives.Error __error_value)
          end).

Definition ballots {A : Set} (ctxt : RPC_context.simple A) (block : A)
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Vote.ballots) :=
  RPC_context.make_call0 S.ballots ctxt block tt tt.

Definition ballot_list {A : Set} (ctxt : RPC_context.simple A) (block : A)
  : Lwt.t
    (Error_monad.shell_tzresult
      (list
        ((|Signature.Public_key_hash|).(S.SPublic_key_hash.t) *
          Alpha_context.Vote.ballot))) :=
  RPC_context.make_call0 S.ballot_list ctxt block tt tt.

Definition current_period_kind {A : Set}
  (ctxt : RPC_context.simple A) (block : A)
  : Lwt.t (Error_monad.shell_tzresult Alpha_context.Voting_period.kind) :=
  RPC_context.make_call0 S.current_period_kind ctxt block tt tt.

Definition current_quorum {A : Set} (ctxt : RPC_context.simple A) (block : A)
  : Lwt.t (Error_monad.shell_tzresult int32) :=
  RPC_context.make_call0 S.current_quorum ctxt block tt tt.

Definition listings {A : Set} (ctxt : RPC_context.simple A) (block : A)
  : Lwt.t
    (Error_monad.shell_tzresult
      (list ((|Signature.Public_key_hash|).(S.SPublic_key_hash.t) * int32))) :=
  RPC_context.make_call0 S.listings ctxt block tt tt.

Definition proposals {A : Set} (ctxt : RPC_context.simple A) (block : A)
  : Lwt.t
    (Error_monad.shell_tzresult
      ((|Protocol_hash|).(S.HASH.Map).(S.INDEXES_Map.t) int32)) :=
  RPC_context.make_call0 S.proposals ctxt block tt tt.

Definition current_proposal {A : Set} (ctxt : RPC_context.simple A) (block : A)
  : Lwt.t (Error_monad.shell_tzresult (option (|Protocol_hash|).(S.HASH.t))) :=
  RPC_context.make_call0 S.current_proposal ctxt block tt tt.
</pre>
  </div>
</div>

<hr />
<div class="row conversion-row" id="voting_services.mli">
  <div style="margin: 20px;">
    <h3>Voting_services_mli</h3>
    <ul>
      <li>OCaml size: 54 lines</li>
      <li>Coq size: 51 lines (-6% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#voting_services.mli"><code>voting_services.mli</code></a>&nbsp;<span class="label label-success">success</span>
    
    <pre>(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

open Alpha_context

val ballots : 'a #RPC_context.simple -&gt; 'a -&gt; Vote.ballots shell_tzresult Lwt.t

val ballot_list :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  (Signature.Public_key_hash.t * Vote.ballot) list shell_tzresult Lwt.t

val current_period_kind :
  'a #RPC_context.simple -&gt; 'a -&gt; Voting_period.kind shell_tzresult Lwt.t

val current_quorum :
  'a #RPC_context.simple -&gt; 'a -&gt; Int32.t shell_tzresult Lwt.t

val listings :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  (Signature.Public_key_hash.t * int32) list shell_tzresult Lwt.t

val proposals :
  'a #RPC_context.simple -&gt;
  'a -&gt;
  Int32.t Protocol_hash.Map.t shell_tzresult Lwt.t

val current_proposal :
  'a #RPC_context.simple -&gt; 'a -&gt; Protocol_hash.t option shell_tzresult Lwt.t

val register : unit -&gt; unit
</pre>
  </div>
  <div class="col-md-6">
    <a href="#voting_services.mli"><code>Voting_services_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Require Import Tezos.Environment.
Import Environment.Notations.
Require Tezos.Alpha_context.

Import Alpha_context.

Parameter ballots : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.Vote.ballots).

Parameter ballot_list : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt;
  Lwt.t
    (Error_monad.shell_tzresult
      (list
        ((|Signature.Public_key_hash|).(S.SPublic_key_hash.t) *
          Alpha_context.Vote.ballot))).

Parameter current_period_kind : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt;
  Lwt.t (Error_monad.shell_tzresult Alpha_context.Voting_period.kind).

Parameter current_quorum : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt; Lwt.t (Error_monad.shell_tzresult Int32.t).

Parameter listings : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt;
  Lwt.t
    (Error_monad.shell_tzresult
      (list ((|Signature.Public_key_hash|).(S.SPublic_key_hash.t) * int32))).

Parameter proposals : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt;
  Lwt.t
    (Error_monad.shell_tzresult
      ((|Protocol_hash|).(S.HASH.Map).(S.INDEXES_Map.t) Int32.t)).

Parameter current_proposal : forall {a : Set},
  RPC_context.simple a -&gt; a -&gt;
  Lwt.t (Error_monad.shell_tzresult (option (|Protocol_hash|).(S.HASH.t))).

Parameter register : unit -&gt; unit.
</pre>
  </div>
</div>

      </div>
      <hr/>
      <div class="footer" style="margin-bottom: 40px;">
        <p class="text-center">
          <small>Sources of&nbsp;<a href="https://foobar-land.github.io/coq-of-ocaml/">coq-of-ocaml</a> are on&nbsp;<a href="https://github.com/clarus/coq-of-ocaml">GitHub</a>. ¬© Guillaume Claret.</small>
        </p>
      </div>
    </div>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <script src="../js/bootstrap.min.js"></script>
  </body>
</html>

