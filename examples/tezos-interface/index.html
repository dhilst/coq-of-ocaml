<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>coq-of-ocaml â€“ Examples</title>
    <link rel="shortcut icon" href="../img/favicon.ico">
    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/custom.css" rel="stylesheet">
    <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="container-fluid" style="overflow: hidden;">
      <div class="navbar navbar-default" role="navigation">
        <div class="container-fluid">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar-collapse-list" aria-expanded="false">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="../">
              <img alt="logo" height="24px" src="../img/favicon.ico" />
              coq-of-ocaml <span class="hidden-xs">- Examples</span></a>
          </div>

          <div class="collapse navbar-collapse" id="navbar-collapse-list">
            <ul class="nav navbar-nav">
              <li ><a href="../kernel/">Kernel of Coq</a></li>
              <li ><a href="../tezos/">Protocol of Tezos</a></li>
              <li class="active"><a href="../tezos-interface/">Interface of Tezos</a></li>
              <li><a href="https://foobar-land.github.io/coq-of-ocaml/">Home</a></li>
            </ul>
          </div>
        </div>
      </div>
      <div class="article">

<div class="row center-block not-full-width">
  <div class="col-md-12">
        <h2>
      Interface of the protocol of Tezos in&nbsp;Coq
      <small>
      <span class="label label-success">Does compile</span>
      </small>
    </h2>
    <p>These are the sources of the interface of the <a href="https://gitlab.com/tezos/tezos/tree/master/src/proto_alpha/lib_protocol">protocol</a> of <a href="https://tezos.com/">Tezos</a> imported to <a href="https://coq.inria.fr/">Coq</a> by the current development version of <a href="https://github.com/clarus/coq-of-ocaml">coq-of-ocaml</a>. Tezos is a crypto-currency with smart-contracts and an upgradable protocol.</p>
    

    <p>We show the original&nbsp;<a href="https://ocaml.org/">OCaml</a> code on the left and the imported&nbsp;<a href="https://coq.inria.fr/">Coq</a> code on the right. The imported code does compile. Warnings reported on the&nbsp;OCaml side are due to either various incompleteness in our tool, or to side-effects in the source code. Go on the <a href="https://gitter.im/clarus/coq-of-ocaml">Gitter chat</a> for more information. Work currently made at <a href="https://www.nomadic-labs.com/">Nomadic Labs</a>.</p>
    <p>To install the latest development version of <a href="https://foobar-land.github.io/coq-of-ocaml/">coq-of-ocaml</a> with <a href="https://opam.ocaml.org/">opam</a>:</p>
    <pre><code>opam repo add coq-released https://coq.inria.fr/opam/released
opam pin add https://github.com/clarus/coq-of-ocaml.git#master</code></pre>
    <ul>
      <li>OCaml size: 6154 lines</li>
      <li>Coq size: 3444 lines (-45% compared to&nbsp;OCaml)</li>
      <li>Warnings from coq-of-ocaml: 47</li>
    </ul>
    
      <canvas id="chart" width="400" height="400"></canvas>
      <script>
        window.chart =       {
        compiling: [
          7,
          826,
          1190,
          2184,
          6443,
        ],
        generated: [
          2185,
          2200,
          2829,
          6265,
          6443,
        ],
        labels: [
          "01-05",
          "01-06",
          "01-07",
          "01-08",
          "01-09",
        ]
      }
;
      </script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.9.3/Chart.bundle.min.js"></script>
      <script src="../js/display-chart.js"></script>
    
    
  </div>
</div>


<hr />
<div class="row conversion-row" id="environment.mli">
  <div style="margin: 20px;">
    <h3>Environment_mli</h3>
    <ul>
      <li>OCaml size: 6154 lines</li>
      <li>Coq size: 3444 lines (-45% compared to&nbsp;OCaml)</li>
    </ul>
  </div>
  <div class="col-md-6">
    <a href="#environment.mli"><code>environment.mli</code></a>&nbsp;<span class="label label-warning">47 warnings</span>
    
    <pre>module Pervasives : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/pervasives.mli&quot;
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* TEZOS CHANGES

   * Import version 4.06.1
   * Remove [channel], [exit], ...
   * Remove polymorphic comparisons
   * Remove floating-point arithmetic
   * Remove string conversion functions for float
   * Remove deprecated functions

*)

(** The initially opened module.

    This module provides the basic operations over the built-in types
    (numbers, booleans, byte sequences, strings, exceptions, references,
    lists, arrays, input-output channels, ...).

    This module is automatically opened at the beginning of each compilation.
    All components of this module can therefore be referred by their short
    name, without prefixing them by [Pervasives].
*)

(** {1 Exceptions} *)

(** Raise the given exception value *)
external raise : exn -&gt; 'a = &quot;%raise&quot;

(** A faster version [raise] which does not record the backtrace.
    @since 4.02.0
*)
external raise_notrace : exn -&gt; 'a = &quot;%raise_notrace&quot;

(** Raise exception [Invalid_argument] with the given string. *)
val invalid_arg : string -&gt; 'a

(** Raise exception [Failure] with the given string. *)
val failwith : string -&gt; 'a

(** The [Exit] exception is not raised by any library function.  It is
    provided for use in your programs. *)
<abbr class="mark-warning" title="Signature item `exception` not handled">exception Exit</abbr>

(** {1 Boolean operations} *)

(** The boolean negation. *)
external not : bool -&gt; bool = &quot;%boolnot&quot;

(** The boolean 'and'. Evaluation is sequential, left-to-right:
    in [e1 &amp;&amp; e2], [e1] is evaluated first, and if it returns [false],
    [e2] is not evaluated at all.
    Right-associative operator at precedence level 3/11. *)
external ( &amp;&amp; ) : bool -&gt; bool -&gt; bool = &quot;%sequand&quot;

(** The boolean 'or'. Evaluation is sequential, left-to-right:
    in [e1 || e2], [e1] is evaluated first, and if it returns [true],
    [e2] is not evaluated at all.
    Right-associative operator at precedence level 2/11.
*)
external ( || ) : bool -&gt; bool -&gt; bool = &quot;%sequor&quot;

(** {1 Debugging} *)

(** [__LOC__] returns the location at which this expression appears in
    the file currently being parsed by the compiler, with the standard
    error format of OCaml: &quot;File %S, line %d, characters %d-%d&quot;.
    @since 4.02.0
*)
external __LOC__ : string = &quot;%loc_LOC&quot;

(** [__FILE__] returns the name of the file currently being
    parsed by the compiler.
    @since 4.02.0
*)
external __FILE__ : string = &quot;%loc_FILE&quot;

(** [__LINE__] returns the line number at which this expression
    appears in the file currently being parsed by the compiler.
    @since 4.02.0
*)
external __LINE__ : int = &quot;%loc_LINE&quot;

(** [__MODULE__] returns the module name of the file being
    parsed by the compiler.
    @since 4.02.0
*)
external __MODULE__ : string = &quot;%loc_MODULE&quot;

(** [__POS__] returns a tuple [(file,lnum,cnum,enum)], corresponding
    to the location at which this expression appears in the file
    currently being parsed by the compiler. [file] is the current
    filename, [lnum] the line number, [cnum] the character position in
    the line and [enum] the last character position in the line.
    @since 4.02.0
*)
external __POS__ : string * int * int * int = &quot;%loc_POS&quot;

(** [__LOC_OF__ expr] returns a pair [(loc, expr)] where [loc] is the
    location of [expr] in the file currently being parsed by the
    compiler, with the standard error format of OCaml: &quot;File %S, line
    %d, characters %d-%d&quot;.
    @since 4.02.0
*)
external __LOC_OF__ : 'a -&gt; string * 'a = &quot;%loc_LOC&quot;

(** [__LINE__ expr] returns a pair [(line, expr)], where [line] is the
    line number at which the expression [expr] appears in the file
    currently being parsed by the compiler.
    @since 4.02.0
*)
external __LINE_OF__ : 'a -&gt; int * 'a = &quot;%loc_LINE&quot;

(** [__POS_OF__ expr] returns a pair [(loc,expr)], where [loc] is a
    tuple [(file,lnum,cnum,enum)] corresponding to the location at
    which the expression [expr] appears in the file currently being
    parsed by the compiler. [file] is the current filename, [lnum] the
    line number, [cnum] the character position in the line and [enum]
    the last character position in the line.
    @since 4.02.0
*)
external __POS_OF__ : 'a -&gt; (string * int * int * int) * 'a = &quot;%loc_POS&quot;

(** {1 Composition operators} *)

(** Reverse-application operator: [x |&gt; f |&gt; g] is exactly equivalent
    to [g (f (x))].
    Left-associative operator at precedence level 4/11.
    @since 4.01
*)
external ( |&gt; ) : 'a -&gt; ('a -&gt; 'b) -&gt; 'b = &quot;%revapply&quot;

(** Application operator: [g @@ f @@ x] is exactly equivalent to
    [g (f (x))].
    Right-associative operator at precedence level 5/11.
    @since 4.01
*)
external ( @@ ) : ('a -&gt; 'b) -&gt; 'a -&gt; 'b = &quot;%apply&quot;

(** {1 Integer arithmetic} *)

(** Integers are 31 bits wide (or 63 bits on 64-bit processors).
    All operations are taken modulo 2{^31} (or 2{^63}).
    They do not fail on overflow. *)

(** Unary negation. You can also write [- e] instead of [~- e].
    Unary operator at precedence level 9/11 for [- e]
    and 11/11 for [~- e]. *)
external ( ~- ) : int -&gt; int = &quot;%negint&quot;

(** Unary addition. You can also write [+ e] instead of [~+ e].
    Unary operator at precedence level 9/11 for [+ e]
    and 11/11 for [~+ e].
    @since 3.12.0
*)
external ( ~+ ) : int -&gt; int = &quot;%identity&quot;

(** [succ x] is [x + 1]. *)
external succ : int -&gt; int = &quot;%succint&quot;

(** [pred x] is [x - 1]. *)
external pred : int -&gt; int = &quot;%predint&quot;

(** Integer addition.
    Left-associative operator at precedence level 6/11. *)
external ( + ) : int -&gt; int -&gt; int = &quot;%addint&quot;

(** Integer subtraction.
    Left-associative operator at precedence level 6/11. *)
external ( - ) : int -&gt; int -&gt; int = &quot;%subint&quot;

(** Integer multiplication.
    Left-associative operator at precedence level 7/11. *)
external ( * ) : int -&gt; int -&gt; int = &quot;%mulint&quot;

(** Integer division.
    Raise [Division_by_zero] if the second argument is 0.
    Integer division rounds the real quotient of its arguments towards zero.
    More precisely, if [x &gt;= 0] and [y &gt; 0], [x / y] is the greatest integer
    less than or equal to the real quotient of [x] by [y].  Moreover,
    [(- x) / y = x / (- y) = - (x / y)].
    Left-associative operator at precedence level 7/11. *)
external ( / ) : int -&gt; int -&gt; int = &quot;%divint&quot;

(** Integer remainder.  If [y] is not zero, the result
    of [x mod y] satisfies the following properties:
    [x = (x / y) * y + x mod y] and
    [abs(x mod y) &lt;= abs(y) - 1].
    If [y = 0], [x mod y] raises [Division_by_zero].
    Note that [x mod y] is negative only if [x &lt; 0].
    Raise [Division_by_zero] if [y] is zero.
    Left-associative operator at precedence level 7/11. *)
external ( mod ) : int -&gt; int -&gt; int = &quot;%modint&quot;

(** Return the absolute value of the argument.  Note that this may be
    negative if the argument is [min_int]. *)
val abs : int -&gt; int

(** The greatest representable integer. *)
val max_int : int

(** The smallest representable integer. *)
val min_int : int

(** {2 Bitwise operations} *)

(** Bitwise logical and.
    Left-associative operator at precedence level 7/11. *)
external ( land ) : int -&gt; int -&gt; int = &quot;%andint&quot;

(** Bitwise logical or.
    Left-associative operator at precedence level 7/11. *)
external ( lor ) : int -&gt; int -&gt; int = &quot;%orint&quot;

(** Bitwise logical exclusive or.
    Left-associative operator at precedence level 7/11. *)
external ( lxor ) : int -&gt; int -&gt; int = &quot;%xorint&quot;

(** Bitwise logical negation. *)
val lnot : int -&gt; int

(** [n lsl m] shifts [n] to the left by [m] bits.
    The result is unspecified if [m &lt; 0] or [m &gt;= bitsize],
    where [bitsize] is [32] on a 32-bit platform and
    [64] on a 64-bit platform.
    Right-associative operator at precedence level 8/11. *)
external ( lsl ) : int -&gt; int -&gt; int = &quot;%lslint&quot;

(** [n lsr m] shifts [n] to the right by [m] bits.
    This is a logical shift: zeroes are inserted regardless of
    the sign of [n].
    The result is unspecified if [m &lt; 0] or [m &gt;= bitsize].
    Right-associative operator at precedence level 8/11. *)
external ( lsr ) : int -&gt; int -&gt; int = &quot;%lsrint&quot;

(** [n asr m] shifts [n] to the right by [m] bits.
    This is an arithmetic shift: the sign bit of [n] is replicated.
    The result is unspecified if [m &lt; 0] or [m &gt;= bitsize].
    Right-associative operator at precedence level 8/11. *)
external ( asr ) : int -&gt; int -&gt; int = &quot;%asrint&quot;

(** {1 String operations}

    More string operations are provided in module {!String}.
*)

(** String concatenation.
    Right-associative operator at precedence level 5/11. *)
val ( ^ ) : string -&gt; string -&gt; string

(** {1 Character operations}

    More character operations are provided in module {!Char}.
*)

(** Return the ASCII code of the argument. *)
external int_of_char : char -&gt; int = &quot;%identity&quot;

(** Return the character with the given ASCII code.
    Raise [Invalid_argument &quot;char_of_int&quot;] if the argument is
    outside the range 0--255. *)
val char_of_int : int -&gt; char

(** {1 Unit operations} *)

(** Discard the value of its argument and return [()].
    For instance, [ignore(f x)] discards the result of
    the side-effecting function [f].  It is equivalent to
    [f x; ()], except that the latter may generate a
    compiler warning; writing [ignore(f x)] instead
    avoids the warning. *)
external ignore : 'a -&gt; unit = &quot;%ignore&quot;

(** {1 String conversion functions} *)

(** Return the string representation of a boolean. As the returned values
    may be shared, the user should not modify them directly.
*)
val string_of_bool : bool -&gt; string

(** Convert the given string to a boolean.
    Return [None] if the string is not
    [&quot;true&quot;] or [&quot;false&quot;].
    @since 4.05
*)
val bool_of_string_opt : string -&gt; bool option

(** Return the string representation of an integer, in decimal. *)
val string_of_int : int -&gt; string

(** Convert the given string to an integer.
    The string is read in decimal (by default, or if the string
    begins with [0u]), in hexadecimal (if it begins with [0x] or
    [0X]), in octal (if it begins with [0o] or [0O]), or in binary
    (if it begins with [0b] or [0B]).

    The [0u] prefix reads the input as an unsigned integer in the range
    [[0, 2*max_int+1]].  If the input exceeds {!max_int}
    it is converted to the signed integer
    [min_int + input - max_int - 1].

    The [_] (underscore) character can appear anywhere in the string
    and is ignored.

    Return [None] if the given string is not a valid representation of
    an integer, or if the integer represented exceeds the range of
    integers representable in type [int].
    @since 4.05
*)
val int_of_string_opt : string -&gt; int option

(** {1 Pair operations} *)

(** Return the first component of a pair. *)
external fst : 'a * 'b -&gt; 'a = &quot;%field0&quot;

(** Return the second component of a pair. *)
external snd : 'a * 'b -&gt; 'b = &quot;%field1&quot;

(** {1 List operations}

    More list operations are provided in module {!List}.
*)

(** List concatenation.  Not tail-recursive (length of the first argument).
    Right-associative operator at precedence level 5/11. *)
val ( @ ) : 'a list -&gt; 'a list -&gt; 'a list

(** {1 References} *)

(** The type of references (mutable indirection cells) containing
    a value of type ['a]. *)
type 'a ref = {mutable contents : 'a}

(** Return a fresh reference containing the given value. *)
external ref : 'a -&gt; 'a ref = &quot;%makemutable&quot;

(** [!r] returns the current contents of reference [r].
    Equivalent to [fun r -&gt; r.contents].
    Unary operator at precedence level 11/11.*)
external ( ! ) : 'a ref -&gt; 'a = &quot;%field0&quot;

(** [r := a] stores the value of [a] in reference [r].
    Equivalent to [fun r v -&gt; r.contents &lt;- v].
    Right-associative operator at precedence level 1/11. *)
external ( := ) : 'a ref -&gt; 'a -&gt; unit = &quot;%setfield0&quot;

(** Increment the integer contained in the given reference.
    Equivalent to [fun r -&gt; r := succ !r]. *)
external incr : int ref -&gt; unit = &quot;%incr&quot;

(** Decrement the integer contained in the given reference.
    Equivalent to [fun r -&gt; r := pred !r]. *)
external decr : int ref -&gt; unit = &quot;%decr&quot;

(** {1 Result type} *)

(** @since 4.03.0 *)
type ('a, 'b) result = Ok of 'a | Error of 'b

(** {1 Operations on format strings} *)

(** Format strings are character strings with special lexical conventions
    that defines the functionality of formatted input/output functions. Format
    strings are used to read data with formatted input functions from module
    {!Scanf} and to print data with formatted output functions from modules
    {!Printf} and {!Format}.

    Format strings are made of three kinds of entities:
    - {e conversions specifications}, introduced by the special character ['%']
    followed by one or more characters specifying what kind of argument to
    read or print,
    - {e formatting indications}, introduced by the special character ['@']
    followed by one or more characters specifying how to read or print the
    argument,
    - {e plain characters} that are regular characters with usual lexical
    conventions. Plain characters specify string literals to be read in the
    input or printed in the output.

    There is an additional lexical rule to escape the special characters ['%']
    and ['@'] in format strings: if a special character follows a ['%']
    character, it is treated as a plain character. In other words, [&quot;%%&quot;] is
    considered as a plain ['%'] and [&quot;%@&quot;] as a plain ['@'].

    For more information about conversion specifications and formatting
    indications available, read the documentation of modules {!Scanf},
    {!Printf} and {!Format}.
*)

(** Format strings have a general and highly polymorphic type
    [('a, 'b, 'c, 'd, 'e, 'f) format6].
    The two simplified types, [format] and [format4] below are
    included for backward compatibility with earlier releases of
    OCaml.

    The meaning of format string type parameters is as follows:

    - ['a] is the type of the parameters of the format for formatted output
      functions ([printf]-style functions);
      ['a] is the type of the values read by the format for formatted input
      functions ([scanf]-style functions).

    - ['b] is the type of input source for formatted input functions and the
      type of output target for formatted output functions.
      For [printf]-style functions from module {!Printf}, ['b] is typically
      [out_channel];
      for [printf]-style functions from module {!Format}, ['b] is typically
      {!Format.formatter};
      for [scanf]-style functions from module {!Scanf}, ['b] is typically
      {!Scanf.Scanning.in_channel}.

      Type argument ['b] is also the type of the first argument given to
      user's defined printing functions for [%a] and [%t] conversions,
      and user's defined reading functions for [%r] conversion.

    - ['c] is the type of the result of the [%a] and [%t] printing
      functions, and also the type of the argument transmitted to the
      first argument of [kprintf]-style functions or to the
      [kscanf]-style functions.

    - ['d] is the type of parameters for the [scanf]-style functions.

    - ['e] is the type of the receiver function for the [scanf]-style functions.

    - ['f] is the final result type of a formatted input/output function
      invocation: for the [printf]-style functions, it is typically [unit];
      for the [scanf]-style functions, it is typically the result type of the
      receiver function.
*)

type ('a, 'b, 'c, 'd, 'e, 'f) format6 =
  ('a, 'b, 'c, 'd, 'e, 'f) CamlinternalFormatBasics.format6

type ('a, 'b, 'c, 'd) format4 = ('a, 'b, 'c, 'c, 'c, 'd) format6

type ('a, 'b, 'c) format = ('a, 'b, 'c, 'c) format4

(** Converts a format string into a string. *)
val string_of_format : ('a, 'b, 'c, 'd, 'e, 'f) format6 -&gt; string

(** [format_of_string s] returns a format string read from the string
    literal [s].
    Note: [format_of_string] can not convert a string argument that is not a
    literal. If you need this functionality, use the more general
    {!Scanf.format_from_string} function.
*)
external format_of_string :
  ('a, 'b, 'c, 'd, 'e, 'f) format6 -&gt; ('a, 'b, 'c, 'd, 'e, 'f) format6
  = &quot;%identity&quot;

(** [f1 ^^ f2] catenates format strings [f1] and [f2]. The result is a
    format string that behaves as the concatenation of format strings [f1] and
    [f2]: in case of formatted output, it accepts arguments from [f1], then
    arguments from [f2]; in case of formatted input, it returns results from
    [f1], then results from [f2].
    Right-associative operator at precedence level 5/11. *)
val ( ^^ ) :
  ('a, 'b, 'c, 'd, 'e, 'f) format6 -&gt;
  ('f, 'b, 'c, 'e, 'g, 'h) format6 -&gt;
  ('a, 'b, 'c, 'd, 'g, 'h) format6
end
open Pervasives
module List : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/list.mli&quot;
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(** List operations.

    Some functions are flagged as not tail-recursive.  A tail-recursive
    function uses constant stack space, while a non-tail-recursive function
    uses stack space proportional to the length of its list argument, which
    can be a problem with very long lists.  When the function takes several
    list arguments, an approximate formula giving stack usage (in some
    unspecified constant unit) is shown in parentheses.

    The above considerations can usually be ignored if your lists are not
    longer than about 10000 elements.
*)

(** Return the length (number of elements) of the given list. *)
val length : 'a list -&gt; int

(** Compare the lengths of two lists. [compare_lengths l1 l2] is
    equivalent to [compare (length l1) (length l2)], except that
    the computation stops after itering on the shortest list.
    @since 4.05.0
*)
val compare_lengths : 'a list -&gt; 'b list -&gt; int

(** Compare the length of a list to an integer. [compare_length_with l n] is
    equivalent to [compare (length l) n], except that
    the computation stops after at most [n] iterations on the list.
    @since 4.05.0
*)
val compare_length_with : 'a list -&gt; int -&gt; int

(** [cons x xs] is [x :: xs]
    @since 4.03.0
*)
val cons : 'a -&gt; 'a list -&gt; 'a list

(** Return the first element of the given list. Raise
    [Failure &quot;hd&quot;] if the list is empty. *)
val hd : 'a list -&gt; 'a

(** Return the given list without its first element. Raise
    [Failure &quot;tl&quot;] if the list is empty. *)
val tl : 'a list -&gt; 'a list

(** Return the [n]-th element of the given list.
    The first element (head of the list) is at position 0.
    Return [None] if the list is too short.
    Raise [Invalid_argument &quot;List.nth&quot;] if [n] is negative.
    @since 4.05
*)
val nth_opt : 'a list -&gt; int -&gt; 'a option

(** List reversal. *)
val rev : 'a list -&gt; 'a list

(** [List.init len f] is [f 0; f 1; ...; f (len-1)], evaluated left to right.

    @raise Invalid_argument if len &lt; 0.
    @since 4.06.0
*)
val init : int -&gt; (int -&gt; 'a) -&gt; 'a list

(** Concatenate two lists.  Same as the infix operator [@].
    Not tail-recursive (length of the first argument).  *)
val append : 'a list -&gt; 'a list -&gt; 'a list

(** [List.rev_append l1 l2] reverses [l1] and concatenates it to [l2].
    This is equivalent to {!List.rev}[ l1 @ l2], but [rev_append] is
    tail-recursive and more efficient. *)
val rev_append : 'a list -&gt; 'a list -&gt; 'a list

(** Concatenate a list of lists.  The elements of the argument are all
    concatenated together (in the same order) to give the result.
    Not tail-recursive
    (length of the argument + length of the longest sub-list). *)
val concat : 'a list list -&gt; 'a list

(** An alias for [concat]. *)
val flatten : 'a list list -&gt; 'a list

(** {1 Iterators} *)

(** [List.iter f [a1; ...; an]] applies function [f] in turn to
    [a1; ...; an]. It is equivalent to
    [begin f a1; f a2; ...; f an; () end]. *)
val iter : ('a -&gt; unit) -&gt; 'a list -&gt; unit

(** Same as {!List.iter}, but the function is applied to the index of
    the element as first argument (counting from 0), and the element
    itself as second argument.
    @since 4.00.0
*)
val iteri : (int -&gt; 'a -&gt; unit) -&gt; 'a list -&gt; unit

(** [List.map f [a1; ...; an]] applies function [f] to [a1, ..., an],
    and builds the list [[f a1; ...; f an]]
    with the results returned by [f].  Not tail-recursive. *)
val map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list

(** Same as {!List.map}, but the function is applied to the index of
    the element as first argument (counting from 0), and the element
    itself as second argument.  Not tail-recursive.
    @since 4.00.0
*)
val mapi : (int -&gt; 'a -&gt; 'b) -&gt; 'a list -&gt; 'b list

(** [List.rev_map f l] gives the same result as
    {!List.rev}[ (]{!List.map}[ f l)], but is tail-recursive and
    more efficient. *)
val rev_map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list

(** [List.fold_left f a [b1; ...; bn]] is
    [f (... (f (f a b1) b2) ...) bn]. *)
val fold_left : ('a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b list -&gt; 'a

(** [List.fold_right f [a1; ...; an] b] is
    [f a1 (f a2 (... (f an b) ...))].  Not tail-recursive. *)
val fold_right : ('a -&gt; 'b -&gt; 'b) -&gt; 'a list -&gt; 'b -&gt; 'b

(** {1 Iterators on two lists} *)

(** [List.iter2 f [a1; ...; an] [b1; ...; bn]] calls in turn
    [f a1 b1; ...; f an bn].
    Raise [Invalid_argument] if the two lists are determined
    to have different lengths. *)
val iter2 : ('a -&gt; 'b -&gt; unit) -&gt; 'a list -&gt; 'b list -&gt; unit

(** [List.map2 f [a1; ...; an] [b1; ...; bn]] is
    [[f a1 b1; ...; f an bn]].
    Raise [Invalid_argument] if the two lists are determined
    to have different lengths.  Not tail-recursive. *)
val map2 : ('a -&gt; 'b -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; 'c list

(** [List.rev_map2 f l1 l2] gives the same result as
    {!List.rev}[ (]{!List.map2}[ f l1 l2)], but is tail-recursive and
    more efficient. *)
val rev_map2 : ('a -&gt; 'b -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; 'c list

(** [List.fold_left2 f a [b1; ...; bn] [c1; ...; cn]] is
    [f (... (f (f a b1 c1) b2 c2) ...) bn cn].
    Raise [Invalid_argument] if the two lists are determined
    to have different lengths. *)
val fold_left2 : ('a -&gt; 'b -&gt; 'c -&gt; 'a) -&gt; 'a -&gt; 'b list -&gt; 'c list -&gt; 'a

(** [List.fold_right2 f [a1; ...; an] [b1; ...; bn] c] is
    [f a1 b1 (f a2 b2 (... (f an bn c) ...))].
    Raise [Invalid_argument] if the two lists are determined
    to have different lengths.  Not tail-recursive. *)
val fold_right2 : ('a -&gt; 'b -&gt; 'c -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; 'c -&gt; 'c

(** {1 List scanning} *)

(** [for_all p [a1; ...; an]] checks if all elements of the list
    satisfy the predicate [p]. That is, it returns
    [(p a1) &amp;&amp; (p a2) &amp;&amp; ... &amp;&amp; (p an)]. *)
val for_all : ('a -&gt; bool) -&gt; 'a list -&gt; bool

(** [exists p [a1; ...; an]] checks if at least one element of
    the list satisfies the predicate [p]. That is, it returns
    [(p a1) || (p a2) || ... || (p an)]. *)
val exists : ('a -&gt; bool) -&gt; 'a list -&gt; bool

(** Same as {!List.for_all}, but for a two-argument predicate.
    Raise [Invalid_argument] if the two lists are determined
    to have different lengths. *)
val for_all2 : ('a -&gt; 'b -&gt; bool) -&gt; 'a list -&gt; 'b list -&gt; bool

(** Same as {!List.exists}, but for a two-argument predicate.
    Raise [Invalid_argument] if the two lists are determined
    to have different lengths. *)
val exists2 : ('a -&gt; 'b -&gt; bool) -&gt; 'a list -&gt; 'b list -&gt; bool

(** [mem a l] is true if and only if [a] is equal
    to an element of [l]. *)
val mem : 'a -&gt; 'a list -&gt; bool

(** Same as {!List.mem}, but uses physical equality instead of structural
    equality to compare list elements. *)
val memq : 'a -&gt; 'a list -&gt; bool

(** {1 List searching} *)

(** [find_opt p l] returns the first element of the list [l] that
    satisfies the predicate [p], or [None] if there is no value that
    satisfies [p] in the list [l].
    @since 4.05 *)
val find_opt : ('a -&gt; bool) -&gt; 'a list -&gt; 'a option

(** [filter p l] returns all the elements of the list [l]
    that satisfy the predicate [p].  The order of the elements
    in the input list is preserved.  *)
val filter : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list

(** [find_all] is another name for {!List.filter}. *)
val find_all : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list

(** [partition p l] returns a pair of lists [(l1, l2)], where
    [l1] is the list of all the elements of [l] that
    satisfy the predicate [p], and [l2] is the list of all the
    elements of [l] that do not satisfy [p].
    The order of the elements in the input list is preserved. *)
val partition : ('a -&gt; bool) -&gt; 'a list -&gt; 'a list * 'a list

(** {1 Association lists} *)

(** [assoc_opt a l] returns the value associated with key [a] in the list of
    pairs [l]. That is,
    [assoc_opt a [ ...; (a,b); ...] = b]
    if [(a,b)] is the leftmost binding of [a] in list [l].
    Returns [None] if there is no value associated with [a] in the
    list [l].
    @since 4.05 *)
val assoc_opt : 'a -&gt; ('a * 'b) list -&gt; 'b option

(** Same as {!List.assoc_opt}, but uses physical equality instead of structural
    equality to compare keys.
    @since 4.05 *)
val assq_opt : 'a -&gt; ('a * 'b) list -&gt; 'b option

(** Same as {!List.assoc}, but simply return true if a binding exists,
    and false if no bindings exist for the given key. *)
val mem_assoc : 'a -&gt; ('a * 'b) list -&gt; bool

(** Same as {!List.mem_assoc}, but uses physical equality instead of
    structural equality to compare keys. *)
val mem_assq : 'a -&gt; ('a * 'b) list -&gt; bool

(** [remove_assoc a l] returns the list of
    pairs [l] without the first pair with key [a], if any.
    Not tail-recursive. *)
val remove_assoc : 'a -&gt; ('a * 'b) list -&gt; ('a * 'b) list

(** Same as {!List.remove_assoc}, but uses physical equality instead
    of structural equality to compare keys.  Not tail-recursive. *)
val remove_assq : 'a -&gt; ('a * 'b) list -&gt; ('a * 'b) list

(** {1 Lists of pairs} *)

(** Transform a list of pairs into a pair of lists:
    [split [(a1,b1); ...; (an,bn)]] is [([a1; ...; an], [b1; ...; bn])].
    Not tail-recursive.
*)
val split : ('a * 'b) list -&gt; 'a list * 'b list

(** Transform a pair of lists into a list of pairs:
    [combine [a1; ...; an] [b1; ...; bn]] is
    [[(a1,b1); ...; (an,bn)]].
    Raise [Invalid_argument] if the two lists
    have different lengths.  Not tail-recursive. *)
val combine : 'a list -&gt; 'b list -&gt; ('a * 'b) list

(** {1 Sorting} *)

(** Sort a list in increasing order according to a comparison
    function.  The comparison function must return 0 if its arguments
    compare as equal, a positive integer if the first is greater,
    and a negative integer if the first is smaller (see Array.sort for
    a complete specification).  For example,
    {!Pervasives.compare} is a suitable comparison function.
    The resulting list is sorted in increasing order.
    [List.sort] is guaranteed to run in constant heap space
    (in addition to the size of the result list) and logarithmic
    stack space.

    The current implementation uses Merge Sort. It runs in constant
    heap space and logarithmic stack space.
*)
val sort : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list

(** Same as {!List.sort}, but the sorting algorithm is guaranteed to
    be stable (i.e. elements that compare equal are kept in their
    original order) .

    The current implementation uses Merge Sort. It runs in constant
    heap space and logarithmic stack space.
*)
val stable_sort : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list

(** Same as {!List.sort} or {!List.stable_sort}, whichever is faster
    on typical input. *)
val fast_sort : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list

(** Same as {!List.sort}, but also remove duplicates.
    @since 4.02.0 *)
val sort_uniq : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list

(** Merge two lists:
    Assuming that [l1] and [l2] are sorted according to the
    comparison function [cmp], [merge cmp l1 l2] will return a
    sorted list containing all the elements of [l1] and [l2].
    If several elements compare equal, the elements of [l1] will be
    before the elements of [l2].
    Not tail-recursive (sum of the lengths of the arguments).
*)
val merge : ('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list -&gt; 'a list
end
module String : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/string.mli&quot;
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* TEZOS CHANGES

   * Import version 4.06.1
   * Remove unsafe functions
   * Remove deprecated functions (enforcing string immutability)
   * Add binary data extraction functions

*)

(** String operations.

    A string is an immutable data structure that contains a
    fixed-length sequence of (single-byte) characters. Each character
    can be accessed in constant time through its index.

    Given a string [s] of length [l], we can access each of the [l]
    characters of [s] via its index in the sequence. Indexes start at
    [0], and we will call an index valid in [s] if it falls within the
    range [[0...l-1]] (inclusive). A position is the point between two
    characters or at the beginning or end of the string.  We call a
    position valid in [s] if it falls within the range [[0...l]]
    (inclusive). Note that the character at index [n] is between
    positions [n] and [n+1].

    Two parameters [start] and [len] are said to designate a valid
    substring of [s] if [len &gt;= 0] and [start] and [start+len] are
    valid positions in [s].

    OCaml strings used to be modifiable in place, for instance via the
    {!String.set} and {!String.blit} functions described below. This
    usage is deprecated and only possible when the compiler is put in
    &quot;unsafe-string&quot; mode by giving the [-unsafe-string] command-line
    option (which is currently the default for reasons of backward
    compatibility). This is done by making the types [string] and
    [bytes] (see module {!Bytes}) interchangeable so that functions
    expecting byte sequences can also accept strings as arguments and
    modify them.

    All new code should avoid this feature and be compiled with the
    [-safe-string] command-line option to enforce the separation between
    the types [string] and [bytes].

*)

(** Return the length (number of characters) of the given string. *)
external length : string -&gt; int = &quot;%string_length&quot;

(** [String.get s n] returns the character at index [n] in string [s].
    You can also write [s.[n]] instead of [String.get s n].

    Raise [Invalid_argument] if [n] not a valid index in [s]. *)
external get : string -&gt; int -&gt; char = &quot;%string_safe_get&quot;

(** [String.make n c] returns a fresh string of length [n],
    filled with the character [c].

    Raise [Invalid_argument] if [n &lt; 0] or [n &gt; ]{!Sys.max_string_length}. *)
val make : int -&gt; char -&gt; string

(** [String.init n f] returns a string of length [n], with character
    [i] initialized to the result of [f i] (called in increasing
    index order).

    Raise [Invalid_argument] if [n &lt; 0] or [n &gt; ]{!Sys.max_string_length}.

    @since 4.02.0
*)
val init : int -&gt; (int -&gt; char) -&gt; string

(** [String.sub s start len] returns a fresh string of length [len],
    containing the substring of [s] that starts at position [start] and
    has length [len].

    Raise [Invalid_argument] if [start] and [len] do not
    designate a valid substring of [s]. *)
val sub : string -&gt; int -&gt; int -&gt; string

(** Same as {!Bytes.blit_string}. *)
val blit : string -&gt; int -&gt; bytes -&gt; int -&gt; int -&gt; unit

(** [String.concat sep sl] concatenates the list of strings [sl],
    inserting the separator string [sep] between each.

    Raise [Invalid_argument] if the result is longer than
    {!Sys.max_string_length} bytes. *)
val concat : string -&gt; string list -&gt; string

(** [String.iter f s] applies function [f] in turn to all
    the characters of [s].  It is equivalent to
    [f s.[0]; f s.[1]; ...; f s.[String.length s - 1]; ()]. *)
val iter : (char -&gt; unit) -&gt; string -&gt; unit

(** Same as {!String.iter}, but the
    function is applied to the index of the element as first argument
    (counting from 0), and the character itself as second argument.
    @since 4.00.0 *)
val iteri : (int -&gt; char -&gt; unit) -&gt; string -&gt; unit

(** [String.map f s] applies function [f] in turn to all the
    characters of [s] (in increasing index order) and stores the
    results in a new string that is returned.
    @since 4.00.0 *)
val map : (char -&gt; char) -&gt; string -&gt; string

(** [String.mapi f s] calls [f] with each character of [s] and its
    index (in increasing index order) and stores the results in a new
    string that is returned.
    @since 4.02.0 *)
val mapi : (int -&gt; char -&gt; char) -&gt; string -&gt; string

(** Return a copy of the argument, without leading and trailing
    whitespace.  The characters regarded as whitespace are: [' '],
    ['\012'], ['\n'], ['\r'], and ['\t'].  If there is neither leading nor
    trailing whitespace character in the argument, return the original
    string itself, not a copy.
    @since 4.00.0 *)
val trim : string -&gt; string

(** Return a copy of the argument, with special characters
    represented by escape sequences, following the lexical
    conventions of OCaml.
    All characters outside the ASCII printable range (32..126) are
    escaped, as well as backslash and double-quote.

    If there is no special character in the argument that needs
    escaping, return the original string itself, not a copy.

    Raise [Invalid_argument] if the result is longer than
    {!Sys.max_string_length} bytes.

    The function {!Scanf.unescaped} is a left inverse of [escaped],
    i.e. [Scanf.unescaped (escaped s) = s] for any string [s] (unless
    [escape s] fails). *)
val escaped : string -&gt; string

(** [String.index_opt s c] returns the index of the first
    occurrence of character [c] in string [s], or
    [None] if [c] does not occur in [s].
    @since 4.05 *)
val index_opt : string -&gt; char -&gt; int option

(** [String.rindex_opt s c] returns the index of the last occurrence
    of character [c] in string [s], or [None] if [c] does not occur in
    [s].
    @since 4.05 *)
val rindex_opt : string -&gt; char -&gt; int option

(** [String.index_from_opt s i c] returns the index of the
    first occurrence of character [c] in string [s] after position [i]
    or [None] if [c] does not occur in [s] after position [i].

    [String.index_opt s c] is equivalent to [String.index_from_opt s 0 c].
    Raise [Invalid_argument] if [i] is not a valid position in [s].

    @since 4.05
*)
val index_from_opt : string -&gt; int -&gt; char -&gt; int option

(** [String.rindex_from_opt s i c] returns the index of the
    last occurrence of character [c] in string [s] before position [i+1]
    or [None] if [c] does not occur in [s] before position [i+1].

    [String.rindex_opt s c] is equivalent to
    [String.rindex_from_opt s (String.length s - 1) c].

    Raise [Invalid_argument] if [i+1] is not a valid position in [s].

    @since 4.05
*)
val rindex_from_opt : string -&gt; int -&gt; char -&gt; int option

(** [String.contains s c] tests if character [c]
    appears in the string [s]. *)
val contains : string -&gt; char -&gt; bool

(** [String.contains_from s start c] tests if character [c]
    appears in [s] after position [start].
    [String.contains s c] is equivalent to
    [String.contains_from s 0 c].

    Raise [Invalid_argument] if [start] is not a valid position in [s]. *)
val contains_from : string -&gt; int -&gt; char -&gt; bool

(** [String.rcontains_from s stop c] tests if character [c]
    appears in [s] before position [stop+1].

    Raise [Invalid_argument] if [stop &lt; 0] or [stop+1] is not a valid
    position in [s]. *)
val rcontains_from : string -&gt; int -&gt; char -&gt; bool

(** Return a copy of the argument, with all lowercase letters
    translated to uppercase, using the US-ASCII character set.
    @since 4.03.0 *)
val uppercase_ascii : string -&gt; string

(** Return a copy of the argument, with all uppercase letters
    translated to lowercase, using the US-ASCII character set.
    @since 4.03.0 *)
val lowercase_ascii : string -&gt; string

(** Return a copy of the argument, with the first character set to uppercase,
    using the US-ASCII character set.
    @since 4.03.0 *)
val capitalize_ascii : string -&gt; string

(** Return a copy of the argument, with the first character set to lowercase,
    using the US-ASCII character set.
    @since 4.03.0 *)
val uncapitalize_ascii : string -&gt; string

(** An alias for the type of strings. *)
type t = string

(** The comparison function for strings, with the same specification as
    {!Pervasives.compare}.  Along with the type [t], this function [compare]
    allows the module [String] to be passed as argument to the functors
    {!Set.Make} and {!Map.Make}. *)
val compare : t -&gt; t -&gt; int

(** The equal function for strings.
    @since 4.03.0 *)
val equal : t -&gt; t -&gt; bool

(** [String.split_on_char sep s] returns the list of all (possibly empty)
    substrings of [s] that are delimited by the [sep] character.

    The function's output is specified by the following invariants:

    - The list is not empty.
    - Concatenating its elements using [sep] as a separator returns a
      string equal to the input ([String.concat (String.make 1 sep)
      (String.split_on_char sep s) = s]).
    - No string in the result contains the [sep] character.

    @since 4.04.0
*)
val split_on_char : char -&gt; string -&gt; string list

(** Functions reading bytes  *)

(** [get_char buff i] reads 1 byte at offset i as a char *)
val get_char : t -&gt; int -&gt; char

(** [get_uint8 buff i] reads 1 byte at offset i as an unsigned int of 8
    bits. i.e. It returns a value between 0 and 2^8-1 *)
val get_uint8 : t -&gt; int -&gt; int

(** [get_int8 buff i] reads 1 byte at offset i as a signed int of 8
    bits. i.e. It returns a value between -2^7 and 2^7-1 *)
val get_int8 : t -&gt; int -&gt; int

(** Functions reading according to Big Endian byte order *)

(** [get_uint16 buff i] reads 2 bytes at offset i as an unsigned int
      of 16 bits. i.e. It returns a value between 0 and 2^16-1 *)
val get_uint16 : t -&gt; int -&gt; int

(** [get_int16 buff i] reads 2 byte at offset i as a signed int of
      16 bits. i.e. It returns a value between -2^15 and 2^15-1 *)
val get_int16 : t -&gt; int -&gt; int

(** [get_int32 buff i] reads 4 bytes at offset i as an int32. *)
val get_int32 : t -&gt; int -&gt; int32

(** [get_int64 buff i] reads 8 bytes at offset i as an int64. *)
val get_int64 : t -&gt; int -&gt; int64

module LE : sig
  (** Functions reading according to Little Endian byte order *)

  (** [get_uint16 buff i] reads 2 bytes at offset i as an unsigned int
      of 16 bits. i.e. It returns a value between 0 and 2^16-1 *)
  val get_uint16 : t -&gt; int -&gt; int

  (** [get_int16 buff i] reads 2 byte at offset i as a signed int of
      16 bits. i.e. It returns a value between -2^15 and 2^15-1 *)
  val get_int16 : t -&gt; int -&gt; int

  (** [get_int32 buff i] reads 4 bytes at offset i as an int32. *)
  val get_int32 : t -&gt; int -&gt; int32

  (** [get_int64 buff i] reads 8 bytes at offset i as an int64. *)
  val get_int64 : t -&gt; int -&gt; int64
end
end
module Int32 : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/int32.mli&quot;
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* TEZOS CHANGES

   * Import version 4.06.1
   * Remove deprecated functions

*)

(** 32-bit integers.

    This module provides operations on the type [int32]
    of signed 32-bit integers.  Unlike the built-in [int] type,
    the type [int32] is guaranteed to be exactly 32-bit wide on all
    platforms.  All arithmetic operations over [int32] are taken
    modulo 2{^32}.

    Performance notice: values of type [int32] occupy more memory
    space than values of type [int], and arithmetic operations on
    [int32] are generally slower than those on [int].  Use [int32]
    only when the application requires exact 32-bit arithmetic. *)

(** The 32-bit integer 0. *)
val zero : int32

(** The 32-bit integer 1. *)
val one : int32

(** The 32-bit integer -1. *)
val minus_one : int32

(** Unary negation. *)
external neg : int32 -&gt; int32 = &quot;%int32_neg&quot;

(** Addition. *)
external add : int32 -&gt; int32 -&gt; int32 = &quot;%int32_add&quot;

(** Subtraction. *)
external sub : int32 -&gt; int32 -&gt; int32 = &quot;%int32_sub&quot;

(** Multiplication. *)
external mul : int32 -&gt; int32 -&gt; int32 = &quot;%int32_mul&quot;

(** Integer division.  Raise [Division_by_zero] if the second
    argument is zero.  This division rounds the real quotient of
    its arguments towards zero, as specified for {!Pervasives.(/)}. *)
external div : int32 -&gt; int32 -&gt; int32 = &quot;%int32_div&quot;

(** Integer remainder.  If [y] is not zero, the result
    of [Int32.rem x y] satisfies the following property:
    [x = Int32.add (Int32.mul (Int32.div x y) y) (Int32.rem x y)].
    If [y = 0], [Int32.rem x y] raises [Division_by_zero]. *)
external rem : int32 -&gt; int32 -&gt; int32 = &quot;%int32_mod&quot;

(** Successor.  [Int32.succ x] is [Int32.add x Int32.one]. *)
val succ : int32 -&gt; int32

(** Predecessor.  [Int32.pred x] is [Int32.sub x Int32.one]. *)
val pred : int32 -&gt; int32

(** Return the absolute value of its argument. *)
val abs : int32 -&gt; int32

(** The greatest representable 32-bit integer, 2{^31} - 1. *)
val max_int : int32

(** The smallest representable 32-bit integer, -2{^31}. *)
val min_int : int32

(** Bitwise logical and. *)
external logand : int32 -&gt; int32 -&gt; int32 = &quot;%int32_and&quot;

(** Bitwise logical or. *)
external logor : int32 -&gt; int32 -&gt; int32 = &quot;%int32_or&quot;

(** Bitwise logical exclusive or. *)
external logxor : int32 -&gt; int32 -&gt; int32 = &quot;%int32_xor&quot;

(** Bitwise logical negation. *)
val lognot : int32 -&gt; int32

(** [Int32.shift_left x y] shifts [x] to the left by [y] bits.
    The result is unspecified if [y &lt; 0] or [y &gt;= 32]. *)
external shift_left : int32 -&gt; int -&gt; int32 = &quot;%int32_lsl&quot;

(** [Int32.shift_right x y] shifts [x] to the right by [y] bits.
    This is an arithmetic shift: the sign bit of [x] is replicated
    and inserted in the vacated bits.
    The result is unspecified if [y &lt; 0] or [y &gt;= 32]. *)
external shift_right : int32 -&gt; int -&gt; int32 = &quot;%int32_asr&quot;

(** [Int32.shift_right_logical x y] shifts [x] to the right by [y] bits.
    This is a logical shift: zeroes are inserted in the vacated bits
    regardless of the sign of [x].
    The result is unspecified if [y &lt; 0] or [y &gt;= 32]. *)
external shift_right_logical : int32 -&gt; int -&gt; int32 = &quot;%int32_lsr&quot;

(** Convert the given integer (type [int]) to a 32-bit integer
    (type [int32]). *)
external of_int : int -&gt; int32 = &quot;%int32_of_int&quot;

(** Convert the given 32-bit integer (type [int32]) to an
    integer (type [int]).  On 32-bit platforms, the 32-bit integer
    is taken modulo 2{^31}, i.e. the high-order bit is lost
    during the conversion.  On 64-bit platforms, the conversion
    is exact. *)
external to_int : int32 -&gt; int = &quot;%int32_to_int&quot;

(** Convert the given floating-point number to a 32-bit integer,
    discarding the fractional part (truncate towards 0).
    The result of the conversion is undefined if, after truncation,
    the number is outside the range \[{!Int32.min_int}, {!Int32.max_int}\]. *)
external of_float : float -&gt; int32
  = &quot;caml_int32_of_float&quot; &quot;caml_int32_of_float_unboxed&quot;
  [@@unboxed] [@@noalloc]

(** Convert the given 32-bit integer to a floating-point number. *)
external to_float : int32 -&gt; float
  = &quot;caml_int32_to_float&quot; &quot;caml_int32_to_float_unboxed&quot;
  [@@unboxed] [@@noalloc]

(** Convert the given string to a 32-bit integer.
    The string is read in decimal (by default, or if the string
    begins with [0u]) or in hexadecimal, octal or binary if the
    string begins with [0x], [0o] or [0b] respectively.

    The [0u] prefix reads the input as an unsigned integer in the range
    [[0, 2*Int32.max_int+1]].  If the input exceeds {!Int32.max_int}
    it is converted to the signed integer
    [Int32.min_int + input - Int32.max_int - 1].

    The [_] (underscore) character can appear anywhere in the string
    and is ignored.
    Raise [Failure &quot;Int32.of_string&quot;] if the given string is not
    a valid representation of an integer, or if the integer represented
    exceeds the range of integers representable in type [int32]. *)
external of_string : string -&gt; int32 = &quot;caml_int32_of_string&quot;

(** Same as [of_string], but return [None] instead of raising.
    @since 4.05 *)
val of_string_opt : string -&gt; int32 option

(** Return the string representation of its argument, in signed decimal. *)
val to_string : int32 -&gt; string

(** Return the internal representation of the given float according
    to the IEEE 754 floating-point 'single format' bit layout.
    Bit 31 of the result represents the sign of the float;
    bits 30 to 23 represent the (biased) exponent; bits 22 to 0
    represent the mantissa. *)
external bits_of_float : float -&gt; int32
  = &quot;caml_int32_bits_of_float&quot; &quot;caml_int32_bits_of_float_unboxed&quot;
  [@@unboxed] [@@noalloc]

(** Return the floating-point number whose internal representation,
    according to the IEEE 754 floating-point 'single format' bit layout,
    is the given [int32]. *)
external float_of_bits : int32 -&gt; float
  = &quot;caml_int32_float_of_bits&quot; &quot;caml_int32_float_of_bits_unboxed&quot;
  [@@unboxed] [@@noalloc]

(** An alias for the type of 32-bit integers. *)
type t = int32

(** The comparison function for 32-bit integers, with the same specification as
    {!Pervasives.compare}.  Along with the type [t], this function [compare]
    allows the module [Int32] to be passed as argument to the functors
    {!Set.Make} and {!Map.Make}. *)
val compare : t -&gt; t -&gt; int

(** The equal function for int32s.
    @since 4.03.0 *)
val equal : t -&gt; t -&gt; bool
end
module Int64 : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/int64.mli&quot;
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* TEZOS CHANGES

   * Import version 4.06.1
   * Remove deprecated functions

*)
(** 64-bit integers.

    This module provides operations on the type [int64] of
    signed 64-bit integers.  Unlike the built-in [int] type,
    the type [int64] is guaranteed to be exactly 64-bit wide on all
    platforms.  All arithmetic operations over [int64] are taken
    modulo 2{^64}

    Performance notice: values of type [int64] occupy more memory
    space than values of type [int], and arithmetic operations on
    [int64] are generally slower than those on [int].  Use [int64]
    only when the application requires exact 64-bit arithmetic.
*)

(** The 64-bit integer 0. *)
val zero : int64

(** The 64-bit integer 1. *)
val one : int64

(** The 64-bit integer -1. *)
val minus_one : int64

(** Unary negation. *)
external neg : int64 -&gt; int64 = &quot;%int64_neg&quot;

(** Addition. *)
external add : int64 -&gt; int64 -&gt; int64 = &quot;%int64_add&quot;

(** Subtraction. *)
external sub : int64 -&gt; int64 -&gt; int64 = &quot;%int64_sub&quot;

(** Multiplication. *)
external mul : int64 -&gt; int64 -&gt; int64 = &quot;%int64_mul&quot;

(** Integer division.  Raise [Division_by_zero] if the second
    argument is zero.  This division rounds the real quotient of
    its arguments towards zero, as specified for {!Pervasives.(/)}. *)
external div : int64 -&gt; int64 -&gt; int64 = &quot;%int64_div&quot;

(** Integer remainder.  If [y] is not zero, the result
    of [Int64.rem x y] satisfies the following property:
    [x = Int64.add (Int64.mul (Int64.div x y) y) (Int64.rem x y)].
    If [y = 0], [Int64.rem x y] raises [Division_by_zero]. *)
external rem : int64 -&gt; int64 -&gt; int64 = &quot;%int64_mod&quot;

(** Successor.  [Int64.succ x] is [Int64.add x Int64.one]. *)
val succ : int64 -&gt; int64

(** Predecessor.  [Int64.pred x] is [Int64.sub x Int64.one]. *)
val pred : int64 -&gt; int64

(** Return the absolute value of its argument. *)
val abs : int64 -&gt; int64

(** The greatest representable 64-bit integer, 2{^63} - 1. *)
val max_int : int64

(** The smallest representable 64-bit integer, -2{^63}. *)
val min_int : int64

(** Bitwise logical and. *)
external logand : int64 -&gt; int64 -&gt; int64 = &quot;%int64_and&quot;

(** Bitwise logical or. *)
external logor : int64 -&gt; int64 -&gt; int64 = &quot;%int64_or&quot;

(** Bitwise logical exclusive or. *)
external logxor : int64 -&gt; int64 -&gt; int64 = &quot;%int64_xor&quot;

(** Bitwise logical negation. *)
val lognot : int64 -&gt; int64

(** [Int64.shift_left x y] shifts [x] to the left by [y] bits.
    The result is unspecified if [y &lt; 0] or [y &gt;= 64]. *)
external shift_left : int64 -&gt; int -&gt; int64 = &quot;%int64_lsl&quot;

(** [Int64.shift_right x y] shifts [x] to the right by [y] bits.
    This is an arithmetic shift: the sign bit of [x] is replicated
    and inserted in the vacated bits.
    The result is unspecified if [y &lt; 0] or [y &gt;= 64]. *)
external shift_right : int64 -&gt; int -&gt; int64 = &quot;%int64_asr&quot;

(** [Int64.shift_right_logical x y] shifts [x] to the right by [y] bits.
    This is a logical shift: zeroes are inserted in the vacated bits
    regardless of the sign of [x].
    The result is unspecified if [y &lt; 0] or [y &gt;= 64]. *)
external shift_right_logical : int64 -&gt; int -&gt; int64 = &quot;%int64_lsr&quot;

(** Convert the given integer (type [int]) to a 64-bit integer
    (type [int64]). *)
external of_int : int -&gt; int64 = &quot;%int64_of_int&quot;

(** Convert the given 64-bit integer (type [int64]) to an
    integer (type [int]).  On 64-bit platforms, the 64-bit integer
    is taken modulo 2{^63}, i.e. the high-order bit is lost
    during the conversion.  On 32-bit platforms, the 64-bit integer
    is taken modulo 2{^31}, i.e. the top 33 bits are lost
    during the conversion. *)
external to_int : int64 -&gt; int = &quot;%int64_to_int&quot;

(** Convert the given floating-point number to a 64-bit integer,
    discarding the fractional part (truncate towards 0).
    The result of the conversion is undefined if, after truncation,
    the number is outside the range \[{!Int64.min_int}, {!Int64.max_int}\]. *)
external of_float : float -&gt; int64
  = &quot;caml_int64_of_float&quot; &quot;caml_int64_of_float_unboxed&quot;
  [@@unboxed] [@@noalloc]

(** Convert the given 64-bit integer to a floating-point number. *)
external to_float : int64 -&gt; float
  = &quot;caml_int64_to_float&quot; &quot;caml_int64_to_float_unboxed&quot;
  [@@unboxed] [@@noalloc]

(** Convert the given 32-bit integer (type [int32])
    to a 64-bit integer (type [int64]). *)
external of_int32 : int32 -&gt; int64 = &quot;%int64_of_int32&quot;

(** Convert the given 64-bit integer (type [int64]) to a
    32-bit integer (type [int32]). The 64-bit integer
    is taken modulo 2{^32}, i.e. the top 32 bits are lost
    during the conversion.  *)
external to_int32 : int64 -&gt; int32 = &quot;%int64_to_int32&quot;

(** Convert the given native integer (type [nativeint])
    to a 64-bit integer (type [int64]). *)
external of_nativeint : nativeint -&gt; int64 = &quot;%int64_of_nativeint&quot;

(** Convert the given 64-bit integer (type [int64]) to a
    native integer.  On 32-bit platforms, the 64-bit integer
    is taken modulo 2{^32}.  On 64-bit platforms,
    the conversion is exact. *)
external to_nativeint : int64 -&gt; nativeint = &quot;%int64_to_nativeint&quot;

(** Convert the given string to a 64-bit integer.
    The string is read in decimal (by default, or if the string
    begins with [0u]) or in hexadecimal, octal or binary if the
    string begins with [0x], [0o] or [0b] respectively.

    The [0u] prefix reads the input as an unsigned integer in the range
    [[0, 2*Int64.max_int+1]].  If the input exceeds {!Int64.max_int}
    it is converted to the signed integer
    [Int64.min_int + input - Int64.max_int - 1].

    The [_] (underscore) character can appear anywhere in the string
    and is ignored.
    Raise [Failure &quot;Int64.of_string&quot;] if the given string is not
    a valid representation of an integer, or if the integer represented
    exceeds the range of integers representable in type [int64]. *)
external of_string : string -&gt; int64 = &quot;caml_int64_of_string&quot;

(** Same as [of_string], but return [None] instead of raising.
    @since 4.05 *)
val of_string_opt : string -&gt; int64 option

(** Return the string representation of its argument, in decimal. *)
val to_string : int64 -&gt; string

(** Return the internal representation of the given float according
    to the IEEE 754 floating-point 'double format' bit layout.
    Bit 63 of the result represents the sign of the float;
    bits 62 to 52 represent the (biased) exponent; bits 51 to 0
    represent the mantissa. *)
external bits_of_float : float -&gt; int64
  = &quot;caml_int64_bits_of_float&quot; &quot;caml_int64_bits_of_float_unboxed&quot;
  [@@unboxed] [@@noalloc]

(** Return the floating-point number whose internal representation,
    according to the IEEE 754 floating-point 'double format' bit layout,
    is the given [int64]. *)
external float_of_bits : int64 -&gt; float
  = &quot;caml_int64_float_of_bits&quot; &quot;caml_int64_float_of_bits_unboxed&quot;
  [@@unboxed] [@@noalloc]

(** An alias for the type of 64-bit integers. *)
type t = int64

(** The comparison function for 64-bit integers, with the same specification as
    {!Pervasives.compare}.  Along with the type [t], this function [compare]
    allows the module [Int64] to be passed as argument to the functors
    {!Set.Make} and {!Map.Make}. *)
val compare : t -&gt; t -&gt; int

(** The equal function for int64s.
    @since 4.03.0 *)
val equal : t -&gt; t -&gt; bool
end
module Format : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/format.mli&quot;
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Pierre Weis, projet Cristal, INRIA Rocquencourt            *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* TEZOS CHANGES

   * Import version 4.06.1
   * Remove channel functions
   * Remove toplevel effect based functions
   * Remove deprecated functions
   * Remove redirecting the standard formatter output
   * Remove redefining formatter output and output functions
   * Remove redefining semantic tag operations (too complex and
     imperative for the need of error message generation)
   * Remove defining formatters and symbolic pretty printing
*)

(** Pretty-printing.

    This module implements a pretty-printing facility to format values
    within {{!boxes}'pretty-printing boxes'} and {{!tags}'semantic tags'}
    combined with a set of {{!fpp}printf-like functions}.
    The pretty-printer splits lines at specified {{!breaks}break hints},
    and indents lines according to the box structure.
    Similarly, {{!tags}semantic tags} can be used to decouple text
    presentation from its contents.

    This pretty-printing facility is implemented as an overlay on top of
    abstract {{!section:formatter}formatters} which provide basic output
    functions.
    Some formatters are predefined, notably:
    - {!std_formatter} outputs to {{!Pervasives.stdout}stdout}
    - {!err_formatter} outputs to {{!Pervasives.stderr}stderr}

    Most functions in the {!Format} module come in two variants:
    a short version that operates on {!std_formatter} and the
    generic version prefixed by [pp_] that takes a formatter
    as its first argument.

    More formatters can be created with {!formatter_of_out_channel},
    {!formatter_of_buffer}, {!formatter_of_symbolic_output_buffer}
    or using {{!section:formatter}custom formatters}.

*)

(** {1 Introduction}
    For a gentle introduction to the basics of pretty-printing using
    [Format], read
    {{:http://caml.inria.fr/resources/doc/guides/format.en.html}
    http://caml.inria.fr/resources/doc/guides/format.en.html}.

    You may consider this module as providing an extension to the
    [printf] facility to provide automatic line splitting. The addition of
    pretty-printing annotations to your regular [printf] format strings gives
    you fancy indentation and line breaks.
    Pretty-printing annotations are described below in the documentation of
    the function {!Format.fprintf}.

    You may also use the explicit pretty-printing box management and printing
    functions provided by this module. This style is more basic but more
    verbose than the concise [fprintf] format strings.

    For instance, the sequence
    [open_box 0; print_string &quot;x =&quot;; print_space ();
    print_int 1; close_box (); print_newline ()]
    that prints [x = 1] within a pretty-printing box, can be
    abbreviated as [printf &quot;@[%s@ %i@]@.&quot; &quot;x =&quot; 1], or even shorter
    [printf &quot;@[x =@ %i@]@.&quot; 1].

    Rule of thumb for casual users of this library:
    - use simple pretty-printing boxes (as obtained by [open_box 0]);
    - use simple break hints as obtained by [print_cut ()] that outputs a
    simple break hint, or by [print_space ()] that outputs a space
    indicating a break hint;
    - once a pretty-printing box is open, display its material with basic
    printing functions (e. g. [print_int] and [print_string]);
    - when the material for a pretty-printing box has been printed, call
    [close_box ()] to close the box;
    - at the end of pretty-printing, flush the pretty-printer to display all
    the remaining material, e.g. evaluate [print_newline ()].

    The behavior of pretty-printing commands is unspecified
    if there is no open pretty-printing box. Each box opened by
    one of the [open_] functions below must be closed using [close_box]
    for proper formatting. Otherwise, some of the material printed in the
    boxes may not be output, or may be formatted incorrectly.

    In case of interactive use, each phrase is executed in the initial state
    of the standard pretty-printer: after each phrase execution, the
    interactive system closes all open pretty-printing boxes, flushes all
    pending text, and resets the standard pretty-printer.

    Warning: mixing calls to pretty-printing functions of this module with
    calls to {!Pervasives} low level output functions is error prone.

    The pretty-printing functions output material that is delayed in the
    pretty-printer queue and stacks in order to compute proper line
    splitting. In contrast, basic I/O output functions write directly in
    their output device. As a consequence, the output of a basic I/O function
    may appear before the output of a pretty-printing function that has been
    called before. For instance,
    [
    Pervasives.print_string &quot;&lt;&quot;;
    Format.print_string &quot;PRETTY&quot;;
    Pervasives.print_string &quot;&gt;&quot;;
    Format.print_string &quot;TEXT&quot;;
    ]
    leads to output [&lt;&gt;PRETTYTEXT].

*)

(** Abstract data corresponding to a pretty-printer (also called a
    formatter) and all its machinery. See also {!section:formatter}. *)
type formatter

(** {1:boxes Pretty-printing boxes} *)

(** The pretty-printing engine uses the concepts of pretty-printing box and
    break hint to drive indentation and line splitting behavior of the
    pretty-printer.

    Each different pretty-printing box kind introduces a specific line splitting
    policy:

    - within an {e horizontal} box, break hints never split the line (but the
    line may be split in a box nested deeper),
    - within a {e vertical} box, break hints always split the line,
    - within an {e horizontal/vertical} box, if the box fits on the current line
    then break hints never split the line, otherwise break hint always split
    the line,
    - within a {e compacting} box, a break hint never splits the line,
    unless there is no more room on the current line.

    Note that line splitting policy is box specific: the policy of a box does
    not rule the policy of inner boxes. For instance, if a vertical box is
    nested in an horizontal box, all break hints within the vertical box will
    split the line.
*)

(** [pp_open_box ppf d] opens a new compacting pretty-printing box with
    offset [d] in the formatter [ppf].

    Within this box, the pretty-printer prints as much as possible material on
    every line.

    A break hint splits the line if there is no more room on the line to
    print the remainder of the box.

    Within this box, the pretty-printer emphasizes the box structure: a break
    hint also splits the line if the splitting ``moves to the left''
    (i.e. the new line gets an indentation smaller than the one of the current
    line).

    This box is the general purpose pretty-printing box.

    If the pretty-printer splits the line in the box, offset [d] is added to
    the current indentation.
*)
val pp_open_box : formatter -&gt; int -&gt; unit

(** Closes the most recently open pretty-printing box. *)
val pp_close_box : formatter -&gt; unit -&gt; unit

(** [pp_open_hbox ppf ()] opens a new 'horizontal' pretty-printing box.

    This box prints material on a single line.

    Break hints in a horizontal box never split the line.
    (Line splitting may still occur inside boxes nested deeper).
*)
val pp_open_hbox : formatter -&gt; unit -&gt; unit

(** [pp_open_vbox ppf d] opens a new 'vertical' pretty-printing box
    with offset [d].

    This box prints material on as many lines as break hints in the box.

    Every break hint in a vertical box splits the line.

    If the pretty-printer splits the line in the box, [d] is added to the
    current indentation.
*)
val pp_open_vbox : formatter -&gt; int -&gt; unit

(** [pp_open_hvbox ppf d] opens a new 'horizontal/vertical' pretty-printing box
    with offset [d].

    This box behaves as an horizontal box if it fits on a single line,
    otherwise it behaves as a vertical box.

    If the pretty-printer splits the line in the box, [d] is added to the
    current indentation.
*)
val pp_open_hvbox : formatter -&gt; int -&gt; unit

(** [pp_open_hovbox ppf d] opens a new 'horizontal-or-vertical'
    pretty-printing box with offset [d].

    This box prints material as much as possible on every line.

    A break hint splits the line if there is no more room on the line to
    print the remainder of the box.

    If the pretty-printer splits the line in the box, [d] is added to the
    current indentation.
*)
val pp_open_hovbox : formatter -&gt; int -&gt; unit

(** {1 Formatting functions} *)

(** [pp_print_string ppf s] prints [s] in the current pretty-printing box. *)
val pp_print_string : formatter -&gt; string -&gt; unit

(** [pp_print_as ppf len s] prints [s] in the current pretty-printing box.
    The pretty-printer formats [s] as if it were of length [len].
*)
val pp_print_as : formatter -&gt; int -&gt; string -&gt; unit

(** Print an integer in the current pretty-printing box. *)
val pp_print_int : formatter -&gt; int -&gt; unit

(** Print a floating point number in the current pretty-printing box. *)
val pp_print_float : formatter -&gt; float -&gt; unit

(** Print a character in the current pretty-printing box. *)
val pp_print_char : formatter -&gt; char -&gt; unit

(** Print a boolean in the current pretty-printing box. *)
val pp_print_bool : formatter -&gt; bool -&gt; unit

(** {1:breaks Break hints} *)

(** A 'break hint' tells the pretty-printer to output some space or split the
    line whichever way is more appropriate to the current pretty-printing box
    splitting rules.

    Break hints are used to separate printing items and are mandatory to let
    the pretty-printer correctly split lines and indent items.

    Simple break hints are:
    - the 'space': output a space or split the line if appropriate,
    - the 'cut': split the line if appropriate.

    Note: the notions of space and line splitting are abstract for the
    pretty-printing engine, since those notions can be completely redefined
    by the programmer.
    However, in the pretty-printer default setting, ``output a space'' simply
    means printing a space character (ASCII code 32) and ``split the line''
    means printing a newline character (ASCII code 10).
*)

(** [pp_print_space ppf ()] emits a 'space' break hint:
    the pretty-printer may split the line at this point,
    otherwise it prints one space.

    [pp_print_space ppf ()] is equivalent to [pp_print_break ppf 1 0].
*)
val pp_print_space : formatter -&gt; unit -&gt; unit

(** [pp_print_cut ppf ()] emits a 'cut' break hint:
    the pretty-printer may split the line at this point,
    otherwise it prints nothing.

    [pp_print_cut ppf ()] is equivalent to [pp_print_break ppf 0 0].
*)
val pp_print_cut : formatter -&gt; unit -&gt; unit

(** [pp_print_break ppf nspaces offset] emits a 'full' break hint:
    the pretty-printer may split the line at this point,
    otherwise it prints [nspaces] spaces.

    If the pretty-printer splits the line, [offset] is added to
    the current indentation.
*)
val pp_print_break : formatter -&gt; int -&gt; int -&gt; unit

(** Force a new line in the current pretty-printing box.

    The pretty-printer must split the line at this point,

    Not the normal way of pretty-printing, since imperative line splitting may
    interfere with current line counters and box size calculation.
    Using break hints within an enclosing vertical box is a better
    alternative.
*)
val pp_force_newline : formatter -&gt; unit -&gt; unit

(** Execute the next formatting command if the preceding line
    has just been split. Otherwise, ignore the next formatting
    command.
*)
val pp_print_if_newline : formatter -&gt; unit -&gt; unit

(** {1 Pretty-printing termination} *)

(** End of pretty-printing: resets the pretty-printer to initial state.

    All open pretty-printing boxes are closed, all pending text is printed.
    In addition, the pretty-printer low level output device is flushed to
    ensure that all pending text is really displayed.

    Note: never use [print_flush] in the normal course of a pretty-printing
    routine, since the pretty-printer uses a complex buffering machinery to
    properly indent the output; manually flushing those buffers at random
    would conflict with the pretty-printer strategy and result to poor
    rendering.

    Only consider using [print_flush] when displaying all pending material is
    mandatory (for instance in case of interactive use when you want the user
    to read some text) and when resetting the pretty-printer state will not
    disturb further pretty-printing.

    Warning: If the output device of the pretty-printer is an output channel,
    repeated calls to [print_flush] means repeated calls to {!Pervasives.flush}
    to flush the out channel; these explicit flush calls could foil the
    buffering strategy of output channels and could dramatically impact
    efficiency.
*)
val pp_print_flush : formatter -&gt; unit -&gt; unit

(** End of pretty-printing: resets the pretty-printer to initial state.

    All open pretty-printing boxes are closed, all pending text is printed.

    Equivalent to {!print_flush} followed by a new line.
    See corresponding words of caution for {!print_flush}.

    Note: this is not the normal way to output a new line;
    the preferred method is using break hints within a vertical pretty-printing
    box.
*)
val pp_print_newline : formatter -&gt; unit -&gt; unit

(** {1 Margin} *)

(** [pp_set_margin ppf d] sets the right margin to [d] (in characters):
    the pretty-printer splits lines that overflow the right margin according to
    the break hints given.
    Nothing happens if [d] is smaller than 2.
    If [d] is too large, the right margin is set to the maximum
    admissible value (which is greater than [10 ^ 9]).
    If [d] is less than the current maximum indentation limit, the
    maximum indentation limit is decreased while trying to preserve
    a minimal ratio [max_indent/margin&gt;=50%] and if possible
    the current difference [margin - max_indent].
*)
val pp_set_margin : formatter -&gt; int -&gt; unit

(** Returns the position of the right margin. *)
val pp_get_margin : formatter -&gt; unit -&gt; int

(** {1 Maximum indentation limit} *)

(** [pp_set_max_indent ppf d] sets the maximum indentation limit of lines
    to [d] (in characters):
    once this limit is reached, new pretty-printing boxes are rejected to the
    left, if they do not fit on the current line.

    Nothing happens if [d] is smaller than 2.
    If [d] is too large, the limit is set to the maximum
    admissible value (which is greater than [10 ^ 9]).

    If [d] is greater or equal than the current margin, it is ignored,
    and the current maximum indentation limit is kept.
*)
val pp_set_max_indent : formatter -&gt; int -&gt; unit

(** Return the maximum indentation limit (in characters). *)
val pp_get_max_indent : formatter -&gt; unit -&gt; int

(** {1 Maximum formatting depth} *)

(** The maximum formatting depth is the maximum number of pretty-printing
    boxes simultaneously open.

    Material inside boxes nested deeper is printed as an ellipsis (more
    precisely as the text returned by {!get_ellipsis_text} [()]).
*)

(** [pp_set_max_boxes ppf max] sets the maximum number of pretty-printing
    boxes simultaneously open.

    Material inside boxes nested deeper is printed as an ellipsis (more
    precisely as the text returned by {!get_ellipsis_text} [()]).

    Nothing happens if [max] is smaller than 2.
*)
val pp_set_max_boxes : formatter -&gt; int -&gt; unit

(** Returns the maximum number of pretty-printing boxes allowed before
    ellipsis.
*)
val pp_get_max_boxes : formatter -&gt; unit -&gt; int

(** Tests if the maximum number of pretty-printing boxes allowed have already
    been opened.
*)
val pp_over_max_boxes : formatter -&gt; unit -&gt; bool

(** {1 Tabulation boxes} *)

(**

   A {e tabulation box} prints material on lines divided into cells of fixed
   length. A tabulation box provides a simple way to display vertical columns
   of left adjusted text.

   This box features command [set_tab] to define cell boundaries, and command
   [print_tab] to move from cell to cell and split the line when there is no
   more cells to print on the line.

   Note: printing within tabulation box is line directed, so arbitrary line
   splitting inside a tabulation box leads to poor rendering. Yet, controlled
   use of tabulation boxes allows simple printing of columns within
   module {!Format}.
*)

(** [open_tbox ()] opens a new tabulation box.

    This box prints lines separated into cells of fixed width.

    Inside a tabulation box, special {e tabulation markers} defines points of
    interest on the line (for instance to delimit cell boundaries).
    Function {!Format.set_tab} sets a tabulation marker at insertion point.

    A tabulation box features specific {e tabulation breaks} to move to next
    tabulation marker or split the line. Function {!Format.print_tbreak} prints
    a tabulation break.
*)
val pp_open_tbox : formatter -&gt; unit -&gt; unit

(** Closes the most recently opened tabulation box. *)
val pp_close_tbox : formatter -&gt; unit -&gt; unit

(** Sets a tabulation marker at current insertion point. *)
val pp_set_tab : formatter -&gt; unit -&gt; unit

(** [print_tab ()] emits a 'next' tabulation break hint: if not already set on
    a tabulation marker, the insertion point moves to the first tabulation
    marker on the right, or the pretty-printer splits the line and insertion
    point moves to the leftmost tabulation marker.

    It is equivalent to [print_tbreak 0 0]. *)
val pp_print_tab : formatter -&gt; unit -&gt; unit

(** [print_tbreak nspaces offset] emits a 'full' tabulation break hint.

    If not already set on a tabulation marker, the insertion point moves to the
    first tabulation marker on the right and the pretty-printer prints
    [nspaces] spaces.

    If there is no next tabulation marker on the right, the pretty-printer
    splits the line at this point, then insertion point moves to the leftmost
    tabulation marker of the box.

    If the pretty-printer splits the line, [offset] is added to
    the current indentation.
*)
val pp_print_tbreak : formatter -&gt; int -&gt; int -&gt; unit

(** {1 Ellipsis} *)

(** Set the text of the ellipsis printed when too many pretty-printing boxes
    are open (a single dot, [.], by default).
*)
val pp_set_ellipsis_text : formatter -&gt; string -&gt; unit

(** Return the text of the ellipsis. *)
val pp_get_ellipsis_text : formatter -&gt; unit -&gt; string

(** {1:tags Semantic tags} *)

type tag = string

(** {i Semantic tags} (or simply {e tags}) are user's defined delimiters
    to associate user's specific operations to printed entities.

    Common usage of semantic tags is text decoration to get specific font or
    text size rendering for a display device, or marking delimitation of
    entities (e.g. HTML or TeX elements or terminal escape sequences).
    More sophisticated usage of semantic tags could handle dynamic
    modification of the pretty-printer behavior to properly print the material
    within some specific tags.

    In order to properly delimit printed entities, a semantic tag must be
    opened before and closed after the entity. Semantic tags must be properly
    nested like parentheses.

    Tag specific operations occur any time a tag is opened or closed, At each
    occurrence, two kinds of operations are performed {e tag-marking} and
    {e tag-printing}:
    - The tag-marking operation is the simpler tag specific operation: it simply
    writes a tag specific string into the output device of the
    formatter. Tag-marking does not interfere with line-splitting computation.
    - The tag-printing operation is the more involved tag specific operation: it
    can print arbitrary material to the formatter. Tag-printing is tightly
    linked to the current pretty-printer operations.

    Roughly speaking, tag-marking is commonly used to get a better rendering of
    texts in the rendering device, while tag-printing allows fine tuning of
    printing routines to print the same entity differently according to the
    semantic tags (i.e. print additional material or even omit parts of the
    output).

    More precisely: when a semantic tag is opened or closed then both and
    successive 'tag-printing' and 'tag-marking' operations occur:
    - Tag-printing a semantic tag means calling the formatter specific function
    [print_open_tag] (resp. [print_close_tag]) with the name of the tag as
    argument: that tag-printing function can then print any regular material
    to the formatter (so that this material is enqueued as usual in the
    formatter queue for further line splitting computation).
    - Tag-marking a semantic tag means calling the formatter specific function
    [mark_open_tag] (resp. [mark_close_tag]) with the name of the tag as
    argument: that tag-marking function can then return the 'tag-opening
    marker' (resp. `tag-closing marker') for direct output into the output
    device of the formatter.

    Being written directly into the output device of the formatter, semantic
    tag marker strings are not considered as part of the printing material that
    drives line splitting (in other words, the length of the strings
    corresponding to tag markers is considered as zero for line splitting).

    Thus, semantic tag handling is in some sense transparent to pretty-printing
    and does not interfere with usual indentation. Hence, a single
    pretty-printing routine can output both simple 'verbatim' material or
    richer decorated output depending on the treatment of tags. By default,
    tags are not active, hence the output is not decorated with tag
    information. Once [set_tags] is set to [true], the pretty-printer engine
    honors tags and decorates the output accordingly.

    Default tag-marking functions behave the HTML way: tags are enclosed in &quot;&lt;&quot;
    and &quot;&gt;&quot;; hence, opening marker for tag [t] is [&quot;&lt;t&gt;&quot;] and closing marker is
    [&quot;&lt;/t&gt;&quot;].

    Default tag-printing functions just do nothing.

    Tag-marking and tag-printing functions are user definable and can
    be set by calling {!set_formatter_tag_functions}.

    Semantic tag operations may be set on or off with {!set_tags}.
    Tag-marking operations may be set on or off with {!set_mark_tags}.
    Tag-printing operations may be set on or off with {!set_print_tags}.
*)

(** [pp_open_tag ppf t] opens the semantic tag named [t].

    The [print_open_tag] tag-printing function of the formatter is called with
    [t] as argument; then the opening tag marker for [t], as given by
    [mark_open_tag t], is written into the output device of the formatter.
*)
val pp_open_tag : formatter -&gt; string -&gt; unit

(** [pp_close_tag ppf ()] closes the most recently opened semantic tag [t].

    The closing tag marker, as given by [mark_close_tag t], is written into the
    output device of the formatter; then the [print_close_tag] tag-printing
    function of the formatter is called with [t] as argument.
*)
val pp_close_tag : formatter -&gt; unit -&gt; unit

(** [pp_set_tags ppf b] turns on or off the treatment of semantic tags
    (default is off).
*)
val pp_set_tags : formatter -&gt; bool -&gt; unit

(** [pp_set_print_tags ppf b] turns on or off the tag-printing operations. *)
val pp_set_print_tags : formatter -&gt; bool -&gt; unit

(** [pp_set_mark_tags ppf b] turns on or off the tag-marking operations. *)
val pp_set_mark_tags : formatter -&gt; bool -&gt; unit

(** Return the current status of tag-printing operations. *)
val pp_get_print_tags : formatter -&gt; unit -&gt; bool

(** Return the current status of tag-marking operations. *)
val pp_get_mark_tags : formatter -&gt; unit -&gt; bool

(** {1 Convenience formatting functions.} *)

(** [pp_print_list ?pp_sep pp_v ppf l] prints items of list [l],
    using [pp_v] to print each item, and calling [pp_sep]
    between items ([pp_sep] defaults to {!pp_print_cut}.
    Does nothing on empty lists.

    @since 4.02.0
*)
val pp_print_list :
  ?pp_sep:(formatter -&gt; unit -&gt; unit) -&gt;
  (formatter -&gt; 'a -&gt; unit) -&gt;
  formatter -&gt;
  'a list -&gt;
  unit

(** [pp_print_text ppf s] prints [s] with spaces and newlines respectively
    printed using {!pp_print_space} and {!pp_force_newline}.

    @since 4.02.0
*)
val pp_print_text : formatter -&gt; string -&gt; unit

(** {1:fpp Formatted pretty-printing} *)

(**
   Module [Format] provides a complete set of [printf] like functions for
   pretty-printing using format string specifications.

   Specific annotations may be added in the format strings to give
   pretty-printing commands to the pretty-printing engine.

   Those annotations are introduced in the format strings using the [@]
   character. For instance, [@ ] means a space break, [@,] means a cut,
   [@\[] opens a new box, and [@\]] closes the last open box.

*)

val fprintf : formatter -&gt; ('a, formatter, unit) format -&gt; 'a

(** [fprintf ff fmt arg1 ... argN] formats the arguments [arg1] to [argN]
    according to the format string [fmt], and outputs the resulting string on
    the formatter [ff].

    The format string [fmt] is a character string which contains three types of
    objects: plain characters and conversion specifications as specified in
    the {!Printf} module, and pretty-printing indications specific to the
    [Format] module.

    The pretty-printing indication characters are introduced by
    a [@] character, and their meanings are:
    - [@\[]: open a pretty-printing box. The type and offset of the
    box may be optionally specified with the following syntax:
    the [&lt;] character, followed by an optional box type indication,
    then an optional integer offset, and the closing [&gt;] character.
    Pretty-printing box type is one of [h], [v], [hv], [b], or [hov].
    '[h]' stands for an 'horizontal' pretty-printing box,
    '[v]' stands for a 'vertical' pretty-printing box,
    '[hv]' stands for an 'horizontal/vertical' pretty-printing box,
    '[b]' stands for an 'horizontal-or-vertical' pretty-printing box
    demonstrating indentation,
    '[hov]' stands a simple 'horizontal-or-vertical' pretty-printing box.
    For instance, [@\[&lt;hov 2&gt;] opens an 'horizontal-or-vertical'
    pretty-printing box with indentation 2 as obtained with [open_hovbox 2].
    For more details about pretty-printing boxes, see the various box opening
    functions [open_*box].
    - [@\]]: close the most recently opened pretty-printing box.
    - [@,]: output a 'cut' break hint, as with [print_cut ()].
    - [@ ]: output a 'space' break hint, as with [print_space ()].
    - [@;]: output a 'full' break hint as with [print_break]. The
    [nspaces] and [offset] parameters of the break hint may be
    optionally specified with the following syntax:
    the [&lt;] character, followed by an integer [nspaces] value,
    then an integer [offset], and a closing [&gt;] character.
    If no parameters are provided, the good break defaults to a
    'space' break hint.
    - [@.]: flush the pretty-printer and split the line, as with
    [print_newline ()].
    - [@&lt;n&gt;]: print the following item as if it were of length [n].
    Hence, [printf &quot;@&lt;0&gt;%s&quot; arg] prints [arg] as a zero length string.
    If [@&lt;n&gt;] is not followed by a conversion specification,
    then the following character of the format is printed as if
    it were of length [n].
    - [@\{]: open a semantic tag. The name of the tag may be optionally
    specified with the following syntax:
    the [&lt;] character, followed by an optional string
    specification, and the closing [&gt;] character. The string
    specification is any character string that does not contain the
    closing character ['&gt;']. If omitted, the tag name defaults to the
    empty string.
    For more details about semantic tags, see the functions {!open_tag} and
    {!close_tag}.
    - [@\}]: close the most recently opened semantic tag.
    - [@?]: flush the pretty-printer as with [print_flush ()].
    This is equivalent to the conversion [%!].
    - [@\n]: force a newline, as with [force_newline ()], not the normal way
    of pretty-printing, you should prefer using break hints inside a vertical
    pretty-printing box.

    Note: To prevent the interpretation of a [@] character as a
    pretty-printing indication, escape it with a [%] character.
    Old quotation mode [@@] is deprecated since it is not compatible with
    formatted input interpretation of character ['@'].

    Example: [printf &quot;@[%s@ %d@]@.&quot; &quot;x =&quot; 1] is equivalent to
    [open_box (); print_string &quot;x =&quot;; print_space ();
    print_int 1; close_box (); print_newline ()].
    It prints [x = 1] within a pretty-printing 'horizontal-or-vertical' box.

*)

(** Same as [printf] above, but instead of printing on a formatter,
    returns a string containing the result of formatting the arguments.
    Note that the pretty-printer queue is flushed at the end of {e each
    call} to [sprintf].

    In case of multiple and related calls to [sprintf] to output
    material on a single string, you should consider using [fprintf]
    with the predefined formatter [str_formatter] and call
    [flush_str_formatter ()] to get the final result.

    Alternatively, you can use [Format.fprintf] with a formatter writing to a
    buffer of your own: flushing the formatter and the buffer at the end of
    pretty-printing returns the desired string.
*)
val sprintf : ('a, unit, string) format -&gt; 'a

(** Same as [printf] above, but instead of printing on a formatter,
    returns a string containing the result of formatting the arguments.
    The type of [asprintf] is general enough to interact nicely with [%a]
    conversions.

    @since 4.01.0
*)
val asprintf : ('a, formatter, unit, string) format4 -&gt; 'a

(** Same as [fprintf] above, but does not print anything.
    Useful to ignore some material when conditionally printing.

    @since 3.10.0
*)
val ifprintf : formatter -&gt; ('a, formatter, unit) format -&gt; 'a

(** Formatted Pretty-Printing with continuations. *)

(** Same as [fprintf] above, but instead of returning immediately,
    passes the formatter to its first argument at the end of printing. *)
val kfprintf :
  (formatter -&gt; 'a) -&gt; formatter -&gt; ('b, formatter, unit, 'a) format4 -&gt; 'b

(** Same as [kfprintf] above, but does not print anything.
    Useful to ignore some material when conditionally printing.

    @since 3.12.0
*)
val ikfprintf :
  (formatter -&gt; 'a) -&gt; formatter -&gt; ('b, formatter, unit, 'a) format4 -&gt; 'b

(** Same as [sprintf] above, but instead of returning the string,
    passes it to the first argument. *)
val ksprintf : (string -&gt; 'a) -&gt; ('b, unit, string, 'a) format4 -&gt; 'b

(** Same as [asprintf] above, but instead of returning the string,
    passes it to the first argument.

    @since 4.03
*)
val kasprintf : (string -&gt; 'a) -&gt; ('b, formatter, unit, 'a) format4 -&gt; 'b
end
module MBytes : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/mBytes.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t

val create : int -&gt; t

val length : t -&gt; int

val copy : t -&gt; t

(** [sub src ofs len] extract a sub-array of [src] starting at [ofs]
    and of length [len]. No copying of elements is involved: the
    sub-array and the original array share the same storage space. *)
val sub : t -&gt; int -&gt; int -&gt; t

(** [blit src ofs_src dst ofs_dst len] copy [len] bytes from [src]
    starting at [ofs_src] into [dst] starting at [ofs_dst]. *)
val blit : t -&gt; int -&gt; t -&gt; int -&gt; int -&gt; unit

(** See [blit] *)
val blit_of_string : string -&gt; int -&gt; t -&gt; int -&gt; int -&gt; unit

(** See [blit] *)
val blit_to_bytes : t -&gt; int -&gt; bytes -&gt; int -&gt; int -&gt; unit

(** [of_string s] create an byte array filled with the same content than [s]. *)
val of_string : string -&gt; t

(** [to_string b] dump the array content in a [string]. *)
val to_string : t -&gt; string

(** [sub_string b ofs len] is equivalent to [to_string (sub b ofs len)]. *)
val sub_string : t -&gt; int -&gt; int -&gt; string

(** Functions reading and writing bytes  *)

(** [get_char buff i] reads 1 byte at offset i as a char *)
val get_char : t -&gt; int -&gt; char

(** [get_uint8 buff i] reads 1 byte at offset i as an unsigned int of 8
    bits. i.e. It returns a value between 0 and 2^8-1 *)
val get_uint8 : t -&gt; int -&gt; int

(** [get_int8 buff i] reads 1 byte at offset i as a signed int of 8
    bits. i.e. It returns a value between -2^7 and 2^7-1 *)
val get_int8 : t -&gt; int -&gt; int

(** [set_char buff i v] writes [v] to [buff] at offset [i] *)
val set_char : t -&gt; int -&gt; char -&gt; unit

(** [set_int8 buff i v] writes the least significant 8 bits of [v]
    to [buff] at offset [i] *)
val set_int8 : t -&gt; int -&gt; int -&gt; unit

(** Functions reading according to Big Endian byte order *)

(** [get_uint16 buff i] reads 2 bytes at offset i as an unsigned int
      of 16 bits. i.e. It returns a value between 0 and 2^16-1 *)
val get_uint16 : t -&gt; int -&gt; int

(** [get_int16 buff i] reads 2 byte at offset i as a signed int of
      16 bits. i.e. It returns a value between -2^15 and 2^15-1 *)
val get_int16 : t -&gt; int -&gt; int

(** [get_int32 buff i] reads 4 bytes at offset i as an int32. *)
val get_int32 : t -&gt; int -&gt; int32

(** [get_int64 buff i] reads 8 bytes at offset i as an int64. *)
val get_int64 : t -&gt; int -&gt; int64

(** [set_int16 buff i v] writes the least significant 16 bits of [v]
      to [buff] at offset [i] *)
val set_int16 : t -&gt; int -&gt; int -&gt; unit

(** [set_int32 buff i v] writes [v] to [buff] at offset [i] *)
val set_int32 : t -&gt; int -&gt; int32 -&gt; unit

(** [set_int64 buff i v] writes [v] to [buff] at offset [i] *)
val set_int64 : t -&gt; int -&gt; int64 -&gt; unit

module LE : sig
  (** Functions reading according to Little Endian byte order *)

  (** [get_uint16 buff i] reads 2 bytes at offset i as an unsigned int
      of 16 bits. i.e. It returns a value between 0 and 2^16-1 *)
  val get_uint16 : t -&gt; int -&gt; int

  (** [get_int16 buff i] reads 2 byte at offset i as a signed int of
      16 bits. i.e. It returns a value between -2^15 and 2^15-1 *)
  val get_int16 : t -&gt; int -&gt; int

  (** [get_int32 buff i] reads 4 bytes at offset i as an int32. *)
  val get_int32 : t -&gt; int -&gt; int32

  (** [get_int64 buff i] reads 8 bytes at offset i as an int64. *)
  val get_int64 : t -&gt; int -&gt; int64

  (** [set_int16 buff i v] writes the least significant 16 bits of [v]
      to [buff] at offset [i] *)
  val set_int16 : t -&gt; int -&gt; int -&gt; unit

  (** [set_int32 buff i v] writes [v] to [buff] at offset [i] *)
  val set_int32 : t -&gt; int -&gt; int32 -&gt; unit

  (** [set_int64 buff i v] writes [v] to [buff] at offset [i] *)
  val set_int64 : t -&gt; int -&gt; int64 -&gt; unit
end

val ( = ) : t -&gt; t -&gt; bool

val ( &lt;&gt; ) : t -&gt; t -&gt; bool

val ( &lt; ) : t -&gt; t -&gt; bool

val ( &lt;= ) : t -&gt; t -&gt; bool

val ( &gt;= ) : t -&gt; t -&gt; bool

val ( &gt; ) : t -&gt; t -&gt; bool

val compare : t -&gt; t -&gt; int

val concat : string -&gt; t list -&gt; t

<abbr class="mark-warning" title="Polymorphic variant types are defined as standard algebraic types">type hex = [`Hex of string]</abbr>

val to_hex : t -&gt; hex

val of_hex : hex -&gt; t
end
module Z : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/z.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Tezos Protocol Environment - Arbitrary precision arithmetic. *)

type t

val zero : t

val one : t

(** Returns its argument plus one. *)
val succ : t -&gt; t

(** Absolute value. *)
val abs : t -&gt; t

(** Unary negation. *)
val neg : t -&gt; t

(** Addition. *)
val add : t -&gt; t -&gt; t

(** Subtraction. *)
val sub : t -&gt; t -&gt; t

(** Multiplication. *)
val mul : t -&gt; t -&gt; t

(** Euclidean division and remainder.  [ediv_rem a b] returns a pair [(q, r)]
    such that [a = b * q + r] and [0 &lt;= r &lt; |b|].
    Raises [Division_by_zero] if [b = 0].
*)
val ediv_rem : t -&gt; t -&gt; t * t

(** Bitwise logical and. *)
val logand : t -&gt; t -&gt; t

(** Bitwise logical or. *)
val logor : t -&gt; t -&gt; t

(** Bitwise logical exclusive or. *)
val logxor : t -&gt; t -&gt; t

(** Bitwise logical negation.
    The identity [lognot a]=[-a-1] always hold.
*)
val lognot : t -&gt; t

(** Shifts to the left.
    Equivalent to a multiplication by a power of 2.
    The second argument must be non-negative.
*)
val shift_left : t -&gt; int -&gt; t

(** Shifts to the right.
    This is an arithmetic shift,
    equivalent to a division by a power of 2 with rounding towards -oo.
    The second argument must be non-negative.
*)
val shift_right : t -&gt; int -&gt; t

(** Gives a human-readable, decimal string representation of the argument. *)
val to_string : t -&gt; string

(** Converts a string to an integer.
    An optional [-] prefix indicates a negative number, while a [+]
    prefix is ignored.
    An optional prefix [0x], [0o], or [0b] (following the optional [-]
    or [+] prefix) indicates that the number is,
    represented, in hexadecimal, octal, or binary, respectively.
    Otherwise, base 10 is assumed.
    (Unlike C, a lone [0] prefix does not denote octal.)
    Raises an [Invalid_argument] exception if the string is not a
    syntactically correct representation of an integer.
*)
val of_string : string -&gt; t

(** Converts to a 64-bit integer. May raise [Overflow]. *)
val to_int64 : t -&gt; int64

(** Converts from a 64-bit integer. *)
val of_int64 : int64 -&gt; t

(** Converts to a base integer. May raise an [Overflow]. *)
val to_int : t -&gt; int

(** Converts from a base integer. *)
val of_int : int -&gt; t

val to_bits : ?pad_to:int -&gt; t -&gt; MBytes.t

val of_bits : MBytes.t -&gt; t

val equal : t -&gt; t -&gt; bool

val compare : t -&gt; t -&gt; int

(** Returns the number of significant bits in the given number.
    If [x] is zero, [numbits x] returns 0.  Otherwise,
    [numbits x] returns a positive integer [n] such that
    [2^{n-1} &lt;= |x| &lt; 2^n].  Note that [numbits] is defined
    for negative arguments, and that [numbits (-x) = numbits x]. *)
val numbits : t -&gt; int
end
module Lwt : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/lwt.mli&quot;
(* Lightweight thread library for OCaml
 * http://www.ocsigen.org/lwt
 * Interface Lwt
 * Copyright (C) 2005-2008 JÃ¯Â¿Â½rÃ¯Â¿Â½me Vouillon
 * Laboratoire PPS - CNRS UniversitÃ¯Â¿Â½ Paris Diderot
 *               2009-2012 JÃ¯Â¿Â½rÃ¯Â¿Â½mie Dimino
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, with linking exceptions;
 * either version 2.1 of the License, or (at your option) any later
 * version. See COPYING file for details.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA.
 *)

(* TEZOS CHANGES

   * import version 2.4.5
   * Comment a few function that shouldn't be used in the protocol:
     * choose: scheduling may be system dependent.
     * wait/wakeup
     * state
     * cancel
     * pause
     * async
     * thread storage
     * lwt exceptions
*)

(** Module [Lwt]: cooperative light-weight threads. *)

(** This module defines {e cooperative light-weight threads} with
    their primitives. A {e light-weight thread} represent a
    computation that may be not terminated, for example because it is
    waiting for some event to happen.

    Lwt threads are cooperative in the sense that switching to another
    thread is awlays explicit (with {!wakeup} or {!wakeup_exn}). When a
    thread is running, it executes as much as possible, and then
    returns (a value or an eror) or sleeps.

    Note that inside a Lwt thread, exceptions must be raised with
    {!fail} instead of [raise]. Also the [try ... with ...]
    construction will not catch Lwt errors. You must use {!catch}
    instead. You can also use {!wrap} for functions that may raise
    normal exception.

    Lwt also provides the syntax extension {!Pa_lwt} to make code
    using Lwt more readable.
*)

(** {2 Definitions and basics} *)

(** The type of threads returning a result of type ['a]. *)
type +'a t

(** [return e] is a thread whose return value is the value of the
    expression [e]. *)
val return : 'a -&gt; 'a t

(* val fail : exn -&gt; 'a t *)
(*   (\** [fail e] is a thread that fails with the exception [e]. *\) *)

(** [bind t f] is a thread which first waits for the thread [t] to
    terminate and then, if the thread succeeds, behaves as the
    application of function [f] to the return value of [t].  If the
    thread [t] fails, [bind t f] also fails, with the same
    exception.

    The expression [bind t (fun x -&gt; t')] can intuitively be read as
    [let x = t in t'], and if you use the {e lwt.syntax} syntax
    extension, you can write a bind operation like that: [lwt x = t in t'].

    Note that [bind] is also often used just for synchronization
    purpose: [t'] will not execute before [t] is terminated.

    The result of a thread can be bound several time. *)
val bind : 'a t -&gt; ('a -&gt; 'b t) -&gt; 'b t

(** [t &gt;&gt;= f] is an alternative notation for [bind t f]. *)
val ( &gt;&gt;= ) : 'a t -&gt; ('a -&gt; 'b t) -&gt; 'b t

(** [f =&lt;&lt; t] is [t &gt;&gt;= f] *)
val ( =&lt;&lt; ) : ('a -&gt; 'b t) -&gt; 'a t -&gt; 'b t

(** [map f m] map the result of a thread. This is the same as [bind
    m (fun x -&gt; return (f x))] *)
val map : ('a -&gt; 'b) -&gt; 'a t -&gt; 'b t

(** [m &gt;|= f] is [map f m] *)
val ( &gt;|= ) : 'a t -&gt; ('a -&gt; 'b) -&gt; 'b t

(** [f =|&lt; m] is [map f m] *)
val ( =|&lt; ) : ('a -&gt; 'b) -&gt; 'a t -&gt; 'b t

(** {3 Pre-allocated threads} *)

(** [return_unit = return ()] *)
val return_unit : unit t

(** [return_none = return None] *)
val return_none : 'a option t

(** [return_nil = return \[\]] *)
val return_nil : 'a list t

(** [return_true = return true] *)
val return_true : bool t

(** [return_false = return false] *)
val return_false : bool t

(* (\** {2 Thread storage} *\) *)

(* type 'a key *)
(*   (\** Type of a key. Keys are used to store local values into *)
(*       threads *\) *)

(* val new_key : unit -&gt; 'a key *)
(*   (\** [new_key ()] creates a new key. *\) *)

(* val get : 'a key -&gt; 'a option *)
(*   (\** [get key] returns the value associated with [key] in the current *)
(*       thread. *\) *)

(* val with_value : 'a key -&gt; 'a option -&gt; (unit -&gt; 'b) -&gt; 'b *)
(*   (\** [with_value key value f] executes [f] with [value] associated to *)
(*       [key]. The previous value associated to [key] is restored after *)
(*       [f] terminates. *\) *)

(* (\** {2 Exceptions handling} *\) *)

(* val catch : (unit -&gt; 'a t) -&gt; (exn -&gt; 'a t) -&gt; 'a t *)
(*   (\** [catch t f] is a thread that behaves as the thread [t ()] if *)
(*       this thread succeeds.  If the thread [t ()] fails with some *)
(*       exception, [catch t f] behaves as the application of [f] to this *)
(*       exception. *\) *)

(* val try_bind : (unit -&gt; 'a t) -&gt; ('a -&gt; 'b t) -&gt; (exn -&gt; 'b t) -&gt; 'b t *)
(*   (\** [try_bind t f g] behaves as [bind (t ()) f] if [t] does not *)
(*       fail.  Otherwise, it behaves as the application of [g] to the *)
(*       exception associated to [t ()]. *\) *)

(* val finalize : (unit -&gt; 'a t) -&gt; (unit -&gt; unit t) -&gt; 'a t *)
(*   (\** [finalize f g] returns the same result as [f ()] whether it *)
(*       fails or not. In both cases, [g ()] is executed after [f]. *\) *)

(* val wrap : (unit -&gt; 'a) -&gt; 'a t *)
(*   (\** [wrap f] calls [f] and transform the result into a monad. If [f] *)
(*       raise an exception, it is catched by Lwt. *)

(*       This is actually the same as: *)

(*       {[ *)
(*         try *)
(*           return (f ()) *)
(*         with exn -&gt; *)
(*           fail exn *)
(*       ]} *)
(*   *\) *)

(* val wrap1 : ('a -&gt; 'b) -&gt; 'a -&gt; 'b t *)
(*   (\** [wrap1 f x] applies [f] on [x] and returns the result as a *)
(*       thread. If the application of [f] to [x] raise an exception it *)
(*       is catched and a thread is returned. *)

(*       Note that you must use {!wrap} instead of {!wrap1} if the *)
(*       evaluation of [x] may raise an exception. *)

(*       for example the following code is not ok: *)

(*       {[ *)
(*         wrap1 f (Hashtbl.find table key) *)
(*       ]} *)

(*       you should write instead: *)

(*       {[ *)
(*         wrap (fun () -&gt; f (Hashtbl.find table key)) *)
(*       ]} *)
(*   *\) *)

(* val wrap2 : ('a -&gt; 'b -&gt; 'c) -&gt; 'a -&gt; 'b -&gt; 'c t *)
(* val wrap3 : ('a -&gt; 'b -&gt; 'c -&gt; 'd) -&gt; 'a -&gt; 'b -&gt; 'c -&gt; 'd t *)
(* val wrap4 : ('a -&gt; 'b -&gt; 'c -&gt; 'd -&gt; 'e) -&gt; 'a -&gt; 'b -&gt; 'c -&gt; 'd -&gt; 'e t *)
(* val wrap5 : ('a -&gt; 'b -&gt; 'c -&gt; 'd -&gt; 'e -&gt; 'f) -&gt; 'a -&gt; 'b -&gt; 'c -&gt; 'd -&gt; 'e -&gt; 'f t *)
(* val wrap6 : ('a -&gt; 'b -&gt; 'c -&gt; 'd -&gt; 'e -&gt; 'f -&gt; 'g) -&gt; 'a -&gt; 'b -&gt; 'c -&gt; 'd -&gt; 'e -&gt; 'f -&gt; 'g t *)
(* val wrap7 : ('a -&gt; 'b -&gt; 'c -&gt; 'd -&gt; 'e -&gt; 'f -&gt; 'g -&gt; 'h) -&gt; 'a -&gt; 'b -&gt; 'c -&gt; 'd -&gt; 'e -&gt; 'f -&gt; 'g -&gt; 'h t *)

(** {2 Multi-threads composition} *)

(* we shouldn't use choose: the scheduling may be system dependent *)

(* val choose : 'a t list -&gt; 'a t *)
(*   (\** [choose l] behaves as the first thread in [l] to terminate.  If *)
(*       several threads are already terminated, one is choosen at *)
(*       random. *)

(*       Note: {!choose} leaves the local values of the current thread *)
(*       unchanged. *\) *)

(* val nchoose : 'a t list -&gt; 'a list t *)
(*   (\** [nchoose l] returns the value of all that have succcessfully *)
(*       terminated. If all threads are sleeping, it waits for at least *)
(*       one to terminates. If one the threads of [l] fails, [nchoose] *)
(*       fails with the same exception. *)

(*       Note: {!nchoose} leaves the local values of the current thread *)
(*       unchanged. *\) *)

(* val nchoose_split : 'a t list -&gt; ('a list * 'a t list) t *)
(*   (\** [nchoose_split l] does the same as {!nchoose} but also retrurns *)
(*       the list of threads that have not yet terminated. *\) *)

(** [join l] waits for all threads in [l] to terminate. If one of
    the threads fails, then [join l] will fails with the same
    exception as the first one to terminate.

    Note: {!join} leaves the local values of the current thread
    unchanged. *)
val join : unit t list -&gt; unit t

(* val ( &lt;?&gt; ) : 'a t -&gt; 'a t -&gt; 'a t *)
(*   (\** [t &lt;?&gt; t'] is the same as [choose [t; t']] *\) *)

(** [t &lt;&amp;&gt; t'] is the same as [join [t; t']] *)
val ( &lt;&amp;&gt; ) : unit t -&gt; unit t -&gt; unit t

(* val async : (unit -&gt; 'a t) -&gt; unit *)
(*   (\** [async f] starts a thread without waiting for the result. If it *)
(*       fails (now or later), the exception is given to *)
(*       {!async_exception_hook}. *)

(*       You should use this function if you want to start a thread that *)
(*       might fail and don't care what its return value is, nor when it *)
(*       terminates (for instance, because it is looping). *\) *)

(* val ignore_result : 'a t -&gt; unit *)
(*   (\** [ignore_result t] is like [Pervasives.ignore t] except that: *)

(*       - if [t] already failed, it raises the exception now, *)
(*       - if [t] is sleeping and fails later, the exception will be *)
(*         given to {!async_exception_hook}. *\) *)

(* val async_exception_hook : (exn -&gt; unit) ref *)
(*   (\** Function called when a asynchronous exception is thrown. *)

(*       The default behavior is to print an error message with a *)
(*       backtrace if available and to exit the program. *)

(*       The behavior is undefined if this function raise an *)
(*       exception. *\) *)

(* (\** {2 Sleeping and resuming} *\) *)

(* type 'a u *)
(*   (\** The type of thread wakeners. *\) *)

(* val wait : unit -&gt; 'a t * 'a u *)
(*   (\** [wait ()] is a pair of a thread which sleeps forever (unless it *)
(*       is resumed by one of the functions [wakeup], [wakeup_exn] below) *)
(*       and the corresponding wakener.  This thread does not block the *)
(*       execution of the remainder of the program (except of course, if *)
(*       another thread tries to wait for its termination). *\) *)

(* val wakeup : 'a u -&gt; 'a -&gt; unit *)
(*   (\** [wakeup t e] makes the sleeping thread [t] terminate and return *)
(*       the value of the expression [e]. *\) *)

(* val wakeup_exn : 'a u -&gt; exn -&gt; unit *)
(*   (\** [wakeup_exn t e] makes the sleeping thread [t] fail with the *)
(*       exception [e]. *\) *)

(* val wakeup_later : 'a u -&gt; 'a -&gt; unit *)
(*   (\** Same as {!wakeup} but it is not guaranteed that the thread will *)
(*       be woken up immediately. *\) *)

(* val wakeup_later_exn : 'a u -&gt; exn -&gt; unit *)
(*   (\** Same as {!wakeup_exn} but it is not guaranteed that the thread *)
(*       will be woken up immediately. *\) *)

(* val waiter_of_wakener : 'a u -&gt; 'a t *)
(*   (\** Returns the thread associated to a wakener. *\) *)

(* type +'a result *)
(*   (\** Either a value of type ['a], either an exception. *\) *)

(* val make_value : 'a -&gt; 'a result *)
(*   (\** [value x] creates a result containing the value [x]. *\) *)

(* val make_error : exn -&gt; 'a result *)
(*   (\** [error e] creates a result containing the exception [e]. *\) *)

(* val of_result : 'a result -&gt; 'a t *)
(*   (\** Returns a thread from a result. *\) *)

(* val wakeup_result : 'a u -&gt; 'a result -&gt; unit *)
(*   (\** [wakeup_result t r] makes the sleeping thread [t] terminate with *)
(*       the result [r]. *\) *)

(* val wakeup_later_result : 'a u -&gt; 'a result -&gt; unit *)
(*   (\** Same as {!wakeup_result} but it is not guaranteed that the *)
(*       thread will be woken up immediately. *\) *)

(* (\** {2 Threads state} *\) *)

(* (\** State of a thread *\) *)
(* type 'a state = *)
(*   | Return of 'a *)
(*       (\** The thread which has successfully terminated *\) *)
(*   | Fail of exn *)
(*       (\** The thread raised an exception *\) *)
(*   | Sleep *)
(*       (\** The thread is sleeping *\) *)

(* val state : 'a t -&gt; 'a state *)
(*   (\** [state t] returns the state of a thread *\) *)

(* val is_sleeping : 'a t -&gt; bool *)
(*   (\** [is_sleeping t] returns [true] iff [t] is sleeping. *\) *)

(* (\** {2 Cancelable threads} *\) *)

(* (\** Cancelable threads are the same as regular threads except that *)
(*     they can be canceled. *\) *)

(* exception Canceled *)
(*   (\** Canceled threads fails with this exception *\) *)

(* val task : unit -&gt; 'a t * 'a u *)
(*   (\** [task ()] is the same as [wait ()] except that threads created *)
(*       with [task] can be canceled. *\) *)

(* val on_cancel : 'a t -&gt; (unit -&gt; unit) -&gt; unit *)
(*   (\** [on_cancel t f] executes [f] when [t] is canceled. [f] will be *)
(*       executed before all other threads waiting on [t]. *)

(*       If [f] raises an exception it is given to *)
(*       {!async_exception_hook}. *\) *)

(* val add_task_r : 'a u Lwt_sequence.t -&gt; 'a t *)
(*   (\** [add_task_r seq] creates a sleeping thread, adds its wakener to *)
(*       the right of [seq] and returns its waiter. When the thread is *)
(*       canceled, it is removed from [seq]. *\) *)

(* val add_task_l : 'a u Lwt_sequence.t -&gt; 'a t *)
(*   (\** [add_task_l seq] creates a sleeping thread, adds its wakener to *)
(*       the left of [seq] and returns its waiter. When the thread is *)
(*       canceled, it is removed from [seq]. *\) *)

(* val cancel : 'a t -&gt; unit *)
(*   (\** [cancel t] cancels the threads [t]. This means that the deepest *)
(*       sleeping thread created with [task] and connected to [t] is *)
(*       woken up with the exception {!Canceled}. *)

(*       For example, in the following code: *)

(*       {[ *)
(*         let waiter, wakener = task () in *)
(*         cancel (waiter &gt;&gt; printl &quot;plop&quot;) *)
(*       ]} *)

(*       [waiter] will be woken up with {!Canceled}. *)
(*   *\) *)

(* val pick : 'a t list -&gt; 'a t *)
(*   (\** [pick l] is the same as {!choose}, except that it cancels all *)
(*       sleeping threads when one terminates. *)

(*       Note: {!pick} leaves the local values of the current thread *)
(*       unchanged. *\) *)

(* val npick : 'a t list -&gt; 'a list t *)
(*   (\** [npick l] is the same as {!nchoose}, except that it cancels all *)
(*       sleeping threads when one terminates. *)

(*       Note: {!npick} leaves the local values of the current thread *)
(*       unchanged. *\) *)

(* val protected : 'a t -&gt; 'a t *)
(*   (\** [protected thread] creates a new cancelable thread which behave *)
(*       as [thread] except that cancelling it does not cancel *)
(*       [thread]. *\) *)

(* val no_cancel : 'a t -&gt; 'a t *)
(*   (\** [no_cancel thread] creates a thread which behave as [thread] *)
(*       except that it cannot be canceled. *\) *)

(* (\** {2 Pause} *\) *)

(* val pause : unit -&gt; unit t *)
(*   (\** [pause ()] is a sleeping thread which is wake up on the next *)
(*       call to {!wakeup_paused}. A thread created with [pause] can be *)
(*       canceled. *\) *)

(* val wakeup_paused : unit -&gt; unit *)
(*   (\** [wakeup_paused ()] wakes up all threads which suspended *)
(*       themselves with {!pause}. *)

(*       This function is called by the scheduler, before entering the *)
(*       main loop. You usually do not have to call it directly, except *)
(*       if you are writing a custom scheduler. *)

(*       Note that if a paused thread resumes and pauses again, it will not *)
(*       be woken up at this point. *\) *)

(* val paused_count : unit -&gt; int *)
(*   (\** [paused_count ()] returns the number of currently paused *)
(*       threads. *\) *)

(* val register_pause_notifier : (int -&gt; unit) -&gt; unit *)
(*   (\** [register_pause_notifier f] register a function [f] that will be *)
(*       called each time pause is called. The parameter passed to [f] is *)
(*       the new number of threads paused. It is usefull to be able to *)
(*       call {!wakeup_paused} when there is no scheduler *\) *)

(* (\** {2 Misc} *\) *)

(* val on_success : 'a t -&gt; ('a -&gt; unit) -&gt; unit *)
(*   (\** [on_success t f] executes [f] when [t] terminates without *)
(*       failing. If [f] raises an exception it is given to *)
(*       {!async_exception_hook}. *\) *)

(* val on_failure : 'a t -&gt; (exn -&gt; unit) -&gt; unit *)
(*   (\** [on_failure t f] executes [f] when [t] terminates and fails. If *)
(*       [f] raises an exception it is given to *)
(*       {!async_exception_hook}. *\) *)

(* val on_termination : 'a t -&gt; (unit -&gt; unit) -&gt; unit *)
(*   (\** [on_termination t f] executes [f] when [t] terminates. If [f] *)
(*       raises an exception it is given to {!async_exception_hook}. *\) *)

(* val on_any : 'a t -&gt; ('a -&gt; unit) -&gt; (exn -&gt; unit) -&gt; unit *)
(*   (\** [on_any t f g] executes [f] or [g] when [t] terminates. If [f] *)
(*       or [g] raises an exception it is given to *)
(*       {!async_exception_hook}. *\) *)

(* (\**/**\) *)

(* (\* The functions below are probably not useful for the casual user. *)
(*    They provide the basic primitives on which can be built multi- *)
(*    threaded libraries such as Lwt_unix. *\) *)

(* val poll : 'a t -&gt; 'a option *)
(*       (\* [poll e] returns [Some v] if the thread [e] is terminated and *)
(*          returned the value [v].  If the thread failed with some *)
(*          exception, this exception is raised.  If the thread is still *)
(*          running, [poll e] returns [None] without blocking. *\) *)

(* val apply : ('a -&gt; 'b t) -&gt; 'a -&gt; 'b t *)
(*       (\* [apply f e] apply the function [f] to the expression [e].  If *)
(*          an exception is raised during this application, it is caught *)
(*          and the resulting thread fails with this exception. *\) *)
(* (\* Q: Could be called 'glue' or 'trap' or something? *\) *)

(* val backtrace_bind : (exn -&gt; exn) -&gt; 'a t -&gt; ('a -&gt; 'b t) -&gt; 'b t *)
(* val backtrace_catch : (exn -&gt; exn) -&gt; (unit -&gt; 'a t) -&gt; (exn -&gt; 'a t) -&gt; 'a t *)
(* val backtrace_try_bind : (exn -&gt; exn) -&gt; (unit -&gt; 'a t) -&gt; ('a -&gt; 'b t) -&gt; (exn -&gt; 'b t) -&gt; 'b t *)
(* val backtrace_finalize : (exn -&gt; exn) -&gt; (unit -&gt; 'a t) -&gt; (unit -&gt; unit t) -&gt; 'a t *)
end
module Lwt_list : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/lwt_list.mli&quot;
(* Lightweight thread library for OCaml
 * http://www.ocsigen.org/lwt
 * Interface Lwt_list
 * Copyright (C) 2010 JÃƒÂ©rÃƒÂ©mie Dimino
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, with linking exceptions;
 * either version 2.1 of the License, or (at your option) any later
 * version. See COPYING file for details.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 * 02111-1307, USA.
 *)

(** List helpers *)

(* TEZOS CHANGES

   * import version 2.4.5
   * Remove iter/iteri
*)

(** Note: this module use the same naming convention as
    {!Lwt_stream}. *)

(** {2 List iterators} *)

val map_s : ('a -&gt; 'b Lwt.t) -&gt; 'a list -&gt; 'b list Lwt.t

val map_p : ('a -&gt; 'b Lwt.t) -&gt; 'a list -&gt; 'b list Lwt.t

val mapi_s : (int -&gt; 'a -&gt; 'b Lwt.t) -&gt; 'a list -&gt; 'b list Lwt.t

val mapi_p : (int -&gt; 'a -&gt; 'b Lwt.t) -&gt; 'a list -&gt; 'b list Lwt.t

val rev_map_s : ('a -&gt; 'b Lwt.t) -&gt; 'a list -&gt; 'b list Lwt.t

val rev_map_p : ('a -&gt; 'b Lwt.t) -&gt; 'a list -&gt; 'b list Lwt.t

val fold_left_s : ('a -&gt; 'b -&gt; 'a Lwt.t) -&gt; 'a -&gt; 'b list -&gt; 'a Lwt.t

val fold_right_s : ('a -&gt; 'b -&gt; 'b Lwt.t) -&gt; 'a list -&gt; 'b -&gt; 'b Lwt.t

(** {2 List scanning} *)

val for_all_s : ('a -&gt; bool Lwt.t) -&gt; 'a list -&gt; bool Lwt.t

val for_all_p : ('a -&gt; bool Lwt.t) -&gt; 'a list -&gt; bool Lwt.t

val exists_s : ('a -&gt; bool Lwt.t) -&gt; 'a list -&gt; bool Lwt.t

val exists_p : ('a -&gt; bool Lwt.t) -&gt; 'a list -&gt; bool Lwt.t

(** {2 List searching} *)

val find_s : ('a -&gt; bool Lwt.t) -&gt; 'a list -&gt; 'a Lwt.t

val filter_s : ('a -&gt; bool Lwt.t) -&gt; 'a list -&gt; 'a list Lwt.t

val filter_p : ('a -&gt; bool Lwt.t) -&gt; 'a list -&gt; 'a list Lwt.t

val filter_map_s : ('a -&gt; 'b option Lwt.t) -&gt; 'a list -&gt; 'b list Lwt.t

val filter_map_p : ('a -&gt; 'b option Lwt.t) -&gt; 'a list -&gt; 'b list Lwt.t

val partition_s : ('a -&gt; bool Lwt.t) -&gt; 'a list -&gt; ('a list * 'a list) Lwt.t

val partition_p : ('a -&gt; bool Lwt.t) -&gt; 'a list -&gt; ('a list * 'a list) Lwt.t
end
module Raw_hashes : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/raw_hashes.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

val blake2b : MBytes.t -&gt; MBytes.t

val sha256 : MBytes.t -&gt; MBytes.t

val sha512 : MBytes.t -&gt; MBytes.t
end
module Compare : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/compare.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

module type COMPARABLE = sig
  type t

  val compare : t -&gt; t -&gt; int
end

module type S = sig
  type t

  val ( = ) : t -&gt; t -&gt; bool

  val ( &lt;&gt; ) : t -&gt; t -&gt; bool

  val ( &lt; ) : t -&gt; t -&gt; bool

  val ( &lt;= ) : t -&gt; t -&gt; bool

  val ( &gt;= ) : t -&gt; t -&gt; bool

  val ( &gt; ) : t -&gt; t -&gt; bool

  val compare : t -&gt; t -&gt; int

  val equal : t -&gt; t -&gt; bool

  val max : t -&gt; t -&gt; t

  val min : t -&gt; t -&gt; t
end

module Make (P : COMPARABLE) : S with type t := P.t

module Char : S with type t = char

module Bool : S with type t = bool

module Int : S with type t = int

module Int32 : S with type t = int32

module Uint32 : S with type t = int32

module Int64 : S with type t = int64

module Uint64 : S with type t = int64

module Float : S with type t = float

module String : S with type t = string

module Z : S with type t = Z.t

module List (P : COMPARABLE) : S with type t = P.t list

module Option (P : COMPARABLE) : S with type t = P.t option
end
module Data_encoding : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/data_encoding.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** In memory JSON data *)
<abbr class="mark-warning" title="Polymorphic variant types are defined as standard algebraic types">type json =
  [ `O of (string * json) list
  | `Bool of bool
  | `Float of float
  | `A of json list
  | `Null
  | `String of string ]</abbr>

type json_schema

type 'a t

type 'a encoding = 'a t

<abbr class="mark-warning" title="No type known for the following variants: `Variable, `Fixed, `Dynamic">val classify : 'a encoding -&gt; [`Fixed of int | `Dynamic | `Variable]</abbr>

val splitted : json:'a encoding -&gt; binary:'a encoding -&gt; 'a encoding

val null : unit encoding

val empty : unit encoding

val unit : unit encoding

val constant : string -&gt; unit encoding

val int8 : int encoding

val uint8 : int encoding

val int16 : int encoding

val uint16 : int encoding

val int31 : int encoding

val int32 : int32 encoding

val int64 : int64 encoding

val n : Z.t encoding

val z : Z.t encoding

val bool : bool encoding

val string : string encoding

val bytes : MBytes.t encoding

val float : float encoding

val option : 'a encoding -&gt; 'a option encoding

val string_enum : (string * 'a) list -&gt; 'a encoding

module Fixed : sig
  val string : int -&gt; string encoding

  val bytes : int -&gt; MBytes.t encoding

  val add_padding : 'a encoding -&gt; int -&gt; 'a encoding
end

module Variable : sig
  val string : string encoding

  val bytes : MBytes.t encoding

  val array : ?max_length:int -&gt; 'a encoding -&gt; 'a array encoding

  val list : ?max_length:int -&gt; 'a encoding -&gt; 'a list encoding
end

module Bounded : sig
  val string : int -&gt; string encoding

  val bytes : int -&gt; MBytes.t encoding
end

<abbr class="mark-warning" title="No type known for the following variants: `Uint16, `Uint8, `Uint30">val dynamic_size :
  ?kind:[`Uint30 | `Uint16 | `Uint8] -&gt; 'a encoding -&gt; 'a encoding</abbr>

val json : json encoding

val json_schema : json_schema encoding

type 'a field

val req :
  ?title:string -&gt; ?description:string -&gt; string -&gt; 't encoding -&gt; 't field

val opt :
  ?title:string -&gt;
  ?description:string -&gt;
  string -&gt;
  't encoding -&gt;
  't option field

val varopt :
  ?title:string -&gt;
  ?description:string -&gt;
  string -&gt;
  't encoding -&gt;
  't option field

val dft :
  ?title:string -&gt;
  ?description:string -&gt;
  string -&gt;
  't encoding -&gt;
  't -&gt;
  't field

val obj1 : 'f1 field -&gt; 'f1 encoding

val obj2 : 'f1 field -&gt; 'f2 field -&gt; ('f1 * 'f2) encoding

val obj3 : 'f1 field -&gt; 'f2 field -&gt; 'f3 field -&gt; ('f1 * 'f2 * 'f3) encoding

val obj4 :
  'f1 field -&gt;
  'f2 field -&gt;
  'f3 field -&gt;
  'f4 field -&gt;
  ('f1 * 'f2 * 'f3 * 'f4) encoding

val obj5 :
  'f1 field -&gt;
  'f2 field -&gt;
  'f3 field -&gt;
  'f4 field -&gt;
  'f5 field -&gt;
  ('f1 * 'f2 * 'f3 * 'f4 * 'f5) encoding

val obj6 :
  'f1 field -&gt;
  'f2 field -&gt;
  'f3 field -&gt;
  'f4 field -&gt;
  'f5 field -&gt;
  'f6 field -&gt;
  ('f1 * 'f2 * 'f3 * 'f4 * 'f5 * 'f6) encoding

val obj7 :
  'f1 field -&gt;
  'f2 field -&gt;
  'f3 field -&gt;
  'f4 field -&gt;
  'f5 field -&gt;
  'f6 field -&gt;
  'f7 field -&gt;
  ('f1 * 'f2 * 'f3 * 'f4 * 'f5 * 'f6 * 'f7) encoding

val obj8 :
  'f1 field -&gt;
  'f2 field -&gt;
  'f3 field -&gt;
  'f4 field -&gt;
  'f5 field -&gt;
  'f6 field -&gt;
  'f7 field -&gt;
  'f8 field -&gt;
  ('f1 * 'f2 * 'f3 * 'f4 * 'f5 * 'f6 * 'f7 * 'f8) encoding

val obj9 :
  'f1 field -&gt;
  'f2 field -&gt;
  'f3 field -&gt;
  'f4 field -&gt;
  'f5 field -&gt;
  'f6 field -&gt;
  'f7 field -&gt;
  'f8 field -&gt;
  'f9 field -&gt;
  ('f1 * 'f2 * 'f3 * 'f4 * 'f5 * 'f6 * 'f7 * 'f8 * 'f9) encoding

val obj10 :
  'f1 field -&gt;
  'f2 field -&gt;
  'f3 field -&gt;
  'f4 field -&gt;
  'f5 field -&gt;
  'f6 field -&gt;
  'f7 field -&gt;
  'f8 field -&gt;
  'f9 field -&gt;
  'f10 field -&gt;
  ('f1 * 'f2 * 'f3 * 'f4 * 'f5 * 'f6 * 'f7 * 'f8 * 'f9 * 'f10) encoding

val tup1 : 'f1 encoding -&gt; 'f1 encoding

val tup2 : 'f1 encoding -&gt; 'f2 encoding -&gt; ('f1 * 'f2) encoding

val tup3 :
  'f1 encoding -&gt; 'f2 encoding -&gt; 'f3 encoding -&gt; ('f1 * 'f2 * 'f3) encoding

val tup4 :
  'f1 encoding -&gt;
  'f2 encoding -&gt;
  'f3 encoding -&gt;
  'f4 encoding -&gt;
  ('f1 * 'f2 * 'f3 * 'f4) encoding

val tup5 :
  'f1 encoding -&gt;
  'f2 encoding -&gt;
  'f3 encoding -&gt;
  'f4 encoding -&gt;
  'f5 encoding -&gt;
  ('f1 * 'f2 * 'f3 * 'f4 * 'f5) encoding

val tup6 :
  'f1 encoding -&gt;
  'f2 encoding -&gt;
  'f3 encoding -&gt;
  'f4 encoding -&gt;
  'f5 encoding -&gt;
  'f6 encoding -&gt;
  ('f1 * 'f2 * 'f3 * 'f4 * 'f5 * 'f6) encoding

val tup7 :
  'f1 encoding -&gt;
  'f2 encoding -&gt;
  'f3 encoding -&gt;
  'f4 encoding -&gt;
  'f5 encoding -&gt;
  'f6 encoding -&gt;
  'f7 encoding -&gt;
  ('f1 * 'f2 * 'f3 * 'f4 * 'f5 * 'f6 * 'f7) encoding

val tup8 :
  'f1 encoding -&gt;
  'f2 encoding -&gt;
  'f3 encoding -&gt;
  'f4 encoding -&gt;
  'f5 encoding -&gt;
  'f6 encoding -&gt;
  'f7 encoding -&gt;
  'f8 encoding -&gt;
  ('f1 * 'f2 * 'f3 * 'f4 * 'f5 * 'f6 * 'f7 * 'f8) encoding

val tup9 :
  'f1 encoding -&gt;
  'f2 encoding -&gt;
  'f3 encoding -&gt;
  'f4 encoding -&gt;
  'f5 encoding -&gt;
  'f6 encoding -&gt;
  'f7 encoding -&gt;
  'f8 encoding -&gt;
  'f9 encoding -&gt;
  ('f1 * 'f2 * 'f3 * 'f4 * 'f5 * 'f6 * 'f7 * 'f8 * 'f9) encoding

val tup10 :
  'f1 encoding -&gt;
  'f2 encoding -&gt;
  'f3 encoding -&gt;
  'f4 encoding -&gt;
  'f5 encoding -&gt;
  'f6 encoding -&gt;
  'f7 encoding -&gt;
  'f8 encoding -&gt;
  'f9 encoding -&gt;
  'f10 encoding -&gt;
  ('f1 * 'f2 * 'f3 * 'f4 * 'f5 * 'f6 * 'f7 * 'f8 * 'f9 * 'f10) encoding

val merge_objs : 'o1 encoding -&gt; 'o2 encoding -&gt; ('o1 * 'o2) encoding

val merge_tups : 'a1 encoding -&gt; 'a2 encoding -&gt; ('a1 * 'a2) encoding

val array : ?max_length:int -&gt; 'a encoding -&gt; 'a array encoding

val list : ?max_length:int -&gt; 'a encoding -&gt; 'a list encoding

val assoc : 'a encoding -&gt; (string * 'a) list encoding

type case_tag = Tag of int | Json_only

type 't case

val case :
  title:string -&gt;
  ?description:string -&gt;
  case_tag -&gt;
  'a encoding -&gt;
  ('t -&gt; 'a option) -&gt;
  ('a -&gt; 't) -&gt;
  't case

<abbr class="mark-warning" title="Polymorphic variant types are defined as standard algebraic types">type tag_size = [`Uint8 | `Uint16]</abbr>

val union : ?tag_size:tag_size -&gt; 't case list -&gt; 't encoding

val def :
  string -&gt; ?title:string -&gt; ?description:string -&gt; 't encoding -&gt; 't encoding

val conv :
  ('a -&gt; 'b) -&gt; ('b -&gt; 'a) -&gt; ?schema:json_schema -&gt; 'b encoding -&gt; 'a encoding

val mu :
  string -&gt;
  ?title:string -&gt;
  ?description:string -&gt;
  ('a encoding -&gt; 'a encoding) -&gt;
  'a encoding

type 'a lazy_t

val lazy_encoding : 'a encoding -&gt; 'a lazy_t encoding

val force_decode : 'a lazy_t -&gt; 'a option

val force_bytes : 'a lazy_t -&gt; MBytes.t

val make_lazy : 'a encoding -&gt; 'a -&gt; 'a lazy_t

val apply_lazy :
  fun_value:('a -&gt; 'b) -&gt;
  fun_bytes:(MBytes.t -&gt; 'b) -&gt;
  fun_combine:('b -&gt; 'b -&gt; 'b) -&gt;
  'a lazy_t -&gt;
  'b

module Json : sig
  val schema : ?definitions_path:string -&gt; 'a encoding -&gt; json_schema

  val construct : 't encoding -&gt; 't -&gt; json

  val destruct : 't encoding -&gt; json -&gt; 't

  (** JSON Error *)

  type path = path_item list

  <abbr class="mark-warning" title="Polymorphic variant types are defined as standard algebraic types">and path_item =
    [ `Field of string  (** A field in an object. *)
    | `Index of int  (** An index in an array. *)
    | `Star  (** Any / every field or index. *)
    | `Next  (** The next element after an array. *) ]</abbr>

  (** Exception raised by destructors, with the location in the original
      JSON structure and the specific error. *)
  <abbr class="mark-warning" title="Signature item `exception` not handled">exception Cannot_destruct of (path * exn)</abbr>

  (** Unexpected kind of data encountered (w/ the expectation). *)
  <abbr class="mark-warning" title="Signature item `exception` not handled">exception Unexpected of string * string</abbr>

  (** Some {!union} couldn't be destructed, w/ the reasons for each {!case}. *)
  <abbr class="mark-warning" title="Signature item `exception` not handled">exception No_case_matched of exn list</abbr>

  (** Array of unexpected size encountered  (w/ the expectation). *)
  <abbr class="mark-warning" title="Signature item `exception` not handled">exception Bad_array_size of int * int</abbr>

  (** Missing field in an object. *)
  <abbr class="mark-warning" title="Signature item `exception` not handled">exception Missing_field of string</abbr>

  (** Supernumerary field in an object. *)
  <abbr class="mark-warning" title="Signature item `exception` not handled">exception Unexpected_field of string</abbr>

  val print_error :
    ?print_unknown:(Format.formatter -&gt; exn -&gt; unit) -&gt;
    Format.formatter -&gt;
    exn -&gt;
    unit

  (** Helpers for writing encoders. *)
  val cannot_destruct : ('a, Format.formatter, unit, 'b) format4 -&gt; 'a

  val wrap_error : ('a -&gt; 'b) -&gt; 'a -&gt; 'b

  val pp : Format.formatter -&gt; json -&gt; unit
end

module Binary : sig
  val length : 'a encoding -&gt; 'a -&gt; int

  val fixed_length : 'a encoding -&gt; int option

  val read : 'a encoding -&gt; MBytes.t -&gt; int -&gt; int -&gt; (int * 'a) option

  val write : 'a encoding -&gt; 'a -&gt; MBytes.t -&gt; int -&gt; int -&gt; int option

  val to_bytes : 'a encoding -&gt; 'a -&gt; MBytes.t option

  val to_bytes_exn : 'a encoding -&gt; 'a -&gt; MBytes.t

  val of_bytes : 'a encoding -&gt; MBytes.t -&gt; 'a option

  type write_error

  <abbr class="mark-warning" title="Signature item `exception` not handled">exception Write_error of write_error</abbr>
end

(** [check_size size encoding] ensures that the binary encoding
    of a value will not be allowed to exceed [size] bytes. The reader
    and the writer fails otherwise. This function do not modify
    the JSON encoding. *)
val check_size : int -&gt; 'a encoding -&gt; 'a encoding
end
module Error_monad : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/error_monad.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Tezos Protocol Implementation - Error Monad *)

(** {2 Error classification} *)

(** Categories of error *)
<abbr class="mark-warning" title="Polymorphic variant types are defined as standard algebraic types">type error_category =
  [ `Branch  (** Errors that may not happen in another context *)
  | `Temporary  (** Errors that may not happen in a later context *)
  | `Permanent  (** Errors that will happen no matter the context *) ]</abbr>

(** Custom error handling for economic protocols. *)

<abbr class="mark-warning" title="Extensible types are not handled">type error = ..</abbr>

val pp : Format.formatter -&gt; error -&gt; unit

(** A JSON error serializer *)
val error_encoding : error Data_encoding.t

val json_of_error : error -&gt; Data_encoding.json

val error_of_json : Data_encoding.json -&gt; error

(** Error information *)
type error_info = {
  category : error_category;
  id : string;
  title : string;
  description : string;
  schema : Data_encoding.json_schema;
}

val pp_info : Format.formatter -&gt; error_info -&gt; unit

(** Retrieves information of registered errors *)
val get_registered_errors : unit -&gt; error_info list

(** For other modules to register specialized error serializers *)
val register_error_kind :
  error_category -&gt;
  id:string -&gt;
  title:string -&gt;
  description:string -&gt;
  ?pp:(Format.formatter -&gt; 'err -&gt; unit) -&gt;
  'err Data_encoding.t -&gt;
  (error -&gt; 'err option) -&gt;
  ('err -&gt; error) -&gt;
  unit

(** Classify an error using the registered kinds *)
val classify_errors : error list -&gt; error_category

(** {2 Monad definition} *)

(** The error monad wrapper type, the error case holds a stack of
    error, initialized by the first call to {!fail} and completed by
    each call to {!trace} as the stack is rewinded. The most general
    error is thus at the top of the error stack, going down to the
    specific error that actually caused the failure. *)
type 'a tzresult = ('a, error list) result

(** A JSON serializer for result of a given type *)
val result_encoding : 'a Data_encoding.t -&gt; 'a tzresult Data_encoding.encoding

(** Sucessful result *)
val ok : 'a -&gt; 'a tzresult

(** Sucessful return *)
val return : 'a -&gt; 'a tzresult Lwt.t

(** Sucessful return of [()] *)
val return_unit : unit tzresult Lwt.t

(** Sucessful return of [None] *)
val return_none : 'a option tzresult Lwt.t

(** [return_some x] is a sucessful return of [Some x] *)
val return_some : 'a -&gt; 'a option tzresult Lwt.t

(** Sucessful return of [[]] *)
val return_nil : 'a list tzresult Lwt.t

(** Sucessful return of [true] *)
val return_true : bool tzresult Lwt.t

(** Sucessful return of [false] *)
val return_false : bool tzresult Lwt.t

(** Erroneous result *)
val error : error -&gt; 'a tzresult

(** Erroneous return *)
val fail : error -&gt; 'a tzresult Lwt.t

(** Non-Lwt bind operator *)
val ( &gt;&gt;? ) : 'a tzresult -&gt; ('a -&gt; 'b tzresult) -&gt; 'b tzresult

(** Bind operator *)
val ( &gt;&gt;=? ) :
  'a tzresult Lwt.t -&gt; ('a -&gt; 'b tzresult Lwt.t) -&gt; 'b tzresult Lwt.t

(** Lwt's bind reexported *)
val ( &gt;&gt;= ) : 'a Lwt.t -&gt; ('a -&gt; 'b Lwt.t) -&gt; 'b Lwt.t

val ( &gt;|= ) : 'a Lwt.t -&gt; ('a -&gt; 'b) -&gt; 'b Lwt.t

(** To operator *)
val ( &gt;&gt;|? ) : 'a tzresult Lwt.t -&gt; ('a -&gt; 'b) -&gt; 'b tzresult Lwt.t

(** Non-Lwt to operator *)
val ( &gt;|? ) : 'a tzresult -&gt; ('a -&gt; 'b) -&gt; 'b tzresult

(** Enrich an error report (or do nothing on a successful result) manually *)
val record_trace : error -&gt; 'a tzresult -&gt; 'a tzresult

(** Automatically enrich error reporting on stack rewind *)
val trace : error -&gt; 'b tzresult Lwt.t -&gt; 'b tzresult Lwt.t

(** Same as record_trace, for unevaluated error *)
val record_trace_eval : (unit -&gt; error tzresult) -&gt; 'a tzresult -&gt; 'a tzresult

(** Same as trace, for unevaluated Lwt error *)
val trace_eval :
  (unit -&gt; error tzresult Lwt.t) -&gt; 'b tzresult Lwt.t -&gt; 'b tzresult Lwt.t

(** Erroneous return on failed assertion *)
val fail_unless : bool -&gt; error -&gt; unit tzresult Lwt.t

(** Erroneous return on successful assertion *)
val fail_when : bool -&gt; error -&gt; unit tzresult Lwt.t

(** {2 In-monad list iterators} *)

(** A {!List.iter} in the monad *)
val iter_s : ('a -&gt; unit tzresult Lwt.t) -&gt; 'a list -&gt; unit tzresult Lwt.t

val iter_p : ('a -&gt; unit tzresult Lwt.t) -&gt; 'a list -&gt; unit tzresult Lwt.t

(** A {!List.map} in the monad *)
val map_s : ('a -&gt; 'b tzresult Lwt.t) -&gt; 'a list -&gt; 'b list tzresult Lwt.t

val map_p : ('a -&gt; 'b tzresult Lwt.t) -&gt; 'a list -&gt; 'b list tzresult Lwt.t

(** A {!List.map2} in the monad *)
val map2 : ('a -&gt; 'b -&gt; 'c tzresult) -&gt; 'a list -&gt; 'b list -&gt; 'c list tzresult

(** A {!List.map2} in the monad *)
val map2_s :
  ('a -&gt; 'b -&gt; 'c tzresult Lwt.t) -&gt;
  'a list -&gt;
  'b list -&gt;
  'c list tzresult Lwt.t

(** A {!List.filter_map} in the monad *)
val filter_map_s :
  ('a -&gt; 'b option tzresult Lwt.t) -&gt; 'a list -&gt; 'b list tzresult Lwt.t

(** A {!List.fold_left} in the monad *)
val fold_left_s :
  ('a -&gt; 'b -&gt; 'a tzresult Lwt.t) -&gt; 'a -&gt; 'b list -&gt; 'a tzresult Lwt.t

(** A {!List.fold_right} in the monad *)
val fold_right_s :
  ('a -&gt; 'b -&gt; 'b tzresult Lwt.t) -&gt; 'a list -&gt; 'b -&gt; 'b tzresult Lwt.t

(**/**)

type shell_error

type 'a shell_tzresult = ('a, shell_error list) result
end
open Error_monad
module Logging : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/logging.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

val debug : ('a, Format.formatter, unit, unit) format4 -&gt; 'a

val log_info : ('a, Format.formatter, unit, unit) format4 -&gt; 'a

val log_notice : ('a, Format.formatter, unit, unit) format4 -&gt; 'a

val warn : ('a, Format.formatter, unit, unit) format4 -&gt; 'a

val log_error : ('a, Format.formatter, unit, unit) format4 -&gt; 'a

val fatal_error : ('a, Format.formatter, unit, unit) format4 -&gt; 'a

val lwt_debug : ('a, Format.formatter, unit, unit Lwt.t) format4 -&gt; 'a

val lwt_log_info : ('a, Format.formatter, unit, unit Lwt.t) format4 -&gt; 'a

val lwt_log_notice : ('a, Format.formatter, unit, unit Lwt.t) format4 -&gt; 'a

val lwt_warn : ('a, Format.formatter, unit, unit Lwt.t) format4 -&gt; 'a

val lwt_log_error : ('a, Format.formatter, unit, unit Lwt.t) format4 -&gt; 'a
end
module Time : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/time.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t

include Compare.S with type t := t

val add : t -&gt; int64 -&gt; t

val diff : t -&gt; t -&gt; int64

val of_seconds : int64 -&gt; t

val to_seconds : t -&gt; int64

val of_notation : string -&gt; t option

val of_notation_exn : string -&gt; t

val to_notation : t -&gt; string

val encoding : t Data_encoding.t

val rfc_encoding : t Data_encoding.t

val pp_hum : Format.formatter -&gt; t -&gt; unit
end
module Option : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/option.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

val map : f:('a -&gt; 'b) -&gt; 'a option -&gt; 'b option

val apply : f:('a -&gt; 'b option) -&gt; 'a option -&gt; 'b option

val iter : f:('a -&gt; unit) -&gt; 'a option -&gt; unit

val unopt : default:'a -&gt; 'a option -&gt; 'a

val unopt_map : f:('a -&gt; 'b) -&gt; default:'b -&gt; 'a option -&gt; 'b

val first_some : 'a option -&gt; 'a option -&gt; 'a option

val try_with : (unit -&gt; 'a) -&gt; 'a option

val some : 'a -&gt; 'a option
end
module RPC_arg : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/RPC_arg.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type 'a t

type 'a arg = 'a t

val make :
  ?descr:string -&gt;
  name:string -&gt;
  destruct:(string -&gt; ('a, string) result) -&gt;
  construct:('a -&gt; string) -&gt;
  unit -&gt;
  'a arg

type descr = {name : string; descr : string option}

val descr : 'a arg -&gt; descr

val int : int arg

val int32 : int32 arg

val int64 : int64 arg

val float : float arg

val string : string arg

val like : 'a arg -&gt; ?descr:string -&gt; string -&gt; 'a arg

type ('a, 'b) eq = Eq : ('a, 'a) eq

val eq : 'a arg -&gt; 'b arg -&gt; ('a, 'b) eq option
end
module RPC_path : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/RPC_path.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type ('prefix, 'params) t

type ('prefix, 'params) path = ('prefix, 'params) t

type 'prefix context = ('prefix, 'prefix) path

val root : unit context

val open_root : 'a context

val add_suffix : ('prefix, 'params) path -&gt; string -&gt; ('prefix, 'params) path

val ( / ) : ('prefix, 'params) path -&gt; string -&gt; ('prefix, 'params) path

val add_arg :
  ('prefix, 'params) path -&gt; 'a RPC_arg.t -&gt; ('prefix, 'params * 'a) path

val ( /: ) :
  ('prefix, 'params) path -&gt; 'a RPC_arg.t -&gt; ('prefix, 'params * 'a) path

val add_final_args :
  ('prefix, 'params) path -&gt; 'a RPC_arg.t -&gt; ('prefix, 'params * 'a list) path

val ( /:* ) :
  ('prefix, 'params) path -&gt; 'a RPC_arg.t -&gt; ('prefix, 'params * 'a list) path
end
module RPC_query : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/RPC_query.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type 'a t

type 'a query = 'a t

val empty : unit query

type ('a, 'b) field

val field :
  ?descr:string -&gt; string -&gt; 'a RPC_arg.t -&gt; 'a -&gt; ('b -&gt; 'a) -&gt; ('b, 'a) field

val opt_field :
  ?descr:string -&gt;
  string -&gt;
  'a RPC_arg.t -&gt;
  ('b -&gt; 'a option) -&gt;
  ('b, 'a option) field

val flag : ?descr:string -&gt; string -&gt; ('b -&gt; bool) -&gt; ('b, bool) field

val multi_field :
  ?descr:string -&gt;
  string -&gt;
  'a RPC_arg.t -&gt;
  ('b -&gt; 'a list) -&gt;
  ('b, 'a list) field

type ('a, 'b, 'c) open_query

val query : 'b -&gt; ('a, 'b, 'b) open_query

val ( |+ ) :
  ('a, 'b, 'c -&gt; 'd) open_query -&gt; ('a, 'c) field -&gt; ('a, 'b, 'd) open_query

val seal : ('a, 'b, 'a) open_query -&gt; 'a t

type untyped = (string * string) list

<abbr class="mark-warning" title="Signature item `exception` not handled">exception Invalid of string</abbr>

val parse : 'a query -&gt; untyped -&gt; 'a
end
module RPC_service : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/RPC_service.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** HTTP methods. *)
<abbr class="mark-warning" title="Polymorphic variant types are defined as standard algebraic types">type meth = [`GET | `POST | `DELETE | `PUT | `PATCH]</abbr>

<abbr class="mark-warning" title="Expected a list of named or unspecified '_' type variables">type (+'meth, 'prefix, 'params, 'query, 'input, 'output) t
  constraint 'meth = [&lt; meth]</abbr>

<abbr class="mark-warning" title="Expected a list of named or unspecified '_' type variables">type (+'meth, 'prefix, 'params, 'query, 'input, 'output) service =
  ('meth, 'prefix, 'params, 'query, 'input, 'output) t</abbr>

val get_service :
  ?description:string -&gt;
  query:'query RPC_query.t -&gt;
  output:'output Data_encoding.t -&gt;
  ('prefix, 'params) RPC_path.t -&gt;
  ([`GET], 'prefix, 'params, 'query, unit, 'output) service

val post_service :
  ?description:string -&gt;
  query:'query RPC_query.t -&gt;
  input:'input Data_encoding.t -&gt;
  output:'output Data_encoding.t -&gt;
  ('prefix, 'params) RPC_path.t -&gt;
  ([`POST], 'prefix, 'params, 'query, 'input, 'output) service

val delete_service :
  ?description:string -&gt;
  query:'query RPC_query.t -&gt;
  output:'output Data_encoding.t -&gt;
  ('prefix, 'params) RPC_path.t -&gt;
  ([`DELETE], 'prefix, 'params, 'query, unit, 'output) service

val patch_service :
  ?description:string -&gt;
  query:'query RPC_query.t -&gt;
  input:'input Data_encoding.t -&gt;
  output:'output Data_encoding.t -&gt;
  ('prefix, 'params) RPC_path.t -&gt;
  ([`PATCH], 'prefix, 'params, 'query, 'input, 'output) service

val put_service :
  ?description:string -&gt;
  query:'query RPC_query.t -&gt;
  input:'input Data_encoding.t -&gt;
  output:'output Data_encoding.t -&gt;
  ('prefix, 'params) RPC_path.t -&gt;
  ([`PUT], 'prefix, 'params, 'query, 'input, 'output) service
end
module RPC_answer : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/RPC_answer.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Return type for service handler *)
<abbr class="mark-warning" title="Polymorphic variant types are defined as standard algebraic types">type 'o t =
  [ `Ok of 'o (* 200 *)
  | `OkStream of 'o stream (* 200 *)
  | `Created of string option (* 201 *)
  | `No_content (* 204 *)
  | `Unauthorized of error list option (* 401 *)
  | `Forbidden of error list option (* 403 *)
  | `Not_found of error list option (* 404 *)
  | `Conflict of error list option (* 409 *)
  | `Error of error list option (* 500 *) ]</abbr>

and 'a stream = {next : unit -&gt; 'a option Lwt.t; shutdown : unit -&gt; unit}

val return : 'o -&gt; 'o t Lwt.t

val return_stream : 'o stream -&gt; 'o t Lwt.t

val not_found : 'o t Lwt.t

val fail : error list -&gt; 'a t Lwt.t
end
module RPC_directory : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/RPC_directory.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Dispatch tree *)
type 'prefix t

type 'prefix directory = 'prefix t

(** Empty list of dispatch trees *)
val empty : 'prefix directory

val map : ('a -&gt; 'b Lwt.t) -&gt; 'b directory -&gt; 'a directory

val prefix : ('pr, 'p) RPC_path.path -&gt; 'p directory -&gt; 'pr directory

val merge : 'a directory -&gt; 'a directory -&gt; 'a directory

(** Possible error while registring services. *)
type step =
  | Static of string
  | Dynamic of RPC_arg.descr
  | DynamicTail of RPC_arg.descr

type conflict =
  | CService of RPC_service.meth
  | CDir
  | CBuilder
  | CTail
  | CTypes of RPC_arg.descr * RPC_arg.descr
  | CType of RPC_arg.descr * string list

<abbr class="mark-warning" title="Signature item `exception` not handled">exception Conflict of step list * conflict</abbr>

(** Registring handler in service tree. *)
val register :
  'prefix directory -&gt;
  ('meth, 'prefix, 'params, 'query, 'input, 'output) RPC_service.t -&gt;
  ('params -&gt; 'query -&gt; 'input -&gt; 'output tzresult Lwt.t) -&gt;
  'prefix directory

val opt_register :
  'prefix directory -&gt;
  ('meth, 'prefix, 'params, 'query, 'input, 'output) RPC_service.t -&gt;
  ('params -&gt; 'query -&gt; 'input -&gt; 'output option tzresult Lwt.t) -&gt;
  'prefix directory

<abbr class="mark-warning" title="No type known for the following variants: `OkStream, `Unauthorized, `Error, `Ok, `Not_found, `Forbidden, `Created, `Conflict, `No_content">val gen_register :
  'prefix directory -&gt;
  ('meth, 'prefix, 'params, 'query, 'input, 'output) RPC_service.t -&gt;
  ('params -&gt; 'query -&gt; 'input -&gt; [&lt; 'output RPC_answer.t] Lwt.t) -&gt;
  'prefix directory</abbr>

val lwt_register :
  'prefix directory -&gt;
  ('meth, 'prefix, 'params, 'query, 'input, 'output) RPC_service.t -&gt;
  ('params -&gt; 'query -&gt; 'input -&gt; 'output Lwt.t) -&gt;
  'prefix directory

(** Registring handler in service tree. Curryfied variant.  *)

val register0 :
  unit directory -&gt;
  ('m, unit, unit, 'q, 'i, 'o) RPC_service.t -&gt;
  ('q -&gt; 'i -&gt; 'o tzresult Lwt.t) -&gt;
  unit directory

val register1 :
  'prefix directory -&gt;
  ('m, 'prefix, unit * 'a, 'q, 'i, 'o) RPC_service.t -&gt;
  ('a -&gt; 'q -&gt; 'i -&gt; 'o tzresult Lwt.t) -&gt;
  'prefix directory

val register2 :
  'prefix directory -&gt;
  ('m, 'prefix, (unit * 'a) * 'b, 'q, 'i, 'o) RPC_service.t -&gt;
  ('a -&gt; 'b -&gt; 'q -&gt; 'i -&gt; 'o tzresult Lwt.t) -&gt;
  'prefix directory

val register3 :
  'prefix directory -&gt;
  ('m, 'prefix, ((unit * 'a) * 'b) * 'c, 'q, 'i, 'o) RPC_service.t -&gt;
  ('a -&gt; 'b -&gt; 'c -&gt; 'q -&gt; 'i -&gt; 'o tzresult Lwt.t) -&gt;
  'prefix directory

val register4 :
  'prefix directory -&gt;
  ('m, 'prefix, (((unit * 'a) * 'b) * 'c) * 'd, 'q, 'i, 'o) RPC_service.t -&gt;
  ('a -&gt; 'b -&gt; 'c -&gt; 'd -&gt; 'q -&gt; 'i -&gt; 'o tzresult Lwt.t) -&gt;
  'prefix directory

val register5 :
  'prefix directory -&gt;
  ( 'm,
    'prefix,
    ((((unit * 'a) * 'b) * 'c) * 'd) * 'e,
    'q,
    'i,
    'o )
  RPC_service.t -&gt;
  ('a -&gt; 'b -&gt; 'c -&gt; 'd -&gt; 'e -&gt; 'q -&gt; 'i -&gt; 'o tzresult Lwt.t) -&gt;
  'prefix directory

val opt_register0 :
  unit directory -&gt;
  ('m, unit, unit, 'q, 'i, 'o) RPC_service.t -&gt;
  ('q -&gt; 'i -&gt; 'o option tzresult Lwt.t) -&gt;
  unit directory

val opt_register1 :
  'prefix directory -&gt;
  ('m, 'prefix, unit * 'a, 'q, 'i, 'o) RPC_service.t -&gt;
  ('a -&gt; 'q -&gt; 'i -&gt; 'o option tzresult Lwt.t) -&gt;
  'prefix directory

val opt_register2 :
  'prefix directory -&gt;
  ('m, 'prefix, (unit * 'a) * 'b, 'q, 'i, 'o) RPC_service.t -&gt;
  ('a -&gt; 'b -&gt; 'q -&gt; 'i -&gt; 'o option tzresult Lwt.t) -&gt;
  'prefix directory

val opt_register3 :
  'prefix directory -&gt;
  ('m, 'prefix, ((unit * 'a) * 'b) * 'c, 'q, 'i, 'o) RPC_service.t -&gt;
  ('a -&gt; 'b -&gt; 'c -&gt; 'q -&gt; 'i -&gt; 'o option tzresult Lwt.t) -&gt;
  'prefix directory

val opt_register4 :
  'prefix directory -&gt;
  ('m, 'prefix, (((unit * 'a) * 'b) * 'c) * 'd, 'q, 'i, 'o) RPC_service.t -&gt;
  ('a -&gt; 'b -&gt; 'c -&gt; 'd -&gt; 'q -&gt; 'i -&gt; 'o option tzresult Lwt.t) -&gt;
  'prefix directory

val opt_register5 :
  'prefix directory -&gt;
  ( 'm,
    'prefix,
    ((((unit * 'a) * 'b) * 'c) * 'd) * 'e,
    'q,
    'i,
    'o )
  RPC_service.t -&gt;
  ('a -&gt; 'b -&gt; 'c -&gt; 'd -&gt; 'e -&gt; 'q -&gt; 'i -&gt; 'o option tzresult Lwt.t) -&gt;
  'prefix directory

<abbr class="mark-warning" title="No type known for the following variants: `OkStream, `Unauthorized, `Error, `Ok, `Not_found, `Forbidden, `Created, `Conflict, `No_content">val gen_register0 :
  unit directory -&gt;
  ('m, unit, unit, 'q, 'i, 'o) RPC_service.t -&gt;
  ('q -&gt; 'i -&gt; [&lt; 'o RPC_answer.t] Lwt.t) -&gt;
  unit directory</abbr>

<abbr class="mark-warning" title="No type known for the following variants: `OkStream, `Unauthorized, `Error, `Ok, `Not_found, `Forbidden, `Created, `Conflict, `No_content">val gen_register1 :
  'prefix directory -&gt;
  ('m, 'prefix, unit * 'a, 'q, 'i, 'o) RPC_service.t -&gt;
  ('a -&gt; 'q -&gt; 'i -&gt; [&lt; 'o RPC_answer.t] Lwt.t) -&gt;
  'prefix directory</abbr>

<abbr class="mark-warning" title="No type known for the following variants: `OkStream, `Unauthorized, `Error, `Ok, `Not_found, `Forbidden, `Created, `Conflict, `No_content">val gen_register2 :
  'prefix directory -&gt;
  ('m, 'prefix, (unit * 'a) * 'b, 'q, 'i, 'o) RPC_service.t -&gt;
  ('a -&gt; 'b -&gt; 'q -&gt; 'i -&gt; [&lt; 'o RPC_answer.t] Lwt.t) -&gt;
  'prefix directory</abbr>

<abbr class="mark-warning" title="No type known for the following variants: `OkStream, `Unauthorized, `Error, `Ok, `Not_found, `Forbidden, `Created, `Conflict, `No_content">val gen_register3 :
  'prefix directory -&gt;
  ('m, 'prefix, ((unit * 'a) * 'b) * 'c, 'q, 'i, 'o) RPC_service.t -&gt;
  ('a -&gt; 'b -&gt; 'c -&gt; 'q -&gt; 'i -&gt; [&lt; 'o RPC_answer.t] Lwt.t) -&gt;
  'prefix directory</abbr>

<abbr class="mark-warning" title="No type known for the following variants: `OkStream, `Unauthorized, `Error, `Ok, `Not_found, `Forbidden, `Created, `Conflict, `No_content">val gen_register4 :
  'prefix directory -&gt;
  ('m, 'prefix, (((unit * 'a) * 'b) * 'c) * 'd, 'q, 'i, 'o) RPC_service.t -&gt;
  ('a -&gt; 'b -&gt; 'c -&gt; 'd -&gt; 'q -&gt; 'i -&gt; [&lt; 'o RPC_answer.t] Lwt.t) -&gt;
  'prefix directory</abbr>

<abbr class="mark-warning" title="No type known for the following variants: `OkStream, `Unauthorized, `Error, `Ok, `Not_found, `Forbidden, `Created, `Conflict, `No_content">val gen_register5 :
  'prefix directory -&gt;
  ( 'm,
    'prefix,
    ((((unit * 'a) * 'b) * 'c) * 'd) * 'e,
    'q,
    'i,
    'o )
  RPC_service.t -&gt;
  ('a -&gt; 'b -&gt; 'c -&gt; 'd -&gt; 'e -&gt; 'q -&gt; 'i -&gt; [&lt; 'o RPC_answer.t] Lwt.t) -&gt;
  'prefix directory</abbr>

val lwt_register0 :
  unit directory -&gt;
  ('m, unit, unit, 'q, 'i, 'o) RPC_service.t -&gt;
  ('q -&gt; 'i -&gt; 'o Lwt.t) -&gt;
  unit directory

val lwt_register1 :
  'prefix directory -&gt;
  ('m, 'prefix, unit * 'a, 'q, 'i, 'o) RPC_service.t -&gt;
  ('a -&gt; 'q -&gt; 'i -&gt; 'o Lwt.t) -&gt;
  'prefix directory

val lwt_register2 :
  'prefix directory -&gt;
  ('m, 'prefix, (unit * 'a) * 'b, 'q, 'i, 'o) RPC_service.t -&gt;
  ('a -&gt; 'b -&gt; 'q -&gt; 'i -&gt; 'o Lwt.t) -&gt;
  'prefix directory

val lwt_register3 :
  'prefix directory -&gt;
  ('m, 'prefix, ((unit * 'a) * 'b) * 'c, 'q, 'i, 'o) RPC_service.t -&gt;
  ('a -&gt; 'b -&gt; 'c -&gt; 'q -&gt; 'i -&gt; 'o Lwt.t) -&gt;
  'prefix directory

val lwt_register4 :
  'prefix directory -&gt;
  ('m, 'prefix, (((unit * 'a) * 'b) * 'c) * 'd, 'q, 'i, 'o) RPC_service.t -&gt;
  ('a -&gt; 'b -&gt; 'c -&gt; 'd -&gt; 'q -&gt; 'i -&gt; 'o Lwt.t) -&gt;
  'prefix directory

val lwt_register5 :
  'prefix directory -&gt;
  ( 'm,
    'prefix,
    ((((unit * 'a) * 'b) * 'c) * 'd) * 'e,
    'q,
    'i,
    'o )
  RPC_service.t -&gt;
  ('a -&gt; 'b -&gt; 'c -&gt; 'd -&gt; 'e -&gt; 'q -&gt; 'i -&gt; 'o Lwt.t) -&gt;
  'prefix directory

(** Registring dynamic subtree. *)
val register_dynamic_directory :
  ?descr:string -&gt;
  'prefix directory -&gt;
  ('prefix, 'a) RPC_path.t -&gt;
  ('a -&gt; 'a directory Lwt.t) -&gt;
  'prefix directory
end
module Base58 : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/base58.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type 'a encoding

val simple_decode : 'a encoding -&gt; string -&gt; 'a option

val simple_encode : 'a encoding -&gt; 'a -&gt; string

<abbr class="mark-warning" title="Extensible types are not handled">type data = ..</abbr>

val register_encoding :
  prefix:string -&gt;
  length:int -&gt;
  to_raw:('a -&gt; string) -&gt;
  of_raw:(string -&gt; 'a option) -&gt;
  wrap:('a -&gt; data) -&gt;
  'a encoding

val check_encoded_prefix : 'a encoding -&gt; string -&gt; int -&gt; unit

val decode : string -&gt; data option
end
module S : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/s.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Generic interface for a datatype with comparison, pretty-printer
    and serialization functions. *)
module type T = sig
  type t

  include Compare.S with type t := t

  val pp : Format.formatter -&gt; t -&gt; unit

  val encoding : t Data_encoding.t

  val to_bytes : t -&gt; MBytes.t

  val of_bytes : MBytes.t -&gt; t option
end

(** Generic interface for a datatype with comparison, pretty-printer,
    serialization functions and a hashing function. *)
module type HASHABLE = sig
  include T

  type hash

  val hash : t -&gt; hash

  val hash_raw : MBytes.t -&gt; hash
end

(** {2 Hash Types} *)

(** The signature of an abstract hash type, as produced by functor
    {!Make_SHA256}. The {!t} type is abstracted for separating the
    various kinds of hashes in the system at typing time. Each type is
    equipped with functions to use it as is of as keys in the database
    or in memory sets and maps. *)

module type MINIMAL_HASH = sig
  type t

  val name : string

  val title : string

  val pp : Format.formatter -&gt; t -&gt; unit

  val pp_short : Format.formatter -&gt; t -&gt; unit

  include Compare.S with type t := t

  val hash_bytes : ?key:MBytes.t -&gt; MBytes.t list -&gt; t

  val hash_string : ?key:string -&gt; string list -&gt; t

  val zero : t
end

module type RAW_DATA = sig
  type t

  val size : int (* in bytes *)

  val to_bytes : t -&gt; MBytes.t

  val of_bytes_opt : MBytes.t -&gt; t option

  val of_bytes_exn : MBytes.t -&gt; t
end

module type B58_DATA = sig
  type t

  val to_b58check : t -&gt; string

  val to_short_b58check : t -&gt; string

  val of_b58check_exn : string -&gt; t

  val of_b58check_opt : string -&gt; t option

  <abbr class="mark-warning" title="Extensible types are not handled.">type Base58.data += Data of t</abbr>

  val b58check_encoding : t Base58.encoding
end

module type ENCODER = sig
  type t

  val encoding : t Data_encoding.t

  val rpc_arg : t RPC_arg.t
end

module type SET = sig
  type elt

  type t

  val empty : t

  val is_empty : t -&gt; bool

  val mem : elt -&gt; t -&gt; bool

  val add : elt -&gt; t -&gt; t

  val singleton : elt -&gt; t

  val remove : elt -&gt; t -&gt; t

  val union : t -&gt; t -&gt; t

  val inter : t -&gt; t -&gt; t

  val diff : t -&gt; t -&gt; t

  val compare : t -&gt; t -&gt; int

  val equal : t -&gt; t -&gt; bool

  val subset : t -&gt; t -&gt; bool

  val iter : (elt -&gt; unit) -&gt; t -&gt; unit

  val map : (elt -&gt; elt) -&gt; t -&gt; t

  val fold : (elt -&gt; 'a -&gt; 'a) -&gt; t -&gt; 'a -&gt; 'a

  val for_all : (elt -&gt; bool) -&gt; t -&gt; bool

  val exists : (elt -&gt; bool) -&gt; t -&gt; bool

  val filter : (elt -&gt; bool) -&gt; t -&gt; t

  val partition : (elt -&gt; bool) -&gt; t -&gt; t * t

  val cardinal : t -&gt; int

  val elements : t -&gt; elt list

  val min_elt_opt : t -&gt; elt option

  val max_elt_opt : t -&gt; elt option

  val choose_opt : t -&gt; elt option

  val split : elt -&gt; t -&gt; t * bool * t

  val find_opt : elt -&gt; t -&gt; elt option

  val find_first_opt : (elt -&gt; bool) -&gt; t -&gt; elt option

  val find_last_opt : (elt -&gt; bool) -&gt; t -&gt; elt option

  val of_list : elt list -&gt; t
end

module type MAP = sig
  type key

  type +'a t

  val empty : 'a t

  val is_empty : 'a t -&gt; bool

  val mem : key -&gt; 'a t -&gt; bool

  val add : key -&gt; 'a -&gt; 'a t -&gt; 'a t

  val update : key -&gt; ('a option -&gt; 'a option) -&gt; 'a t -&gt; 'a t

  val singleton : key -&gt; 'a -&gt; 'a t

  val remove : key -&gt; 'a t -&gt; 'a t

  val merge :
    (key -&gt; 'a option -&gt; 'b option -&gt; 'c option) -&gt; 'a t -&gt; 'b t -&gt; 'c t

  val union : (key -&gt; 'a -&gt; 'a -&gt; 'a option) -&gt; 'a t -&gt; 'a t -&gt; 'a t

  val compare : ('a -&gt; 'a -&gt; int) -&gt; 'a t -&gt; 'a t -&gt; int

  val equal : ('a -&gt; 'a -&gt; bool) -&gt; 'a t -&gt; 'a t -&gt; bool

  val iter : (key -&gt; 'a -&gt; unit) -&gt; 'a t -&gt; unit

  val fold : (key -&gt; 'a -&gt; 'b -&gt; 'b) -&gt; 'a t -&gt; 'b -&gt; 'b

  val for_all : (key -&gt; 'a -&gt; bool) -&gt; 'a t -&gt; bool

  val exists : (key -&gt; 'a -&gt; bool) -&gt; 'a t -&gt; bool

  val filter : (key -&gt; 'a -&gt; bool) -&gt; 'a t -&gt; 'a t

  val partition : (key -&gt; 'a -&gt; bool) -&gt; 'a t -&gt; 'a t * 'a t

  val cardinal : 'a t -&gt; int

  val bindings : 'a t -&gt; (key * 'a) list

  val min_binding_opt : 'a t -&gt; (key * 'a) option

  val max_binding_opt : 'a t -&gt; (key * 'a) option

  val choose_opt : 'a t -&gt; (key * 'a) option

  val split : key -&gt; 'a t -&gt; 'a t * 'a option * 'a t

  val find_opt : key -&gt; 'a t -&gt; 'a option

  val find_first_opt : (key -&gt; bool) -&gt; 'a t -&gt; (key * 'a) option

  val find_last_opt : (key -&gt; bool) -&gt; 'a t -&gt; (key * 'a) option

  val map : ('a -&gt; 'b) -&gt; 'a t -&gt; 'b t

  val mapi : (key -&gt; 'a -&gt; 'b) -&gt; 'a t -&gt; 'b t
end

module type INDEXES_Set = sig
  include Stdlib.Set.S

  val encoding : t Data_encoding.t
end

module type INDEXES_Map = sig
  include Stdlib.Map.S

  val encoding : 'a Data_encoding.t -&gt; 'a t Data_encoding.t
end

module type INDEXES = sig
  type t

  val to_path : t -&gt; string list -&gt; string list

  val of_path : string list -&gt; t option

  val of_path_exn : string list -&gt; t

  val prefix_path : string -&gt; string list

  val path_length : int

  module Set : INDEXES_Set with type elt = t

  module Map : INDEXES_Map with type key = t
end

module type HASH = sig
  include MINIMAL_HASH

  include RAW_DATA with type t := t

  <abbr class="mark-warning" title="Extensible type 'Base58.data' not handled">include B58_DATA with type t := t</abbr>

  include ENCODER with type t := t

  <abbr class="mark-warning" title="Sub-module 'Map' in included signature.

Sub-modules in included signatures are not handled well yet. It does not work if there are destructive type substitutions (:=) in the sub-module or type definitions in the sub-module's source signature. We do not develop this feature further as it is working in our cases.

A safer way is to make a sub-module instead of an `include`.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Sub-module 'Set' in included signature.

Sub-modules in included signatures are not handled well yet. It does not work if there are destructive type substitutions (:=) in the sub-module or type definitions in the sub-module's source signature. We do not develop this feature further as it is working in our cases.

A safer way is to make a sub-module instead of an `include`.">include INDEXES with type t := t</abbr>
end

module type MERKLE_TREE = sig
  type elt

  <abbr class="mark-warning" title="Sub-module 'Map' in included signature.

Sub-modules in included signatures are not handled well yet. It does not work if there are destructive type substitutions (:=) in the sub-module or type definitions in the sub-module's source signature. We do not develop this feature further as it is working in our cases.

A safer way is to make a sub-module instead of an `include`.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Sub-module 'Set' in included signature.

Sub-modules in included signatures are not handled well yet. It does not work if there are destructive type substitutions (:=) in the sub-module or type definitions in the sub-module's source signature. We do not develop this feature further as it is working in our cases.

A safer way is to make a sub-module instead of an `include`.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Extensible type 'Base58.data' not handled">include HASH</abbr>

  val compute : elt list -&gt; t

  val empty : t

  <abbr class="mark-warning" title="We do not handle the definition of new types in signatures">type path = Left of path * t | Right of t * path | Op</abbr>

  val compute_path : elt list -&gt; int -&gt; path

  val check_path : path -&gt; elt -&gt; t * int

  val path_encoding : path Data_encoding.t
end

module type SPublic_key_hash = sig
  type t

  val pp : Format.formatter -&gt; t -&gt; unit

  val pp_short : Format.formatter -&gt; t -&gt; unit

  include Compare.S with type t := t

  include RAW_DATA with type t := t

  <abbr class="mark-warning" title="Extensible type 'Base58.data' not handled">include B58_DATA with type t := t</abbr>

  include ENCODER with type t := t

  <abbr class="mark-warning" title="Sub-module 'Map' in included signature.

Sub-modules in included signatures are not handled well yet. It does not work if there are destructive type substitutions (:=) in the sub-module or type definitions in the sub-module's source signature. We do not develop this feature further as it is working in our cases.

A safer way is to make a sub-module instead of an `include`.

â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”

Sub-module 'Set' in included signature.

Sub-modules in included signatures are not handled well yet. It does not work if there are destructive type substitutions (:=) in the sub-module or type definitions in the sub-module's source signature. We do not develop this feature further as it is working in our cases.

A safer way is to make a sub-module instead of an `include`.">include INDEXES with type t := t</abbr>

  val zero : t
end

module type SPublic_key = sig
  type t

  val pp : Format.formatter -&gt; t -&gt; unit

  include Compare.S with type t := t

  <abbr class="mark-warning" title="Extensible type 'Base58.data' not handled">include B58_DATA with type t := t</abbr>

  include ENCODER with type t := t

  type public_key_hash_t

  val hash : t -&gt; public_key_hash_t
end

module type SIGNATURE = sig
  module Public_key_hash : SPublic_key_hash

  module Public_key :
    SPublic_key with type public_key_hash_t := Public_key_hash.t

  type t

  val pp : Format.formatter -&gt; t -&gt; unit

  include RAW_DATA with type t := t

  include Compare.S with type t := t

  <abbr class="mark-warning" title="Extensible type 'Base58.data' not handled">include B58_DATA with type t := t</abbr>

  include ENCODER with type t := t

  val zero : t

  type watermark

  (** Check a signature *)
  val check : ?watermark:watermark -&gt; Public_key.t -&gt; t -&gt; MBytes.t -&gt; bool
end
end
module Set : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/set.mli&quot;
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(** Sets over ordered types.

    This module implements the set data structure, given a total ordering
    function over the set elements. All operations over sets
    are purely applicative (no side-effects).
    The implementation uses balanced binary trees, and is therefore
    reasonably efficient: insertion and membership take time
    logarithmic in the size of the set, for instance.

    The {!Make} functor constructs implementations for any type, given a
    [compare] function.
    For instance:
    {[
      module IntPairs =
      struct
        type t = int * int
        let compare (x0,y0) (x1,y1) =
          match Pervasives.compare x0 x1 with
            0 -&gt; Pervasives.compare y0 y1
          | c -&gt; c
      end

      module PairsSet = Set.Make(IntPairs)

      let m = PairsSet.(empty |&gt; add (2,3) |&gt; add (5,7) |&gt; add (11,13))
    ]}

    This creates a new module [PairsSet], with a new type [PairsSet.t]
    of sets of [int * int].
*)

(** Functor building an implementation of the set structure
    given a totally ordered type. *)
module Make (Ord : Compare.COMPARABLE) : S.SET with type elt = Ord.t
end
module Map : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/map.mli&quot;
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(** Association tables over ordered types.

    This module implements applicative association tables, also known as
    finite maps or dictionaries, given a total ordering function
    over the keys.
    All operations over maps are purely applicative (no side-effects).
    The implementation uses balanced binary trees, and therefore searching
    and insertion take time logarithmic in the size of the map.

    For instance:
    {[
      module IntPairs =
      struct
        type t = int * int
        let compare (x0,y0) (x1,y1) =
          match Pervasives.compare x0 x1 with
            0 -&gt; Pervasives.compare y0 y1
          | c -&gt; c
      end

      module PairsMap = Map.Make(IntPairs)

      let m = PairsMap.(empty |&gt; add (0,1) &quot;hello&quot; |&gt; add (1,0) &quot;world&quot;)
    ]}

    This creates a new module [PairsMap], with a new type ['a PairsMap.t]
    of maps from [int * int] to ['a]. In this example, [m] contains [string]
    values so its type is [string PairsMap.t].
*)

(** Functor building an implementation of the map structure
    given a totally ordered type. *)
module Make (Ord : Compare.COMPARABLE) : S.MAP with type key = Ord.t
end
module Blake2B : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/blake2B.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Builds a new Hash type using Blake2B. *)

(** The parameters for creating a new Hash type using
    {!Make_Blake2B}. Both {!name} and {!title} are only informative,
    used in error messages and serializers. *)

module type Name = sig
  val name : string

  val title : string

  val size : int option
end

module type PrefixedName = sig
  include Name

  val b58check_prefix : string
end

module Make_minimal (Name : Name) : S.MINIMAL_HASH

module type SRegister = sig
  val register_encoding :
    prefix:string -&gt;
    length:int -&gt;
    to_raw:('a -&gt; string) -&gt;
    of_raw:(string -&gt; 'a option) -&gt;
    wrap:('a -&gt; Base58.data) -&gt;
    'a Base58.encoding
end

module Make (Register : SRegister) (Name : PrefixedName) : S.HASH
end
module Ed25519 : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/ed25519.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Tezos - Ed25519 cryptography *)

include S.SIGNATURE with type watermark := MBytes.t
end
module Secp256k1 : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/secp256k1.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Tezos - Secp256k1 cryptography *)

include S.SIGNATURE with type watermark := MBytes.t
end
module P256 : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/p256.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Tezos - P256 cryptography *)

include S.SIGNATURE with type watermark := MBytes.t
end
module Chain_id : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/chain_id.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

include S.HASH
end
module Signature : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/signature.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

val signature_module_tag : unit

type public_key_hash =
  | Ed25519Hash of Ed25519.Public_key_hash.t
  | Secp256k1Hash of Secp256k1.Public_key_hash.t
  | P256Hash of P256.Public_key_hash.t

type public_key =
  | Ed25519 of Ed25519.Public_key.t
  | Secp256k1 of Secp256k1.Public_key.t
  | P256 of P256.Public_key.t

type watermark =
  | Block_header of Chain_id.t
  | Endorsement of Chain_id.t
  | Generic_operation
  | Custom of MBytes.t

<abbr class="mark-warning" title="Type extension not handled">include
  S.SIGNATURE
    with type Public_key_hash.t = public_key_hash
     and type Public_key.t = public_key
     and type watermark := watermark</abbr>
end
module Block_hash : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/block_hash.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Blocks hashes / IDs. *)
include S.HASH
end
module Operation_hash : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/operation_hash.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Operations hashes / IDs. *)
include S.HASH
end
module Operation_list_hash : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/operation_list_hash.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Blocks hashes / IDs. *)
include
  S.MERKLE_TREE with type elt = Operation_hash.t
end
module Operation_list_list_hash : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/operation_list_list_hash.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Blocks hashes / IDs. *)
include
  S.MERKLE_TREE with type elt = Operation_list_hash.t
end
module Protocol_hash : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/protocol_hash.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Protocol hashes / IDs. *)
include S.HASH
end
module Context_hash : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/context_hash.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Commited context hashes / IDs. *)
include S.HASH
end
module Micheline : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/micheline.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type annot = string list

type ('l, 'p) node =
  | Int of 'l * Z.t
  | String of 'l * string
  | Bytes of 'l * MBytes.t
  | Prim of 'l * 'p * ('l, 'p) node list * annot
  | Seq of 'l * ('l, 'p) node list

type 'p canonical

type canonical_location = int

val root : 'p canonical -&gt; (canonical_location, 'p) node

val canonical_location_encoding : canonical_location Data_encoding.encoding

val canonical_encoding :
  variant:string -&gt;
  'l Data_encoding.encoding -&gt;
  'l canonical Data_encoding.encoding

val canonical_encoding_v1 :
  variant:string -&gt;
  'l Data_encoding.encoding -&gt;
  'l canonical Data_encoding.encoding

(*
val erased_encoding : variant:string -&gt; 'l -&gt; 'p Data_encoding.encoding -&gt; ('l, 'p) node Data_encoding.encoding
val table_encoding : variant:string -&gt; 'l Data_encoding.encoding -&gt; 'p Data_encoding.encoding -&gt; ('l, 'p) node Data_encoding.encoding
*)
val location : ('l, 'p) node -&gt; 'l

val annotations : ('l, 'p) node -&gt; string list

val strip_locations : (_, 'p) node -&gt; 'p canonical

val extract_locations :
  ('l, 'p) node -&gt; 'p canonical * (canonical_location * 'l) list

val inject_locations :
  (canonical_location -&gt; 'l) -&gt; 'p canonical -&gt; ('l, 'p) node
end
module Block_header : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/block_header.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type shell_header = {
  level : Int32.t;
      (** The number of preceding block in this chain, i.e. the genesis
      has level 0. *)
  proto_level : int;
      (** The number of preceding protocol change in the chain (modulo 256),
      i.e. the genesis has proto_level 0. *)
  predecessor : Block_hash.t;
  timestamp : Time.t;
  validation_passes : int;
  operations_hash : Operation_list_list_hash.t;
  fitness : MBytes.t list;
  context : Context_hash.t;
}

val shell_header_encoding : shell_header Data_encoding.t

type t = {shell : shell_header; protocol_data : MBytes.t}

include S.HASHABLE with type t := t and type hash := Block_hash.t
end
module Fitness : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/fitness.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** The fitness of a block is defined as a list of bytes,
    compared in a lexicographical order (longer list are greater). *)
include
  S.T with type t = MBytes.t list
end
module Operation : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/operation.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Tezos operations. *)

type shell_header = {
  branch : Block_hash.t;
      (** The operation is only valid in a branch containing the
      block [branch]. *)
}

val shell_header_encoding : shell_header Data_encoding.t

type t = {shell : shell_header; proto : MBytes.t}

include S.HASHABLE with type t := t and type hash := Operation_hash.t
end
module Protocol : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/protocol.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** An OCaml source component of a protocol implementation. *)
type component = {
  (* The OCaml module name. *)
  name : string;
  (* The OCaml interface source code *)
  interface : string option;
  (* The OCaml source code *)
  implementation : string;
}

and t = {expected_env : env_version; components : component list}

and env_version = V1

val component_encoding : component Data_encoding.t

val env_version_encoding : env_version Data_encoding.t

include S.HASHABLE with type t := t and type hash := Protocol_hash.t
end
module Context : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/context.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** View over the context store, restricted to types, access and
    functional manipulation of an existing context. *)

type t

(** Keys in (kex x value) database implementations *)
type key = string list

(** Values in (kex x value) database implementations *)
type value = MBytes.t

val mem : t -&gt; key -&gt; bool Lwt.t

val dir_mem : t -&gt; key -&gt; bool Lwt.t

val get : t -&gt; key -&gt; value option Lwt.t

val set : t -&gt; key -&gt; value -&gt; t Lwt.t

(** [copy] returns None if the [from] key is not bound *)
val copy : t -&gt; from:key -&gt; to_:key -&gt; t option Lwt.t

val del : t -&gt; key -&gt; t Lwt.t

val remove_rec : t -&gt; key -&gt; t Lwt.t

<abbr class="mark-warning" title="Polymorphic variant types are defined as standard algebraic types">type dir_or_key = [`Key of key | `Dir of key]</abbr>

val fold :
  t -&gt;
  key -&gt;
  init:'a -&gt;
  f:([`Key of key | `Dir of key] -&gt; 'a -&gt; 'a Lwt.t) -&gt;
  'a Lwt.t

val keys : t -&gt; key -&gt; key list Lwt.t

val fold_keys : t -&gt; key -&gt; init:'a -&gt; f:(key -&gt; 'a -&gt; 'a Lwt.t) -&gt; 'a Lwt.t

val register_resolver :
  'a Base58.encoding -&gt; (t -&gt; string -&gt; 'a list Lwt.t) -&gt; unit

val complete : t -&gt; string -&gt; string list Lwt.t
end
module Updater : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/updater.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

(** Tezos Protocol Environment - Protocol updater. *)

(** Validation result: the record returned by the protocol
    on the successfull validation of a block. *)
type validation_result = {
  context : Context.t;
      (** The resulting context, it will be used for the next block. *)
  fitness : Fitness.t;
      (** The effective fitness of the block (to be compared with
      the 'announced' one in the block header. *)
  message : string option;
      (** An optional informative message to be used as in the 'git
      commit' of the block's context. *)
  max_operations_ttl : int;
      (** The &quot;time-to-live&quot; of operation for the next block: any
      operations whose 'branch' is older than 'ttl' blocks in the
      past cannot be included in the next block. *)
  last_allowed_fork_level : Int32.t;
      (** The level of the last block for which the node might consider an
      alternate branch. The shell should consider as invalid any
      branch whose fork point is older than the given level *)
}

type quota = {
  max_size : int;
      (** The maximum size (in bytes) of the serialized list of
      operations. *)
  max_op : int option;
      (** The maximum number of operation.
      [None] means no limit. *)
}

type rpc_context = {
  block_hash : Block_hash.t;
  block_header : Block_header.shell_header;
  context : Context.t;
}

(** This is the signature of a Tezos protocol implementation. It has
    access to the standard library and the Environment module. *)
module type PROTOCOL = sig
  (** The maximum size of a block header in bytes. *)
  val max_block_length : int

  (** The maximum size of an operation in bytes. *)
  val max_operation_data_length : int

  (** The number of validation passes (length of the list) and the
      operation's quota for each pass. *)
  val validation_passes : quota list

  (** The version specific type of blocks. *)
  type block_header_data

  (** Encoding for version specific part of block headers.  *)
  val block_header_data_encoding : block_header_data Data_encoding.t

  (** A fully parsed block header. *)
  <abbr class="mark-warning" title="We do not handle the definition of new types in signatures">type block_header = {
    shell : Block_header.shell_header;
    protocol_data : block_header_data;
  }</abbr>

  (** Version-specific side information computed by the protocol
      during the validation of a block. Should not include information
      about the evaluation of operations which is handled separately by
      {!operation_metadata}. To be used as an execution trace by tools
      (client, indexer). Not necessary for validation. *)
  type block_header_metadata

  (** Encoding for version-specific block metadata. *)
  val block_header_metadata_encoding : block_header_metadata Data_encoding.t

  (** The version specific type of operations. *)
  type operation_data

  (** Version-specific side information computed by the protocol
      during the validation of each operation, to be used conjointly
      with {!block_header_metadata}. *)
  type operation_receipt

  (** A fully parsed operation. *)
  <abbr class="mark-warning" title="We do not handle the definition of new types in signatures">type operation = {
    shell : Operation.shell_header;
    protocol_data : operation_data;
  }</abbr>

  (** Encoding for version-specific operation data. *)
  val operation_data_encoding : operation_data Data_encoding.t

  (** Encoding for version-specific operation receipts. *)
  val operation_receipt_encoding : operation_receipt Data_encoding.t

  (** Encoding that mixes an operation data and its receipt. *)
  val operation_data_and_receipt_encoding :
    (operation_data * operation_receipt) Data_encoding.t

  (** The Validation passes in which an operation can appear.
      For instance [[0]] if it only belongs to the first pass.
      An answer of [[]] means that the operation is ill-formed
      and cannot be included at all. *)
  val acceptable_passes : operation -&gt; int list

  (** Basic ordering of operations. [compare_operations op1 op2] means
      that [op1] should appear before [op2] in a block. *)
  val compare_operations : operation -&gt; operation -&gt; int

  (** A functional state that is transmitted through the steps of a
      block validation sequence. It must retain the current state of
      the store (that can be extracted from the outside using
      {!current_context}, and whose final value is produced by
      {!finalize_block}). It can also contain the information that
      must be remembered during the validation, which must be
      immutable (as validator or baker implementations are allowed to
      pause, replay or backtrack during the validation process). *)
  type validation_state

  (** Access the context at a given validation step. *)
  val current_context : validation_state -&gt; Context.t tzresult Lwt.t

  (** Checks that a block is well formed in a given context. This
      function should run quickly, as its main use is to reject bad
      blocks from the chain as early as possible. The input context
      is the one resulting of an ancestor block of same protocol
      version. This ancestor of the current head is guaranteed to be
      more recent than `last_allowed_fork_level`.

      The resulting `validation_state` will be used for multi-pass
      validation. *)
  val begin_partial_application :
    chain_id:Chain_id.t -&gt;
    ancestor_context:Context.t -&gt;
    predecessor_timestamp:Time.t -&gt;
    predecessor_fitness:Fitness.t -&gt;
    block_header -&gt;
    validation_state tzresult Lwt.t

  (** The first step in a block validation sequence. Initializes a
      validation context for validating a block. Takes as argument the
      {!Block_header.t} to initialize the context for this block. The
      function {!precheck_block} may not have been called before
      [begin_application], so all the check performed by the former
      must be repeated in the latter. *)
  val begin_application :
    chain_id:Chain_id.t -&gt;
    predecessor_context:Context.t -&gt;
    predecessor_timestamp:Time.t -&gt;
    predecessor_fitness:Fitness.t -&gt;
    block_header -&gt;
    validation_state tzresult Lwt.t

  (** Initializes a validation context for constructing a new block
      (as opposed to validating an existing block). When the
      [protocol_data] argument is specified, it should contains a
      'prototype' of a the protocol specific part of a block header,
      and the function should produce the exact same effect on the
      context than would produce the validation of a block containing
      an &quot;equivalent&quot; (but complete) header. For instance, if the
      block header usually includes a signature, the header provided
      to {!begin_construction} should includes a faked signature. *)
  val begin_construction :
    chain_id:Chain_id.t -&gt;
    predecessor_context:Context.t -&gt;
    predecessor_timestamp:Time.t -&gt;
    predecessor_level:Int32.t -&gt;
    predecessor_fitness:Fitness.t -&gt;
    predecessor:Block_hash.t -&gt;
    timestamp:Time.t -&gt;
    ?protocol_data:block_header_data -&gt;
    unit -&gt;
    validation_state tzresult Lwt.t

  (** Called after {!begin_application} (or {!begin_construction}) and
      before {!finalize_block}, with each operation in the block. *)
  val apply_operation :
    validation_state -&gt;
    operation -&gt;
    (validation_state * operation_receipt) tzresult Lwt.t

  (** The last step in a block validation sequence. It produces the
      context that will be used as input for the validation of its
      successor block candidates. *)
  val finalize_block :
    validation_state -&gt;
    (validation_result * block_header_metadata) tzresult Lwt.t

  (** The list of remote procedures exported by this implementation *)
  val rpc_services : rpc_context RPC_directory.t

  (** Initialize the context (or upgrade the context after a protocol
      amendment). This function receives the context resulting of the
      application of a block that triggered the amendment. It also
      receives the header of the block that triggered the amendment. *)
  val init :
    Context.t -&gt; Block_header.shell_header -&gt; validation_result tzresult Lwt.t
end

(** Activates a given protocol version from a given context. This
    means that the context used for the next block will use this
    version (this is not an immediate change). The version must have
    been previously compiled successfully. *)
val activate : Context.t -&gt; Protocol_hash.t -&gt; Context.t Lwt.t

(** Fork a test chain. The forkerd chain will use the current block
    as genesis, and [protocol] as economic protocol. The chain will
    be destroyed when a (successor) block will have a timestamp greater
    than [expiration]. The protocol must have been previously compiled
    successfully. *)
val fork_test_chain :
  Context.t -&gt; protocol:Protocol_hash.t -&gt; expiration:Time.t -&gt; Context.t Lwt.t
end
module RPC_context : sig
# 1 &quot;../lib_protocol_environment/sigs/v1/RPC_context.mli&quot;
(*****************************************************************************)
(*                                                                           *)
(* Open Source License                                                       *)
(* Copyright (c) 2018 Dynamic Ledger Solutions, Inc. &lt;contact@tezos.com&gt;     *)
(*                                                                           *)
(* Permission is hereby granted, free of charge, to any person obtaining a   *)
(* copy of this software and associated documentation files (the &quot;Software&quot;),*)
(* to deal in the Software without restriction, including without limitation *)
(* the rights to use, copy, modify, merge, publish, distribute, sublicense,  *)
(* and/or sell copies of the Software, and to permit persons to whom the     *)
(* Software is furnished to do so, subject to the following conditions:      *)
(*                                                                           *)
(* The above copyright notice and this permission notice shall be included   *)
(* in all copies or substantial portions of the Software.                    *)
(*                                                                           *)
(* THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR*)
(* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,  *)
(* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL   *)
(* THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER*)
(* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING   *)
(* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER       *)
(* DEALINGS IN THE SOFTWARE.                                                 *)
(*                                                                           *)
(*****************************************************************************)

type t = Updater.rpc_context

class type ['pr] simple =
  object
    method call_proto_service0 :
      'm 'q 'i 'o.
      (([&lt; RPC_service.meth] as 'm), t, t, 'q, 'i, 'o) RPC_service.t -&gt; 'pr -&gt;
      'q -&gt; 'i -&gt; 'o Error_monad.shell_tzresult Lwt.t

    method call_proto_service1 :
      'm 'a 'q 'i 'o.
      (([&lt; RPC_service.meth] as 'm), t, t * 'a, 'q, 'i, 'o) RPC_service.t -&gt;
      'pr -&gt; 'a -&gt; 'q -&gt; 'i -&gt; 'o Error_monad.shell_tzresult Lwt.t

    method call_proto_service2 :
      'm 'a 'b 'q 'i 'o.
      ( ([&lt; RPC_service.meth] as 'm),
        t,
        (t * 'a) * 'b,
        'q,
        'i,
        'o )
      RPC_service.t -&gt; 'pr -&gt; 'a -&gt; 'b -&gt; 'q -&gt; 'i -&gt;
      'o Error_monad.shell_tzresult Lwt.t

    method call_proto_service3 :
      'm 'a 'b 'c 'q 'i 'o.
      ( ([&lt; RPC_service.meth] as 'm),
        t,
        ((t * 'a) * 'b) * 'c,
        'q,
        'i,
        'o )
      RPC_service.t -&gt; 'pr -&gt; 'a -&gt; 'b -&gt; 'c -&gt; 'q -&gt; 'i -&gt;
      'o Error_monad.shell_tzresult Lwt.t
  end

val make_call0 :
  ([&lt; RPC_service.meth], t, t, 'q, 'i, 'o) RPC_service.t -&gt;
  'pr #simple -&gt;
  'pr -&gt;
  'q -&gt;
  'i -&gt;
  'o shell_tzresult Lwt.t

val make_call1 :
  ([&lt; RPC_service.meth], t, t * 'a, 'q, 'i, 'o) RPC_service.t -&gt;
  'pr #simple -&gt;
  'pr -&gt;
  'a -&gt;
  'q -&gt;
  'i -&gt;
  'o shell_tzresult Lwt.t

val make_call2 :
  ([&lt; RPC_service.meth], t, (t * 'a) * 'b, 'q, 'i, 'o) RPC_service.t -&gt;
  'pr #simple -&gt;
  'pr -&gt;
  'a -&gt;
  'b -&gt;
  'q -&gt;
  'i -&gt;
  'o shell_tzresult Lwt.t

val make_call3 :
  ([&lt; RPC_service.meth], t, ((t * 'a) * 'b) * 'c, 'q, 'i, 'o) RPC_service.t -&gt;
  'pr #simple -&gt;
  'pr -&gt;
  'a -&gt;
  'b -&gt;
  'c -&gt;
  'q -&gt;
  'i -&gt;
  'o shell_tzresult Lwt.t

val make_opt_call0 :
  ([&lt; RPC_service.meth], t, t, 'q, 'i, 'o) RPC_service.t -&gt;
  'pr #simple -&gt;
  'pr -&gt;
  'q -&gt;
  'i -&gt;
  'o option shell_tzresult Lwt.t

val make_opt_call1 :
  ([&lt; RPC_service.meth], t, t * 'a, 'q, 'i, 'o) RPC_service.t -&gt;
  'pr #simple -&gt;
  'pr -&gt;
  'a -&gt;
  'q -&gt;
  'i -&gt;
  'o option shell_tzresult Lwt.t

val make_opt_call2 :
  ([&lt; RPC_service.meth], t, (t * 'a) * 'b, 'q, 'i, 'o) RPC_service.t -&gt;
  'pr #simple -&gt;
  'pr -&gt;
  'a -&gt;
  'b -&gt;
  'q -&gt;
  'i -&gt;
  'o option shell_tzresult Lwt.t

val make_opt_call3 :
  ([&lt; RPC_service.meth], t, ((t * 'a) * 'b) * 'c, 'q, 'i, 'o) RPC_service.t -&gt;
  'pr #simple -&gt;
  'pr -&gt;
  'a -&gt;
  'b -&gt;
  'c -&gt;
  'q -&gt;
  'i -&gt;
  'o option shell_tzresult Lwt.t
end</pre>
  </div>
  <div class="col-md-6">
    <a href="#environment.mli"><code>Environment_mli.v</code></a>
    <pre>(** Generated by coq-of-ocaml *)
Require Import OCaml.OCaml.

Local Set Primitive Projections.
Local Open Scope string_scope.
Local Open Scope Z_scope.
Local Open Scope type_scope.
Import ListNotations.

Module Pervasives.
  Parameter raise : forall {a : Set}, extensible_type -&gt; a.
  
  Parameter raise_notrace : forall {a : Set}, extensible_type -&gt; a.
  
  Parameter invalid_arg : forall {a : Set}, string -&gt; a.
  
  Parameter failwith : forall {a : Set}, string -&gt; a.
  
  (* exception Exit *)
  
  Parameter not : bool -&gt; bool.
  
  Parameter op_andand : bool -&gt; bool -&gt; bool.
  
  Parameter op_pipepipe : bool -&gt; bool -&gt; bool.
  
  Parameter __LOC__ : string.
  
  Parameter __FILE__ : string.
  
  Parameter __LINE__ : int.
  
  Parameter __MODULE__ : string.
  
  Parameter __POS__ : string * int * int * int.
  
  Parameter __LOC_OF__ : forall {a : Set}, a -&gt; string * a.
  
  Parameter __LINE_OF__ : forall {a : Set}, a -&gt; int * a.
  
  Parameter __POS_OF__ : forall {a : Set}, a -&gt; (string * int * int * int) * a.
  
  Parameter op_pipegt : forall {a b : Set}, a -&gt; (a -&gt; b) -&gt; b.
  
  Parameter op_atat : forall {a b : Set}, (a -&gt; b) -&gt; a -&gt; b.
  
  Parameter op_tildeminus : int -&gt; int.
  
  Parameter op_tildeplus : int -&gt; int.
  
  Parameter succ : int -&gt; int.
  
  Parameter pred : int -&gt; int.
  
  Parameter op_plus : int -&gt; int -&gt; int.
  
  Parameter op_minus : int -&gt; int -&gt; int.
  
  Parameter op_star : int -&gt; int -&gt; int.
  
  Parameter op_div : int -&gt; int -&gt; int.
  
  Parameter __mod : int -&gt; int -&gt; int.
  
  Parameter abs : int -&gt; int.
  
  Parameter max_int : int.
  
  Parameter min_int : int.
  
  Parameter land : int -&gt; int -&gt; int.
  
  Parameter lor : int -&gt; int -&gt; int.
  
  Parameter lxor : int -&gt; int -&gt; int.
  
  Parameter lnot : int -&gt; int.
  
  Parameter lsl : int -&gt; int -&gt; int.
  
  Parameter lsr : int -&gt; int -&gt; int.
  
  Parameter asr : int -&gt; int -&gt; int.
  
  Parameter op_caret : string -&gt; string -&gt; string.
  
  Parameter int_of_char : ascii -&gt; int.
  
  Parameter char_of_int : int -&gt; ascii.
  
  Parameter ignore : forall {a : Set}, a -&gt; unit.
  
  Parameter string_of_bool : bool -&gt; string.
  
  Parameter bool_of_string_opt : string -&gt; option bool.
  
  Parameter string_of_int : int -&gt; string.
  
  Parameter int_of_string_opt : string -&gt; option int.
  
  Parameter fst : forall {a b : Set}, a * b -&gt; a.
  
  Parameter snd : forall {a b : Set}, a * b -&gt; b.
  
  Parameter op_at : forall {a : Set}, list a -&gt; list a -&gt; list a.
  
  Module ref.
    Record record {a : Set} : Set := Build {
      contents : a }.
    Arguments record : clear implicits.
    Definition with_contents {t_a} contents (r : record t_a) :=
      Build t_a contents.
  End ref.
  Definition ref := ref.record.
  
  Parameter __ref_value : forall {a : Set}, a -&gt; ref a.
  
  Parameter op_exclamation : forall {a : Set}, ref a -&gt; a.
  
  Parameter op_coloneq : forall {a : Set}, ref a -&gt; a -&gt; unit.
  
  Parameter incr : ref int -&gt; unit.
  
  Parameter decr : ref int -&gt; unit.
  
  Inductive result (a b : Set) : Set :=
  | Ok : a -&gt; result a b
  | Error : b -&gt; result a b.
  
  Arguments Ok {_ _}.
  Arguments Error {_ _}.
  
  Definition format6 (a b c d e f : Set) : Set :=
    CamlinternalFormatBasics.format6 a b c d e f.
  
  Definition format4 (a b c d : Set) : Set := format6 a b c c c d.
  
  Definition format (a b c : Set) : Set := format4 a b c c.
  
  Parameter string_of_format : forall {a b c d e f : Set},
    format6 a b c d e f -&gt; string.
  
  Parameter format_of_string : forall {a b c d e f : Set},
    format6 a b c d e f -&gt; format6 a b c d e f.
  
  Parameter op_caretcaret : forall {a b c d e f g h : Set},
    format6 a b c d e f -&gt; format6 f b c e g h -&gt; format6 a b c d g h.
End Pervasives.

Import Pervasives.

Module Type List_type.
  Parameter length : forall {a : Set}, list a -&gt; int.
  
  Parameter compare_lengths : forall {a b : Set}, list a -&gt; list b -&gt; int.
  
  Parameter compare_length_with : forall {a : Set}, list a -&gt; int -&gt; int.
  
  Parameter __cons_value : forall {a : Set}, a -&gt; list a -&gt; list a.
  
  Parameter hd : forall {a : Set}, list a -&gt; a.
  
  Parameter tl : forall {a : Set}, list a -&gt; list a.
  
  Parameter nth_opt : forall {a : Set}, list a -&gt; int -&gt; option a.
  
  Parameter rev : forall {a : Set}, list a -&gt; list a.
  
  Parameter init : forall {a : Set}, int -&gt; (int -&gt; a) -&gt; list a.
  
  Parameter append : forall {a : Set}, list a -&gt; list a -&gt; list a.
  
  Parameter rev_append : forall {a : Set}, list a -&gt; list a -&gt; list a.
  
  Parameter concat : forall {a : Set}, list (list a) -&gt; list a.
  
  Parameter flatten : forall {a : Set}, list (list a) -&gt; list a.
  
  Parameter iter : forall {a : Set}, (a -&gt; unit) -&gt; list a -&gt; unit.
  
  Parameter iteri : forall {a : Set}, (int -&gt; a -&gt; unit) -&gt; list a -&gt; unit.
  
  Parameter map : forall {a b : Set}, (a -&gt; b) -&gt; list a -&gt; list b.
  
  Parameter mapi : forall {a b : Set}, (int -&gt; a -&gt; b) -&gt; list a -&gt; list b.
  
  Parameter rev_map : forall {a b : Set}, (a -&gt; b) -&gt; list a -&gt; list b.
  
  Parameter fold_left : forall {a b : Set}, (a -&gt; b -&gt; a) -&gt; a -&gt; list b -&gt; a.
  
  Parameter fold_right : forall {a b : Set}, (a -&gt; b -&gt; b) -&gt; list a -&gt; b -&gt; b.
  
  Parameter iter2 : forall {a b : Set},
    (a -&gt; b -&gt; unit) -&gt; list a -&gt; list b -&gt; unit.
  
  Parameter map2 : forall {a b c : Set},
    (a -&gt; b -&gt; c) -&gt; list a -&gt; list b -&gt; list c.
  
  Parameter rev_map2 : forall {a b c : Set},
    (a -&gt; b -&gt; c) -&gt; list a -&gt; list b -&gt; list c.
  
  Parameter fold_left2 : forall {a b c : Set},
    (a -&gt; b -&gt; c -&gt; a) -&gt; a -&gt; list b -&gt; list c -&gt; a.
  
  Parameter fold_right2 : forall {a b c : Set},
    (a -&gt; b -&gt; c -&gt; c) -&gt; list a -&gt; list b -&gt; c -&gt; c.
  
  Parameter for_all : forall {a : Set}, (a -&gt; bool) -&gt; list a -&gt; bool.
  
  Parameter __exists : forall {a : Set}, (a -&gt; bool) -&gt; list a -&gt; bool.
  
  Parameter for_all2 : forall {a b : Set},
    (a -&gt; b -&gt; bool) -&gt; list a -&gt; list b -&gt; bool.
  
  Parameter __exists2 : forall {a b : Set},
    (a -&gt; b -&gt; bool) -&gt; list a -&gt; list b -&gt; bool.
  
  Parameter mem : forall {a : Set}, a -&gt; list a -&gt; bool.
  
  Parameter memq : forall {a : Set}, a -&gt; list a -&gt; bool.
  
  Parameter find_opt : forall {a : Set}, (a -&gt; bool) -&gt; list a -&gt; option a.
  
  Parameter filter : forall {a : Set}, (a -&gt; bool) -&gt; list a -&gt; list a.
  
  Parameter find_all : forall {a : Set}, (a -&gt; bool) -&gt; list a -&gt; list a.
  
  Parameter partition : forall {a : Set},
    (a -&gt; bool) -&gt; list a -&gt; list a * list a.
  
  Parameter assoc_opt : forall {a b : Set}, a -&gt; list (a * b) -&gt; option b.
  
  Parameter assq_opt : forall {a b : Set}, a -&gt; list (a * b) -&gt; option b.
  
  Parameter mem_assoc : forall {a b : Set}, a -&gt; list (a * b) -&gt; bool.
  
  Parameter mem_assq : forall {a b : Set}, a -&gt; list (a * b) -&gt; bool.
  
  Parameter remove_assoc : forall {a b : Set},
    a -&gt; list (a * b) -&gt; list (a * b).
  
  Parameter remove_assq : forall {a b : Set}, a -&gt; list (a * b) -&gt; list (a * b).
  
  Parameter split : forall {a b : Set}, list (a * b) -&gt; list a * list b.
  
  Parameter combine : forall {a b : Set}, list a -&gt; list b -&gt; list (a * b).
  
  Parameter sort : forall {a : Set}, (a -&gt; a -&gt; int) -&gt; list a -&gt; list a.
  
  Parameter stable_sort : forall {a : Set}, (a -&gt; a -&gt; int) -&gt; list a -&gt; list a.
  
  Parameter fast_sort : forall {a : Set}, (a -&gt; a -&gt; int) -&gt; list a -&gt; list a.
  
  Parameter sort_uniq : forall {a : Set}, (a -&gt; a -&gt; int) -&gt; list a -&gt; list a.
  
  Parameter merge : forall {a : Set},
    (a -&gt; a -&gt; int) -&gt; list a -&gt; list a -&gt; list a.
End List_type.

Module List.
  Parameter length : forall {a : Set}, list a -&gt; int.
  Parameter compare_lengths : forall {a b : Set}, list a -&gt; list b -&gt; int.
  Parameter compare_length_with : forall {a : Set}, list a -&gt; int -&gt; int.
  Parameter __cons_value : forall {a : Set}, a -&gt; list a -&gt; list a.
  Parameter hd : forall {a : Set}, list a -&gt; a.
  Parameter tl : forall {a : Set}, list a -&gt; list a.
  Parameter nth_opt : forall {a : Set}, list a -&gt; int -&gt; option a.
  Definition rev : forall {a : Set}, list a -&gt; list a :=
    fun {_} =&gt; List.rev.
  Parameter init : forall {a : Set}, int -&gt; (int -&gt; a) -&gt; list a.
  Parameter append : forall {a : Set}, list a -&gt; list a -&gt; list a.
  Parameter rev_append : forall {a : Set}, list a -&gt; list a -&gt; list a.
  Parameter concat : forall {a : Set}, list (list a) -&gt; list a.
  Parameter flatten : forall {a : Set}, list (list a) -&gt; list a.
  Parameter iter : forall {a : Set}, (a -&gt; unit) -&gt; list a -&gt; unit.
  Parameter iteri : forall {a : Set}, (int -&gt; a -&gt; unit) -&gt; list a -&gt; unit.
  Definition map : forall {a b : Set}, (a -&gt; b) -&gt; list a -&gt; list b :=
    fun {_ _} =&gt; List.map.
  Parameter mapi : forall {a b : Set}, (int -&gt; a -&gt; b) -&gt; list a -&gt; list b.
  Parameter rev_map : forall {a b : Set}, (a -&gt; b) -&gt; list a -&gt; list b.
  Parameter fold_left : forall {a b : Set}, (a -&gt; b -&gt; a) -&gt; a -&gt; list b -&gt; a.
  Parameter fold_right : forall {a b : Set}, (a -&gt; b -&gt; b) -&gt; list a -&gt; b -&gt; b.
  Parameter iter2 : forall {a b : Set}, (a -&gt; b -&gt; unit) -&gt; list a -&gt; list b -&gt; unit.
  Parameter map2 : forall {a b c : Set}, (a -&gt; b -&gt; c) -&gt; list a -&gt; list b -&gt; list c.
  Parameter rev_map2 : forall {a b c : Set}, (a -&gt; b -&gt; c) -&gt; list a -&gt; list b -&gt; list c.
  Parameter fold_left2 : forall {a b c : Set}, (a -&gt; b -&gt; c -&gt; a) -&gt; a -&gt; list b -&gt; list c -&gt; a.
  Parameter fold_right2 : forall {a b c : Set}, (a -&gt; b -&gt; c -&gt; c) -&gt; list a -&gt; list b -&gt; c -&gt; c.
  Parameter for_all : forall {a : Set}, (a -&gt; bool) -&gt; list a -&gt; bool.
  Parameter __exists : forall {a : Set}, (a -&gt; bool) -&gt; list a -&gt; bool.
  Parameter for_all2 : forall {a b : Set}, (a -&gt; b -&gt; bool) -&gt; list a -&gt; list b -&gt; bool.
  Parameter __exists2 : forall {a b : Set}, (a -&gt; b -&gt; bool) -&gt; list a -&gt; list b -&gt; bool.
  Parameter mem : forall {a : Set}, a -&gt; list a -&gt; bool.
  Parameter memq : forall {a : Set}, a -&gt; list a -&gt; bool.
  Parameter find_opt : forall {a : Set}, (a -&gt; bool) -&gt; list a -&gt; option a.
  Parameter filter : forall {a : Set}, (a -&gt; bool) -&gt; list a -&gt; list a.
  Parameter find_all : forall {a : Set}, (a -&gt; bool) -&gt; list a -&gt; list a.
  Parameter partition : forall {a : Set}, (a -&gt; bool) -&gt; list a -&gt; list a * list a.
  Parameter assoc_opt : forall {a b : Set}, a -&gt; list (a * b) -&gt; option b.
  Parameter assq_opt : forall {a b : Set}, a -&gt; list (a * b) -&gt; option b.
  Parameter mem_assoc : forall {a b : Set}, a -&gt; list (a * b) -&gt; bool.
  Parameter mem_assq : forall {a b : Set}, a -&gt; list (a * b) -&gt; bool.
  Parameter remove_assoc : forall {a b : Set}, a -&gt; list (a * b) -&gt; list (a * b).
  Parameter remove_assq : forall {a b : Set}, a -&gt; list (a * b) -&gt; list (a * b).
  Parameter split : forall {a b : Set}, list (a * b) -&gt; list a * list b.
  Parameter combine : forall {a b : Set}, list a -&gt; list b -&gt; list (a * b).
  Parameter sort : forall {a : Set}, (a -&gt; a -&gt; int) -&gt; list a -&gt; list a.
  Parameter stable_sort : forall {a : Set}, (a -&gt; a -&gt; int) -&gt; list a -&gt; list a.
  Parameter fast_sort : forall {a : Set}, (a -&gt; a -&gt; int) -&gt; list a -&gt; list a.
  Parameter sort_uniq : forall {a : Set}, (a -&gt; a -&gt; int) -&gt; list a -&gt; list a.
  Parameter merge : forall {a : Set}, (a -&gt; a -&gt; int) -&gt; list a -&gt; list a -&gt; list a.
End List.

Module List_check : List_type := List.

Module String.
  Parameter length : string -&gt; int.
  
  Parameter get : string -&gt; int -&gt; ascii.
  
  Parameter make : int -&gt; ascii -&gt; string.
  
  Parameter init : int -&gt; (int -&gt; ascii) -&gt; string.
  
  Parameter sub : string -&gt; int -&gt; int -&gt; string.
  
  Parameter blit : string -&gt; int -&gt; bytes -&gt; int -&gt; int -&gt; unit.
  
  Parameter concat : string -&gt; list string -&gt; string.
  
  Parameter iter : (ascii -&gt; unit) -&gt; string -&gt; unit.
  
  Parameter iteri : (int -&gt; ascii -&gt; unit) -&gt; string -&gt; unit.
  
  Parameter map : (ascii -&gt; ascii) -&gt; string -&gt; string.
  
  Parameter mapi : (int -&gt; ascii -&gt; ascii) -&gt; string -&gt; string.
  
  Parameter trim : string -&gt; string.
  
  Parameter escaped : string -&gt; string.
  
  Parameter index_opt : string -&gt; ascii -&gt; option int.
  
  Parameter rindex_opt : string -&gt; ascii -&gt; option int.
  
  Parameter index_from_opt : string -&gt; int -&gt; ascii -&gt; option int.
  
  Parameter rindex_from_opt : string -&gt; int -&gt; ascii -&gt; option int.
  
  Parameter contains : string -&gt; ascii -&gt; bool.
  
  Parameter contains_from : string -&gt; int -&gt; ascii -&gt; bool.
  
  Parameter rcontains_from : string -&gt; int -&gt; ascii -&gt; bool.
  
  Parameter uppercase_ascii : string -&gt; string.
  
  Parameter lowercase_ascii : string -&gt; string.
  
  Parameter capitalize_ascii : string -&gt; string.
  
  Parameter uncapitalize_ascii : string -&gt; string.
  
  Definition t : Set := string.
  
  Parameter compare : t -&gt; t -&gt; int.
  
  Parameter equal : t -&gt; t -&gt; bool.
  
  Parameter split_on_char : ascii -&gt; string -&gt; list string.
  
  Parameter get_char : t -&gt; int -&gt; ascii.
  
  Parameter get_uint8 : t -&gt; int -&gt; int.
  
  Parameter get_int8 : t -&gt; int -&gt; int.
  
  Parameter get_uint16 : t -&gt; int -&gt; int.
  
  Parameter get_int16 : t -&gt; int -&gt; int.
  
  Parameter get_int32 : t -&gt; int -&gt; int32.
  
  Parameter get_int64 : t -&gt; int -&gt; int64.
  
  Module LE.
    Parameter get_uint16 : t -&gt; int -&gt; int.
    
    Parameter get_int16 : t -&gt; int -&gt; int.
    
    Parameter get_int32 : t -&gt; int -&gt; int32.
    
    Parameter get_int64 : t -&gt; int -&gt; int64.
  End LE.
End String.

Module Int32.
  Parameter zero : int32.
  
  Parameter one : int32.
  
  Parameter minus_one : int32.
  
  Parameter neg : int32 -&gt; int32.
  
  Parameter add : int32 -&gt; int32 -&gt; int32.
  
  Parameter sub : int32 -&gt; int32 -&gt; int32.
  
  Parameter mul : int32 -&gt; int32 -&gt; int32.
  
  Parameter div : int32 -&gt; int32 -&gt; int32.
  
  Parameter rem : int32 -&gt; int32 -&gt; int32.
  
  Parameter succ : int32 -&gt; int32.
  
  Parameter pred : int32 -&gt; int32.
  
  Parameter abs : int32 -&gt; int32.
  
  Parameter max_int : int32.
  
  Parameter min_int : int32.
  
  Parameter logand : int32 -&gt; int32 -&gt; int32.
  
  Parameter logor : int32 -&gt; int32 -&gt; int32.
  
  Parameter logxor : int32 -&gt; int32 -&gt; int32.
  
  Parameter lognot : int32 -&gt; int32.
  
  Parameter shift_left : int32 -&gt; int -&gt; int32.
  
  Parameter shift_right : int32 -&gt; int -&gt; int32.
  
  Parameter shift_right_logical : int32 -&gt; int -&gt; int32.
  
  Parameter of_int : int -&gt; int32.
  
  Parameter to_int : int32 -&gt; int.
  
  Parameter of_float : float -&gt; int32.
  
  Parameter to_float : int32 -&gt; float.
  
  Parameter of_string : string -&gt; int32.
  
  Parameter of_string_opt : string -&gt; option int32.
  
  Parameter to_string : int32 -&gt; string.
  
  Parameter bits_of_float : float -&gt; int32.
  
  Parameter float_of_bits : int32 -&gt; float.
  
  Definition t : Set := int32.
  
  Parameter compare : t -&gt; t -&gt; int.
  
  Parameter equal : t -&gt; t -&gt; bool.
End Int32.

Module Int64.
  Parameter zero : int64.
  
  Parameter one : int64.
  
  Parameter minus_one : int64.
  
  Parameter neg : int64 -&gt; int64.
  
  Parameter add : int64 -&gt; int64 -&gt; int64.
  
  Parameter sub : int64 -&gt; int64 -&gt; int64.
  
  Parameter mul : int64 -&gt; int64 -&gt; int64.
  
  Parameter div : int64 -&gt; int64 -&gt; int64.
  
  Parameter rem : int64 -&gt; int64 -&gt; int64.
  
  Parameter succ : int64 -&gt; int64.
  
  Parameter pred : int64 -&gt; int64.
  
  Parameter abs : int64 -&gt; int64.
  
  Parameter max_int : int64.
  
  Parameter min_int : int64.
  
  Parameter logand : int64 -&gt; int64 -&gt; int64.
  
  Parameter logor : int64 -&gt; int64 -&gt; int64.
  
  Parameter logxor : int64 -&gt; int64 -&gt; int64.
  
  Parameter lognot : int64 -&gt; int64.
  
  Parameter shift_left : int64 -&gt; int -&gt; int64.
  
  Parameter shift_right : int64 -&gt; int -&gt; int64.
  
  Parameter shift_right_logical : int64 -&gt; int -&gt; int64.
  
  Parameter of_int : int -&gt; int64.
  
  Parameter to_int : int64 -&gt; int.
  
  Parameter of_float : float -&gt; int64.
  
  Parameter to_float : int64 -&gt; float.
  
  Parameter of_int32 : int32 -&gt; int64.
  
  Parameter to_int32 : int64 -&gt; int32.
  
  Parameter of_nativeint : nativeint -&gt; int64.
  
  Parameter to_nativeint : int64 -&gt; nativeint.
  
  Parameter of_string : string -&gt; int64.
  
  Parameter of_string_opt : string -&gt; option int64.
  
  Parameter to_string : int64 -&gt; string.
  
  Parameter bits_of_float : float -&gt; int64.
  
  Parameter float_of_bits : int64 -&gt; float.
  
  Definition t : Set := int64.
  
  Parameter compare : t -&gt; t -&gt; int.
  
  Parameter equal : t -&gt; t -&gt; bool.
End Int64.

Module Format.
  Parameter formatter : Set.
  
  Parameter pp_open_box : formatter -&gt; int -&gt; unit.
  
  Parameter pp_close_box : formatter -&gt; unit -&gt; unit.
  
  Parameter pp_open_hbox : formatter -&gt; unit -&gt; unit.
  
  Parameter pp_open_vbox : formatter -&gt; int -&gt; unit.
  
  Parameter pp_open_hvbox : formatter -&gt; int -&gt; unit.
  
  Parameter pp_open_hovbox : formatter -&gt; int -&gt; unit.
  
  Parameter pp_print_string : formatter -&gt; string -&gt; unit.
  
  Parameter pp_print_as : formatter -&gt; int -&gt; string -&gt; unit.
  
  Parameter pp_print_int : formatter -&gt; int -&gt; unit.
  
  Parameter pp_print_float : formatter -&gt; float -&gt; unit.
  
  Parameter pp_print_char : formatter -&gt; ascii -&gt; unit.
  
  Parameter pp_print_bool : formatter -&gt; bool -&gt; unit.
  
  Parameter pp_print_space : formatter -&gt; unit -&gt; unit.
  
  Parameter pp_print_cut : formatter -&gt; unit -&gt; unit.
  
  Parameter pp_print_break : formatter -&gt; int -&gt; int -&gt; unit.
  
  Parameter pp_force_newline : formatter -&gt; unit -&gt; unit.
  
  Parameter pp_print_if_newline : formatter -&gt; unit -&gt; unit.
  
  Parameter pp_print_flush : formatter -&gt; unit -&gt; unit.
  
  Parameter pp_print_newline : formatter -&gt; unit -&gt; unit.
  
  Parameter pp_set_margin : formatter -&gt; int -&gt; unit.
  
  Parameter pp_get_margin : formatter -&gt; unit -&gt; int.
  
  Parameter pp_set_max_indent : formatter -&gt; int -&gt; unit.
  
  Parameter pp_get_max_indent : formatter -&gt; unit -&gt; int.
  
  Parameter pp_set_max_boxes : formatter -&gt; int -&gt; unit.
  
  Parameter pp_get_max_boxes : formatter -&gt; unit -&gt; int.
  
  Parameter pp_over_max_boxes : formatter -&gt; unit -&gt; bool.
  
  Parameter pp_open_tbox : formatter -&gt; unit -&gt; unit.
  
  Parameter pp_close_tbox : formatter -&gt; unit -&gt; unit.
  
  Parameter pp_set_tab : formatter -&gt; unit -&gt; unit.
  
  Parameter pp_print_tab : formatter -&gt; unit -&gt; unit.
  
  Parameter pp_print_tbreak : formatter -&gt; int -&gt; int -&gt; unit.
  
  Parameter pp_set_ellipsis_text : formatter -&gt; string -&gt; unit.
  
  Parameter pp_get_ellipsis_text : formatter -&gt; unit -&gt; string.
  
  Definition tag : Set := string.
  
  Parameter pp_open_tag : formatter -&gt; string -&gt; unit.
  
  Parameter pp_close_tag : formatter -&gt; unit -&gt; unit.
  
  Parameter pp_set_tags : formatter -&gt; bool -&gt; unit.
  
  Parameter pp_set_print_tags : formatter -&gt; bool -&gt; unit.
  
  Parameter pp_set_mark_tags : formatter -&gt; bool -&gt; unit.
  
  Parameter pp_get_print_tags : formatter -&gt; unit -&gt; bool.
  
  Parameter pp_get_mark_tags : formatter -&gt; unit -&gt; bool.
  
  Parameter pp_print_list : forall {a : Set},
    option (formatter -&gt; unit -&gt; unit) -&gt; (formatter -&gt; a -&gt; unit) -&gt;
    formatter -&gt; list a -&gt; unit.
  
  Parameter pp_print_text : formatter -&gt; string -&gt; unit.
  
  Parameter fprintf : forall {a : Set},
    formatter -&gt; Pervasives.format a formatter unit -&gt; a.
  
  Parameter sprintf : forall {a : Set}, Pervasives.format a unit string -&gt; a.
  
  Parameter asprintf : forall {a : Set},
    Pervasives.format4 a formatter unit string -&gt; a.
  
  Parameter ifprintf : forall {a : Set},
    formatter -&gt; Pervasives.format a formatter unit -&gt; a.
  
  Parameter kfprintf : forall {a b : Set},
    (formatter -&gt; a) -&gt; formatter -&gt; Pervasives.format4 b formatter unit a -&gt; b.
  
  Parameter ikfprintf : forall {a b : Set},
    (formatter -&gt; a) -&gt; formatter -&gt; Pervasives.format4 b formatter unit a -&gt; b.
  
  Parameter ksprintf : forall {a b : Set},
    (string -&gt; a) -&gt; Pervasives.format4 b unit string a -&gt; b.
  
  Parameter kasprintf : forall {a b : Set},
    (string -&gt; a) -&gt; Pervasives.format4 b formatter unit a -&gt; b.
End Format.

Module Type MBytes_type.
  Parameter t : Set.
  
  Parameter create : int -&gt; t.
  
  Parameter length : t -&gt; int.
  
  Parameter copy : t -&gt; t.
  
  Parameter sub : t -&gt; int -&gt; int -&gt; t.
  
  Parameter blit : t -&gt; int -&gt; t -&gt; int -&gt; int -&gt; unit.
  
  Parameter blit_of_string : string -&gt; int -&gt; t -&gt; int -&gt; int -&gt; unit.
  
  Parameter blit_to_bytes : t -&gt; int -&gt; bytes -&gt; int -&gt; int -&gt; unit.
  
  Parameter of_string : string -&gt; t.
  
  Parameter to_string : t -&gt; string.
  
  Parameter sub_string : t -&gt; int -&gt; int -&gt; string.
  
  Parameter get_char : t -&gt; int -&gt; ascii.
  
  Parameter get_uint8 : t -&gt; int -&gt; int.
  
  Parameter get_int8 : t -&gt; int -&gt; int.
  
  Parameter set_char : t -&gt; int -&gt; ascii -&gt; unit.
  
  Parameter set_int8 : t -&gt; int -&gt; int -&gt; unit.
  
  Parameter get_uint16 : t -&gt; int -&gt; int.
  
  Parameter get_int16 : t -&gt; int -&gt; int.
  
  Parameter get_int32 : t -&gt; int -&gt; int32.
  
  Parameter get_int64 : t -&gt; int -&gt; int64.
  
  Parameter set_int16 : t -&gt; int -&gt; int -&gt; unit.
  
  Parameter set_int32 : t -&gt; int -&gt; int32 -&gt; unit.
  
  Parameter set_int64 : t -&gt; int -&gt; int64 -&gt; unit.
  
  Module LE.
    Parameter get_uint16 : t -&gt; int -&gt; int.
    
    Parameter get_int16 : t -&gt; int -&gt; int.
    
    Parameter get_int32 : t -&gt; int -&gt; int32.
    
    Parameter get_int64 : t -&gt; int -&gt; int64.
    
    Parameter set_int16 : t -&gt; int -&gt; int -&gt; unit.
    
    Parameter set_int32 : t -&gt; int -&gt; int32 -&gt; unit.
    
    Parameter set_int64 : t -&gt; int -&gt; int64 -&gt; unit.
  End LE.
  
  Parameter op_eq : t -&gt; t -&gt; bool.
  
  Parameter op_ltgt : t -&gt; t -&gt; bool.
  
  Parameter op_lt : t -&gt; t -&gt; bool.
  
  Parameter op_lteq : t -&gt; t -&gt; bool.
  
  Parameter op_gteq : t -&gt; t -&gt; bool.
  
  Parameter op_gt : t -&gt; t -&gt; bool.
  
  Parameter compare : t -&gt; t -&gt; int.
  
  Parameter concat : string -&gt; list t -&gt; t.
  
  Inductive hex : Set :=
  | Hex : string -&gt; hex.
  
  Parameter to_hex : t -&gt; hex.
  
  Parameter of_hex : hex -&gt; t.
End MBytes_type.

Module MBytes.
  Definition t : Set := string.
  Parameter create : int -&gt; t.
  Parameter length : t -&gt; int.
  Parameter copy : t -&gt; t.
  Parameter sub : t -&gt; int -&gt; int -&gt; t.
  Parameter blit : t -&gt; int -&gt; t -&gt; int -&gt; int -&gt; unit.
  Parameter blit_of_string : string -&gt; int -&gt; t -&gt; int -&gt; int -&gt; unit.
  Parameter blit_to_bytes : t -&gt; int -&gt; bytes -&gt; int -&gt; int -&gt; unit.
  Definition of_string : string -&gt; t := fun s =&gt; s.
  Definition to_string : t -&gt; string := fun b =&gt; b.
  Parameter sub_string : t -&gt; int -&gt; int -&gt; string.
  Parameter get_char : t -&gt; int -&gt; ascii.
  Parameter get_uint8 : t -&gt; int -&gt; int.
  Parameter get_int8 : t -&gt; int -&gt; int.
  Parameter set_char : t -&gt; int -&gt; ascii -&gt; unit.
  Parameter set_int8 : t -&gt; int -&gt; int -&gt; unit.
  Parameter get_uint16 : t -&gt; int -&gt; int.
  Parameter get_int16 : t -&gt; int -&gt; int.
  Parameter get_int32 : t -&gt; int -&gt; int32.
  Parameter get_int64 : t -&gt; int -&gt; int64.
  Parameter set_int16 : t -&gt; int -&gt; int -&gt; unit.
  Parameter set_int32 : t -&gt; int -&gt; int32 -&gt; unit.
  Parameter set_int64 : t -&gt; int -&gt; int64 -&gt; unit.

  Module LE.
    Parameter get_uint16 : t -&gt; int -&gt; int.
    Parameter get_int16 : t -&gt; int -&gt; int.
    Parameter get_int32 : t -&gt; int -&gt; int32.
    Parameter get_int64 : t -&gt; int -&gt; int64.
    Parameter set_int16 : t -&gt; int -&gt; int -&gt; unit.
    Parameter set_int32 : t -&gt; int -&gt; int32 -&gt; unit.
    Parameter set_int64 : t -&gt; int -&gt; int64 -&gt; unit.
  End LE.

  Parameter op_eq : t -&gt; t -&gt; bool.
  Parameter op_ltgt : t -&gt; t -&gt; bool.
  Parameter op_lt : t -&gt; t -&gt; bool.
  Parameter op_lteq : t -&gt; t -&gt; bool.
  Parameter op_gteq : t -&gt; t -&gt; bool.
  Parameter op_gt : t -&gt; t -&gt; bool.
  Parameter compare : t -&gt; t -&gt; int.
  Parameter concat : string -&gt; list t -&gt; t.
  
  Inductive hex : Set :=
  | Hex : string -&gt; hex.
  
  Parameter to_hex : t -&gt; hex.
  Parameter of_hex : hex -&gt; t.
End MBytes.

Module MBytes_check : MBytes_type := MBytes.

Module Type Z_type.
  Parameter t : Set.
  
  Parameter zero : t.
  
  Parameter one : t.
  
  Parameter succ : t -&gt; t.
  
  Parameter abs : t -&gt; t.
  
  Parameter neg : t -&gt; t.
  
  Parameter add : t -&gt; t -&gt; t.
  
  Parameter sub : t -&gt; t -&gt; t.
  
  Parameter mul : t -&gt; t -&gt; t.
  
  Parameter ediv_rem : t -&gt; t -&gt; t * t.
  
  Parameter logand : t -&gt; t -&gt; t.
  
  Parameter logor : t -&gt; t -&gt; t.
  
  Parameter logxor : t -&gt; t -&gt; t.
  
  Parameter lognot : t -&gt; t.
  
  Parameter shift_left : t -&gt; int -&gt; t.
  
  Parameter shift_right : t -&gt; int -&gt; t.
  
  Parameter to_string : t -&gt; string.
  
  Parameter of_string : string -&gt; t.
  
  Parameter to_int64 : t -&gt; int64.
  
  Parameter of_int64 : int64 -&gt; t.
  
  Parameter to_int : t -&gt; int.
  
  Parameter of_int : int -&gt; t.
  
  Parameter to_bits : option int -&gt; t -&gt; MBytes.t.
  
  Parameter of_bits : MBytes.t -&gt; t.
  
  Parameter equal : t -&gt; t -&gt; bool.
  
  Parameter compare : t -&gt; t -&gt; int.
  
  Parameter numbits : t -&gt; int.
End Z_type.

Module Z.
  Definition t := Z.
  Definition zero := 0.
  Definition one := 1.
  Definition succ z := Z.add z 1.
  Definition abs := Z.abs.
  Definition neg z := -z.
  Definition add := Z.add.
  Definition sub := Z.sub.
  Definition mul := Z.mul.
  Parameter ediv_rem : t -&gt; t -&gt; t * t.
  Parameter logand : t -&gt; t -&gt; t.
  Parameter logor : t -&gt; t -&gt; t.
  Parameter logxor : t -&gt; t -&gt; t.
  Parameter lognot : t -&gt; t.
  Parameter shift_left : t -&gt; int -&gt; t.
  Parameter shift_right : t -&gt; int -&gt; t.
  Parameter to_string : t -&gt; string.
  Parameter of_string : string -&gt; t.
  Parameter to_int64 : t -&gt; int64.
  Parameter of_int64 : int64 -&gt; t.
  Parameter to_int : t -&gt; int.
  Parameter of_int : int -&gt; t.
  Parameter to_bits : option int -&gt; t -&gt; MBytes.t.
  Parameter of_bits : MBytes.t -&gt; t.
  Definition equal := Z.eqb.
  Parameter compare : t -&gt; t -&gt; int.
  Parameter numbits : t -&gt; int.
End Z.

Module Z_check : Z_type := Z.

Module Type Lwt_type.
  Parameter t : forall (a : Set), Set.
  
  Parameter __return : forall {a : Set}, a -&gt; t a.
  
  Parameter bind : forall {a b : Set}, t a -&gt; (a -&gt; t b) -&gt; t b.
  
  Parameter op_gtgteq : forall {a b : Set}, t a -&gt; (a -&gt; t b) -&gt; t b.
  
  Parameter op_eqltlt : forall {a b : Set}, (a -&gt; t b) -&gt; t a -&gt; t b.
  
  Parameter map : forall {a b : Set}, (a -&gt; b) -&gt; t a -&gt; t b.
  
  Parameter op_gtpipeeq : forall {a b : Set}, t a -&gt; (a -&gt; b) -&gt; t b.
  
  Parameter op_eqpipelt : forall {a b : Set}, (a -&gt; b) -&gt; t a -&gt; t b.
  
  Parameter return_unit : t unit.
  
  Parameter return_none : forall {a : Set}, t (option a).
  
  Parameter return_nil : forall {a : Set}, t (list a).
  
  Parameter return_true : t bool.
  
  Parameter return_false : t bool.
  
  Parameter join : list (t unit) -&gt; t unit.
  
  Parameter op_ltandgt : t unit -&gt; t unit -&gt; t unit.
End Lwt_type.

Module Lwt.
  Definition t (a : Set) : Set := a.
  Definition __return {a : Set} (x : a) : t a := x.
  Definition bind {a b : Set} (x : t a) (f : a -&gt; t b) : t b := f x.
  Definition op_gtgteq {a b : Set} : t a -&gt; (a -&gt; t b) -&gt; t b := bind.
  Definition op_eqltlt {a b : Set} (f : a -&gt; t b) (x : t a) : t b := f x.
  Definition map {a b : Set} (f : a -&gt; b) (x : t a) : t b := f x.
  Definition op_gtpipeeq {a b : Set} (x : t a) (f : a -&gt; b) : t b := f x.
  Definition op_eqpipelt {a b : Set} : (a -&gt; b) -&gt; t a -&gt; t b := map.
  Definition return_unit : t unit := tt.
  Definition return_none {a : Set} : t (option a) := None.
  Definition return_nil {a : Set} : t (list a) := [].
  Definition return_true : t bool := true.
  Definition return_false : t bool := false.
  Parameter join : list (t unit) -&gt; t unit.
  Parameter op_ltandgt : t unit -&gt; t unit -&gt; t unit.
End Lwt.

Module Lwt_check : Lwt_type := Lwt.

Module Lwt_list.
  Parameter map_s : forall {a b : Set},
    (a -&gt; Lwt.t b) -&gt; list a -&gt; Lwt.t (list b).
  
  Parameter map_p : forall {a b : Set},
    (a -&gt; Lwt.t b) -&gt; list a -&gt; Lwt.t (list b).
  
  Parameter mapi_s : forall {a b : Set},
    (int -&gt; a -&gt; Lwt.t b) -&gt; list a -&gt; Lwt.t (list b).
  
  Parameter mapi_p : forall {a b : Set},
    (int -&gt; a -&gt; Lwt.t b) -&gt; list a -&gt; Lwt.t (list b).
  
  Parameter rev_map_s : forall {a b : Set},
    (a -&gt; Lwt.t b) -&gt; list a -&gt; Lwt.t (list b).
  
  Parameter rev_map_p : forall {a b : Set},
    (a -&gt; Lwt.t b) -&gt; list a -&gt; Lwt.t (list b).
  
  Parameter fold_left_s : forall {a b : Set},
    (a -&gt; b -&gt; Lwt.t a) -&gt; a -&gt; list b -&gt; Lwt.t a.
  
  Parameter fold_right_s : forall {a b : Set},
    (a -&gt; b -&gt; Lwt.t b) -&gt; list a -&gt; b -&gt; Lwt.t b.
  
  Parameter for_all_s : forall {a : Set},
    (a -&gt; Lwt.t bool) -&gt; list a -&gt; Lwt.t bool.
  
  Parameter for_all_p : forall {a : Set},
    (a -&gt; Lwt.t bool) -&gt; list a -&gt; Lwt.t bool.
  
  Parameter exists_s : forall {a : Set},
    (a -&gt; Lwt.t bool) -&gt; list a -&gt; Lwt.t bool.
  
  Parameter exists_p : forall {a : Set},
    (a -&gt; Lwt.t bool) -&gt; list a -&gt; Lwt.t bool.
  
  Parameter find_s : forall {a : Set}, (a -&gt; Lwt.t bool) -&gt; list a -&gt; Lwt.t a.
  
  Parameter filter_s : forall {a : Set},
    (a -&gt; Lwt.t bool) -&gt; list a -&gt; Lwt.t (list a).
  
  Parameter filter_p : forall {a : Set},
    (a -&gt; Lwt.t bool) -&gt; list a -&gt; Lwt.t (list a).
  
  Parameter filter_map_s : forall {a b : Set},
    (a -&gt; Lwt.t (option b)) -&gt; list a -&gt; Lwt.t (list b).
  
  Parameter filter_map_p : forall {a b : Set},
    (a -&gt; Lwt.t (option b)) -&gt; list a -&gt; Lwt.t (list b).
  
  Parameter partition_s : forall {a : Set},
    (a -&gt; Lwt.t bool) -&gt; list a -&gt; Lwt.t (list a * list a).
  
  Parameter partition_p : forall {a : Set},
    (a -&gt; Lwt.t bool) -&gt; list a -&gt; Lwt.t (list a * list a).
End Lwt_list.

Module Raw_hashes.
  Parameter blake2b : MBytes.t -&gt; MBytes.t.
  
  Parameter sha256 : MBytes.t -&gt; MBytes.t.
  
  Parameter sha512 : MBytes.t -&gt; MBytes.t.
End Raw_hashes.

Module Compare.
  Module COMPARABLE.
    Record signature {t : Set} : Set := {
      t := t;
      compare : t -&gt; t -&gt; int;
    }.
  End COMPARABLE.
  
  Module S.
    Record signature {t : Set} : Set := {
      t := t;
      op_eq : t -&gt; t -&gt; bool;
      op_ltgt : t -&gt; t -&gt; bool;
      op_lt : t -&gt; t -&gt; bool;
      op_lteq : t -&gt; t -&gt; bool;
      op_gteq : t -&gt; t -&gt; bool;
      op_gt : t -&gt; t -&gt; bool;
      compare : t -&gt; t -&gt; int;
      equal : t -&gt; t -&gt; bool;
      max : t -&gt; t -&gt; t;
      min : t -&gt; t -&gt; t;
    }.
  End S.
  
  Parameter Make :
    forall (P : {t : Set &amp; COMPARABLE.signature (t := t)}),
      {_ : unit &amp; S.signature (t := (|P|).(COMPARABLE.t))}.
  
  Parameter Char : {_ : unit &amp; S.signature (t := ascii)}.
  
  Parameter Bool : {_ : unit &amp; S.signature (t := bool)}.
  
  Parameter Int : {_ : unit &amp; S.signature (t := int)}.
  
  Parameter Int32 : {_ : unit &amp; S.signature (t := int32)}.
  
  Parameter Uint32 : {_ : unit &amp; S.signature (t := int32)}.
  
  Parameter Int64 : {_ : unit &amp; S.signature (t := int64)}.
  
  Parameter Uint64 : {_ : unit &amp; S.signature (t := int64)}.
  
  Parameter Float : {_ : unit &amp; S.signature (t := float)}.
  
  Parameter String : {_ : unit &amp; S.signature (t := string)}.
  
  Parameter Z : {_ : unit &amp; S.signature (t := Z.t)}.
  
  Parameter List :
    forall (P : {t : Set &amp; COMPARABLE.signature (t := t)}),
      {_ : unit &amp; S.signature (t := (list (|P|).(COMPARABLE.t)))}.
  
  Parameter Option :
    forall (P : {t : Set &amp; COMPARABLE.signature (t := t)}),
      {_ : unit &amp; S.signature (t := (option (|P|).(COMPARABLE.t)))}.
End Compare.

Module Data_encoding.
  Inductive json : Set :=
  | Bool : bool -&gt; json
  | Null : json
  | O : list (string * json) -&gt; json
  | Float : float -&gt; json
  | String : string -&gt; json
  | A : list json -&gt; json.
  
  Parameter json_schema : Set.
  
  Parameter t : forall (a : Set), Set.
  
  Definition encoding (a : Set) : Set := t a.
  
  Parameter classify : forall {a : Set},
    encoding a -&gt; (* `Variable *) unit + (* `Fixed *) int + (* `Dynamic *) unit.
  
  Parameter splitted : forall {a : Set}, encoding a -&gt; encoding a -&gt; encoding a.
  
  Parameter null : encoding unit.
  
  Parameter empty : encoding unit.
  
  Parameter __unit_value : encoding unit.
  
  Parameter constant : string -&gt; encoding unit.
  
  Parameter int8 : encoding int.
  
  Parameter uint8 : encoding int.
  
  Parameter int16 : encoding int.
  
  Parameter uint16 : encoding int.
  
  Parameter int31 : encoding int.
  
  Parameter __int32_value : encoding int32.
  
  Parameter __int64_value : encoding int64.
  
  Parameter n : encoding Z.t.
  
  Parameter z : encoding Z.t.
  
  Parameter __bool_value : encoding bool.
  
  Parameter __string_value : encoding string.
  
  Parameter __bytes_value : encoding MBytes.t.
  
  Parameter __float_value : encoding float.
  
  Parameter __option_value : forall {a : Set},
    encoding a -&gt; encoding (option a).
  
  Parameter string_enum : forall {a : Set}, list (string * a) -&gt; encoding a.
  
  Module Fixed.
    Parameter __string_value : int -&gt; encoding string.
    
    Parameter __bytes_value : int -&gt; encoding MBytes.t.
    
    Parameter add_padding : forall {a : Set}, encoding a -&gt; int -&gt; encoding a.
  End Fixed.
  
  Module __Variable.
    Parameter __string_value : encoding string.
    
    Parameter __bytes_value : encoding MBytes.t.
    
    Parameter array : forall {a : Set},
      option int -&gt; encoding a -&gt; encoding (array a).
    
    Parameter __list_value : forall {a : Set},
      option int -&gt; encoding a -&gt; encoding (list a).
  End __Variable.
  
  Module Bounded.
    Parameter __string_value : int -&gt; encoding string.
    
    Parameter __bytes_value : int -&gt; encoding MBytes.t.
  End Bounded.
  
  Parameter dynamic_size : forall {a : Set},
    option ((* `Uint16 *) unit + (* `Uint8 *) unit + (* `Uint30 *) unit) -&gt;
    encoding a -&gt; encoding a.
  
  Parameter __json_value : encoding json.
  
  Parameter __json_schema_value : encoding json_schema.
  
  Parameter field : forall (a : Set), Set.
  
  Parameter req : forall {t : Set},
    option string -&gt; option string -&gt; string -&gt; encoding t -&gt; field t.
  
  Parameter opt : forall {t : Set},
    option string -&gt; option string -&gt; string -&gt; encoding t -&gt; field (option t).
  
  Parameter varopt : forall {t : Set},
    option string -&gt; option string -&gt; string -&gt; encoding t -&gt; field (option t).
  
  Parameter dft : forall {t : Set},
    option string -&gt; option string -&gt; string -&gt; encoding t -&gt; t -&gt; field t.
  
  Parameter obj1 : forall {f1 : Set}, field f1 -&gt; encoding f1.
  
  Parameter obj2 : forall {f1 f2 : Set},
    field f1 -&gt; field f2 -&gt; encoding (f1 * f2).
  
  Parameter obj3 : forall {f1 f2 f3 : Set},
    field f1 -&gt; field f2 -&gt; field f3 -&gt; encoding (f1 * f2 * f3).
  
  Parameter obj4 : forall {f1 f2 f3 f4 : Set},
    field f1 -&gt; field f2 -&gt; field f3 -&gt; field f4 -&gt; encoding (f1 * f2 * f3 * f4).
  
  Parameter obj5 : forall {f1 f2 f3 f4 f5 : Set},
    field f1 -&gt; field f2 -&gt; field f3 -&gt; field f4 -&gt; field f5 -&gt;
    encoding (f1 * f2 * f3 * f4 * f5).
  
  Parameter obj6 : forall {f1 f2 f3 f4 f5 f6 : Set},
    field f1 -&gt; field f2 -&gt; field f3 -&gt; field f4 -&gt; field f5 -&gt; field f6 -&gt;
    encoding (f1 * f2 * f3 * f4 * f5 * f6).
  
  Parameter obj7 : forall {f1 f2 f3 f4 f5 f6 f7 : Set},
    field f1 -&gt; field f2 -&gt; field f3 -&gt; field f4 -&gt; field f5 -&gt; field f6 -&gt;
    field f7 -&gt; encoding (f1 * f2 * f3 * f4 * f5 * f6 * f7).
  
  Parameter obj8 : forall {f1 f2 f3 f4 f5 f6 f7 f8 : Set},
    field f1 -&gt; field f2 -&gt; field f3 -&gt; field f4 -&gt; field f5 -&gt; field f6 -&gt;
    field f7 -&gt; field f8 -&gt; encoding (f1 * f2 * f3 * f4 * f5 * f6 * f7 * f8).
  
  Parameter obj9 : forall {f1 f2 f3 f4 f5 f6 f7 f8 f9 : Set},
    field f1 -&gt; field f2 -&gt; field f3 -&gt; field f4 -&gt; field f5 -&gt; field f6 -&gt;
    field f7 -&gt; field f8 -&gt; field f9 -&gt;
    encoding (f1 * f2 * f3 * f4 * f5 * f6 * f7 * f8 * f9).
  
  Parameter obj10 : forall {f1 f10 f2 f3 f4 f5 f6 f7 f8 f9 : Set},
    field f1 -&gt; field f2 -&gt; field f3 -&gt; field f4 -&gt; field f5 -&gt; field f6 -&gt;
    field f7 -&gt; field f8 -&gt; field f9 -&gt; field f10 -&gt;
    encoding (f1 * f2 * f3 * f4 * f5 * f6 * f7 * f8 * f9 * f10).
  
  Parameter tup1 : forall {f1 : Set}, encoding f1 -&gt; encoding f1.
  
  Parameter tup2 : forall {f1 f2 : Set},
    encoding f1 -&gt; encoding f2 -&gt; encoding (f1 * f2).
  
  Parameter tup3 : forall {f1 f2 f3 : Set},
    encoding f1 -&gt; encoding f2 -&gt; encoding f3 -&gt; encoding (f1 * f2 * f3).
  
  Parameter tup4 : forall {f1 f2 f3 f4 : Set},
    encoding f1 -&gt; encoding f2 -&gt; encoding f3 -&gt; encoding f4 -&gt;
    encoding (f1 * f2 * f3 * f4).
  
  Parameter tup5 : forall {f1 f2 f3 f4 f5 : Set},
    encoding f1 -&gt; encoding f2 -&gt; encoding f3 -&gt; encoding f4 -&gt; encoding f5 -&gt;
    encoding (f1 * f2 * f3 * f4 * f5).
  
  Parameter tup6 : forall {f1 f2 f3 f4 f5 f6 : Set},
    encoding f1 -&gt; encoding f2 -&gt; encoding f3 -&gt; encoding f4 -&gt; encoding f5 -&gt;
    encoding f6 -&gt; encoding (f1 * f2 * f3 * f4 * f5 * f6).
  
  Parameter tup7 : forall {f1 f2 f3 f4 f5 f6 f7 : Set},
    encoding f1 -&gt; encoding f2 -&gt; encoding f3 -&gt; encoding f4 -&gt; encoding f5 -&gt;
    encoding f6 -&gt; encoding f7 -&gt; encoding (f1 * f2 * f3 * f4 * f5 * f6 * f7).
  
  Parameter tup8 : forall {f1 f2 f3 f4 f5 f6 f7 f8 : Set},
    encoding f1 -&gt; encoding f2 -&gt; encoding f3 -&gt; encoding f4 -&gt; encoding f5 -&gt;
    encoding f6 -&gt; encoding f7 -&gt; encoding f8 -&gt;
    encoding (f1 * f2 * f3 * f4 * f5 * f6 * f7 * f8).
  
  Parameter tup9 : forall {f1 f2 f3 f4 f5 f6 f7 f8 f9 : Set},
    encoding f1 -&gt; encoding f2 -&gt; encoding f3 -&gt; encoding f4 -&gt; encoding f5 -&gt;
    encoding f6 -&gt; encoding f7 -&gt; encoding f8 -&gt; encoding f9 -&gt;
    encoding (f1 * f2 * f3 * f4 * f5 * f6 * f7 * f8 * f9).
  
  Parameter tup10 : forall {f1 f10 f2 f3 f4 f5 f6 f7 f8 f9 : Set},
    encoding f1 -&gt; encoding f2 -&gt; encoding f3 -&gt; encoding f4 -&gt; encoding f5 -&gt;
    encoding f6 -&gt; encoding f7 -&gt; encoding f8 -&gt; encoding f9 -&gt; encoding f10 -&gt;
    encoding (f1 * f2 * f3 * f4 * f5 * f6 * f7 * f8 * f9 * f10).
  
  Parameter merge_objs : forall {o1 o2 : Set},
    encoding o1 -&gt; encoding o2 -&gt; encoding (o1 * o2).
  
  Parameter merge_tups : forall {a1 a2 : Set},
    encoding a1 -&gt; encoding a2 -&gt; encoding (a1 * a2).
  
  Parameter array : forall {a : Set},
    option int -&gt; encoding a -&gt; encoding (array a).
  
  Parameter __list_value : forall {a : Set},
    option int -&gt; encoding a -&gt; encoding (list a).
  
  Parameter assoc : forall {a : Set},
    encoding a -&gt; encoding (list (string * a)).
  
  Inductive case_tag : Set :=
  | Tag : int -&gt; case_tag
  | Json_only : case_tag.
  
  Parameter case : forall (t : Set), Set.
  
  Parameter __case_value : forall {a t : Set},
    string -&gt; option string -&gt; case_tag -&gt; encoding a -&gt; (t -&gt; option a) -&gt;
    (a -&gt; t) -&gt; case t.
  
  Inductive tag_size : Set :=
  | Uint16 : tag_size
  | Uint8 : tag_size.
  
  Parameter union : forall {t : Set},
    option tag_size -&gt; list (case t) -&gt; encoding t.
  
  Parameter def : forall {t : Set},
    string -&gt; option string -&gt; option string -&gt; encoding t -&gt; encoding t.
  
  Parameter conv : forall {a b : Set},
    (a -&gt; b) -&gt; (b -&gt; a) -&gt; option json_schema -&gt; encoding b -&gt; encoding a.
  
  Parameter mu : forall {a : Set},
    string -&gt; option string -&gt; option string -&gt; (encoding a -&gt; encoding a) -&gt;
    encoding a.
  
  Parameter lazy_t : forall (a : Set), Set.
  
  Parameter lazy_encoding : forall {a : Set}, encoding a -&gt; encoding (lazy_t a).
  
  Parameter force_decode : forall {a : Set}, lazy_t a -&gt; option a.
  
  Parameter force_bytes : forall {a : Set}, lazy_t a -&gt; MBytes.t.
  
  Parameter make_lazy : forall {a : Set}, encoding a -&gt; a -&gt; lazy_t a.
  
  Parameter apply_lazy : forall {a b : Set},
    (a -&gt; b) -&gt; (MBytes.t -&gt; b) -&gt; (b -&gt; b -&gt; b) -&gt; lazy_t a -&gt; b.
  
  Module Json.
    Parameter schema : forall {a : Set},
      option string -&gt; encoding a -&gt; json_schema.
    
    Parameter construct : forall {t : Set}, encoding t -&gt; t -&gt; json.
    
    Parameter destruct : forall {t : Set}, encoding t -&gt; json -&gt; t.
    
    Reserved Notation &quot;'path&quot;.
    
    Inductive path_item : Set :=
    | Index : int -&gt; path_item
    | Field : string -&gt; path_item
    | Next : path_item
    | Star : path_item
    
    where &quot;'path&quot; := (list path_item).
    
    Definition path := 'path.
    
    (* exception Cannot_destruct *)
    
    (* exception Unexpected *)
    
    (* exception No_case_matched *)
    
    (* exception Bad_array_size *)
    
    (* exception Missing_field *)
    
    (* exception Unexpected_field *)
    
    Parameter print_error :
      option (Format.formatter -&gt; extensible_type -&gt; unit) -&gt;
      Format.formatter -&gt; extensible_type -&gt; unit.
    
    Parameter cannot_destruct : forall {a b : Set},
      Pervasives.format4 a Format.formatter unit b -&gt; a.
    
    Parameter wrap_error : forall {a b : Set}, (a -&gt; b) -&gt; a -&gt; b.
    
    Parameter pp : Format.formatter -&gt; json -&gt; unit.
  End Json.
  
  Module Binary.
    Parameter length : forall {a : Set}, encoding a -&gt; a -&gt; int.
    
    Parameter fixed_length : forall {a : Set}, encoding a -&gt; option int.
    
    Parameter read : forall {a : Set},
      encoding a -&gt; MBytes.t -&gt; int -&gt; int -&gt; option (int * a).
    
    Parameter write : forall {a : Set},
      encoding a -&gt; a -&gt; MBytes.t -&gt; int -&gt; int -&gt; option int.
    
    Parameter to_bytes : forall {a : Set}, encoding a -&gt; a -&gt; option MBytes.t.
    
    Parameter to_bytes_exn : forall {a : Set}, encoding a -&gt; a -&gt; MBytes.t.
    
    Parameter of_bytes : forall {a : Set}, encoding a -&gt; MBytes.t -&gt; option a.
    
    Parameter write_error : Set.
    
    (* exception Write_error *)
  End Binary.
  
  Parameter check_size : forall {a : Set}, int -&gt; encoding a -&gt; encoding a.
End Data_encoding.

Module Type Error_monad_type.
  Inductive error_category : Set :=
  | Permanent : error_category
  | Temporary : error_category
  | Branch : error_category.
  
  Definition __error : Set := extensible_type.
  
  Parameter pp : Format.formatter -&gt; __error -&gt; unit.
  
  Parameter error_encoding : Data_encoding.t __error.
  
  Parameter json_of_error : __error -&gt; Data_encoding.json.
  
  Parameter error_of_json : Data_encoding.json -&gt; __error.
  
  Module error_info.
    Record record : Set := Build {
      category : error_category;
      id : string;
      title : string;
      description : string;
      schema : Data_encoding.json_schema }.
    Definition with_category category (r : record) :=
      Build category r.(id) r.(title) r.(description) r.(schema).
    Definition with_id id (r : record) :=
      Build r.(category) id r.(title) r.(description) r.(schema).
    Definition with_title title (r : record) :=
      Build r.(category) r.(id) title r.(description) r.(schema).
    Definition with_description description (r : record) :=
      Build r.(category) r.(id) r.(title) description r.(schema).
    Definition with_schema schema (r : record) :=
      Build r.(category) r.(id) r.(title) r.(description) schema.
  End error_info.
  Definition error_info := error_info.record.
  
  Parameter pp_info : Format.formatter -&gt; error_info -&gt; unit.
  
  Parameter get_registered_errors : unit -&gt; list error_info.
  
  Parameter register_error_kind : forall {err : Set},
    error_category -&gt; string -&gt; string -&gt; string -&gt;
    option (Format.formatter -&gt; err -&gt; unit) -&gt; Data_encoding.t err -&gt;
    (__error -&gt; option err) -&gt; (err -&gt; __error) -&gt; unit.
  
  Parameter classify_errors : list __error -&gt; error_category.
  
  Definition tzresult (a : Set) : Set := Pervasives.result a (list __error).
  
  Parameter result_encoding : forall {a : Set},
    Data_encoding.t a -&gt; Data_encoding.encoding (tzresult a).
  
  Parameter ok : forall {a : Set}, a -&gt; tzresult a.
  
  Parameter __return : forall {a : Set}, a -&gt; Lwt.t (tzresult a).
  
  Parameter return_unit : Lwt.t (tzresult unit).
  
  Parameter return_none : forall {a : Set}, Lwt.t (tzresult (option a)).
  
  Parameter return_some : forall {a : Set}, a -&gt; Lwt.t (tzresult (option a)).
  
  Parameter return_nil : forall {a : Set}, Lwt.t (tzresult (list a)).
  
  Parameter return_true : Lwt.t (tzresult bool).
  
  Parameter return_false : Lwt.t (tzresult bool).
  
  Parameter __error_value : forall {a : Set}, __error -&gt; tzresult a.
  
  Parameter fail : forall {a : Set}, __error -&gt; Lwt.t (tzresult a).
  
  Parameter op_gtgtquestion : forall {a b : Set},
    tzresult a -&gt; (a -&gt; tzresult b) -&gt; tzresult b.
  
  Parameter op_gtgteqquestion : forall {a b : Set},
    Lwt.t (tzresult a) -&gt; (a -&gt; Lwt.t (tzresult b)) -&gt; Lwt.t (tzresult b).
  
  Parameter op_gtgteq : forall {a b : Set},
    Lwt.t a -&gt; (a -&gt; Lwt.t b) -&gt; Lwt.t b.
  
  Parameter op_gtpipeeq : forall {a b : Set}, Lwt.t a -&gt; (a -&gt; b) -&gt; Lwt.t b.
  
  Parameter op_gtgtpipequestion : forall {a b : Set},
    Lwt.t (tzresult a) -&gt; (a -&gt; b) -&gt; Lwt.t (tzresult b).
  
  Parameter op_gtpipequestion : forall {a b : Set},
    tzresult a -&gt; (a -&gt; b) -&gt; tzresult b.
  
  Parameter record_trace : forall {a : Set},
    __error -&gt; tzresult a -&gt; tzresult a.
  
  Parameter trace : forall {b : Set},
    __error -&gt; Lwt.t (tzresult b) -&gt; Lwt.t (tzresult b).
  
  Parameter record_trace_eval : forall {a : Set},
    (unit -&gt; tzresult __error) -&gt; tzresult a -&gt; tzresult a.
  
  Parameter trace_eval : forall {b : Set},
    (unit -&gt; Lwt.t (tzresult __error)) -&gt; Lwt.t (tzresult b) -&gt;
    Lwt.t (tzresult b).
  
  Parameter fail_unless : bool -&gt; __error -&gt; Lwt.t (tzresult unit).
  
  Parameter fail_when : bool -&gt; __error -&gt; Lwt.t (tzresult unit).
  
  Parameter iter_s : forall {a : Set},
    (a -&gt; Lwt.t (tzresult unit)) -&gt; list a -&gt; Lwt.t (tzresult unit).
  
  Parameter iter_p : forall {a : Set},
    (a -&gt; Lwt.t (tzresult unit)) -&gt; list a -&gt; Lwt.t (tzresult unit).
  
  Parameter map_s : forall {a b : Set},
    (a -&gt; Lwt.t (tzresult b)) -&gt; list a -&gt; Lwt.t (tzresult (list b)).
  
  Parameter map_p : forall {a b : Set},
    (a -&gt; Lwt.t (tzresult b)) -&gt; list a -&gt; Lwt.t (tzresult (list b)).
  
  Parameter map2 : forall {a b c : Set},
    (a -&gt; b -&gt; tzresult c) -&gt; list a -&gt; list b -&gt; tzresult (list c).
  
  Parameter map2_s : forall {a b c : Set},
    (a -&gt; b -&gt; Lwt.t (tzresult c)) -&gt; list a -&gt; list b -&gt;
    Lwt.t (tzresult (list c)).
  
  Parameter filter_map_s : forall {a b : Set},
    (a -&gt; Lwt.t (tzresult (option b))) -&gt; list a -&gt; Lwt.t (tzresult (list b)).
  
  Parameter fold_left_s : forall {a b : Set},
    (a -&gt; b -&gt; Lwt.t (tzresult a)) -&gt; a -&gt; list b -&gt; Lwt.t (tzresult a).
  
  Parameter fold_right_s : forall {a b : Set},
    (a -&gt; b -&gt; Lwt.t (tzresult b)) -&gt; list a -&gt; b -&gt; Lwt.t (tzresult b).
  
  Parameter shell_error : Set.
  
  Definition shell_tzresult (a : Set) : Set :=
    Pervasives.result a (list shell_error).
End Error_monad_type.

Module Error_monad.
  Inductive error_category : Set :=
  | Permanent : error_category
  | Temporary : error_category
  | Branch : error_category.
  
  Definition __error : Set := extensible_type.
  
  Parameter pp : Format.formatter -&gt; __error -&gt; unit.
  
  Parameter error_encoding : Data_encoding.t __error.
  
  Parameter json_of_error : __error -&gt; Data_encoding.json.
  
  Parameter error_of_json : Data_encoding.json -&gt; __error.
  
  Module error_info.
    Record record : Set := Build {
      category : error_category;
      id : string;
      title : string;
      description : string;
      schema : Data_encoding.json_schema }.
    Definition with_category category (r : record) :=
      Build category r.(id) r.(title) r.(description) r.(schema).
    Definition with_id id (r : record) :=
      Build r.(category) id r.(title) r.(description) r.(schema).
    Definition with_title title (r : record) :=
      Build r.(category) r.(id) title r.(description) r.(schema).
    Definition with_description description (r : record) :=
      Build r.(category) r.(id) r.(title) description r.(schema).
    Definition with_schema schema (r : record) :=
      Build r.(category) r.(id) r.(title) r.(description) schema.
  End error_info.
  Definition error_info := error_info.record.
  
  Parameter pp_info : Format.formatter -&gt; error_info -&gt; unit.
  
  Parameter get_registered_errors : unit -&gt; list error_info.
  
  Parameter register_error_kind : forall {err : Set},
    error_category -&gt; string -&gt; string -&gt; string -&gt;
    option (Format.formatter -&gt; err -&gt; unit) -&gt; Data_encoding.t err -&gt;
    (__error -&gt; option err) -&gt; (err -&gt; __error) -&gt; unit.
  
  Parameter classify_errors : list __error -&gt; error_category.
  
  Definition tzresult (a : Set) : Set := Pervasives.result a (list __error).
  
  Parameter result_encoding : forall {a : Set},
    Data_encoding.t a -&gt; Data_encoding.encoding (tzresult a).
  
  Definition ok {a : Set} (x : a) : tzresult a := Pervasives.Ok x.
  
  Definition __return {a : Set} (x : a) : Lwt.t (tzresult a) :=
    Lwt.__return (ok x).
  
  Parameter return_unit : Lwt.t (tzresult unit).
  
  Parameter return_none : forall {a : Set}, Lwt.t (tzresult (option a)).
  
  Parameter return_some : forall {a : Set}, a -&gt; Lwt.t (tzresult (option a)).
  
  Parameter return_nil : forall {a : Set}, Lwt.t (tzresult (list a)).
  
  Parameter return_true : Lwt.t (tzresult bool).
  
  Parameter return_false : Lwt.t (tzresult bool).
  
  Parameter __error_value : forall {a : Set}, __error -&gt; tzresult a.
  
  Parameter fail : forall {a : Set}, __error -&gt; Lwt.t (tzresult a).
  
  Definition op_gtgtquestion {a b : Set}
    : tzresult a -&gt; (a -&gt; tzresult b) -&gt; tzresult b :=
    fun x f =&gt;
    match x with
    | Pervasives.Ok x =&gt; f x
    | Pervasives.Error error =&gt; Pervasives.Error error
    end.
  
  Definition op_gtgteqquestion {a b : Set}
    : Lwt.t (tzresult a) -&gt; (a -&gt; Lwt.t (tzresult b)) -&gt; Lwt.t (tzresult b) :=
    fun x f =&gt;
    Lwt.bind x (fun x =&gt;
      match x with
      | Pervasives.Ok x =&gt; f x
      | Pervasives.Error error =&gt; Lwt.__return (Pervasives.Error error)
      end
    ).
  
  Parameter op_gtgteq : forall {a b : Set},
    Lwt.t a -&gt; (a -&gt; Lwt.t b) -&gt; Lwt.t b.
  
  Parameter op_gtpipeeq : forall {a b : Set}, Lwt.t a -&gt; (a -&gt; b) -&gt; Lwt.t b.
  
  Parameter op_gtgtpipequestion : forall {a b : Set},
    Lwt.t (tzresult a) -&gt; (a -&gt; b) -&gt; Lwt.t (tzresult b).
  
  Parameter op_gtpipequestion : forall {a b : Set},
    tzresult a -&gt; (a -&gt; b) -&gt; tzresult b.
  
  Parameter record_trace : forall {a : Set},
    __error -&gt; tzresult a -&gt; tzresult a.
  
  Parameter trace : forall {b : Set},
    __error -&gt; Lwt.t (tzresult b) -&gt; Lwt.t (tzresult b).
  
  Parameter record_trace_eval : forall {a : Set},
    (unit -&gt; tzresult __error) -&gt; tzresult a -&gt; tzresult a.
  
  Parameter trace_eval : forall {b : Set},
    (unit -&gt; Lwt.t (tzresult __error)) -&gt; Lwt.t (tzresult b) -&gt;
    Lwt.t (tzresult b).
  
  Parameter fail_unless : bool -&gt; __error -&gt; Lwt.t (tzresult unit).
  
  Parameter fail_when : bool -&gt; __error -&gt; Lwt.t (tzresult unit).
  
  Parameter iter_s : forall {a : Set},
    (a -&gt; Lwt.t (tzresult unit)) -&gt; list a -&gt; Lwt.t (tzresult unit).
  
  Parameter iter_p : forall {a : Set},
    (a -&gt; Lwt.t (tzresult unit)) -&gt; list a -&gt; Lwt.t (tzresult unit).
  
  Parameter map_s : forall {a b : Set},
    (a -&gt; Lwt.t (tzresult b)) -&gt; list a -&gt; Lwt.t (tzresult (list b)).
  
  Parameter map_p : forall {a b : Set},
    (a -&gt; Lwt.t (tzresult b)) -&gt; list a -&gt; Lwt.t (tzresult (list b)).
  
  Parameter map2 : forall {a b c : Set},
    (a -&gt; b -&gt; tzresult c) -&gt; list a -&gt; list b -&gt; tzresult (list c).
  
  Parameter map2_s : forall {a b c : Set},
    (a -&gt; b -&gt; Lwt.t (tzresult c)) -&gt; list a -&gt; list b -&gt;
    Lwt.t (tzresult (list c)).
  
  Parameter filter_map_s : forall {a b : Set},
    (a -&gt; Lwt.t (tzresult (option b))) -&gt; list a -&gt; Lwt.t (tzresult (list b)).
  
  Parameter fold_left_s : forall {a b : Set},
    (a -&gt; b -&gt; Lwt.t (tzresult a)) -&gt; a -&gt; list b -&gt; Lwt.t (tzresult a).
  
  Parameter fold_right_s : forall {a b : Set},
    (a -&gt; b -&gt; Lwt.t (tzresult b)) -&gt; list a -&gt; b -&gt; Lwt.t (tzresult b).
  
  Parameter shell_error : Set.
  
  Definition shell_tzresult (a : Set) : Set :=
    Pervasives.result a (list shell_error).
End Error_monad.

Module Error_monad_check : Error_monad_type := Error_monad.

Import Error_monad.

Module Logging.
  Parameter debug : forall {a : Set},
    Pervasives.format4 a Format.formatter unit unit -&gt; a.
  
  Parameter log_info : forall {a : Set},
    Pervasives.format4 a Format.formatter unit unit -&gt; a.
  
  Parameter log_notice : forall {a : Set},
    Pervasives.format4 a Format.formatter unit unit -&gt; a.
  
  Parameter warn : forall {a : Set},
    Pervasives.format4 a Format.formatter unit unit -&gt; a.
  
  Parameter log_error : forall {a : Set},
    Pervasives.format4 a Format.formatter unit unit -&gt; a.
  
  Parameter fatal_error : forall {a : Set},
    Pervasives.format4 a Format.formatter unit unit -&gt; a.
  
  Parameter lwt_debug : forall {a : Set},
    Pervasives.format4 a Format.formatter unit (Lwt.t unit) -&gt; a.
  
  Parameter lwt_log_info : forall {a : Set},
    Pervasives.format4 a Format.formatter unit (Lwt.t unit) -&gt; a.
  
  Parameter lwt_log_notice : forall {a : Set},
    Pervasives.format4 a Format.formatter unit (Lwt.t unit) -&gt; a.
  
  Parameter lwt_warn : forall {a : Set},
    Pervasives.format4 a Format.formatter unit (Lwt.t unit) -&gt; a.
  
  Parameter lwt_log_error : forall {a : Set},
    Pervasives.format4 a Format.formatter unit (Lwt.t unit) -&gt; a.
End Logging.

Module Time.
  Parameter t : Set.
  
  Parameter Included_S : {_ : unit &amp; Compare.S.signature (t := t)}.
  
  Definition op_eq : t -&gt; t -&gt; bool := (|Included_S|).(Compare.S.op_eq).
  
  Definition op_ltgt : t -&gt; t -&gt; bool := (|Included_S|).(Compare.S.op_ltgt).
  
  Definition op_lt : t -&gt; t -&gt; bool := (|Included_S|).(Compare.S.op_lt).
  
  Definition op_lteq : t -&gt; t -&gt; bool := (|Included_S|).(Compare.S.op_lteq).
  
  Definition op_gteq : t -&gt; t -&gt; bool := (|Included_S|).(Compare.S.op_gteq).
  
  Definition op_gt : t -&gt; t -&gt; bool := (|Included_S|).(Compare.S.op_gt).
  
  Definition compare : t -&gt; t -&gt; int := (|Included_S|).(Compare.S.compare).
  
  Definition equal : t -&gt; t -&gt; bool := (|Included_S|).(Compare.S.equal).
  
  Definition max : t -&gt; t -&gt; t := (|Included_S|).(Compare.S.max).
  
  Definition min : t -&gt; t -&gt; t := (|Included_S|).(Compare.S.min).
  
  Parameter add : t -&gt; int64 -&gt; t.
  
  Parameter diff : t -&gt; t -&gt; int64.
  
  Parameter of_seconds : int64 -&gt; t.
  
  Parameter to_seconds : t -&gt; int64.
  
  Parameter of_notation : string -&gt; option t.
  
  Parameter of_notation_exn : string -&gt; t.
  
  Parameter to_notation : t -&gt; string.
  
  Parameter encoding : Data_encoding.t t.
  
  Parameter rfc_encoding : Data_encoding.t t.
  
  Parameter pp_hum : Format.formatter -&gt; t -&gt; unit.
End Time.

Module Option.
  Parameter map : forall {a b : Set}, (a -&gt; b) -&gt; option a -&gt; option b.
  
  Parameter apply : forall {a b : Set}, (a -&gt; option b) -&gt; option a -&gt; option b.
  
  Parameter iter : forall {a : Set}, (a -&gt; unit) -&gt; option a -&gt; unit.
  
  Parameter unopt : forall {a : Set}, a -&gt; option a -&gt; a.
  
  Parameter unopt_map : forall {a b : Set}, (a -&gt; b) -&gt; b -&gt; option a -&gt; b.
  
  Parameter first_some : forall {a : Set}, option a -&gt; option a -&gt; option a.
  
  Parameter try_with : forall {a : Set}, (unit -&gt; a) -&gt; option a.
  
  Parameter some : forall {a : Set}, a -&gt; option a.
End Option.

Module RPC_arg.
  Parameter t : forall (a : Set), Set.
  
  Definition arg (a : Set) : Set := t a.
  
  Parameter make : forall {a : Set},
    option string -&gt; string -&gt; (string -&gt; Pervasives.result a string) -&gt;
    (a -&gt; string) -&gt; unit -&gt; arg a.
  
  Module descr.
    Record record : Set := Build {
      name : string;
      descr : option string }.
    Definition with_name name (r : record) :=
      Build name r.(descr).
    Definition with_descr descr (r : record) :=
      Build r.(name) descr.
  End descr.
  Definition descr := descr.record.
  
  Parameter __descr_value : forall {a : Set}, arg a -&gt; descr.
  
  Parameter __int_value : arg int.
  
  Parameter __int32_value : arg int32.
  
  Parameter __int64_value : arg int64.
  
  Parameter __float_value : arg float.
  
  Parameter __string_value : arg string.
  
  Parameter like : forall {a : Set}, arg a -&gt; option string -&gt; string -&gt; arg a.
  
  Inductive eq : Set :=
  | Eq : eq.
  
  Parameter __eq_value : forall {a b : Set}, arg a -&gt; arg b -&gt; option eq.
End RPC_arg.

Module RPC_path.
  Parameter t : forall (prefix params : Set), Set.
  
  Definition path (prefix params : Set) : Set := t prefix params.
  
  Definition context (prefix : Set) : Set := path prefix prefix.
  
  Parameter root : context unit.
  
  Parameter open_root : forall {a : Set}, context a.
  
  Parameter add_suffix : forall {params prefix : Set},
    path prefix params -&gt; string -&gt; path prefix params.
  
  Parameter op_div : forall {params prefix : Set},
    path prefix params -&gt; string -&gt; path prefix params.
  
  Parameter add_arg : forall {a params prefix : Set},
    path prefix params -&gt; RPC_arg.t a -&gt; path prefix (params * a).
  
  Parameter op_divcolon : forall {a params prefix : Set},
    path prefix params -&gt; RPC_arg.t a -&gt; path prefix (params * a).
  
  Parameter add_final_args : forall {a params prefix : Set},
    path prefix params -&gt; RPC_arg.t a -&gt; path prefix (params * list a).
  
  Parameter op_divcolonstar : forall {a params prefix : Set},
    path prefix params -&gt; RPC_arg.t a -&gt; path prefix (params * list a).
End RPC_path.

Module RPC_query.
  Parameter t : forall (a : Set), Set.
  
  Definition query (a : Set) : Set := t a.
  
  Parameter empty : query unit.
  
  Parameter field : forall (a b : Set), Set.
  
  Parameter __field_value : forall {a b : Set},
    option string -&gt; string -&gt; RPC_arg.t a -&gt; a -&gt; (b -&gt; a) -&gt; field b a.
  
  Parameter opt_field : forall {a b : Set},
    option string -&gt; string -&gt; RPC_arg.t a -&gt; (b -&gt; option a) -&gt;
    field b (option a).
  
  Parameter flag : forall {b : Set},
    option string -&gt; string -&gt; (b -&gt; bool) -&gt; field b bool.
  
  Parameter multi_field : forall {a b : Set},
    option string -&gt; string -&gt; RPC_arg.t a -&gt; (b -&gt; list a) -&gt; field b (list a).
  
  Parameter open_query : forall (a b c : Set), Set.
  
  Parameter __query_value : forall {a b : Set}, b -&gt; open_query a b b.
  
  Parameter op_pipeplus : forall {a b c d : Set},
    open_query a b (c -&gt; d) -&gt; field a c -&gt; open_query a b d.
  
  Parameter seal : forall {a b : Set}, open_query a b a -&gt; t a.
  
  Definition untyped : Set := list (string * string).
  
  (* exception Invalid *)
  
  Parameter parse : forall {a : Set}, query a -&gt; untyped -&gt; a.
End RPC_query.

Module RPC_service.
  Inductive meth : Set :=
  | PUT : meth
  | GET : meth
  | DELETE : meth
  | POST : meth
  | PATCH : meth.
  
  Parameter t : forall (prefix params query input output : Set), Set.
  
  Definition service (prefix params query input output : Set) : Set :=
    t prefix params query input output.
  
  Parameter get_service : forall {output params prefix query : Set},
    option string -&gt; RPC_query.t query -&gt; Data_encoding.t output -&gt;
    RPC_path.t prefix params -&gt; service prefix params query unit output.
  
  Parameter post_service : forall {input output params prefix query : Set},
    option string -&gt; RPC_query.t query -&gt; Data_encoding.t input -&gt;
    Data_encoding.t output -&gt; RPC_path.t prefix params -&gt;
    service prefix params query input output.
  
  Parameter delete_service : forall {output params prefix query : Set},
    option string -&gt; RPC_query.t query -&gt; Data_encoding.t output -&gt;
    RPC_path.t prefix params -&gt; service prefix params query unit output.
  
  Parameter patch_service : forall {input output params prefix query : Set},
    option string -&gt; RPC_query.t query -&gt; Data_encoding.t input -&gt;
    Data_encoding.t output -&gt; RPC_path.t prefix params -&gt;
    service prefix params query input output.
  
  Parameter put_service : forall {input output params prefix query : Set},
    option string -&gt; RPC_query.t query -&gt; Data_encoding.t input -&gt;
    Data_encoding.t output -&gt; RPC_path.t prefix params -&gt;
    service prefix params query input output.
End RPC_service.

Module RPC_answer.
  Module stream.
    Record record {next shutdown : Set} : Set := Build {
      next : next;
      shutdown : shutdown }.
    Arguments record : clear implicits.
    Definition with_next {t_next t_shutdown} next
      (r : record t_next t_shutdown) :=
      Build t_next t_shutdown next r.(shutdown).
    Definition with_shutdown {t_next t_shutdown} shutdown
      (r : record t_next t_shutdown) :=
      Build t_next t_shutdown r.(next) shutdown.
  End stream.
  Definition stream_skeleton := stream.record.
  
  Reserved Notation &quot;'stream&quot;.
  
  Inductive t (o : Set) : Set :=
  | OkStream : 'stream o -&gt; t o
  | Unauthorized : option (list Error_monad.__error) -&gt; t o
  | Error : option (list Error_monad.__error) -&gt; t o
  | Ok : o -&gt; t o
  | Not_found : option (list Error_monad.__error) -&gt; t o
  | Forbidden : option (list Error_monad.__error) -&gt; t o
  | Created : option string -&gt; t o
  | Conflict : option (list Error_monad.__error) -&gt; t o
  | No_content : t o
  
  where &quot;'stream&quot; := (fun (t_a : Set) =&gt;
    stream_skeleton (unit -&gt; Lwt.t (option t_a)) (unit -&gt; unit)).
  
  Definition stream := 'stream.
  
  Arguments OkStream {_}.
  Arguments Unauthorized {_}.
  Arguments Error {_}.
  Arguments Ok {_}.
  Arguments Not_found {_}.
  Arguments Forbidden {_}.
  Arguments Created {_}.
  Arguments Conflict {_}.
  Arguments No_content {_}.
  
  Parameter __return : forall {o : Set}, o -&gt; Lwt.t (t o).
  
  Parameter return_stream : forall {o : Set}, stream o -&gt; Lwt.t (t o).
  
  Parameter not_found : forall {o : Set}, Lwt.t (t o).
  
  Parameter fail : forall {a : Set}, list Error_monad.__error -&gt; Lwt.t (t a).
End RPC_answer.

Module RPC_directory.
  Parameter t : forall (prefix : Set), Set.
  
  Definition directory (prefix : Set) : Set := t prefix.
  
  Parameter empty : forall {prefix : Set}, directory prefix.
  
  Parameter map : forall {a b : Set},
    (a -&gt; Lwt.t b) -&gt; directory b -&gt; directory a.
  
  Parameter prefix : forall {p pr : Set},
    RPC_path.path pr p -&gt; directory p -&gt; directory pr.
  
  Parameter merge : forall {a : Set}, directory a -&gt; directory a -&gt; directory a.
  
  Inductive step : Set :=
  | Static : string -&gt; step
  | Dynamic : RPC_arg.descr -&gt; step
  | DynamicTail : RPC_arg.descr -&gt; step.
  
  Inductive conflict : Set :=
  | CService : RPC_service.meth -&gt; conflict
  | CDir : conflict
  | CBuilder : conflict
  | CTail : conflict
  | CTypes : RPC_arg.descr -&gt; RPC_arg.descr -&gt; conflict
  | CType : RPC_arg.descr -&gt; list string -&gt; conflict.
  
  (* exception Conflict *)
  
  Parameter register : forall {input output params prefix query : Set},
    directory prefix -&gt; RPC_service.t prefix params query input output -&gt;
    (params -&gt; query -&gt; input -&gt; Lwt.t (Error_monad.tzresult output)) -&gt;
    directory prefix.
  
  Parameter opt_register : forall {input output params prefix query : Set},
    directory prefix -&gt; RPC_service.t prefix params query input output -&gt;
    (params -&gt; query -&gt; input -&gt; Lwt.t (Error_monad.tzresult (option output)))
    -&gt; directory prefix.
  
  Parameter gen_register : forall {input output params prefix query : Set},
    directory prefix -&gt; RPC_service.t prefix params query input output -&gt;
    (params -&gt; query -&gt; input -&gt;
    Lwt.t
      ((* `OkStream *) RPC_answer.stream output +
        (* `Unauthorized *) option (list Error_monad.__error) +
        (* `Error *) option (list Error_monad.__error) + (* `Ok *) output +
        (* `Not_found *) option (list Error_monad.__error) +
        (* `Forbidden *) option (list Error_monad.__error) +
        (* `Created *) option string +
        (* `Conflict *) option (list Error_monad.__error) +
        (* `No_content *) unit)) -&gt; directory prefix.
  
  Parameter lwt_register : forall {input output params prefix query : Set},
    directory prefix -&gt; RPC_service.t prefix params query input output -&gt;
    (params -&gt; query -&gt; input -&gt; Lwt.t output) -&gt; directory prefix.
  
  Parameter register0 : forall {i o q : Set},
    directory unit -&gt; RPC_service.t unit unit q i o -&gt;
    (q -&gt; i -&gt; Lwt.t (Error_monad.tzresult o)) -&gt; directory unit.
  
  Parameter register1 : forall {a i o prefix q : Set},
    directory prefix -&gt; RPC_service.t prefix (unit * a) q i o -&gt;
    (a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.tzresult o)) -&gt; directory prefix.
  
  Parameter register2 : forall {a b i o prefix q : Set},
    directory prefix -&gt; RPC_service.t prefix ((unit * a) * b) q i o -&gt;
    (a -&gt; b -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.tzresult o)) -&gt; directory prefix.
  
  Parameter register3 : forall {a b c i o prefix q : Set},
    directory prefix -&gt; RPC_service.t prefix (((unit * a) * b) * c) q i o -&gt;
    (a -&gt; b -&gt; c -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.tzresult o)) -&gt;
    directory prefix.
  
  Parameter register4 : forall {a b c d i o prefix q : Set},
    directory prefix -&gt;
    RPC_service.t prefix ((((unit * a) * b) * c) * d) q i o -&gt;
    (a -&gt; b -&gt; c -&gt; d -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.tzresult o)) -&gt;
    directory prefix.
  
  Parameter register5 : forall {a b c d e i o prefix q : Set},
    directory prefix -&gt;
    RPC_service.t prefix (((((unit * a) * b) * c) * d) * e) q i o -&gt;
    (a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.tzresult o)) -&gt;
    directory prefix.
  
  Parameter opt_register0 : forall {i o q : Set},
    directory unit -&gt; RPC_service.t unit unit q i o -&gt;
    (q -&gt; i -&gt; Lwt.t (Error_monad.tzresult (option o))) -&gt; directory unit.
  
  Parameter opt_register1 : forall {a i o prefix q : Set},
    directory prefix -&gt; RPC_service.t prefix (unit * a) q i o -&gt;
    (a -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.tzresult (option o))) -&gt; directory prefix.
  
  Parameter opt_register2 : forall {a b i o prefix q : Set},
    directory prefix -&gt; RPC_service.t prefix ((unit * a) * b) q i o -&gt;
    (a -&gt; b -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.tzresult (option o))) -&gt;
    directory prefix.
  
  Parameter opt_register3 : forall {a b c i o prefix q : Set},
    directory prefix -&gt; RPC_service.t prefix (((unit * a) * b) * c) q i o -&gt;
    (a -&gt; b -&gt; c -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.tzresult (option o))) -&gt;
    directory prefix.
  
  Parameter opt_register4 : forall {a b c d i o prefix q : Set},
    directory prefix -&gt;
    RPC_service.t prefix ((((unit * a) * b) * c) * d) q i o -&gt;
    (a -&gt; b -&gt; c -&gt; d -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.tzresult (option o))) -&gt;
    directory prefix.
  
  Parameter opt_register5 : forall {a b c d e i o prefix q : Set},
    directory prefix -&gt;
    RPC_service.t prefix (((((unit * a) * b) * c) * d) * e) q i o -&gt;
    (a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.tzresult (option o)))
    -&gt; directory prefix.
  
  Parameter gen_register0 : forall {i o q : Set},
    directory unit -&gt; RPC_service.t unit unit q i o -&gt;
    (q -&gt; i -&gt;
    Lwt.t
      ((* `OkStream *) RPC_answer.stream o +
        (* `Unauthorized *) option (list Error_monad.__error) +
        (* `Error *) option (list Error_monad.__error) + (* `Ok *) o +
        (* `Not_found *) option (list Error_monad.__error) +
        (* `Forbidden *) option (list Error_monad.__error) +
        (* `Created *) option string +
        (* `Conflict *) option (list Error_monad.__error) +
        (* `No_content *) unit)) -&gt; directory unit.
  
  Parameter gen_register1 : forall {a i o prefix q : Set},
    directory prefix -&gt; RPC_service.t prefix (unit * a) q i o -&gt;
    (a -&gt; q -&gt; i -&gt;
    Lwt.t
      ((* `OkStream *) RPC_answer.stream o +
        (* `Unauthorized *) option (list Error_monad.__error) +
        (* `Error *) option (list Error_monad.__error) + (* `Ok *) o +
        (* `Not_found *) option (list Error_monad.__error) +
        (* `Forbidden *) option (list Error_monad.__error) +
        (* `Created *) option string +
        (* `Conflict *) option (list Error_monad.__error) +
        (* `No_content *) unit)) -&gt; directory prefix.
  
  Parameter gen_register2 : forall {a b i o prefix q : Set},
    directory prefix -&gt; RPC_service.t prefix ((unit * a) * b) q i o -&gt;
    (a -&gt; b -&gt; q -&gt; i -&gt;
    Lwt.t
      ((* `OkStream *) RPC_answer.stream o +
        (* `Unauthorized *) option (list Error_monad.__error) +
        (* `Error *) option (list Error_monad.__error) + (* `Ok *) o +
        (* `Not_found *) option (list Error_monad.__error) +
        (* `Forbidden *) option (list Error_monad.__error) +
        (* `Created *) option string +
        (* `Conflict *) option (list Error_monad.__error) +
        (* `No_content *) unit)) -&gt; directory prefix.
  
  Parameter gen_register3 : forall {a b c i o prefix q : Set},
    directory prefix -&gt; RPC_service.t prefix (((unit * a) * b) * c) q i o -&gt;
    (a -&gt; b -&gt; c -&gt; q -&gt; i -&gt;
    Lwt.t
      ((* `OkStream *) RPC_answer.stream o +
        (* `Unauthorized *) option (list Error_monad.__error) +
        (* `Error *) option (list Error_monad.__error) + (* `Ok *) o +
        (* `Not_found *) option (list Error_monad.__error) +
        (* `Forbidden *) option (list Error_monad.__error) +
        (* `Created *) option string +
        (* `Conflict *) option (list Error_monad.__error) +
        (* `No_content *) unit)) -&gt; directory prefix.
  
  Parameter gen_register4 : forall {a b c d i o prefix q : Set},
    directory prefix -&gt;
    RPC_service.t prefix ((((unit * a) * b) * c) * d) q i o -&gt;
    (a -&gt; b -&gt; c -&gt; d -&gt; q -&gt; i -&gt;
    Lwt.t
      ((* `OkStream *) RPC_answer.stream o +
        (* `Unauthorized *) option (list Error_monad.__error) +
        (* `Error *) option (list Error_monad.__error) + (* `Ok *) o +
        (* `Not_found *) option (list Error_monad.__error) +
        (* `Forbidden *) option (list Error_monad.__error) +
        (* `Created *) option string +
        (* `Conflict *) option (list Error_monad.__error) +
        (* `No_content *) unit)) -&gt; directory prefix.
  
  Parameter gen_register5 : forall {a b c d e i o prefix q : Set},
    directory prefix -&gt;
    RPC_service.t prefix (((((unit * a) * b) * c) * d) * e) q i o -&gt;
    (a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; q -&gt; i -&gt;
    Lwt.t
      ((* `OkStream *) RPC_answer.stream o +
        (* `Unauthorized *) option (list Error_monad.__error) +
        (* `Error *) option (list Error_monad.__error) + (* `Ok *) o +
        (* `Not_found *) option (list Error_monad.__error) +
        (* `Forbidden *) option (list Error_monad.__error) +
        (* `Created *) option string +
        (* `Conflict *) option (list Error_monad.__error) +
        (* `No_content *) unit)) -&gt; directory prefix.
  
  Parameter lwt_register0 : forall {i o q : Set},
    directory unit -&gt; RPC_service.t unit unit q i o -&gt; (q -&gt; i -&gt; Lwt.t o) -&gt;
    directory unit.
  
  Parameter lwt_register1 : forall {a i o prefix q : Set},
    directory prefix -&gt; RPC_service.t prefix (unit * a) q i o -&gt;
    (a -&gt; q -&gt; i -&gt; Lwt.t o) -&gt; directory prefix.
  
  Parameter lwt_register2 : forall {a b i o prefix q : Set},
    directory prefix -&gt; RPC_service.t prefix ((unit * a) * b) q i o -&gt;
    (a -&gt; b -&gt; q -&gt; i -&gt; Lwt.t o) -&gt; directory prefix.
  
  Parameter lwt_register3 : forall {a b c i o prefix q : Set},
    directory prefix -&gt; RPC_service.t prefix (((unit * a) * b) * c) q i o -&gt;
    (a -&gt; b -&gt; c -&gt; q -&gt; i -&gt; Lwt.t o) -&gt; directory prefix.
  
  Parameter lwt_register4 : forall {a b c d i o prefix q : Set},
    directory prefix -&gt;
    RPC_service.t prefix ((((unit * a) * b) * c) * d) q i o -&gt;
    (a -&gt; b -&gt; c -&gt; d -&gt; q -&gt; i -&gt; Lwt.t o) -&gt; directory prefix.
  
  Parameter lwt_register5 : forall {a b c d e i o prefix q : Set},
    directory prefix -&gt;
    RPC_service.t prefix (((((unit * a) * b) * c) * d) * e) q i o -&gt;
    (a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; q -&gt; i -&gt; Lwt.t o) -&gt; directory prefix.
  
  Parameter register_dynamic_directory : forall {a prefix : Set},
    option string -&gt; directory prefix -&gt; RPC_path.t prefix a -&gt;
    (a -&gt; Lwt.t (directory a)) -&gt; directory prefix.
End RPC_directory.

Module Base58.
  Parameter encoding : forall (a : Set), Set.
  
  Parameter simple_decode : forall {a : Set}, encoding a -&gt; string -&gt; option a.
  
  Parameter simple_encode : forall {a : Set}, encoding a -&gt; a -&gt; string.
  
  Definition data : Set := extensible_type.
  
  Parameter register_encoding : forall {a : Set},
    string -&gt; int -&gt; (a -&gt; string) -&gt; (string -&gt; option a) -&gt; (a -&gt; data) -&gt;
    encoding a.
  
  Parameter check_encoded_prefix : forall {a : Set},
    encoding a -&gt; string -&gt; int -&gt; unit.
  
  Parameter decode : string -&gt; option data.
End Base58.

Module S.
  Module T.
    Record signature {t : Set} : Set := {
      t := t;
      op_eq : t -&gt; t -&gt; bool;
      op_ltgt : t -&gt; t -&gt; bool;
      op_lt : t -&gt; t -&gt; bool;
      op_lteq : t -&gt; t -&gt; bool;
      op_gteq : t -&gt; t -&gt; bool;
      op_gt : t -&gt; t -&gt; bool;
      compare : t -&gt; t -&gt; int;
      equal : t -&gt; t -&gt; bool;
      max : t -&gt; t -&gt; t;
      min : t -&gt; t -&gt; t;
      pp : Format.formatter -&gt; t -&gt; unit;
      encoding : Data_encoding.t t;
      to_bytes : t -&gt; MBytes.t;
      of_bytes : MBytes.t -&gt; option t;
    }.
  End T.
  
  Module HASHABLE.
    Record signature {t hash : Set} : Set := {
      t := t;
      op_eq : t -&gt; t -&gt; bool;
      op_ltgt : t -&gt; t -&gt; bool;
      op_lt : t -&gt; t -&gt; bool;
      op_lteq : t -&gt; t -&gt; bool;
      op_gteq : t -&gt; t -&gt; bool;
      op_gt : t -&gt; t -&gt; bool;
      compare : t -&gt; t -&gt; int;
      equal : t -&gt; t -&gt; bool;
      max : t -&gt; t -&gt; t;
      min : t -&gt; t -&gt; t;
      pp : Format.formatter -&gt; t -&gt; unit;
      encoding : Data_encoding.t t;
      to_bytes : t -&gt; MBytes.t;
      of_bytes : MBytes.t -&gt; option t;
      hash := hash;
      __hash_value : t -&gt; hash;
      hash_raw : MBytes.t -&gt; hash;
    }.
  End HASHABLE.
  
  Module MINIMAL_HASH.
    Record signature {t : Set} : Set := {
      t := t;
      name : string;
      title : string;
      pp : Format.formatter -&gt; t -&gt; unit;
      pp_short : Format.formatter -&gt; t -&gt; unit;
      op_eq : t -&gt; t -&gt; bool;
      op_ltgt : t -&gt; t -&gt; bool;
      op_lt : t -&gt; t -&gt; bool;
      op_lteq : t -&gt; t -&gt; bool;
      op_gteq : t -&gt; t -&gt; bool;
      op_gt : t -&gt; t -&gt; bool;
      compare : t -&gt; t -&gt; int;
      equal : t -&gt; t -&gt; bool;
      max : t -&gt; t -&gt; t;
      min : t -&gt; t -&gt; t;
      hash_bytes : option MBytes.t -&gt; list MBytes.t -&gt; t;
      hash_string : option string -&gt; list string -&gt; t;
      zero : t;
    }.
  End MINIMAL_HASH.
  
  Module RAW_DATA.
    Record signature {t : Set} : Set := {
      t := t;
      size : int;
      to_bytes : t -&gt; MBytes.t;
      of_bytes_opt : MBytes.t -&gt; option t;
      of_bytes_exn : MBytes.t -&gt; t;
    }.
  End RAW_DATA.
  
  Module B58_DATA.
    Record signature {t : Set} : Set := {
      t := t;
      to_b58check : t -&gt; string;
      to_short_b58check : t -&gt; string;
      of_b58check_exn : string -&gt; t;
      of_b58check_opt : string -&gt; option t;
      (* extensible_type data *)
      b58check_encoding : Base58.encoding t;
    }.
  End B58_DATA.
  
  Module ENCODER.
    Record signature {t : Set} : Set := {
      t := t;
      encoding : Data_encoding.t t;
      rpc_arg : RPC_arg.t t;
    }.
  End ENCODER.
  
  Module SET.
    Record signature {elt t : Set} : Set := {
      elt := elt;
      t := t;
      empty : t;
      is_empty : t -&gt; bool;
      mem : elt -&gt; t -&gt; bool;
      add : elt -&gt; t -&gt; t;
      singleton : elt -&gt; t;
      remove : elt -&gt; t -&gt; t;
      union : t -&gt; t -&gt; t;
      inter : t -&gt; t -&gt; t;
      diff : t -&gt; t -&gt; t;
      compare : t -&gt; t -&gt; int;
      equal : t -&gt; t -&gt; bool;
      subset : t -&gt; t -&gt; bool;
      iter : (elt -&gt; unit) -&gt; t -&gt; unit;
      map : (elt -&gt; elt) -&gt; t -&gt; t;
      fold : forall {a : Set}, (elt -&gt; a -&gt; a) -&gt; t -&gt; a -&gt; a;
      for_all : (elt -&gt; bool) -&gt; t -&gt; bool;
      __exists : (elt -&gt; bool) -&gt; t -&gt; bool;
      filter : (elt -&gt; bool) -&gt; t -&gt; t;
      partition : (elt -&gt; bool) -&gt; t -&gt; t * t;
      cardinal : t -&gt; int;
      elements : t -&gt; list elt;
      min_elt_opt : t -&gt; option elt;
      max_elt_opt : t -&gt; option elt;
      choose_opt : t -&gt; option elt;
      split : elt -&gt; t -&gt; t * bool * t;
      find_opt : elt -&gt; t -&gt; option elt;
      find_first_opt : (elt -&gt; bool) -&gt; t -&gt; option elt;
      find_last_opt : (elt -&gt; bool) -&gt; t -&gt; option elt;
      of_list : list elt -&gt; t;
    }.
  End SET.
  
  Module MAP.
    Record signature {key : Set} {t : Set -&gt; Set} : Set := {
      key := key;
      t := t;
      empty : forall {a : Set}, t a;
      is_empty : forall {a : Set}, t a -&gt; bool;
      mem : forall {a : Set}, key -&gt; t a -&gt; bool;
      add : forall {a : Set}, key -&gt; a -&gt; t a -&gt; t a;
      update : forall {a : Set}, key -&gt; (option a -&gt; option a) -&gt; t a -&gt; t a;
      singleton : forall {a : Set}, key -&gt; a -&gt; t a;
      remove : forall {a : Set}, key -&gt; t a -&gt; t a;
      merge : forall {a b c : Set},
        (key -&gt; option a -&gt; option b -&gt; option c) -&gt; t a -&gt; t b -&gt; t c;
      union : forall {a : Set},
        (key -&gt; a -&gt; a -&gt; option a) -&gt; t a -&gt; t a -&gt; t a;
      compare : forall {a : Set}, (a -&gt; a -&gt; int) -&gt; t a -&gt; t a -&gt; int;
      equal : forall {a : Set}, (a -&gt; a -&gt; bool) -&gt; t a -&gt; t a -&gt; bool;
      iter : forall {a : Set}, (key -&gt; a -&gt; unit) -&gt; t a -&gt; unit;
      fold : forall {a b : Set}, (key -&gt; a -&gt; b -&gt; b) -&gt; t a -&gt; b -&gt; b;
      for_all : forall {a : Set}, (key -&gt; a -&gt; bool) -&gt; t a -&gt; bool;
      __exists : forall {a : Set}, (key -&gt; a -&gt; bool) -&gt; t a -&gt; bool;
      filter : forall {a : Set}, (key -&gt; a -&gt; bool) -&gt; t a -&gt; t a;
      partition : forall {a : Set}, (key -&gt; a -&gt; bool) -&gt; t a -&gt; t a * t a;
      cardinal : forall {a : Set}, t a -&gt; int;
      bindings : forall {a : Set}, t a -&gt; list (key * a);
      min_binding_opt : forall {a : Set}, t a -&gt; option (key * a);
      max_binding_opt : forall {a : Set}, t a -&gt; option (key * a);
      choose_opt : forall {a : Set}, t a -&gt; option (key * a);
      split : forall {a : Set}, key -&gt; t a -&gt; t a * option a * t a;
      find_opt : forall {a : Set}, key -&gt; t a -&gt; option a;
      find_first_opt : forall {a : Set},
        (key -&gt; bool) -&gt; t a -&gt; option (key * a);
      find_last_opt : forall {a : Set},
        (key -&gt; bool) -&gt; t a -&gt; option (key * a);
      map : forall {a b : Set}, (a -&gt; b) -&gt; t a -&gt; t b;
      mapi : forall {a b : Set}, (key -&gt; a -&gt; b) -&gt; t a -&gt; t b;
    }.
  End MAP.
  
  Module INDEXES_Set.
    Record signature {elt t : Set} : Set := {
      elt := elt;
      t := t;
      empty : t;
      is_empty : t -&gt; bool;
      mem : elt -&gt; t -&gt; bool;
      add : elt -&gt; t -&gt; t;
      singleton : elt -&gt; t;
      remove : elt -&gt; t -&gt; t;
      union : t -&gt; t -&gt; t;
      inter : t -&gt; t -&gt; t;
      diff : t -&gt; t -&gt; t;
      compare : t -&gt; t -&gt; int;
      equal : t -&gt; t -&gt; bool;
      subset : t -&gt; t -&gt; bool;
      iter : (elt -&gt; unit) -&gt; t -&gt; unit;
      map : (elt -&gt; elt) -&gt; t -&gt; t;
      fold : forall {a : Set}, (elt -&gt; a -&gt; a) -&gt; t -&gt; a -&gt; a;
      for_all : (elt -&gt; bool) -&gt; t -&gt; bool;
      __exists : (elt -&gt; bool) -&gt; t -&gt; bool;
      filter : (elt -&gt; bool) -&gt; t -&gt; t;
      partition : (elt -&gt; bool) -&gt; t -&gt; t * t;
      cardinal : t -&gt; int;
      elements : t -&gt; list elt;
      min_elt : t -&gt; elt;
      min_elt_opt : t -&gt; option elt;
      max_elt : t -&gt; elt;
      max_elt_opt : t -&gt; option elt;
      choose : t -&gt; elt;
      choose_opt : t -&gt; option elt;
      split : elt -&gt; t -&gt; t * bool * t;
      find : elt -&gt; t -&gt; elt;
      find_opt : elt -&gt; t -&gt; option elt;
      find_first : (elt -&gt; bool) -&gt; t -&gt; elt;
      find_first_opt : (elt -&gt; bool) -&gt; t -&gt; option elt;
      find_last : (elt -&gt; bool) -&gt; t -&gt; elt;
      find_last_opt : (elt -&gt; bool) -&gt; t -&gt; option elt;
      of_list : list elt -&gt; t;
      to_seq_from : elt -&gt; t -&gt; OCaml.Seq.t elt;
      to_seq : t -&gt; OCaml.Seq.t elt;
      add_seq : OCaml.Seq.t elt -&gt; t -&gt; t;
      of_seq : OCaml.Seq.t elt -&gt; t;
      encoding : Data_encoding.t t;
    }.
  End INDEXES_Set.
  
  Module INDEXES_Map.
    Record signature {key : Set} {t : Set -&gt; Set} : Set := {
      key := key;
      t := t;
      empty : forall {a : Set}, t a;
      is_empty : forall {a : Set}, t a -&gt; bool;
      mem : forall {a : Set}, key -&gt; t a -&gt; bool;
      add : forall {a : Set}, key -&gt; a -&gt; t a -&gt; t a;
      update : forall {a : Set}, key -&gt; (option a -&gt; option a) -&gt; t a -&gt; t a;
      singleton : forall {a : Set}, key -&gt; a -&gt; t a;
      remove : forall {a : Set}, key -&gt; t a -&gt; t a;
      merge : forall {a b c : Set},
        (key -&gt; option a -&gt; option b -&gt; option c) -&gt; t a -&gt; t b -&gt; t c;
      union : forall {a : Set},
        (key -&gt; a -&gt; a -&gt; option a) -&gt; t a -&gt; t a -&gt; t a;
      compare : forall {a : Set}, (a -&gt; a -&gt; int) -&gt; t a -&gt; t a -&gt; int;
      equal : forall {a : Set}, (a -&gt; a -&gt; bool) -&gt; t a -&gt; t a -&gt; bool;
      iter : forall {a : Set}, (key -&gt; a -&gt; unit) -&gt; t a -&gt; unit;
      fold : forall {a b : Set}, (key -&gt; a -&gt; b -&gt; b) -&gt; t a -&gt; b -&gt; b;
      for_all : forall {a : Set}, (key -&gt; a -&gt; bool) -&gt; t a -&gt; bool;
      __exists : forall {a : Set}, (key -&gt; a -&gt; bool) -&gt; t a -&gt; bool;
      filter : forall {a : Set}, (key -&gt; a -&gt; bool) -&gt; t a -&gt; t a;
      partition : forall {a : Set}, (key -&gt; a -&gt; bool) -&gt; t a -&gt; t a * t a;
      cardinal : forall {a : Set}, t a -&gt; int;
      bindings : forall {a : Set}, t a -&gt; list (key * a);
      min_binding : forall {a : Set}, t a -&gt; key * a;
      min_binding_opt : forall {a : Set}, t a -&gt; option (key * a);
      max_binding : forall {a : Set}, t a -&gt; key * a;
      max_binding_opt : forall {a : Set}, t a -&gt; option (key * a);
      choose : forall {a : Set}, t a -&gt; key * a;
      choose_opt : forall {a : Set}, t a -&gt; option (key * a);
      split : forall {a : Set}, key -&gt; t a -&gt; t a * option a * t a;
      find : forall {a : Set}, key -&gt; t a -&gt; a;
      find_opt : forall {a : Set}, key -&gt; t a -&gt; option a;
      find_first : forall {a : Set}, (key -&gt; bool) -&gt; t a -&gt; key * a;
      find_first_opt : forall {a : Set},
        (key -&gt; bool) -&gt; t a -&gt; option (key * a);
      find_last : forall {a : Set}, (key -&gt; bool) -&gt; t a -&gt; key * a;
      find_last_opt : forall {a : Set},
        (key -&gt; bool) -&gt; t a -&gt; option (key * a);
      map : forall {a b : Set}, (a -&gt; b) -&gt; t a -&gt; t b;
      mapi : forall {a b : Set}, (key -&gt; a -&gt; b) -&gt; t a -&gt; t b;
      to_seq : forall {a : Set}, t a -&gt; OCaml.Seq.t (key * a);
      to_seq_from : forall {a : Set}, key -&gt; t a -&gt; OCaml.Seq.t (key * a);
      add_seq : forall {a : Set}, OCaml.Seq.t (key * a) -&gt; t a -&gt; t a;
      of_seq : forall {a : Set}, OCaml.Seq.t (key * a) -&gt; t a;
      encoding : forall {a : Set}, Data_encoding.t a -&gt; Data_encoding.t (t a);
    }.
  End INDEXES_Map.
  
  Module INDEXES.
    Record signature {t __Set_t : Set} {Map_t : Set -&gt; Set} : Set := {
      t := t;
      to_path : t -&gt; list string -&gt; list string;
      of_path : list string -&gt; option t;
      of_path_exn : list string -&gt; t;
      prefix_path : string -&gt; list string;
      path_length : int;
      __Set : INDEXES_Set.signature (elt := t) (t := __Set_t);
      Map : INDEXES_Map.signature (key := t) (t := Map_t);
    }.
  End INDEXES.
  
  Module HASH.
    Record signature {t __Set_t : Set} {Map_t : Set -&gt; Set} : Set := {
      t := t;
      name : string;
      title : string;
      pp : Format.formatter -&gt; t -&gt; unit;
      pp_short : Format.formatter -&gt; t -&gt; unit;
      op_eq : t -&gt; t -&gt; bool;
      op_ltgt : t -&gt; t -&gt; bool;
      op_lt : t -&gt; t -&gt; bool;
      op_lteq : t -&gt; t -&gt; bool;
      op_gteq : t -&gt; t -&gt; bool;
      op_gt : t -&gt; t -&gt; bool;
      compare : t -&gt; t -&gt; int;
      equal : t -&gt; t -&gt; bool;
      max : t -&gt; t -&gt; t;
      min : t -&gt; t -&gt; t;
      hash_bytes : option MBytes.t -&gt; list MBytes.t -&gt; t;
      hash_string : option string -&gt; list string -&gt; t;
      zero : t;
      size : int;
      to_bytes : t -&gt; MBytes.t;
      of_bytes_opt : MBytes.t -&gt; option t;
      of_bytes_exn : MBytes.t -&gt; t;
      to_b58check : t -&gt; string;
      to_short_b58check : t -&gt; string;
      of_b58check_exn : string -&gt; t;
      of_b58check_opt : string -&gt; option t;
      (* extensible_type_definition `Base58.data` *)
      b58check_encoding : Base58.encoding t;
      encoding : Data_encoding.t t;
      rpc_arg : RPC_arg.t t;
      to_path : t -&gt; list string -&gt; list string;
      of_path : list string -&gt; option t;
      of_path_exn : list string -&gt; t;
      prefix_path : string -&gt; list string;
      path_length : int;
      __Set : INDEXES_Set.signature (elt := t) (t := __Set_t);
      Map : INDEXES_Map.signature (key := t) (t := Map_t);
    }.
  End HASH.
  
  Module MERKLE_TREE.
    Record signature {elt t __Set_t : Set} {Map_t : Set -&gt; Set} {path : Set}
      : Set := {
      elt := elt;
      t := t;
      name : string;
      title : string;
      pp : Format.formatter -&gt; t -&gt; unit;
      pp_short : Format.formatter -&gt; t -&gt; unit;
      op_eq : t -&gt; t -&gt; bool;
      op_ltgt : t -&gt; t -&gt; bool;
      op_lt : t -&gt; t -&gt; bool;
      op_lteq : t -&gt; t -&gt; bool;
      op_gteq : t -&gt; t -&gt; bool;
      op_gt : t -&gt; t -&gt; bool;
      compare : t -&gt; t -&gt; int;
      equal : t -&gt; t -&gt; bool;
      max : t -&gt; t -&gt; t;
      min : t -&gt; t -&gt; t;
      hash_bytes : option MBytes.t -&gt; list MBytes.t -&gt; t;
      hash_string : option string -&gt; list string -&gt; t;
      zero : t;
      size : int;
      to_bytes : t -&gt; MBytes.t;
      of_bytes_opt : MBytes.t -&gt; option t;
      of_bytes_exn : MBytes.t -&gt; t;
      to_b58check : t -&gt; string;
      to_short_b58check : t -&gt; string;
      of_b58check_exn : string -&gt; t;
      of_b58check_opt : string -&gt; option t;
      (* extensible_type_definition `Base58.data` *)
      b58check_encoding : Base58.encoding t;
      encoding : Data_encoding.t t;
      rpc_arg : RPC_arg.t t;
      to_path : t -&gt; list string -&gt; list string;
      of_path : list string -&gt; option t;
      of_path_exn : list string -&gt; t;
      prefix_path : string -&gt; list string;
      path_length : int;
      __Set : INDEXES_Set.signature (elt := t) (t := __Set_t);
      Map : INDEXES_Map.signature (key := t) (t := Map_t);
      compute : list elt -&gt; t;
      empty : t;
      path := path;
      compute_path : list elt -&gt; int -&gt; path;
      check_path : path -&gt; elt -&gt; t * int;
      path_encoding : Data_encoding.t path;
    }.
  End MERKLE_TREE.
  
  Module SPublic_key_hash.
    Record signature {t __Set_t : Set} {Map_t : Set -&gt; Set} : Set := {
      t := t;
      pp : Format.formatter -&gt; t -&gt; unit;
      pp_short : Format.formatter -&gt; t -&gt; unit;
      op_eq : t -&gt; t -&gt; bool;
      op_ltgt : t -&gt; t -&gt; bool;
      op_lt : t -&gt; t -&gt; bool;
      op_lteq : t -&gt; t -&gt; bool;
      op_gteq : t -&gt; t -&gt; bool;
      op_gt : t -&gt; t -&gt; bool;
      compare : t -&gt; t -&gt; int;
      equal : t -&gt; t -&gt; bool;
      max : t -&gt; t -&gt; t;
      min : t -&gt; t -&gt; t;
      size : int;
      to_bytes : t -&gt; MBytes.t;
      of_bytes_opt : MBytes.t -&gt; option t;
      of_bytes_exn : MBytes.t -&gt; t;
      to_b58check : t -&gt; string;
      to_short_b58check : t -&gt; string;
      of_b58check_exn : string -&gt; t;
      of_b58check_opt : string -&gt; option t;
      (* extensible_type_definition `Base58.data` *)
      b58check_encoding : Base58.encoding t;
      encoding : Data_encoding.t t;
      rpc_arg : RPC_arg.t t;
      to_path : t -&gt; list string -&gt; list string;
      of_path : list string -&gt; option t;
      of_path_exn : list string -&gt; t;
      prefix_path : string -&gt; list string;
      path_length : int;
      __Set : INDEXES_Set.signature (elt := t) (t := __Set_t);
      Map : INDEXES_Map.signature (key := t) (t := Map_t);
      zero : t;
    }.
  End SPublic_key_hash.
  
  Module SPublic_key.
    Record signature {t public_key_hash_t : Set} : Set := {
      t := t;
      pp : Format.formatter -&gt; t -&gt; unit;
      op_eq : t -&gt; t -&gt; bool;
      op_ltgt : t -&gt; t -&gt; bool;
      op_lt : t -&gt; t -&gt; bool;
      op_lteq : t -&gt; t -&gt; bool;
      op_gteq : t -&gt; t -&gt; bool;
      op_gt : t -&gt; t -&gt; bool;
      compare : t -&gt; t -&gt; int;
      equal : t -&gt; t -&gt; bool;
      max : t -&gt; t -&gt; t;
      min : t -&gt; t -&gt; t;
      to_b58check : t -&gt; string;
      to_short_b58check : t -&gt; string;
      of_b58check_exn : string -&gt; t;
      of_b58check_opt : string -&gt; option t;
      (* extensible_type_definition `Base58.data` *)
      b58check_encoding : Base58.encoding t;
      encoding : Data_encoding.t t;
      rpc_arg : RPC_arg.t t;
      public_key_hash_t := public_key_hash_t;
      __hash_value : t -&gt; public_key_hash_t;
    }.
  End SPublic_key.
  
  Module SIGNATURE.
    Record signature {Public_key_hash_t Public_key_hash___Set_t : Set}
      {Public_key_hash_Map_t : Set -&gt; Set} {Public_key_t t watermark : Set}
      : Set := {
      Public_key_hash :
        SPublic_key_hash.signature (t := Public_key_hash_t)
          (__Set_t := Public_key_hash___Set_t) (Map_t := Public_key_hash_Map_t);
      Public_key :
        SPublic_key.signature (t := Public_key_t)
          (public_key_hash_t := Public_key_hash.(SPublic_key_hash.t));
      t := t;
      pp : Format.formatter -&gt; t -&gt; unit;
      size : int;
      to_bytes : t -&gt; MBytes.t;
      of_bytes_opt : MBytes.t -&gt; option t;
      of_bytes_exn : MBytes.t -&gt; t;
      op_eq : t -&gt; t -&gt; bool;
      op_ltgt : t -&gt; t -&gt; bool;
      op_lt : t -&gt; t -&gt; bool;
      op_lteq : t -&gt; t -&gt; bool;
      op_gteq : t -&gt; t -&gt; bool;
      op_gt : t -&gt; t -&gt; bool;
      compare : t -&gt; t -&gt; int;
      equal : t -&gt; t -&gt; bool;
      max : t -&gt; t -&gt; t;
      min : t -&gt; t -&gt; t;
      to_b58check : t -&gt; string;
      to_short_b58check : t -&gt; string;
      of_b58check_exn : string -&gt; t;
      of_b58check_opt : string -&gt; option t;
      (* extensible_type_definition `Base58.data` *)
      b58check_encoding : Base58.encoding t;
      encoding : Data_encoding.t t;
      rpc_arg : RPC_arg.t t;
      zero : t;
      watermark := watermark;
      check :
        option watermark -&gt; Public_key.(SPublic_key.t) -&gt; t -&gt; MBytes.t -&gt; bool;
    }.
  End SIGNATURE.
End S.

Module __Set.
  Parameter Make :
    forall (Ord : {t : Set &amp; Compare.COMPARABLE.signature (t := t)}),
      {t : Set &amp;
        S.SET.signature (elt := (|Ord|).(Compare.COMPARABLE.t)) (t := t)}.
End __Set.

Module Map.
  Parameter Make :
    forall (Ord : {t : Set &amp; Compare.COMPARABLE.signature (t := t)}),
      {t : Set -&gt; Set &amp;
        S.MAP.signature (key := (|Ord|).(Compare.COMPARABLE.t)) (t := t)}.
End Map.

Module Blake2B.
  Module Name.
    Record signature : Set := {
      name : string;
      title : string;
      size : option int;
    }.
  End Name.
  
  Module PrefixedName.
    Record signature : Set := {
      name : string;
      title : string;
      size : option int;
      b58check_prefix : string;
    }.
  End PrefixedName.
  
  Parameter Make_minimal :
    forall (Name : {_ : unit &amp; Name.signature}),
      {t : Set &amp; S.MINIMAL_HASH.signature (t := t)}.
  
  Module SRegister.
    Record signature : Set := {
      register_encoding : forall {a : Set},
        string -&gt; int -&gt; (a -&gt; string) -&gt; (string -&gt; option a) -&gt;
        (a -&gt; Base58.data) -&gt; Base58.encoding a;
    }.
  End SRegister.
  
  Parameter Make :
    forall (Register : {_ : unit &amp; SRegister.signature}),
      (forall (Name : {_ : unit &amp; PrefixedName.signature}),
        {'[t, __Set_t, Map_t] : [Set ** Set ** Set -&gt; Set] &amp;
          S.HASH.signature (t := t) (__Set_t := __Set_t) (Map_t := Map_t)}).
End Blake2B.

Parameter Ed25519 :
  {'[Public_key_hash_t, Public_key_hash___Set_t, Public_key_hash_Map_t,
    Public_key_t, t] : [Set ** Set ** Set -&gt; Set ** Set ** Set] &amp;
    S.SIGNATURE.signature (Public_key_hash_t := Public_key_hash_t)
      (Public_key_hash___Set_t := Public_key_hash___Set_t)
      (Public_key_hash_Map_t := Public_key_hash_Map_t)
      (Public_key_t := Public_key_t) (t := t) (watermark := MBytes.t)}.

Parameter Secp256k1 :
  {'[Public_key_hash_t, Public_key_hash___Set_t, Public_key_hash_Map_t,
    Public_key_t, t] : [Set ** Set ** Set -&gt; Set ** Set ** Set] &amp;
    S.SIGNATURE.signature (Public_key_hash_t := Public_key_hash_t)
      (Public_key_hash___Set_t := Public_key_hash___Set_t)
      (Public_key_hash_Map_t := Public_key_hash_Map_t)
      (Public_key_t := Public_key_t) (t := t) (watermark := MBytes.t)}.

Parameter P256 :
  {'[Public_key_hash_t, Public_key_hash___Set_t, Public_key_hash_Map_t,
    Public_key_t, t] : [Set ** Set ** Set -&gt; Set ** Set ** Set] &amp;
    S.SIGNATURE.signature (Public_key_hash_t := Public_key_hash_t)
      (Public_key_hash___Set_t := Public_key_hash___Set_t)
      (Public_key_hash_Map_t := Public_key_hash_Map_t)
      (Public_key_t := Public_key_t) (t := t) (watermark := MBytes.t)}.

Parameter Chain_id :
  {'[t, __Set_t, Map_t] : [Set ** Set ** Set -&gt; Set] &amp;
    S.HASH.signature (t := t) (__Set_t := __Set_t) (Map_t := Map_t)}.

Module Signature.
  Parameter signature_module_tag : unit.
  
  Inductive public_key_hash : Set :=
  | Ed25519Hash :
    (|Ed25519|).(S.SIGNATURE.Public_key_hash).(S.SPublic_key_hash.t) -&gt;
    public_key_hash
  | Secp256k1Hash :
    (|Secp256k1|).(S.SIGNATURE.Public_key_hash).(S.SPublic_key_hash.t) -&gt;
    public_key_hash
  | P256Hash :
    (|P256|).(S.SIGNATURE.Public_key_hash).(S.SPublic_key_hash.t) -&gt;
    public_key_hash.
  
  Inductive public_key : Set :=
  | Ed25519 :
    (|Ed25519|).(S.SIGNATURE.Public_key).(S.SPublic_key.t) -&gt; public_key
  | Secp256k1 :
    (|Secp256k1|).(S.SIGNATURE.Public_key).(S.SPublic_key.t) -&gt; public_key
  | P256 : (|P256|).(S.SIGNATURE.Public_key).(S.SPublic_key.t) -&gt; public_key.
  
  Inductive watermark : Set :=
  | Block_header : (|Chain_id|).(S.HASH.t) -&gt; watermark
  | Endorsement : (|Chain_id|).(S.HASH.t) -&gt; watermark
  | Generic_operation : watermark
  | Custom : MBytes.t -&gt; watermark.
  
  Parameter Included_SIGNATURE :
    {'[Public_key_hash___Set_t, Public_key_hash_Map_t, t] :
      [Set ** Set -&gt; Set ** Set] &amp;
      S.SIGNATURE.signature (Public_key_hash_t := public_key_hash)
        (Public_key_hash___Set_t := Public_key_hash___Set_t)
        (Public_key_hash_Map_t := Public_key_hash_Map_t)
        (Public_key_t := public_key) (t := t) (watermark := watermark)}.
  
  Definition Public_key_hash :=
    existT (fun _ =&gt; _) tt (|Included_SIGNATURE|).(S.SIGNATURE.Public_key_hash).
  
  Definition Public_key :=
    existT (fun _ =&gt; _) tt (|Included_SIGNATURE|).(S.SIGNATURE.Public_key).
  
  Definition t := (|Included_SIGNATURE|).(S.SIGNATURE.t).
  
  Definition pp : Format.formatter -&gt; t -&gt; unit :=
    (|Included_SIGNATURE|).(S.SIGNATURE.pp).
  
  Definition size : int := (|Included_SIGNATURE|).(S.SIGNATURE.size).
  
  Definition to_bytes : t -&gt; MBytes.t :=
    (|Included_SIGNATURE|).(S.SIGNATURE.to_bytes).
  
  Definition of_bytes_opt : MBytes.t -&gt; option t :=
    (|Included_SIGNATURE|).(S.SIGNATURE.of_bytes_opt).
  
  Definition of_bytes_exn : MBytes.t -&gt; t :=
    (|Included_SIGNATURE|).(S.SIGNATURE.of_bytes_exn).
  
  Definition op_eq : t -&gt; t -&gt; bool :=
    (|Included_SIGNATURE|).(S.SIGNATURE.op_eq).
  
  Definition op_ltgt : t -&gt; t -&gt; bool :=
    (|Included_SIGNATURE|).(S.SIGNATURE.op_ltgt).
  
  Definition op_lt : t -&gt; t -&gt; bool :=
    (|Included_SIGNATURE|).(S.SIGNATURE.op_lt).
  
  Definition op_lteq : t -&gt; t -&gt; bool :=
    (|Included_SIGNATURE|).(S.SIGNATURE.op_lteq).
  
  Definition op_gteq : t -&gt; t -&gt; bool :=
    (|Included_SIGNATURE|).(S.SIGNATURE.op_gteq).
  
  Definition op_gt : t -&gt; t -&gt; bool :=
    (|Included_SIGNATURE|).(S.SIGNATURE.op_gt).
  
  Definition compare : t -&gt; t -&gt; int :=
    (|Included_SIGNATURE|).(S.SIGNATURE.compare).
  
  Definition equal : t -&gt; t -&gt; bool :=
    (|Included_SIGNATURE|).(S.SIGNATURE.equal).
  
  Definition max : t -&gt; t -&gt; t := (|Included_SIGNATURE|).(S.SIGNATURE.max).
  
  Definition min : t -&gt; t -&gt; t := (|Included_SIGNATURE|).(S.SIGNATURE.min).
  
  Definition to_b58check : t -&gt; string :=
    (|Included_SIGNATURE|).(S.SIGNATURE.to_b58check).
  
  Definition to_short_b58check : t -&gt; string :=
    (|Included_SIGNATURE|).(S.SIGNATURE.to_short_b58check).
  
  Definition of_b58check_exn : string -&gt; t :=
    (|Included_SIGNATURE|).(S.SIGNATURE.of_b58check_exn).
  
  Definition of_b58check_opt : string -&gt; option t :=
    (|Included_SIGNATURE|).(S.SIGNATURE.of_b58check_opt).
  
  Definition b58check_encoding : Base58.encoding t :=
    (|Included_SIGNATURE|).(S.SIGNATURE.b58check_encoding).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_SIGNATURE|).(S.SIGNATURE.encoding).
  
  Definition rpc_arg : RPC_arg.t t :=
    (|Included_SIGNATURE|).(S.SIGNATURE.rpc_arg).
  
  Definition zero : t := (|Included_SIGNATURE|).(S.SIGNATURE.zero).
  
  Definition check :
    option watermark -&gt; (|Public_key|).(S.SPublic_key.t) -&gt; t -&gt; MBytes.t -&gt;
    bool := (|Included_SIGNATURE|).(S.SIGNATURE.check).
End Signature.

Parameter Block_hash :
  {'[t, __Set_t, Map_t] : [Set ** Set ** Set -&gt; Set] &amp;
    S.HASH.signature (t := t) (__Set_t := __Set_t) (Map_t := Map_t)}.

Parameter Operation_hash :
  {'[t, __Set_t, Map_t] : [Set ** Set ** Set -&gt; Set] &amp;
    S.HASH.signature (t := t) (__Set_t := __Set_t) (Map_t := Map_t)}.

Parameter Operation_list_hash :
  {'[t, __Set_t, Map_t, path] : [Set ** Set ** Set -&gt; Set ** Set] &amp;
    S.MERKLE_TREE.signature (elt := (|Operation_hash|).(S.HASH.t)) (t := t)
      (__Set_t := __Set_t) (Map_t := Map_t) (path := path)}.

Parameter Operation_list_list_hash :
  {'[t, __Set_t, Map_t, path] : [Set ** Set ** Set -&gt; Set ** Set] &amp;
    S.MERKLE_TREE.signature (elt := (|Operation_list_hash|).(S.MERKLE_TREE.t))
      (t := t) (__Set_t := __Set_t) (Map_t := Map_t) (path := path)}.

Parameter Protocol_hash :
  {'[t, __Set_t, Map_t] : [Set ** Set ** Set -&gt; Set] &amp;
    S.HASH.signature (t := t) (__Set_t := __Set_t) (Map_t := Map_t)}.

Parameter Context_hash :
  {'[t, __Set_t, Map_t] : [Set ** Set ** Set -&gt; Set] &amp;
    S.HASH.signature (t := t) (__Set_t := __Set_t) (Map_t := Map_t)}.

Module Micheline.
  Definition annot : Set := list string.
  
  Inductive node (l p : Set) : Set :=
  | Int : l -&gt; Z.t -&gt; node l p
  | String : l -&gt; string -&gt; node l p
  | Bytes : l -&gt; MBytes.t -&gt; node l p
  | Prim : l -&gt; p -&gt; list (node l p) -&gt; annot -&gt; node l p
  | Seq : l -&gt; list (node l p) -&gt; node l p.
  
  Arguments Int {_ _}.
  Arguments String {_ _}.
  Arguments Bytes {_ _}.
  Arguments Prim {_ _}.
  Arguments Seq {_ _}.
  
  Parameter canonical : forall (p : Set), Set.
  
  Definition canonical_location : Set := int.
  
  Parameter root : forall {p : Set}, canonical p -&gt; node canonical_location p.
  
  Parameter canonical_location_encoding :
    Data_encoding.encoding canonical_location.
  
  Parameter canonical_encoding : forall {l : Set},
    string -&gt; Data_encoding.encoding l -&gt; Data_encoding.encoding (canonical l).
  
  Parameter canonical_encoding_v1 : forall {l : Set},
    string -&gt; Data_encoding.encoding l -&gt; Data_encoding.encoding (canonical l).
  
  Parameter location : forall {l p : Set}, node l p -&gt; l.
  
  Parameter annotations : forall {l p : Set}, node l p -&gt; list string.
  
  Parameter strip_locations : forall {A p : Set}, node A p -&gt; canonical p.
  
  Parameter extract_locations : forall {l p : Set},
    node l p -&gt; canonical p * list (canonical_location * l).
  
  Parameter inject_locations : forall {l p : Set},
    (canonical_location -&gt; l) -&gt; canonical p -&gt; node l p.
End Micheline.

Module Block_header.
  Module shell_header.
    Record record : Set := Build {
      level : Int32.t;
      proto_level : int;
      predecessor : (|Block_hash|).(S.HASH.t);
      timestamp : Time.t;
      validation_passes : int;
      operations_hash : (|Operation_list_list_hash|).(S.MERKLE_TREE.t);
      fitness : list MBytes.t;
      context : (|Context_hash|).(S.HASH.t) }.
    Definition with_level level (r : record) :=
      Build level r.(proto_level) r.(predecessor) r.(timestamp)
        r.(validation_passes) r.(operations_hash) r.(fitness) r.(context).
    Definition with_proto_level proto_level (r : record) :=
      Build r.(level) proto_level r.(predecessor) r.(timestamp)
        r.(validation_passes) r.(operations_hash) r.(fitness) r.(context).
    Definition with_predecessor predecessor (r : record) :=
      Build r.(level) r.(proto_level) predecessor r.(timestamp)
        r.(validation_passes) r.(operations_hash) r.(fitness) r.(context).
    Definition with_timestamp timestamp (r : record) :=
      Build r.(level) r.(proto_level) r.(predecessor) timestamp
        r.(validation_passes) r.(operations_hash) r.(fitness) r.(context).
    Definition with_validation_passes validation_passes (r : record) :=
      Build r.(level) r.(proto_level) r.(predecessor) r.(timestamp)
        validation_passes r.(operations_hash) r.(fitness) r.(context).
    Definition with_operations_hash operations_hash (r : record) :=
      Build r.(level) r.(proto_level) r.(predecessor) r.(timestamp)
        r.(validation_passes) operations_hash r.(fitness) r.(context).
    Definition with_fitness fitness (r : record) :=
      Build r.(level) r.(proto_level) r.(predecessor) r.(timestamp)
        r.(validation_passes) r.(operations_hash) fitness r.(context).
    Definition with_context context (r : record) :=
      Build r.(level) r.(proto_level) r.(predecessor) r.(timestamp)
        r.(validation_passes) r.(operations_hash) r.(fitness) context.
  End shell_header.
  Definition shell_header := shell_header.record.
  
  Parameter shell_header_encoding : Data_encoding.t shell_header.
  
  Module t.
    Record record : Set := Build {
      shell : shell_header;
      protocol_data : MBytes.t }.
    Definition with_shell shell (r : record) :=
      Build shell r.(protocol_data).
    Definition with_protocol_data protocol_data (r : record) :=
      Build r.(shell) protocol_data.
  End t.
  Definition t := t.record.
  
  Parameter Included_HASHABLE :
    {_ : unit &amp;
      S.HASHABLE.signature (t := t) (hash := (|Block_hash|).(S.HASH.t))}.
  
  Definition op_eq : t -&gt; t -&gt; bool := (|Included_HASHABLE|).(S.HASHABLE.op_eq).
  
  Definition op_ltgt : t -&gt; t -&gt; bool :=
    (|Included_HASHABLE|).(S.HASHABLE.op_ltgt).
  
  Definition op_lt : t -&gt; t -&gt; bool := (|Included_HASHABLE|).(S.HASHABLE.op_lt).
  
  Definition op_lteq : t -&gt; t -&gt; bool :=
    (|Included_HASHABLE|).(S.HASHABLE.op_lteq).
  
  Definition op_gteq : t -&gt; t -&gt; bool :=
    (|Included_HASHABLE|).(S.HASHABLE.op_gteq).
  
  Definition op_gt : t -&gt; t -&gt; bool := (|Included_HASHABLE|).(S.HASHABLE.op_gt).
  
  Definition compare : t -&gt; t -&gt; int :=
    (|Included_HASHABLE|).(S.HASHABLE.compare).
  
  Definition equal : t -&gt; t -&gt; bool := (|Included_HASHABLE|).(S.HASHABLE.equal).
  
  Definition max : t -&gt; t -&gt; t := (|Included_HASHABLE|).(S.HASHABLE.max).
  
  Definition min : t -&gt; t -&gt; t := (|Included_HASHABLE|).(S.HASHABLE.min).
  
  Definition pp : Format.formatter -&gt; t -&gt; unit :=
    (|Included_HASHABLE|).(S.HASHABLE.pp).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_HASHABLE|).(S.HASHABLE.encoding).
  
  Definition to_bytes : t -&gt; MBytes.t :=
    (|Included_HASHABLE|).(S.HASHABLE.to_bytes).
  
  Definition of_bytes : MBytes.t -&gt; option t :=
    (|Included_HASHABLE|).(S.HASHABLE.of_bytes).
  
  Definition __hash_value : t -&gt; (|Block_hash|).(S.HASH.t) :=
    (|Included_HASHABLE|).(S.HASHABLE.__hash_value).
  
  Definition hash_raw : MBytes.t -&gt; (|Block_hash|).(S.HASH.t) :=
    (|Included_HASHABLE|).(S.HASHABLE.hash_raw).
End Block_header.

Parameter Fitness : {_ : unit &amp; S.T.signature (t := (list MBytes.t))}.

Module Operation.
  Module shell_header.
    Record record : Set := Build {
      branch : (|Block_hash|).(S.HASH.t) }.
    Definition with_branch branch (r : record) :=
      Build branch.
  End shell_header.
  Definition shell_header := shell_header.record.
  
  Parameter shell_header_encoding : Data_encoding.t shell_header.
  
  Module t.
    Record record : Set := Build {
      shell : shell_header;
      proto : MBytes.t }.
    Definition with_shell shell (r : record) :=
      Build shell r.(proto).
    Definition with_proto proto (r : record) :=
      Build r.(shell) proto.
  End t.
  Definition t := t.record.
  
  Parameter Included_HASHABLE :
    {_ : unit &amp;
      S.HASHABLE.signature (t := t) (hash := (|Operation_hash|).(S.HASH.t))}.
  
  Definition op_eq : t -&gt; t -&gt; bool := (|Included_HASHABLE|).(S.HASHABLE.op_eq).
  
  Definition op_ltgt : t -&gt; t -&gt; bool :=
    (|Included_HASHABLE|).(S.HASHABLE.op_ltgt).
  
  Definition op_lt : t -&gt; t -&gt; bool := (|Included_HASHABLE|).(S.HASHABLE.op_lt).
  
  Definition op_lteq : t -&gt; t -&gt; bool :=
    (|Included_HASHABLE|).(S.HASHABLE.op_lteq).
  
  Definition op_gteq : t -&gt; t -&gt; bool :=
    (|Included_HASHABLE|).(S.HASHABLE.op_gteq).
  
  Definition op_gt : t -&gt; t -&gt; bool := (|Included_HASHABLE|).(S.HASHABLE.op_gt).
  
  Definition compare : t -&gt; t -&gt; int :=
    (|Included_HASHABLE|).(S.HASHABLE.compare).
  
  Definition equal : t -&gt; t -&gt; bool := (|Included_HASHABLE|).(S.HASHABLE.equal).
  
  Definition max : t -&gt; t -&gt; t := (|Included_HASHABLE|).(S.HASHABLE.max).
  
  Definition min : t -&gt; t -&gt; t := (|Included_HASHABLE|).(S.HASHABLE.min).
  
  Definition pp : Format.formatter -&gt; t -&gt; unit :=
    (|Included_HASHABLE|).(S.HASHABLE.pp).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_HASHABLE|).(S.HASHABLE.encoding).
  
  Definition to_bytes : t -&gt; MBytes.t :=
    (|Included_HASHABLE|).(S.HASHABLE.to_bytes).
  
  Definition of_bytes : MBytes.t -&gt; option t :=
    (|Included_HASHABLE|).(S.HASHABLE.of_bytes).
  
  Definition __hash_value : t -&gt; (|Operation_hash|).(S.HASH.t) :=
    (|Included_HASHABLE|).(S.HASHABLE.__hash_value).
  
  Definition hash_raw : MBytes.t -&gt; (|Operation_hash|).(S.HASH.t) :=
    (|Included_HASHABLE|).(S.HASHABLE.hash_raw).
End Operation.

Module Protocol.
  Module t.
    Record record {expected_env components : Set} : Set := Build {
      expected_env : expected_env;
      components : components }.
    Arguments record : clear implicits.
    Definition with_expected_env {t_expected_env t_components} expected_env
      (r : record t_expected_env t_components) :=
      Build t_expected_env t_components expected_env r.(components).
    Definition with_components {t_expected_env t_components} components
      (r : record t_expected_env t_components) :=
      Build t_expected_env t_components r.(expected_env) components.
  End t.
  Definition t_skeleton := t.record.
  
  Module component.
    Record record {name interface implementation : Set} : Set := Build {
      name : name;
      interface : interface;
      implementation : implementation }.
    Arguments record : clear implicits.
    Definition with_name {t_name t_interface t_implementation} name
      (r : record t_name t_interface t_implementation) :=
      Build t_name t_interface t_implementation name r.(interface)
        r.(implementation).
    Definition with_interface {t_name t_interface t_implementation} interface
      (r : record t_name t_interface t_implementation) :=
      Build t_name t_interface t_implementation r.(name) interface
        r.(implementation).
    Definition with_implementation {t_name t_interface t_implementation}
      implementation (r : record t_name t_interface t_implementation) :=
      Build t_name t_interface t_implementation r.(name) r.(interface)
        implementation.
  End component.
  Definition component_skeleton := component.record.
  
  Reserved Notation &quot;'component&quot;.
  Reserved Notation &quot;'t&quot;.
  
  Inductive env_version : Set :=
  | V1 : env_version
  
  where &quot;'component&quot; := (component_skeleton string (option string) string)
  and &quot;'t&quot; := (t_skeleton env_version (list 'component)).
  
  Definition component := 'component.
  Definition t := 't.
  
  Parameter component_encoding : Data_encoding.t component.
  
  Parameter env_version_encoding : Data_encoding.t env_version.
  
  Parameter Included_HASHABLE :
    {_ : unit &amp;
      S.HASHABLE.signature (t := t) (hash := (|Protocol_hash|).(S.HASH.t))}.
  
  Definition op_eq : t -&gt; t -&gt; bool := (|Included_HASHABLE|).(S.HASHABLE.op_eq).
  
  Definition op_ltgt : t -&gt; t -&gt; bool :=
    (|Included_HASHABLE|).(S.HASHABLE.op_ltgt).
  
  Definition op_lt : t -&gt; t -&gt; bool := (|Included_HASHABLE|).(S.HASHABLE.op_lt).
  
  Definition op_lteq : t -&gt; t -&gt; bool :=
    (|Included_HASHABLE|).(S.HASHABLE.op_lteq).
  
  Definition op_gteq : t -&gt; t -&gt; bool :=
    (|Included_HASHABLE|).(S.HASHABLE.op_gteq).
  
  Definition op_gt : t -&gt; t -&gt; bool := (|Included_HASHABLE|).(S.HASHABLE.op_gt).
  
  Definition compare : t -&gt; t -&gt; int :=
    (|Included_HASHABLE|).(S.HASHABLE.compare).
  
  Definition equal : t -&gt; t -&gt; bool := (|Included_HASHABLE|).(S.HASHABLE.equal).
  
  Definition max : t -&gt; t -&gt; t := (|Included_HASHABLE|).(S.HASHABLE.max).
  
  Definition min : t -&gt; t -&gt; t := (|Included_HASHABLE|).(S.HASHABLE.min).
  
  Definition pp : Format.formatter -&gt; t -&gt; unit :=
    (|Included_HASHABLE|).(S.HASHABLE.pp).
  
  Definition encoding : Data_encoding.t t :=
    (|Included_HASHABLE|).(S.HASHABLE.encoding).
  
  Definition to_bytes : t -&gt; MBytes.t :=
    (|Included_HASHABLE|).(S.HASHABLE.to_bytes).
  
  Definition of_bytes : MBytes.t -&gt; option t :=
    (|Included_HASHABLE|).(S.HASHABLE.of_bytes).
  
  Definition __hash_value : t -&gt; (|Protocol_hash|).(S.HASH.t) :=
    (|Included_HASHABLE|).(S.HASHABLE.__hash_value).
  
  Definition hash_raw : MBytes.t -&gt; (|Protocol_hash|).(S.HASH.t) :=
    (|Included_HASHABLE|).(S.HASHABLE.hash_raw).
End Protocol.

Module Context.
  Parameter t : Set.
  
  Definition key : Set := list string.
  
  Definition value : Set := MBytes.t.
  
  Parameter mem : t -&gt; key -&gt; Lwt.t bool.
  
  Parameter dir_mem : t -&gt; key -&gt; Lwt.t bool.
  
  Parameter get : t -&gt; key -&gt; Lwt.t (option value).
  
  Parameter set : t -&gt; key -&gt; value -&gt; Lwt.t t.
  
  Parameter copy : t -&gt; key -&gt; key -&gt; Lwt.t (option t).
  
  Parameter del : t -&gt; key -&gt; Lwt.t t.
  
  Parameter remove_rec : t -&gt; key -&gt; Lwt.t t.
  
  Inductive dir_or_key : Set :=
  | Dir : key -&gt; dir_or_key
  | Key : key -&gt; dir_or_key.
  
  Parameter fold : forall {a : Set},
    t -&gt; key -&gt; a -&gt; (Context.dir_or_key -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a.
  
  Parameter keys : t -&gt; key -&gt; Lwt.t (list key).
  
  Parameter fold_keys : forall {a : Set},
    t -&gt; key -&gt; a -&gt; (key -&gt; a -&gt; Lwt.t a) -&gt; Lwt.t a.
  
  Parameter register_resolver : forall {a : Set},
    Base58.encoding a -&gt; (t -&gt; string -&gt; Lwt.t (list a)) -&gt; unit.
  
  Parameter complete : t -&gt; string -&gt; Lwt.t (list string).
End Context.

Module Updater.
  Module validation_result.
    Record record : Set := Build {
      context : Context.t;
      fitness : (|Fitness|).(S.T.t);
      message : option string;
      max_operations_ttl : int;
      last_allowed_fork_level : Int32.t }.
    Definition with_context context (r : record) :=
      Build context r.(fitness) r.(message) r.(max_operations_ttl)
        r.(last_allowed_fork_level).
    Definition with_fitness fitness (r : record) :=
      Build r.(context) fitness r.(message) r.(max_operations_ttl)
        r.(last_allowed_fork_level).
    Definition with_message message (r : record) :=
      Build r.(context) r.(fitness) message r.(max_operations_ttl)
        r.(last_allowed_fork_level).
    Definition with_max_operations_ttl max_operations_ttl (r : record) :=
      Build r.(context) r.(fitness) r.(message) max_operations_ttl
        r.(last_allowed_fork_level).
    Definition with_last_allowed_fork_level last_allowed_fork_level
      (r : record) :=
      Build r.(context) r.(fitness) r.(message) r.(max_operations_ttl)
        last_allowed_fork_level.
  End validation_result.
  Definition validation_result := validation_result.record.
  
  Module quota.
    Record record : Set := Build {
      max_size : int;
      max_op : option int }.
    Definition with_max_size max_size (r : record) :=
      Build max_size r.(max_op).
    Definition with_max_op max_op (r : record) :=
      Build r.(max_size) max_op.
  End quota.
  Definition quota := quota.record.
  
  Module rpc_context.
    Record record : Set := Build {
      block_hash : (|Block_hash|).(S.HASH.t);
      block_header : Block_header.shell_header;
      context : Context.t }.
    Definition with_block_hash block_hash (r : record) :=
      Build block_hash r.(block_header) r.(context).
    Definition with_block_header block_header (r : record) :=
      Build r.(block_hash) block_header r.(context).
    Definition with_context context (r : record) :=
      Build r.(block_hash) r.(block_header) context.
  End rpc_context.
  Definition rpc_context := rpc_context.record.
  
  Module PROTOCOL.
    Record signature {block_header_data block_header block_header_metadata
      operation_data operation_receipt operation validation_state : Set} : Set
      := {
      max_block_length : int;
      max_operation_data_length : int;
      validation_passes : list quota;
      block_header_data := block_header_data;
      block_header_data_encoding : Data_encoding.t block_header_data;
      block_header := block_header;
      block_header_metadata := block_header_metadata;
      block_header_metadata_encoding : Data_encoding.t block_header_metadata;
      operation_data := operation_data;
      operation_receipt := operation_receipt;
      operation := operation;
      operation_data_encoding : Data_encoding.t operation_data;
      operation_receipt_encoding : Data_encoding.t operation_receipt;
      operation_data_and_receipt_encoding :
        Data_encoding.t (operation_data * operation_receipt);
      acceptable_passes : operation -&gt; list int;
      compare_operations : operation -&gt; operation -&gt; int;
      validation_state := validation_state;
      current_context :
        validation_state -&gt; Lwt.t (Error_monad.tzresult Context.t);
      begin_partial_application :
        (|Chain_id|).(S.HASH.t) -&gt; Context.t -&gt; Time.t -&gt; (|Fitness|).(S.T.t) -&gt;
        block_header -&gt; Lwt.t (Error_monad.tzresult validation_state);
      begin_application :
        (|Chain_id|).(S.HASH.t) -&gt; Context.t -&gt; Time.t -&gt; (|Fitness|).(S.T.t) -&gt;
        block_header -&gt; Lwt.t (Error_monad.tzresult validation_state);
      begin_construction :
        (|Chain_id|).(S.HASH.t) -&gt; Context.t -&gt; Time.t -&gt; Int32.t -&gt;
        (|Fitness|).(S.T.t) -&gt; (|Block_hash|).(S.HASH.t) -&gt; Time.t -&gt;
        option block_header_data -&gt; unit -&gt;
        Lwt.t (Error_monad.tzresult validation_state);
      apply_operation :
        validation_state -&gt; operation -&gt;
        Lwt.t (Error_monad.tzresult (validation_state * operation_receipt));
      finalize_block :
        validation_state -&gt;
        Lwt.t (Error_monad.tzresult (validation_result * block_header_metadata));
      rpc_services : RPC_directory.t rpc_context;
      init :
        Context.t -&gt; Block_header.shell_header -&gt;
        Lwt.t (Error_monad.tzresult validation_result);
    }.
  End PROTOCOL.
  
  Parameter activate :
    Context.t -&gt; (|Protocol_hash|).(S.HASH.t) -&gt; Lwt.t Context.t.
  
  Parameter fork_test_chain :
    Context.t -&gt; (|Protocol_hash|).(S.HASH.t) -&gt; Time.t -&gt; Lwt.t Context.t.
End Updater.

Module RPC_context.
  Definition t : Set := Updater.rpc_context.
  
  Module simple.
    Record record {pr : Set} : Set := Build {
      call_proto_service0 :
        forall {q i o : Set},
          RPC_service.t t t q i o -&gt; pr -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o);
      call_proto_service1 :
        forall {a q i o : Set},
          RPC_service.t t (t * a) q i o -&gt; pr -&gt; a -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o);
      call_proto_service2 :
        forall {a b q i o : Set},
          RPC_service.t t ((t * a) * b) q i o -&gt; pr -&gt; a -&gt; b -&gt; q -&gt; i -&gt;
          Lwt.t (Error_monad.shell_tzresult o);
      call_proto_service3 :
        forall {a b c q i o : Set},
          RPC_service.t t (((t * a) * b) * c) q i o -&gt; pr -&gt; a -&gt; b -&gt; c -&gt; q -&gt;
          i -&gt; Lwt.t (Error_monad.shell_tzresult o) }.
    Arguments record : clear implicits.
  End simple.
  Definition simple := simple.record.
  
  Parameter make_call0 : forall {i o pr q : Set},
    RPC_service.t t t q i o -&gt; simple pr -&gt; pr -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult o).
  
  Parameter make_call1 : forall {a i o pr q : Set},
    RPC_service.t t (t * a) q i o -&gt; simple pr -&gt; pr -&gt; a -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult o).
  
  Parameter make_call2 : forall {a b i o pr q : Set},
    RPC_service.t t ((t * a) * b) q i o -&gt; simple pr -&gt; pr -&gt; a -&gt; b -&gt; q -&gt;
    i -&gt; Lwt.t (Error_monad.shell_tzresult o).
  
  Parameter make_call3 : forall {a b c i o pr q : Set},
    RPC_service.t t (((t * a) * b) * c) q i o -&gt; simple pr -&gt; pr -&gt; a -&gt; b -&gt;
    c -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult o).
  
  Parameter make_opt_call0 : forall {i o pr q : Set},
    RPC_service.t t t q i o -&gt; simple pr -&gt; pr -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult (option o)).
  
  Parameter make_opt_call1 : forall {a i o pr q : Set},
    RPC_service.t t (t * a) q i o -&gt; simple pr -&gt; pr -&gt; a -&gt; q -&gt; i -&gt;
    Lwt.t (Error_monad.shell_tzresult (option o)).
  
  Parameter make_opt_call2 : forall {a b i o pr q : Set},
    RPC_service.t t ((t * a) * b) q i o -&gt; simple pr -&gt; pr -&gt; a -&gt; b -&gt; q -&gt;
    i -&gt; Lwt.t (Error_monad.shell_tzresult (option o)).
  
  Parameter make_opt_call3 : forall {a b c i o pr q : Set},
    RPC_service.t t (((t * a) * b) * c) q i o -&gt; simple pr -&gt; pr -&gt; a -&gt; b -&gt;
    c -&gt; q -&gt; i -&gt; Lwt.t (Error_monad.shell_tzresult (option o)).
End RPC_context.

Module Notations.
  Notation &quot;'let=' x ':=' X 'in' Y&quot; :=
    (Error_monad.op_gtgteq X (fun x =&gt; Y))
    (at level 200, x ident, X at level 100, Y at level 200).

  Notation &quot;'let=' ' x ':=' X 'in' Y&quot; :=
    (Error_monad.op_gtgteq X (fun x =&gt; Y))
    (at level 200, x pattern, X at level 100, Y at level 200).

  Notation &quot;'let=?' x ':=' X 'in' Y&quot; :=
    (Error_monad.op_gtgteqquestion X (fun x =&gt; Y))
    (at level 200, x ident, X at level 100, Y at level 200).

  Notation &quot;'let=?' ' x ':=' X 'in' Y&quot; :=
    (Error_monad.op_gtgteqquestion X (fun x =&gt; Y))
    (at level 200, x pattern, X at level 100, Y at level 200).

  Notation &quot;'let?' x ':=' X 'in' Y&quot; :=
    (Error_monad.op_gtgtquestion X (fun x =&gt; Y))
    (at level 200, x ident, X at level 100, Y at level 200).

  Notation &quot;'let?' ' x ':=' X 'in' Y&quot; :=
    (Error_monad.op_gtgtquestion X (fun x =&gt; Y))
    (at level 200, x pattern, X at level 100, Y at level 200).
End Notations.
</pre>
  </div>
</div>

      </div>
      <hr/>
      <div class="footer" style="margin-bottom: 40px;">
        <p class="text-center">
          <small>Sources of&nbsp;<a href="https://foobar-land.github.io/coq-of-ocaml/">coq-of-ocaml</a> are on&nbsp;<a href="https://github.com/clarus/coq-of-ocaml">GitHub</a>. Â© Guillaume Claret.</small>
        </p>
      </div>
    </div>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <script src="../js/bootstrap.min.js"></script>
  </body>
</html>

